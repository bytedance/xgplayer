(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("xgplayer"));
	else if(typeof define === 'function' && define.amd)
		define(["xgplayer"], factory);
	else if(typeof exports === 'object')
		exports["xgplayer-hlsjs.js"] = factory(require("xgplayer"));
	else
		root["xgplayer-hlsjs.js"] = factory(root["xgplayer"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_xgplayer__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/eventemitter3/index.js":
/*!***********************************************************************************************!*\
  !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/eventemitter3/index.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "../../node_modules/events/events.js":
/*!*****************************************************************************************!*\
  !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/events/events.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),

/***/ "../../node_modules/url-toolkit/src/url-toolkit.js":
/*!*******************************************************************************************************!*\
  !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/url-toolkit/src/url-toolkit.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// see https://tools.ietf.org/html/rfc1808

/* jshint ignore:start */
(function(root) { 
/* jshint ignore:end */

  var URL_REGEX = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/\?#]*\/)*.*?)??(;.*?)?(\?.*?)?(#.*?)?$/;
  var FIRST_SEGMENT_REGEX = /^([^\/?#]*)(.*)$/;
  var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
  var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g;

  var URLToolkit = { // jshint ignore:line
    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
    // E.g
    // With opts.alwaysNormalize = false (default, spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
    // With opts.alwaysNormalize = true (not spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
    buildAbsoluteURL: function(baseURL, relativeURL, opts) {
      opts = opts || {};
      // remove any remaining space and CRLF
      baseURL = baseURL.trim();
      relativeURL = relativeURL.trim();
      if (!relativeURL) {
        // 2a) If the embedded URL is entirely empty, it inherits the
        // entire base URL (i.e., is set equal to the base URL)
        // and we are done.
        if (!opts.alwaysNormalize) {
          return baseURL;
        }
        var basePartsForNormalise = URLToolkit.parseURL(baseURL);
        if (!basePartsForNormalise) {
          throw new Error('Error trying to parse base URL.');
        }
        basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
        return URLToolkit.buildURLFromParts(basePartsForNormalise);
      }
      var relativeParts = URLToolkit.parseURL(relativeURL);
      if (!relativeParts) {
        throw new Error('Error trying to parse relative URL.');
      }
      if (relativeParts.scheme) {
        // 2b) If the embedded URL starts with a scheme name, it is
        // interpreted as an absolute URL and we are done.
        if (!opts.alwaysNormalize) {
          return relativeURL;
        }
        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
        return URLToolkit.buildURLFromParts(relativeParts);
      }
      var baseParts = URLToolkit.parseURL(baseURL);
      if (!baseParts) {
        throw new Error('Error trying to parse base URL.');
      }
      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
        baseParts.netLoc = pathParts[1];
        baseParts.path = pathParts[2];
      }
      if (baseParts.netLoc && !baseParts.path) {
        baseParts.path = '/';
      }
      var builtParts = {
        // 2c) Otherwise, the embedded URL inherits the scheme of
        // the base URL.
        scheme: baseParts.scheme,
        netLoc: relativeParts.netLoc,
        path: null,
        params: relativeParts.params,
        query: relativeParts.query,
        fragment: relativeParts.fragment
      };
      if (!relativeParts.netLoc) {
        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
        // (if any) of the base URL.
        builtParts.netLoc = baseParts.netLoc;
        // 4) If the embedded URL path is preceded by a slash "/", the
        // path is not relative and we skip to Step 7.
        if (relativeParts.path[0] !== '/') {
          if (!relativeParts.path) {
            // 5) If the embedded URL path is empty (and not preceded by a
            // slash), then the embedded URL inherits the base URL path
            builtParts.path = baseParts.path;
            // 5a) if the embedded URL's <params> is non-empty, we skip to
            // step 7; otherwise, it inherits the <params> of the base
            // URL (if any) and
            if (!relativeParts.params) {
              builtParts.params = baseParts.params;
              // 5b) if the embedded URL's <query> is non-empty, we skip to
              // step 7; otherwise, it inherits the <query> of the base
              // URL (if any) and we skip to step 7.
              if (!relativeParts.query) {
                builtParts.query = baseParts.query;
              }
            }
          } else {
            // 6) The last segment of the base URL's path (anything
            // following the rightmost slash "/", or the entire path if no
            // slash is present) is removed and the embedded URL's path is
            // appended in its place.
            var baseURLPath = baseParts.path;
            var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;
            builtParts.path = URLToolkit.normalizePath(newPath);
          }
        }
      }
      if (builtParts.path === null) {
        builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
      }
      return URLToolkit.buildURLFromParts(builtParts);
    },
    parseURL: function(url) {
      var parts = URL_REGEX.exec(url);
      if (!parts) {
        return null;
      }
      return {
        scheme: parts[1] || '',
        netLoc: parts[2] || '',
        path: parts[3] || '',
        params: parts[4] || '',
        query: parts[5] || '',
        fragment: parts[6] || ''
      };
    },
    normalizePath: function(path) {
      // The following operations are
      // then applied, in order, to the new path:
      // 6a) All occurrences of "./", where "." is a complete path
      // segment, are removed.
      // 6b) If the path ends with "." as a complete path segment,
      // that "." is removed.
      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
      // 6c) All occurrences of "<segment>/../", where <segment> is a
      // complete path segment not equal to "..", are removed.
      // Removal of these path segments is performed iteratively,
      // removing the leftmost matching pattern on each iteration,
      // until no matching pattern remains.
      // 6d) If the path ends with "<segment>/..", where <segment> is a
      // complete path segment not equal to "..", that
      // "<segment>/.." is removed.
      while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line
      return path.split('').reverse().join('');
    },
    buildURLFromParts: function(parts) {
      return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
    }
  };

/* jshint ignore:start */
  if(true)
    module.exports = URLToolkit;
  else {}
})(this);
/* jshint ignore:end */


/***/ }),

/***/ "../../node_modules/webworkify-webpack/index.js":
/*!****************************************************************************************************!*\
  !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/webworkify-webpack/index.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function webpackBootstrapFunc (modules) {
/******/  // The module cache
/******/  var installedModules = {};

/******/  // The require function
/******/  function __webpack_require__(moduleId) {

/******/    // Check if module is in cache
/******/    if(installedModules[moduleId])
/******/      return installedModules[moduleId].exports;

/******/    // Create a new module (and put it into the cache)
/******/    var module = installedModules[moduleId] = {
/******/      i: moduleId,
/******/      l: false,
/******/      exports: {}
/******/    };

/******/    // Execute the module function
/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/    // Flag the module as loaded
/******/    module.l = true;

/******/    // Return the exports of the module
/******/    return module.exports;
/******/  }

/******/  // expose the modules object (__webpack_modules__)
/******/  __webpack_require__.m = modules;

/******/  // expose the module cache
/******/  __webpack_require__.c = installedModules;

/******/  // identity function for calling harmony imports with the correct context
/******/  __webpack_require__.i = function(value) { return value; };

/******/  // define getter function for harmony exports
/******/  __webpack_require__.d = function(exports, name, getter) {
/******/    if(!__webpack_require__.o(exports, name)) {
/******/      Object.defineProperty(exports, name, {
/******/        configurable: false,
/******/        enumerable: true,
/******/        get: getter
/******/      });
/******/    }
/******/  };

/******/  // define __esModule on exports
/******/  __webpack_require__.r = function(exports) {
/******/    Object.defineProperty(exports, '__esModule', { value: true });
/******/  };

/******/  // getDefaultExport function for compatibility with non-harmony modules
/******/  __webpack_require__.n = function(module) {
/******/    var getter = module && module.__esModule ?
/******/      function getDefault() { return module['default']; } :
/******/      function getModuleExports() { return module; };
/******/    __webpack_require__.d(getter, 'a', getter);
/******/    return getter;
/******/  };

/******/  // Object.prototype.hasOwnProperty.call
/******/  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/  // __webpack_public_path__
/******/  __webpack_require__.p = "/";

/******/  // on error function for async loading
/******/  __webpack_require__.oe = function(err) { console.error(err); throw err; };

  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE)
  return f.default || f // try to call default if defined to also support babel esmodule exports
}

var moduleNameReqExp = '[\\.|\\-|\\+|\\w|\/|@]+'
var dependencyRegExp = '\\(\\s*(\/\\*.*?\\*\/)?\\s*.*?(' + moduleNameReqExp + ').*?\\)' // additional chars when output.pathinfo is true

// http://stackoverflow.com/a/2593661/130442
function quoteRegExp (str) {
  return (str + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&')
}

function isNumeric(n) {
  return !isNaN(1 * n); // 1 * n converts integers, integers as string ("123"), 1e3 and "1e3" to integers and strings to NaN
}

function getModuleDependencies (sources, module, queueName) {
  var retval = {}
  retval[queueName] = []

  var fnString = module.toString()
  var wrapperSignature = fnString.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/)
  if (!wrapperSignature) return retval
  var webpackRequireName = wrapperSignature[1]

  // main bundle deps
  var re = new RegExp('(\\\\n|\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')
  var match
  while ((match = re.exec(fnString))) {
    if (match[3] === 'dll-reference') continue
    retval[queueName].push(match[3])
  }

  // dll deps
  re = new RegExp('\\(' + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, 'g')
  while ((match = re.exec(fnString))) {
    if (!sources[match[2]]) {
      retval[queueName].push(match[1])
      sources[match[2]] = __webpack_require__(match[1]).m
    }
    retval[match[2]] = retval[match[2]] || []
    retval[match[2]].push(match[4])
  }

  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3
  var keys = Object.keys(retval);
  for (var i = 0; i < keys.length; i++) {
    for (var j = 0; j < retval[keys[i]].length; j++) {
      if (isNumeric(retval[keys[i]][j])) {
        retval[keys[i]][j] = 1 * retval[keys[i]][j];
      }
    }
  }

  return retval
}

function hasValuesInQueues (queues) {
  var keys = Object.keys(queues)
  return keys.reduce(function (hasValues, key) {
    return hasValues || queues[key].length > 0
  }, false)
}

function getRequiredModules (sources, moduleId) {
  var modulesQueue = {
    main: [moduleId]
  }
  var requiredModules = {
    main: []
  }
  var seenModules = {
    main: {}
  }

  while (hasValuesInQueues(modulesQueue)) {
    var queues = Object.keys(modulesQueue)
    for (var i = 0; i < queues.length; i++) {
      var queueName = queues[i]
      var queue = modulesQueue[queueName]
      var moduleToCheck = queue.pop()
      seenModules[queueName] = seenModules[queueName] || {}
      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue
      seenModules[queueName][moduleToCheck] = true
      requiredModules[queueName] = requiredModules[queueName] || []
      requiredModules[queueName].push(moduleToCheck)
      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)
      var newModulesKeys = Object.keys(newModules)
      for (var j = 0; j < newModulesKeys.length; j++) {
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])
      }
    }
  }

  return requiredModules
}

module.exports = function (moduleId, options) {
  options = options || {}
  var sources = {
    main: __webpack_require__.m
  }

  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId)

  var src = ''

  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {
    var entryModule = 0
    while (requiredModules[module][entryModule]) {
      entryModule++
    }
    requiredModules[module].push(entryModule)
    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'
    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\n'
  })

  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '}))(self);'

  var blob = new window.Blob([src], { type: 'text/javascript' })
  if (options.bare) { return blob }

  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL

  var workerUrl = URL.createObjectURL(blob)
  var worker = new window.Worker(workerUrl)
  worker.objectURL = workerUrl

  return worker
}


/***/ }),

/***/ "./src/hls.js/config.js":
/*!******************************!*\
  !*** ./src/hls.js/config.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hlsDefaultConfig = undefined;

var _abrController = __webpack_require__(/*! ./controller/abr-controller */ "./src/hls.js/controller/abr-controller.js");

var _abrController2 = _interopRequireDefault(_abrController);

var _bufferController = __webpack_require__(/*! ./controller/buffer-controller */ "./src/hls.js/controller/buffer-controller.js");

var _bufferController2 = _interopRequireDefault(_bufferController);

var _capLevelController = __webpack_require__(/*! ./controller/cap-level-controller */ "./src/hls.js/controller/cap-level-controller.js");

var _capLevelController2 = _interopRequireDefault(_capLevelController);

var _fpsController = __webpack_require__(/*! ./controller/fps-controller */ "./src/hls.js/controller/fps-controller.js");

var _fpsController2 = _interopRequireDefault(_fpsController);

var _xhrLoader = __webpack_require__(/*! ./utils/xhr-loader */ "./src/hls.js/utils/xhr-loader.js");

var _xhrLoader2 = _interopRequireDefault(_xhrLoader);

var _audioTrackController = __webpack_require__(/*! ./controller/audio-track-controller */ "./src/hls.js/controller/audio-track-controller.js");

var _audioTrackController2 = _interopRequireDefault(_audioTrackController);

var _audioStreamController = __webpack_require__(/*! ./controller/audio-stream-controller */ "./src/hls.js/controller/audio-stream-controller.js");

var _audioStreamController2 = _interopRequireDefault(_audioStreamController);

var _cues = __webpack_require__(/*! ./utils/cues */ "./src/hls.js/utils/cues.js");

var Cues = _interopRequireWildcard(_cues);

var _timelineController = __webpack_require__(/*! ./controller/timeline-controller */ "./src/hls.js/controller/timeline-controller.js");

var _timelineController2 = _interopRequireDefault(_timelineController);

var _subtitleTrackController = __webpack_require__(/*! ./controller/subtitle-track-controller */ "./src/hls.js/controller/subtitle-track-controller.js");

var _subtitleTrackController2 = _interopRequireDefault(_subtitleTrackController);

var _subtitleStreamController = __webpack_require__(/*! ./controller/subtitle-stream-controller */ "./src/hls.js/controller/subtitle-stream-controller.js");

var _emeController = __webpack_require__(/*! ./controller/eme-controller */ "./src/hls.js/controller/eme-controller.js");

var _emeController2 = _interopRequireDefault(_emeController);

var _mediakeysHelper = __webpack_require__(/*! ./utils/mediakeys-helper */ "./src/hls.js/utils/mediakeys-helper.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import FetchLoader from './utils/fetch-loader';

var hlsDefaultConfig = exports.hlsDefaultConfig = {
  autoStartLoad: true, // used by stream-controller
  startPosition: -1, // used by stream-controller
  defaultAudioCodec: undefined, // used by stream-controller
  debug: false, // used by logger
  capLevelOnFPSDrop: false, // used by fps-controller
  capLevelToPlayerSize: false, // used by cap-level-controller
  initialLiveManifestSize: 1, // used by stream-controller
  maxBufferLength: 30, // used by stream-controller
  maxBufferSize: 60 * 1000 * 1000, // used by stream-controller
  maxBufferHole: 0.5, // used by stream-controller

  lowBufferWatchdogPeriod: 0.5, // used by stream-controller
  highBufferWatchdogPeriod: 3, // used by stream-controller
  nudgeOffset: 0.1, // used by stream-controller
  nudgeMaxRetry: 3, // used by stream-controller
  maxFragLookUpTolerance: 0.25, // used by stream-controller
  liveSyncDurationCount: 3, // used by stream-controller
  liveMaxLatencyDurationCount: Infinity, // used by stream-controller
  liveSyncDuration: undefined, // used by stream-controller
  liveMaxLatencyDuration: undefined, // used by stream-controller
  liveDurationInfinity: false, // used by buffer-controller
  liveBackBufferLength: Infinity, // used by buffer-controller
  maxMaxBufferLength: 600, // used by stream-controller
  enableWorker: true, // used by demuxer
  enableSoftwareAES: true, // used by decrypter
  manifestLoadingTimeOut: 10000, // used by playlist-loader
  manifestLoadingMaxRetry: 1, // used by playlist-loader
  manifestLoadingRetryDelay: 1000, // used by playlist-loader
  manifestLoadingMaxRetryTimeout: 64000, // used by playlist-loader
  startLevel: undefined, // used by level-controller
  levelLoadingTimeOut: 10000, // used by playlist-loader
  levelLoadingMaxRetry: 4, // used by playlist-loader
  levelLoadingRetryDelay: 1000, // used by playlist-loader
  levelLoadingMaxRetryTimeout: 64000, // used by playlist-loader
  fragLoadingTimeOut: 20000, // used by fragment-loader
  fragLoadingMaxRetry: 6, // used by fragment-loader
  fragLoadingRetryDelay: 1000, // used by fragment-loader
  fragLoadingMaxRetryTimeout: 64000, // used by fragment-loader
  startFragPrefetch: false, // used by stream-controller
  fpsDroppedMonitoringPeriod: 5000, // used by fps-controller
  fpsDroppedMonitoringThreshold: 0.2, // used by fps-controller
  appendErrorMaxRetry: 3, // used by buffer-controller
  loader: _xhrLoader2.default,
  // loader: FetchLoader,
  fLoader: undefined, // used by fragment-loader
  pLoader: undefined, // used by playlist-loader
  xhrSetup: undefined, // used by xhr-loader
  licenseXhrSetup: undefined, // used by eme-controller
  // fetchSetup: undefined,
  abrController: _abrController2.default,
  bufferController: _bufferController2.default,
  capLevelController: _capLevelController2.default,
  fpsController: _fpsController2.default,
  stretchShortVideoTrack: false, // used by mp4-remuxer
  maxAudioFramesDrift: 1, // used by mp4-remuxer
  forceKeyFrameOnDiscontinuity: true, // used by ts-demuxer
  abrEwmaFastLive: 3, // used by abr-controller
  abrEwmaSlowLive: 9, // used by abr-controller
  abrEwmaFastVoD: 3, // used by abr-controller
  abrEwmaSlowVoD: 9, // used by abr-controller
  abrEwmaDefaultEstimate: 5e5, // 500 kbps  // used by abr-controller
  abrBandWidthFactor: 0.95, // used by abr-controller
  abrBandWidthUpFactor: 0.7, // used by abr-controller
  abrMaxWithRealBitrate: false, // used by abr-controller
  maxStarvationDelay: 4, // used by abr-controller
  maxLoadingDelay: 4, // used by abr-controller
  minAutoBitrate: 0, // used by hls
  emeEnabled: false, // used by eme-controller
  widevineLicenseUrl: undefined, // used by eme-controller
  requestMediaKeySystemAccessFunc: _mediakeysHelper.requestMediaKeySystemAccess // used by eme-controller
}; /**
    * HLS config
    */

hlsDefaultConfig.subtitleStreamController = _subtitleStreamController.SubtitleStreamController;
hlsDefaultConfig.subtitleTrackController = _subtitleTrackController2.default;
hlsDefaultConfig.timelineController = _timelineController2.default;
hlsDefaultConfig.cueHandler = Cues; // used by timeline-controller
hlsDefaultConfig.enableCEA708Captions = true; // used by timeline-controller
hlsDefaultConfig.enableWebVTT = true; // used by timeline-controller
hlsDefaultConfig.captionsTextTrack1Label = 'English'; // used by timeline-controller
hlsDefaultConfig.captionsTextTrack1LanguageCode = 'en'; // used by timeline-controller
hlsDefaultConfig.captionsTextTrack2Label = 'Spanish'; // used by timeline-controller
hlsDefaultConfig.captionsTextTrack2LanguageCode = 'es'; // used by timeline-controller


hlsDefaultConfig.audioStreamController = _audioStreamController2.default;
hlsDefaultConfig.audioTrackController = _audioTrackController2.default;

hlsDefaultConfig.emeController = _emeController2.default;

/***/ }),

/***/ "./src/hls.js/controller/abr-controller.js":
/*!*************************************************!*\
  !*** ./src/hls.js/controller/abr-controller.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _ewmaBandwidthEstimator = __webpack_require__(/*! ../utils/ewma-bandwidth-estimator */ "./src/hls.js/utils/ewma-bandwidth-estimator.js");

var _ewmaBandwidthEstimator2 = _interopRequireDefault(_ewmaBandwidthEstimator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * simple ABR Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - compute next level based on last fragment bw heuristics
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _window = window,
    performance = _window.performance;

var AbrController = function (_EventHandler) {
  _inherits(AbrController, _EventHandler);

  function AbrController(hls) {
    _classCallCheck(this, AbrController);

    var _this = _possibleConstructorReturn(this, (AbrController.__proto__ || Object.getPrototypeOf(AbrController)).call(this, hls, _events2.default.FRAG_LOADING, _events2.default.FRAG_LOADED, _events2.default.FRAG_BUFFERED, _events2.default.ERROR));

    _this.lastLoadedFragLevel = 0;
    _this._nextAutoLevel = -1;
    _this.hls = hls;
    _this.timer = null;
    _this._bwEstimator = null;
    _this.onCheck = _this._abandonRulesCheck.bind(_this);
    return _this;
  }

  _createClass(AbrController, [{
    key: 'destroy',
    value: function destroy() {
      this.clearTimer();
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag;
      if (frag.type === 'main') {
        if (!this.timer) {
          this.fragCurrent = frag;
          this.timer = setInterval(this.onCheck, 100);
        }

        // lazy init of BwEstimator, rationale is that we use different params for Live/VoD
        // so we need to wait for stream manifest / playlist type to instantiate it.
        if (!this._bwEstimator) {
          var hls = this.hls;
          var config = hls.config;
          var level = frag.levels;
          var isLive = hls.levels[level].details.live;

          var ewmaFast = void 0,
              ewmaSlow = void 0;
          if (isLive) {
            ewmaFast = config.abrEwmaFastLive;
            ewmaSlow = config.abrEwmaSlowLive;
          } else {
            ewmaFast = config.abrEwmaFastVoD;
            ewmaSlow = config.abrEwmaSlowVoD;
          }
          this._bwEstimator = new _ewmaBandwidthEstimator2.default(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
        }
      }
    }
  }, {
    key: '_abandonRulesCheck',
    value: function _abandonRulesCheck() {
      /*
        monitor fragment retrieval time...
        we compute expected time of arrival of the complete fragment.
        we compare it to expected time of buffer starvation
      */
      var hls = this.hls;
      var video = hls.media;
      var frag = this.fragCurrent;

      if (!frag) {
        return;
      }

      var loader = frag.loader;
      var minAutoLevel = hls.minAutoLevel;

      // if loader has been destroyed or loading has been aborted, stop timer and return
      if (!loader || loader.stats && loader.stats.aborted) {
        _logger.logger.warn('frag loader destroy or aborted, disarm abandonRules');
        this.clearTimer();
        // reset forced auto level value so that next level will be selected
        this._nextAutoLevel = -1;
        return;
      }
      var stats = loader.stats;
      /* only monitor frag retrieval time if
      (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
      if (video && stats && (!video.paused && video.playbackRate !== 0 || !video.readyState) && frag.autoLevel && frag.levels) {
        var requestDelay = performance.now() - stats.trequest,
            playbackRate = Math.abs(video.playbackRate);
        // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
        if (requestDelay > 500 * frag.duration / playbackRate) {
          var levels = hls.levels,
              loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay),
              // byte/s; at least 1 byte/s to avoid division by zero
          // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
          level = levels[frag.levels],
              levelBitrate = level.realBitrate ? Math.max(level.realBitrate, level.bitrate) : level.bitrate,
              expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levelBitrate / 8)),
              pos = video.currentTime,
              fragLoadedDelay = (expectedLen - stats.loaded) / loadRate,
              bufferStarvationDelay = (_bufferHelper.BufferHelper.bufferInfo(video, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
          // consider emergency switch down only if we have less than 2 frag buffered AND
          // time to finish loading current fragment is bigger than buffer starvation delay
          // ie if we risk buffer starvation if bw does not increase quickly
          if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {
            var fragLevelNextLoadedDelay = void 0,
                nextLoadLevel = void 0;
            // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
            // we start from current level - 1 and we step down , until we find a matching level
            for (nextLoadLevel = frag.levels - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
              // compute time to load next fragment at lower level
              // 0.8 : consider only 80% of current bw to be conservative
              // 8 = bits per byte (bps/Bps)
              var levelNextBitrate = levels[nextLoadLevel].realBitrate ? Math.max(levels[nextLoadLevel].realBitrate, levels[nextLoadLevel].bitrate) : levels[nextLoadLevel].bitrate;
              fragLevelNextLoadedDelay = frag.duration * levelNextBitrate / (8 * 0.8 * loadRate);
              if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
                // we found a lower level that be rebuffering free with current estimated bw !
                break;
              }
            }
            // only emergency switch down if it takes less time to load new fragment at lowest level instead
            // of finishing loading current one ...
            if (fragLevelNextLoadedDelay < fragLoadedDelay) {
              _logger.logger.warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel + ':fragLoadedDelay[' + nextLoadLevel + ']<fragLoadedDelay[' + (frag.levels - 1) + '];bufferStarvationDelay:' + fragLevelNextLoadedDelay.toFixed(1) + '<' + fragLoadedDelay.toFixed(1) + ':' + bufferStarvationDelay.toFixed(1));
              // force next load level in auto mode
              hls.nextLoadLevel = nextLoadLevel;
              // update bw estimate for this fragment before cancelling load (this will help reducing the bw)
              this._bwEstimator.sample(requestDelay, stats.loaded);
              // abort fragment loading
              loader.abort();
              // stop abandon rules timer
              this.clearTimer();
              hls.trigger(_events2.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, stats: stats });
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var frag = data.frag;
      if (frag.type === 'main' && Number.isFinite(frag.sn)) {
        // stop monitoring bw once frag loaded
        this.clearTimer();
        // store level id after successful fragment load
        this.lastLoadedFragLevel = frag.levels;
        // reset forced auto level value so that next level will be selected
        this._nextAutoLevel = -1;

        // compute level average bitrate
        if (this.hls.config.abrMaxWithRealBitrate) {
          var level = this.hls.levels[frag.levels];
          var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + data.stats.loaded;
          var loadedDuration = (level.loaded ? level.loaded.duration : 0) + data.frag.duration;
          level.loaded = { bytes: loadedBytes, duration: loadedDuration };
          level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
        }
        // if fragment has been loaded to perform a bitrate test,
        if (data.frag.bitrateTest) {
          var stats = data.stats;
          stats.tparsed = stats.tbuffered = stats.tload;
          this.onFragBuffered(data);
        }
      }
    }
  }, {
    key: 'onFragBuffered',
    value: function onFragBuffered(data) {
      var stats = data.stats;
      var frag = data.frag;
      // only update stats on first frag buffering
      // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
      // and leading to wrong bw estimation
      // on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)
      if (stats.aborted !== true && frag.type === 'main' && Number.isFinite(frag.sn) && (!frag.bitrateTest || stats.tload === stats.tbuffered)) {
        // use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached
        // in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached
        // as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation
        var fragLoadingProcessingMs = stats.tparsed - stats.trequest;
        _logger.logger.log('latency/loading/parsing/append/kbps:' + Math.round(stats.tfirst - stats.trequest) + '/' + Math.round(stats.tload - stats.tfirst) + '/' + Math.round(stats.tparsed - stats.tload) + '/' + Math.round(stats.tbuffered - stats.tparsed) + '/' + Math.round(8 * stats.loaded / (stats.tbuffered - stats.trequest)));
        this._bwEstimator.sample(fragLoadingProcessingMs, stats.loaded);
        stats.bwEstimate = this._bwEstimator.getEstimate();
        // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration
        if (frag.bitrateTest) {
          this.bitrateTestDelay = fragLoadingProcessingMs / 1000;
        } else {
          this.bitrateTestDelay = 0;
        }
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      // stop timer in case of frag loading error
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          this.clearTimer();
          break;
        default:
          break;
      }
    }
  }, {
    key: 'clearTimer',
    value: function clearTimer() {
      clearInterval(this.timer);
      this.timer = null;
    }

    // return next auto level

  }, {
    key: '_findBestLevel',
    value: function _findBestLevel(currentLevel, currentFragDuration, currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {
      for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
        var levelInfo = levels[i];

        if (!levelInfo) {
          continue;
        }

        var levelDetails = levelInfo.details,
            avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration,
            live = levelDetails ? levelDetails.live : false,
            adjustedbw = void 0;
        // follow algorithm captured from stagefright :
        // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
        // Pick the highest bandwidth stream below or equal to estimated bandwidth.
        // consider only 80% of the available bandwidth, but if we are switching up,
        // be even more conservative (70%) to avoid overestimating and immediately
        // switching back.
        if (i <= currentLevel) {
          adjustedbw = bwFactor * currentBw;
        } else {
          adjustedbw = bwUpFactor * currentBw;
        }

        var bitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate,
            fetchDuration = bitrate * avgDuration / adjustedbw;

        _logger.logger.trace('level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: ' + i + '/' + Math.round(adjustedbw) + '/' + bitrate + '/' + avgDuration + '/' + maxFetchDuration + '/' + fetchDuration);
        // if adjusted bw is greater than level bitrate AND
        if (adjustedbw > bitrate && (
        // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
        // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that _findBestLevel will return -1
        !fetchDuration || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {
          // as we are looping from highest to lowest, this will return the best achievable quality level
          return i;
        }
      }
      // not enough time budget even with quality level 0 ... rebuffering might happen
      return -1;
    }
  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var forcedAutoLevel = this._nextAutoLevel;
      var bwEstimator = this._bwEstimator;
      // in case next auto level has been forced, and bw not available or not reliable, return forced value
      if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {
        return forcedAutoLevel;
      }

      // compute next level using ABR logic
      var nextABRAutoLevel = this._nextABRAutoLevel;
      // if forced auto level has been defined, use it to cap ABR computed quality level
      if (forcedAutoLevel !== -1) {
        nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);
      }

      return nextABRAutoLevel;
    },
    set: function set(nextLevel) {
      this._nextAutoLevel = nextLevel;
    }
  }, {
    key: '_nextABRAutoLevel',
    get: function get() {
      var hls = this.hls,
          maxAutoLevel = hls.maxAutoLevel,
          levels = hls.levels,
          config = hls.config,
          minAutoLevel = hls.minAutoLevel;
      var video = hls.media,
          currentLevel = this.lastLoadedFragLevel,
          currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0,
          pos = video ? video.currentTime : 0,

      // playbackRate is the absolute value of the playback rate; if video.playbackRate is 0, we use 1 to load as
      // if we're playing back at the normal rate.
      playbackRate = video && video.playbackRate !== 0 ? Math.abs(video.playbackRate) : 1.0,
          avgbw = this._bwEstimator ? this._bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate,

      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
      bufferStarvationDelay = (_bufferHelper.BufferHelper.bufferInfo(video, pos, config.maxBufferHole).end - pos) / playbackRate;

      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
      var bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);
      if (bestLevel >= 0) {
        return bestLevel;
      } else {
        _logger.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');
        // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
        // if no matching level found, logic will return 0
        var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay,
            bwFactor = config.abrBandWidthFactor,
            bwUpFactor = config.abrBandWidthUpFactor;
        if (bufferStarvationDelay === 0) {
          // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
          var bitrateTestDelay = this.bitrateTestDelay;
          if (bitrateTestDelay) {
            // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
            // max video loading delay used in  automatic start level selection :
            // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
            // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
            // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration
            var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
            maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
            _logger.logger.trace('bitrate test took ' + Math.round(1000 * bitrateTestDelay) + 'ms, set first fragment max fetchDuration to ' + Math.round(1000 * maxStarvationDelay) + ' ms');
            // don't use conservative factor on bitrate test
            bwFactor = bwUpFactor = 1;
          }
        }
        bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels);
        return Math.max(bestLevel, 0);
      }
    }
  }]);

  return AbrController;
}(_eventHandler2.default);

exports.default = AbrController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/audio-stream-controller.js":
/*!**********************************************************!*\
  !*** ./src/hls.js/controller/audio-stream-controller.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = __webpack_require__(/*! ../utils/binary-search */ "./src/hls.js/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _demuxer = __webpack_require__(/*! ../demux/demuxer */ "./src/hls.js/demux/demuxer.js");

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

var LevelHelper = _interopRequireWildcard(_levelHelper);

var _timeRanges = __webpack_require__(/*! ../utils/time-ranges */ "./src/hls.js/utils/time-ranges.js");

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _discontinuities = __webpack_require__(/*! ../utils/discontinuities */ "./src/hls.js/utils/discontinuities.js");

var _fragmentTracker = __webpack_require__(/*! ./fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _fragment = __webpack_require__(/*! ../loader/fragment */ "./src/hls.js/loader/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _baseStreamController = __webpack_require__(/*! ./base-stream-controller */ "./src/hls.js/controller/base-stream-controller.js");

var _baseStreamController2 = _interopRequireDefault(_baseStreamController);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Audio Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var _window = window,
    performance = _window.performance;


var TICK_INTERVAL = 100; // how often to tick in ms

var AudioStreamController = function (_BaseStreamController) {
  _inherits(AudioStreamController, _BaseStreamController);

  function AudioStreamController(hls, fragmentTracker) {
    _classCallCheck(this, AudioStreamController);

    var _this = _possibleConstructorReturn(this, (AudioStreamController.__proto__ || Object.getPrototypeOf(AudioStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.AUDIO_TRACKS_UPDATED, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.BUFFER_RESET, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED, _events2.default.INIT_PTS_FOUND));

    _this.fragmentTracker = fragmentTracker;
    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this._state = _baseStreamController.State.STOPPED;
    _this.initPTS = [];
    _this.waitingFragment = null;
    _this.videoTrackCC = null;
    return _this;
  }

  // Signal that video PTS was found


  _createClass(AudioStreamController, [{
    key: 'onInitPtsFound',
    value: function onInitPtsFound(data) {
      var demuxerId = data.id,
          cc = data.frag.cc,
          initPTS = data.initPTS;
      if (demuxerId === 'main') {
        // Always update the new INIT PTS
        // Can change due level switch
        this.initPTS[cc] = initPTS;
        this.videoTrackCC = cc;
        _logger.logger.log('InitPTS for cc: ' + cc + ' found from video track: ' + initPTS);

        // If we are waiting we need to demux/remux the waiting frag
        // With the new initPTS
        if (this.state === _baseStreamController.State.WAITING_INIT_PTS) {
          this.tick();
        }
      }
    }
  }, {
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.tracks) {
        var lastCurrentTime = this.lastCurrentTime;
        this.stopLoad();
        this.setInterval(TICK_INTERVAL);
        this.fragLoadError = 0;
        if (lastCurrentTime > 0 && startPosition === -1) {
          _logger.logger.log('audio:override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
          this.state = _baseStreamController.State.IDLE;
        } else {
          this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
          this.state = _baseStreamController.State.STARTING;
        }
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
        this.tick();
      } else {
        this.startPosition = startPosition;
        this.state = _baseStreamController.State.STOPPED;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      var pos = void 0,
          track = void 0,
          trackDetails = void 0,
          hls = this.hls,
          config = hls.config;
      // logger.log('audioStream:' + this.state);
      switch (this.state) {
        case _baseStreamController.State.ERROR:
        // don't do anything in error state to avoid breaking further ...
        case _baseStreamController.State.PAUSED:
        // don't do anything in paused state either ...
        case _baseStreamController.State.BUFFER_FLUSHING:
          break;
        case _baseStreamController.State.STARTING:
          this.state = _baseStreamController.State.WAITING_TRACK;
          this.loadedmetadata = false;
          break;
        case _baseStreamController.State.IDLE:
          var tracks = this.tracks;
          // audio tracks not received => exit loop
          if (!tracks) {
            break;
          }

          // if video not attached AND
          // start fragment already requested OR start frag prefetch disable
          // exit loop
          // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
          if (!this.media && (this.startFragRequested || !config.startFragPrefetch)) {
            break;
          }

          // determine next candidate fragment to be loaded, based on current position and
          //  end of buffer position
          // if we have not yet loaded any fragment, start loading from start position
          if (this.loadedmetadata) {
            pos = this.media.currentTime;
          } else {
            pos = this.nextLoadPosition;
            if (pos === undefined) {
              break;
            }
          }
          var media = this.mediaBuffer ? this.mediaBuffer : this.media,
              videoBuffer = this.videoBuffer ? this.videoBuffer : this.media,
              bufferInfo = _bufferHelper.BufferHelper.bufferInfo(media, pos, config.maxBufferHole),
              mainBufferInfo = _bufferHelper.BufferHelper.bufferInfo(videoBuffer, pos, config.maxBufferHole),
              bufferLen = bufferInfo.len,
              bufferEnd = bufferInfo.end,
              fragPrevious = this.fragPrevious,

          // ensure we buffer at least config.maxBufferLength (default 30s) or config.maxMaxBufferLength (default: 600s)
          // whichever is smaller.
          // once we reach that threshold, don't buffer more than video (mainBufferInfo.len)
          maxConfigBuffer = Math.min(config.maxBufferLength, config.maxMaxBufferLength),
              maxBufLen = Math.max(maxConfigBuffer, mainBufferInfo.len),
              audioSwitch = this.audioSwitch,
              trackId = this.trackId;

          // if buffer length is less than maxBufLen try to load a new fragment
          if ((bufferLen < maxBufLen || audioSwitch) && trackId < tracks.length) {
            trackDetails = tracks[trackId].details;
            // if track info not retrieved yet, switch state and wait for track retrieval
            if (typeof trackDetails === 'undefined') {
              this.state = _baseStreamController.State.WAITING_TRACK;
              break;
            }

            if (!audioSwitch && this._streamEnded(bufferInfo, trackDetails)) {
              this.hls.trigger(_events2.default.BUFFER_EOS, { type: 'audio' });
              this.state = _baseStreamController.State.ENDED;
              return;
            }

            // find fragment index, contiguous with end of buffer position
            var fragments = trackDetails.fragments,
                fragLen = fragments.length,
                start = fragments[0].start,
                end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
                frag = void 0;

            // When switching audio track, reload audio as close as possible to currentTime
            if (audioSwitch) {
              if (trackDetails.live && !trackDetails.PTSKnown) {
                _logger.logger.log('switching audiotrack, live stream, unknown PTS,load first fragment');
                bufferEnd = 0;
              } else {
                bufferEnd = pos;
                // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime
                if (trackDetails.PTSKnown && pos < start) {
                  // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start
                  if (bufferInfo.end > start || bufferInfo.nextStart) {
                    _logger.logger.log('alt audio track ahead of main track, seek to start of alt audio track');
                    this.media.currentTime = start + 0.05;
                  } else {
                    return;
                  }
                }
              }
            }
            if (trackDetails.initSegment && !trackDetails.initSegment.data) {
              frag = trackDetails.initSegment;
            } // eslint-disable-line brace-style
            // if bufferEnd before start of playlist, load first fragment
            else if (bufferEnd <= start) {
                frag = fragments[0];
                if (this.videoTrackCC !== null && frag.cc !== this.videoTrackCC) {
                  // Ensure we find a fragment which matches the continuity of the video track
                  frag = (0, _discontinuities.findFragWithCC)(fragments, this.videoTrackCC);
                }
                if (trackDetails.live && frag.loadIdx && frag.loadIdx === this.fragLoadIdx) {
                  // we just loaded this first fragment, and we are still lagging behind the start of the live playlist
                  // let's force seek to start
                  var nextBuffered = bufferInfo.nextStart ? bufferInfo.nextStart : start;
                  _logger.logger.log('no alt audio available @currentTime:' + this.media.currentTime + ', seeking @' + (nextBuffered + 0.05));
                  this.media.currentTime = nextBuffered + 0.05;
                  return;
                }
              } else {
                var foundFrag = void 0;
                var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;
                var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
                  // offset should be within fragment boundary - config.maxFragLookUpTolerance
                  // this is to cope with situations like
                  // bufferEnd = 9.991
                  // frag[] : [0,10]
                  // frag[1] : [10,20]
                  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
                  //              frag start               frag start+duration
                  //                  |-----------------------------|
                  //              <--->                         <--->
                  //  ...--------><-----------------------------><---------....
                  // previous frag         matching fragment         next frag
                  //  return -1             return 0                 return 1
                  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
                  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
                  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);
                  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
                    return 1;
                  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
                    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
                    return -1;
                  }

                  return 0;
                };

                if (bufferEnd < end) {
                  if (bufferEnd > end - maxFragLookUpTolerance) {
                    maxFragLookUpTolerance = 0;
                  }

                  // Prefer the next fragment if it's within tolerance
                  if (fragNext && !fragmentWithinToleranceTest(fragNext)) {
                    foundFrag = fragNext;
                  } else {
                    foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);
                  }
                } else {
                  // reach end of playlist
                  foundFrag = fragments[fragLen - 1];
                }
                if (foundFrag) {
                  frag = foundFrag;
                  start = foundFrag.start;
                  // logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
                  if (fragPrevious && frag.levels === fragPrevious.levels && frag.sn === fragPrevious.sn) {
                    if (frag.sn < trackDetails.endSN) {
                      frag = fragments[frag.sn + 1 - trackDetails.startSN];
                      _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
                    } else {
                      frag = null;
                    }
                  }
                }
              }
            if (frag) {
              // logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
              if (frag.encrypted) {
                _logger.logger.log('Loading key for ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId);
                this.state = _baseStreamController.State.KEY_LOADING;
                hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
              } else {
                _logger.logger.log('Loading ' + frag.sn + ', cc: ' + frag.cc + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
                // only load if fragment is not loaded or if in audio switch
                // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch
                this.fragCurrent = frag;
                if (audioSwitch || this.fragmentTracker.getState(frag) === _fragmentTracker.FragmentState.NOT_LOADED) {
                  this.startFragRequested = true;
                  if (Number.isFinite(frag.sn)) {
                    this.nextLoadPosition = frag.start + frag.duration;
                  }

                  hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
                  this.state = _baseStreamController.State.FRAG_LOADING;
                }
              }
            }
          }
          break;
        case _baseStreamController.State.WAITING_TRACK:
          track = this.tracks[this.trackId];
          // check if playlist is already loaded
          if (track && track.details) {
            this.state = _baseStreamController.State.IDLE;
          }

          break;
        case _baseStreamController.State.FRAG_LOADING_WAITING_RETRY:
          var now = performance.now();
          var retryDate = this.retryDate;
          media = this.media;
          var isSeeking = media && media.seeking;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || isSeeking) {
            _logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');
            this.state = _baseStreamController.State.IDLE;
          }
          break;
        case _baseStreamController.State.WAITING_INIT_PTS:
          var videoTrackCC = this.videoTrackCC;
          if (this.initPTS[videoTrackCC] === undefined) {
            break;
          }

          // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS
          var waitingFrag = this.waitingFragment;
          if (waitingFrag) {
            var waitingFragCC = waitingFrag.frag.cc;
            if (videoTrackCC !== waitingFragCC) {
              track = this.tracks[this.trackId];
              if (track.details && track.details.live) {
                _logger.logger.warn('Waiting fragment CC (' + waitingFragCC + ') does not match video track CC (' + videoTrackCC + ')');
                this.waitingFragment = null;
                this.state = _baseStreamController.State.IDLE;
              }
            } else {
              this.state = _baseStreamController.State.FRAG_LOADING;
              this.onFragLoaded(this.waitingFragment);
              this.waitingFragment = null;
            }
          } else {
            this.state = _baseStreamController.State.IDLE;
          }

          break;
        case _baseStreamController.State.STOPPED:
        case _baseStreamController.State.FRAG_LOADING:
        case _baseStreamController.State.PARSING:
        case _baseStreamController.State.PARSED:
        case _baseStreamController.State.ENDED:
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.tracks && config.autoStartLoad) {
        this.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = this.mediaBuffer = this.videoBuffer = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onAudioTracksUpdated',
    value: function onAudioTracksUpdated(data) {
      _logger.logger.log('audio tracks updated');
      this.tracks = data.audioTracks;
    }
  }, {
    key: 'onAudioTrackSwitching',
    value: function onAudioTrackSwitching(data) {
      // if any URL found on new audio track, it is an alternate audio track
      var altAudio = !!data.url;
      this.trackId = data.id;

      this.fragCurrent = null;
      this.state = _baseStreamController.State.PAUSED;
      this.waitingFragment = null;
      // destroy useless demuxer when switching audio to main
      if (!altAudio) {
        if (this.demuxer) {
          this.demuxer.destroy();
          this.demuxer = null;
        }
      } else {
        // switching to audio track, start timer if not already started
        this.setInterval(TICK_INTERVAL);
      }

      // should we switch tracks ?
      if (altAudio) {
        this.audioSwitch = true;
        // main audio track are handled by stream-controller, just do something if switching to alt audio track
        this.state = _baseStreamController.State.IDLE;
      }
      this.tick();
    }
  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      var newDetails = data.details,
          trackId = data.id,
          track = this.tracks[trackId],
          duration = newDetails.totalduration,
          sliding = 0;

      _logger.logger.log('track ' + trackId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);

      if (newDetails.live) {
        var curDetails = track.details;
        if (curDetails && newDetails.fragments.length > 0) {
          // we already have details for that level, merge them
          LevelHelper.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          // TODO
          // this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown) {
            _logger.logger.log('live audio playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live audio playlist - outdated PTS, unknown sliding');
          }
        } else {
          newDetails.PTSKnown = false;
          _logger.logger.log('live audio playlist - first load, unknown sliding');
        }
      } else {
        newDetails.PTSKnown = false;
      }
      track.details = newDetails;

      // compute start position
      if (!this.startFragRequested) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (Number.isFinite(startTimeOffset)) {
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            this.startPosition = 0;
          }
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
      if (this.state === _baseStreamController.State.WAITING_TRACK) {
        this.state = _baseStreamController.State.IDLE;
      }

      // trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === _baseStreamController.State.KEY_LOADING) {
        this.state = _baseStreamController.State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent,
          fragLoaded = data.frag;
      if (this.state === _baseStreamController.State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'audio' && fragLoaded.levels === fragCurrent.levels && fragLoaded.sn === fragCurrent.sn) {
        var track = this.tracks[this.trackId],
            details = track.details,
            duration = details.totalduration,
            trackId = fragCurrent.levels,
            sn = fragCurrent.sn,
            cc = fragCurrent.cc,
            audioCodec = this.config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2',
            stats = this.stats = data.stats;
        if (sn === 'initSegment') {
          this.state = _baseStreamController.State.IDLE;

          stats.tparsed = stats.tbuffered = performance.now();
          details.initSegment.data = data.payload;
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'audio' });
          this.tick();
        } else {
          this.state = _baseStreamController.State.PARSING;
          // transmux the MPEG-TS data to ISO-BMFF segments
          this.appended = false;
          if (!this.demuxer) {
            this.demuxer = new _demuxer2.default(this.hls, 'audio');
          }

          // Check if we have video initPTS
          // If not we need to wait for it
          var initPTS = this.initPTS[cc];
          var initSegmentData = details.initSegment ? details.initSegment.data : [];
          if (details.initSegment || initPTS !== undefined) {
            this.pendingBuffering = true;
            _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
            // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
            var accurateTimeOffset = false; // details.PTSKnown || !details.live;
            this.demuxer.push(data.payload, initSegmentData, audioCodec, null, fragCurrent, duration, accurateTimeOffset, initPTS);
          } else {
            _logger.logger.log('unknown video PTS for continuity counter ' + cc + ', waiting for video PTS before demuxing audio frag ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
            this.waitingFragment = data;
            this.state = _baseStreamController.State.WAITING_INIT_PTS;
          }
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.levels === fragCurrent.levels && this.state === _baseStreamController.State.PARSING) {
        var tracks = data.tracks,
            track = void 0;

        // delete any video track found on audio demuxer
        if (tracks.video) {
          delete tracks.video;
        }

        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          track.levelCodec = track.codec;
          track.id = data.id;
          this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
          _logger.logger.log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            var appendObj = { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' };
            if (this.audioSwitch) {
              this.pendingData = [appendObj];
            } else {
              this.appended = true;
              // arm pending Buffering flag before appending a segment
              this.pendingBuffering = true;
              this.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
            }
          }
          // trigger handler right now
          this.tick();
        }
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && data.type === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.levels === fragCurrent.levels && this.state === _baseStreamController.State.PARSING) {
        var trackId = this.trackId,
            track = this.tracks[trackId],
            hls = this.hls;

        if (!Number.isFinite(data.endPTS)) {
          data.endPTS = data.startPTS + fragCurrent.duration;
          data.endDTS = data.startDTS + fragCurrent.duration;
        }

        fragCurrent.addElementaryStream(_fragment2.default.ElementaryStreamTypes.AUDIO);

        _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb);
        LevelHelper.updateFragPTSDTS(track.details, fragCurrent, data.startPTS, data.endPTS);

        var audioSwitch = this.audioSwitch,
            media = this.media,
            appendOnBufferFlush = false;
        // Only flush audio from old audio tracks when PTS is known on new audio track
        if (audioSwitch && media) {
          if (media.readyState) {
            var currentTime = media.currentTime;
            _logger.logger.log('switching audio track : currentTime:' + currentTime);
            if (currentTime >= data.startPTS) {
              _logger.logger.log('switching audio track : flushing all audio');
              this.state = _baseStreamController.State.BUFFER_FLUSHING;
              hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
              appendOnBufferFlush = true;
              // Lets announce that the initial audio track switch flush occur
              this.audioSwitch = false;
              hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
            }
          } else {
            // Lets announce that the initial audio track switch flush occur
            this.audioSwitch = false;
            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
          }
        }

        var pendingData = this.pendingData;

        if (!pendingData) {
          _logger.logger.warn('Apparently attempt to enqueue media payload without codec initialization data upfront');
          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: null, fatal: true });
          return;
        }

        if (!this.audioSwitch) {
          [data.data1, data.data2].forEach(function (buffer) {
            if (buffer && buffer.length) {
              pendingData.push({ type: data.type, data: buffer, parent: 'audio', content: 'data' });
            }
          });
          if (!appendOnBufferFlush && pendingData.length) {
            pendingData.forEach(function (appendObj) {
              // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
              // in that case it is useless to append following segments
              if (_this2.state === _baseStreamController.State.PARSING) {
                // arm pending Buffering flag before appending a segment
                _this2.pendingBuffering = true;
                _this2.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
              }
            });
            this.pendingData = [];
            this.appended = true;
          }
        }
        // trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.levels === fragCurrent.levels && this.state === _baseStreamController.State.PARSING) {
        this.stats.tparsed = performance.now();
        this.state = _baseStreamController.State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onBufferReset',
    value: function onBufferReset() {
      // reset reference to sourcebuffers
      this.mediaBuffer = this.videoBuffer = null;
      this.loadedmetadata = false;
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var audioTrack = data.tracks.audio;
      if (audioTrack) {
        this.mediaBuffer = audioTrack.buffer;
        this.loadedmetadata = true;
      }
      if (data.tracks.video) {
        this.videoBuffer = data.tracks.video.buffer;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'audio') {
        var state = this.state;
        if (state === _baseStreamController.State.PARSING || state === _baseStreamController.State.PARSED) {
          // check if all buffers have been appended
          this.pendingBuffering = data.pending > 0;
          this._checkAppendedParsed();
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      // trigger handler right now
      if (this.state === _baseStreamController.State.PARSED && (!this.appended || !this.pendingBuffering)) {
        var frag = this.fragCurrent,
            stats = this.stats,
            hls = this.hls;
        if (frag) {
          this.fragPrevious = frag;
          stats.tbuffered = performance.now();
          hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('audio buffered : ' + _timeRanges2.default.toString(media.buffered));
          if (this.audioSwitch && this.appended) {
            this.audioSwitch = false;
            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: this.trackId });
          }
          this.state = _baseStreamController.State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle frag error not related to audio fragment
      if (frag && frag.type !== 'audio') {
        return;
      }

      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          var _frag = data.frag;
          // don't handle frag error not related to audio fragment
          if (_frag && _frag.type !== 'audio') {
            break;
          }

          if (!data.fatal) {
            var loadError = this.fragLoadError;
            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }

            var config = this.config;
            if (loadError <= config.fragLoadingMaxRetry) {
              this.fragLoadError = loadError;
              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
              _logger.logger.warn('AudioStreamController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = performance.now() + delay;
              // retry loading state
              this.state = _baseStreamController.State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('AudioStreamController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // switch error to fatal
              data.fatal = true;
              this.state = _baseStreamController.State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
          if (this.state !== _baseStreamController.State.ERROR) {
            // if fatal error, stop processing, otherwise move to IDLE to retry loading
            this.state = data.fatal ? _baseStreamController.State.ERROR : _baseStreamController.State.IDLE;
            _logger.logger.warn('AudioStreamController: ' + data.details + ' while loading frag, now switching to ' + this.state + ' state ...');
          }
          break;
        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
          // if in appending state
          if (data.parent === 'audio' && (this.state === _baseStreamController.State.PARSING || this.state === _baseStreamController.State.PARSED)) {
            var media = this.mediaBuffer,
                currentTime = this.media.currentTime,
                mediaBuffered = media && _bufferHelper.BufferHelper.isBuffered(media, currentTime) && _bufferHelper.BufferHelper.isBuffered(media, currentTime + 0.5);
            // reduce max buf len if current position is buffered
            if (mediaBuffered) {
              var _config = this.config;
              if (_config.maxMaxBufferLength >= _config.maxBufferLength) {
                // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
                _config.maxMaxBufferLength /= 2;
                _logger.logger.warn('AudioStreamController: reduce max buffer length to ' + _config.maxMaxBufferLength + 's');
              }
              this.state = _baseStreamController.State.IDLE;
            } else {
              // current position is not buffered, but browser is still complaining about buffer full error
              // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
              // in that case flush the whole audio buffer to recover
              _logger.logger.warn('AudioStreamController: buffer full error also media.currentTime is not buffered, flush audio buffer');
              this.fragCurrent = null;
              // flush everything
              this.state = _baseStreamController.State.BUFFER_FLUSHING;
              this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
            }
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      var _this3 = this;

      var pendingData = this.pendingData;
      if (pendingData && pendingData.length) {
        _logger.logger.log('AudioStreamController: appending pending audio data after buffer flushed');
        pendingData.forEach(function (appendObj) {
          _this3.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
        });
        this.appended = true;
        this.pendingData = [];
        this.state = _baseStreamController.State.PARSED;
      } else {
        // move to IDLE once flush complete. this should trigger new fragment loading
        this.state = _baseStreamController.State.IDLE;
        // reset reference to frag
        this.fragPrevious = null;
        this.tick();
      }
    }
  }, {
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('audio stream:' + previousState + '->' + nextState);
      }
    },
    get: function get() {
      return this._state;
    }
  }]);

  return AudioStreamController;
}(_baseStreamController2.default);

exports.default = AudioStreamController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/audio-track-controller.js":
/*!*********************************************************!*\
  !*** ./src/hls.js/controller/audio-track-controller.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _taskLoop = __webpack_require__(/*! ../task-loop */ "./src/hls.js/task-loop.js");

var _taskLoop2 = _interopRequireDefault(_taskLoop);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class AudioTrackController
 * @implements {EventHandler}
 *
 * Handles main manifest and audio-track metadata loaded,
 * owns and exposes the selectable audio-tracks data-models.
 *
 * Exposes internal interface to select available audio-tracks.
 *
 * Handles errors on loading audio-track playlists. Manages fallback mechanism
 * with redundants tracks (group-IDs).
 *
 * Handles level-loading and group-ID switches for video (fallback on video levels),
 * and eventually adapts the audio-track group-ID to match.
 *
 * @fires AUDIO_TRACK_LOADING
 * @fires AUDIO_TRACK_SWITCHING
 * @fires AUDIO_TRACKS_UPDATED
 * @fires ERROR
 *
 */
var AudioTrackController = function (_TaskLoop) {
  _inherits(AudioTrackController, _TaskLoop);

  function AudioTrackController(hls) {
    _classCallCheck(this, AudioTrackController);

    /**
     * @private
     * Currently selected index in `tracks`
     * @member {number} trackId
     */
    var _this = _possibleConstructorReturn(this, (AudioTrackController.__proto__ || Object.getPrototypeOf(AudioTrackController)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.AUDIO_TRACK_LOADED, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.LEVEL_LOADED, _events2.default.ERROR));

    _this._trackId = -1;

    /**
     * @private
     * If should select tracks according to default track attribute
     * @member {boolean} _selectDefaultTrack
     */
    _this._selectDefaultTrack = true;

    /**
     * @public
     * All tracks available
     * @member {AudioTrack[]}
     */
    _this.tracks = [];

    /**
     * @public
     * List of blacklisted audio track IDs (that have caused failure)
     * @member {number[]}
     */
    _this.trackIdBlacklist = Object.create(null);

    /**
     * @public
     * The currently running group ID for audio
     * (we grab this on manifest-parsed and new level-loaded)
     * @member {string}
     */
    _this.audioGroupId = null;
    return _this;
  }

  /**
   * Reset audio tracks on new manifest loading.
   */


  _createClass(AudioTrackController, [{
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.tracks = [];
      this._trackId = -1;
      this._selectDefaultTrack = true;
    }

    /**
     * Store tracks data from manifest parsed data.
     *
     * Trigger AUDIO_TRACKS_UPDATED event.
     *
     * @param {*} data
     */

  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var tracks = this.tracks = data.audioTracks || [];
      this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });
    }

    /**
     * Store track details of loaded track in our data-model.
     *
     * Set-up metadata update interval task for live-mode streams.
     *
     * @param {} data
     */

  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      if (data.id >= this.tracks.length) {
        _logger.logger.warn('Invalid audio track id:', data.id);
        return;
      }

      _logger.logger.log('audioTrack ' + data.id + ' loaded');

      this.tracks[data.id].details = data.details;

      // check if current playlist is a live playlist
      // and if we have already our reload interval setup
      if (data.details.live && !this.hasInterval()) {
        // if live playlist we will have to reload it periodically
        // set reload period to playlist target duration
        var updatePeriodMs = data.details.targetduration * 1000;
        this.setInterval(updatePeriodMs);
      }

      if (!data.details.live && this.hasInterval()) {
        // playlist is not live and timer is scheduled: cancel it
        this.clearInterval();
      }
    }

    /**
     * Update the internal group ID to any audio-track we may have set manually
     * or because of a failure-handling fallback.
     *
     * Quality-levels should update to that group ID in this case.
     *
     * @param {*} data
     */

  }, {
    key: 'onAudioTrackSwitched',
    value: function onAudioTrackSwitched(data) {
      var audioGroupId = this.tracks[data.id].groupId;
      if (audioGroupId && this.audioGroupId !== audioGroupId) {
        this.audioGroupId = audioGroupId;
      }
    }

    /**
     * When a level gets loaded, if it has redundant audioGroupIds (in the same ordinality as it's redundant URLs)
     * we are setting our audio-group ID internally to the one set, if it is different from the group ID currently set.
     *
     * If group-ID got update, we re-select the appropriate audio-track with this group-ID matching the currently
     * selected one (based on NAME property).
     *
     * @param {*} data
     */

  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      // FIXME: crashes because currentLevel is undefined
      // const levelInfo = this.hls.levels[this.hls.currentLevel];

      var levelInfo = this.hls.levels[data.levels];

      if (!levelInfo.audioGroupIds) {
        return;
      }

      var audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];
      if (this.audioGroupId !== audioGroupId) {
        this.audioGroupId = audioGroupId;
        this._selectInitialAudioTrack();
      }
    }

    /**
     * Handle network errors loading audio track manifests
     * and also pausing on any netwok errors.
     *
     * @param {ErrorEventData} data
     */

  }, {
    key: 'onError',
    value: function onError(data) {
      // Only handle network errors
      if (data.type !== _errors.ErrorTypes.NETWORK_ERROR) {
        return;
      }

      // If fatal network error, cancel update task
      if (data.fatal) {
        this.clearInterval();
      }

      // If not an audio-track loading error don't handle further
      if (data.details !== _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR) {
        return;
      }

      _logger.logger.warn('Network failure on audio-track id:', data.context.id);
      this._handleLoadError();
    }

    /**
     * @type {AudioTrack[]} Audio-track list we own
     */

  }, {
    key: '_setAudioTrack',


    /**
     * @private
     * @param {number} newId
     */
    value: function _setAudioTrack(newId) {
      // noop on same audio track id as already set
      if (this._trackId === newId && this.tracks[this._trackId].details) {
        _logger.logger.debug('Same id as current audio-track passed, and track details available -> no-op');
        return;
      }

      // check if level idx is valid
      if (newId < 0 || newId >= this.tracks.length) {
        _logger.logger.warn('Invalid id passed to audio-track controller');
        return;
      }

      var audioTrack = this.tracks[newId];

      _logger.logger.log('Now switching to audio-track index ' + newId);

      // stopping live reloading timer if any
      this.clearInterval();
      this._trackId = newId;

      var url = audioTrack.url,
          type = audioTrack.type,
          id = audioTrack.id;

      this.hls.trigger(_events2.default.AUDIO_TRACK_SWITCHING, { id: id, type: type, url: url });
      this._loadTrackDetailsIfNeeded(audioTrack);
    }

    /**
     * @override
     */

  }, {
    key: 'doTick',
    value: function doTick() {
      this._updateTrack(this._trackId);
    }

    /**
     * Select initial track
     * @private
     */

  }, {
    key: '_selectInitialAudioTrack',
    value: function _selectInitialAudioTrack() {
      var _this2 = this;

      var tracks = this.tracks;
      if (!tracks.length) {
        return;
      }

      var currentAudioTrack = this.tracks[this._trackId];

      var name = null;
      if (currentAudioTrack) {
        name = currentAudioTrack.name;
      }

      // Pre-select default tracks if there are any
      if (this._selectDefaultTrack) {
        var defaultTracks = tracks.filter(function (track) {
          return track.default;
        });
        if (defaultTracks.length) {
          tracks = defaultTracks;
        } else {
          _logger.logger.warn('No default audio tracks defined');
        }
      }

      var trackFound = false;

      var traverseTracks = function traverseTracks() {
        // Select track with right group ID
        tracks.forEach(function (track) {
          if (trackFound) {
            return;
          }
          // We need to match the (pre-)selected group ID
          // and the NAME of the current track.
          if ((!_this2.audioGroupId || track.groupId === _this2.audioGroupId) && (!name || name === track.name)) {
            // If there was a previous track try to stay with the same `NAME`.
            // It should be unique across tracks of same group, and consistent through redundant track groups.
            _this2._setAudioTrack(track.id);
            trackFound = true;
          }
        });
      };

      traverseTracks();

      if (!trackFound) {
        name = null;
        traverseTracks();
      }

      if (!trackFound) {
        _logger.logger.error('No track found for running audio group-ID: ' + this.audioGroupId);

        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
          fatal: true
        });
      }
    }

    /**
     * @private
     * @param {AudioTrack} audioTrack
     * @returns {boolean}
     */

  }, {
    key: '_needsTrackLoading',
    value: function _needsTrackLoading(audioTrack) {
      var details = audioTrack.details,
          url = audioTrack.url;


      if (!details || details.live) {
        // check if we face an audio track embedded in main playlist (audio track without URI attribute)
        return !!url;
      }

      return false;
    }

    /**
     * @private
     * @param {AudioTrack} audioTrack
     */

  }, {
    key: '_loadTrackDetailsIfNeeded',
    value: function _loadTrackDetailsIfNeeded(audioTrack) {
      if (this._needsTrackLoading(audioTrack)) {
        var url = audioTrack.url,
            id = audioTrack.id;
        // track not retrieved yet, or live playlist we need to (re)load it

        _logger.logger.log('loading audio-track playlist for id: ' + id);
        this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: id });
      }
    }

    /**
     * @private
     * @param {number} newId
     */

  }, {
    key: '_updateTrack',
    value: function _updateTrack(newId) {
      // check if level idx is valid
      if (newId < 0 || newId >= this.tracks.length) {
        return;
      }

      // stopping live reloading timer if any
      this.clearInterval();
      this._trackId = newId;
      _logger.logger.log('trying to update audio-track ' + newId);
      var audioTrack = this.tracks[newId];
      this._loadTrackDetailsIfNeeded(audioTrack);
    }

    /**
     * @private
     */

  }, {
    key: '_handleLoadError',
    value: function _handleLoadError() {
      // First, let's black list current track id
      this.trackIdBlacklist[this._trackId] = true;

      // Let's try to fall back on a functional audio-track with the same group ID
      var previousId = this._trackId;
      var _tracks$previousId = this.tracks[previousId],
          name = _tracks$previousId.name,
          language = _tracks$previousId.language,
          groupId = _tracks$previousId.groupId;


      _logger.logger.warn('Loading failed on audio track id: ' + previousId + ', group-id: ' + groupId + ', name/language: "' + name + '" / "' + language + '"');

      // Find a non-blacklisted track ID with the same NAME
      // At least a track that is not blacklisted, thus on another group-ID.
      var newId = previousId;
      for (var i = 0; i < this.tracks.length; i++) {
        if (this.trackIdBlacklist[i]) {
          continue;
        }
        var newTrack = this.tracks[i];
        if (newTrack.name === name) {
          newId = i;
          break;
        }
      }

      if (newId === previousId) {
        _logger.logger.warn('No fallback audio-track found for name/language: "' + name + '" / "' + language + '"');
        return;
      }

      _logger.logger.log('Attempting audio-track fallback id:', newId, 'group-id:', this.tracks[newId].groupId);

      this._setAudioTrack(newId);
    }
  }, {
    key: 'audioTracks',
    get: function get() {
      return this.tracks;
    }

    /**
     * @type {number} Index into audio-tracks list of currently selected track.
     */

  }, {
    key: 'audioTrack',
    get: function get() {
      return this._trackId;
    }

    /**
     * Select current track by index
     */
    ,
    set: function set(newId) {
      this._setAudioTrack(newId);
      // If audio track is selected from API then don't choose from the manifest default track
      this._selectDefaultTrack = false;
    }
  }]);

  return AudioTrackController;
}(_taskLoop2.default);

exports.default = AudioTrackController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/base-stream-controller.js":
/*!*********************************************************!*\
  !*** ./src/hls.js/controller/base-stream-controller.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.State = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _taskLoop = __webpack_require__(/*! ../task-loop */ "./src/hls.js/task-loop.js");

var _taskLoop2 = _interopRequireDefault(_taskLoop);

var _fragmentTracker = __webpack_require__(/*! ./fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var State = exports.State = {
  STOPPED: 'STOPPED',
  STARTING: 'STARTING',
  IDLE: 'IDLE',
  PAUSED: 'PAUSED',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_TRACK: 'WAITING_TRACK',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  BUFFER_FLUSHING: 'BUFFER_FLUSHING',
  ENDED: 'ENDED',
  ERROR: 'ERROR',
  WAITING_INIT_PTS: 'WAITING_INIT_PTS',
  WAITING_LEVEL: 'WAITING_LEVEL'
};

var BaseStreamController = function (_TaskLoop) {
  _inherits(BaseStreamController, _TaskLoop);

  function BaseStreamController() {
    _classCallCheck(this, BaseStreamController);

    return _possibleConstructorReturn(this, (BaseStreamController.__proto__ || Object.getPrototypeOf(BaseStreamController)).apply(this, arguments));
  }

  _createClass(BaseStreamController, [{
    key: 'doTick',
    value: function doTick() {}
  }, {
    key: 'startLoad',
    value: function startLoad() {}
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var frag = this.fragCurrent;
      if (frag) {
        if (frag.loader) {
          frag.loader.abort();
        }
        this.fragmentTracker.removeFragment(frag);
      }
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
      this.fragCurrent = null;
      this.fragPrevious = null;
      this.clearInterval();
      this.clearNextTick();
      this.state = State.STOPPED;
    }
  }, {
    key: '_streamEnded',
    value: function _streamEnded(bufferInfo, levelDetails) {
      var fragCurrent = this.fragCurrent,
          fragmentTracker = this.fragmentTracker;
      // we just got done loading the final fragment and there is no other buffered range after ...
      // rationale is that in case there are any buffered ranges after, it means that there are unbuffered portion in between
      // so we should not switch to ENDED in that case, to be able to buffer them
      // dont switch to ENDED if we need to backtrack last fragment

      if (!levelDetails.live && fragCurrent && !fragCurrent.backtracked && fragCurrent.sn === levelDetails.endSN && !bufferInfo.nextStart) {
        var fragState = fragmentTracker.getState(fragCurrent);
        return fragState === _fragmentTracker.FragmentState.PARTIAL || fragState === _fragmentTracker.FragmentState.OK;
      }
      return false;
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      var config = this.config,
          media = this.media,
          mediaBuffer = this.mediaBuffer,
          state = this.state;

      var currentTime = media ? media.currentTime : null;
      var bufferInfo = _bufferHelper.BufferHelper.bufferInfo(mediaBuffer || media, currentTime, this.config.maxBufferHole);

      if (Number.isFinite(currentTime)) {
        _logger.logger.log('media seeking to ' + currentTime.toFixed(3));
      }

      if (state === State.FRAG_LOADING) {
        var fragCurrent = this.fragCurrent;
        // check if we are seeking to a unbuffered area AND if frag loading is in progress
        if (bufferInfo.len === 0 && fragCurrent) {
          var tolerance = config.maxFragLookUpTolerance;
          var fragStartOffset = fragCurrent.start - tolerance;
          var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
          // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything
          if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
            if (fragCurrent.loader) {
              _logger.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            this.fragPrevious = null;
            // switch to IDLE state to load new fragment
            this.state = State.IDLE;
          } else {
            _logger.logger.log('seeking outside of buffer but within currently loaded fragment range');
          }
        }
      } else if (state === State.ENDED) {
        // if seeking to unbuffered area, clean up fragPrevious
        if (bufferInfo.len === 0) {
          this.fragPrevious = null;
          this.fragCurrent = null;
        }

        // switch to IDLE state to check for potential new fragment
        this.state = State.IDLE;
      }
      if (media) {
        this.lastCurrentTime = currentTime;
      }

      // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target
      if (!this.loadedmetadata) {
        this.nextLoadPosition = this.startPosition = currentTime;
      }

      // tick to speed up processing
      this.tick();
    }
  }, {
    key: 'onMediaEnded',
    value: function onMediaEnded() {
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onHandlerDestroying',
    value: function onHandlerDestroying() {
      this.stopLoad();
      _get(BaseStreamController.prototype.__proto__ || Object.getPrototypeOf(BaseStreamController.prototype), 'onHandlerDestroying', this).call(this);
    }
  }, {
    key: 'onHandlerDestroyed',
    value: function onHandlerDestroyed() {
      this.state = State.STOPPED;
      this.fragmentTracker = null;
    }
  }]);

  return BaseStreamController;
}(_taskLoop2.default);

exports.default = BaseStreamController;

/***/ }),

/***/ "./src/hls.js/controller/buffer-controller.js":
/*!****************************************************!*\
  !*** ./src/hls.js/controller/buffer-controller.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _mediasourceHelper = __webpack_require__(/*! ../utils/mediasource-helper */ "./src/hls.js/utils/mediasource-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Buffer Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var MediaSource = (0, _mediasourceHelper.getMediaSource)();

var BufferController = function (_EventHandler) {
  _inherits(BufferController, _EventHandler);

  function BufferController(hls) {
    _classCallCheck(this, BufferController);

    // the value that we have set mediasource.duration to
    // (the actual duration may be tweaked slighly by the browser)
    var _this = _possibleConstructorReturn(this, (BufferController.__proto__ || Object.getPrototypeOf(BufferController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_RESET, _events2.default.BUFFER_APPENDING, _events2.default.BUFFER_CODECS, _events2.default.BUFFER_EOS, _events2.default.BUFFER_FLUSHING, _events2.default.LEVEL_PTS_UPDATED, _events2.default.LEVEL_UPDATED));

    _this._msDuration = null;
    // the value that we want to set mediaSource.duration to
    _this._levelDuration = null;
    // the target duration of the current media playlist
    _this._levelTargetDuration = 10;
    // current stream state: true - for live broadcast, false - for VoD content
    _this._live = null;
    // cache the self generated object url to detect hijack of video tag
    _this._objectUrl = null;
    // The number of BUFFER_CODEC events received before any sourceBuffers are created
    _this.bufferCodecEventsExpected = 0;

    // Source Buffer listeners
    _this.onsbue = _this.onSBUpdateEnd.bind(_this);
    _this.onsbe = _this.onSBUpdateError.bind(_this);
    _this.pendingTracks = {};
    _this.tracks = {};
    return _this;
  }

  _createClass(BufferController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onLevelPtsUpdated',
    value: function onLevelPtsUpdated(data) {
      var type = data.type;
      var audioTrack = this.tracks.audio;

      // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
      // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
      // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue
      // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`
      // event if SB is in updating state.
      // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486

      if (type === 'audio' && audioTrack && audioTrack.container === 'audio/mpeg') {
        // Chrome audio mp3 track
        var audioBuffer = this.sourceBuffer.audio;
        var delta = Math.abs(audioBuffer.timestampOffset - data.start);

        // adjust timestamp offset if time delta is greater than 100ms
        if (delta > 0.1) {
          var updating = audioBuffer.updating;

          try {
            audioBuffer.abort();
          } catch (err) {
            _logger.logger.warn('can not abort audio buffer: ' + err);
          }

          if (!updating) {
            _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + data.start);
            audioBuffer.timestampOffset = data.start;
          } else {
            this.audioTimestampOffset = data.start;
          }
        }
      }
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
      // sourcebuffers will be created all at once when the expected nb of tracks will be reached
      // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
      // it will contain the expected nb of source buffers, no need to compute it
      this.bufferCodecEventsExpected = data.altAudio ? 2 : 1;
      _logger.logger.log(this.bufferCodecEventsExpected + ' bufferCodec event(s) expected');
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var media = this.media = data.media;
      if (media) {
        // setup the media source
        var ms = this.mediaSource = new MediaSource();
        // Media Source listeners
        this.onmso = this.onMediaSourceOpen.bind(this);
        this.onmse = this.onMediaSourceEnded.bind(this);
        this.onmsc = this.onMediaSourceClose.bind(this);
        ms.addEventListener('sourceopen', this.onmso);
        ms.addEventListener('sourceended', this.onmse);
        ms.addEventListener('sourceclose', this.onmsc);
        // link video and media Source
        media.src = window.URL.createObjectURL(ms);
        // cache the locally generated object url
        this._objectUrl = media.src;
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      _logger.logger.log('media source detaching');
      var ms = this.mediaSource;
      if (ms) {
        if (ms.readyState === 'open') {
          try {
            // endOfStream could trigger exception if any sourcebuffer is in updating state
            // we don't really care about checking sourcebuffer state here,
            // as we are anyway detaching the MediaSource
            // let's just avoid this exception to propagate
            ms.endOfStream();
          } catch (err) {
            _logger.logger.warn('onMediaDetaching:' + err.message + ' while calling endOfStream');
          }
        }
        ms.removeEventListener('sourceopen', this.onmso);
        ms.removeEventListener('sourceended', this.onmse);
        ms.removeEventListener('sourceclose', this.onmsc);

        // Detach properly the MediaSource from the HTMLMediaElement as
        // suggested in https://github.com/w3c/media-source/issues/53.
        if (this.media) {
          window.URL.revokeObjectURL(this._objectUrl);

          // clean up video tag src only if it's our own url. some external libraries might
          // hijack the video tag and change its 'src' without destroying the Hls instance first
          if (this.media.src === this._objectUrl) {
            this.media.removeAttribute('src');
            this.media.load();
          } else {
            _logger.logger.warn('media.src was changed by a third party - skip cleanup');
          }
        }

        this.mediaSource = null;
        this.media = null;
        this._objectUrl = null;
        this.pendingTracks = {};
        this.tracks = {};
        this.sourceBuffer = {};
        this.flushRange = [];
        this.segments = [];
        this.appended = 0;
      }
      this.onmso = this.onmse = this.onmsc = null;
      this.hls.trigger(_events2.default.MEDIA_DETACHED);
    }
  }, {
    key: 'onMediaSourceOpen',
    value: function onMediaSourceOpen() {
      _logger.logger.log('media source opened');
      this.hls.trigger(_events2.default.MEDIA_ATTACHED, { media: this.media });
      var mediaSource = this.mediaSource;
      if (mediaSource) {
        // once received, don't listen anymore to sourceopen event
        mediaSource.removeEventListener('sourceopen', this.onmso);
      }
      this.checkPendingTracks();
    }
  }, {
    key: 'checkPendingTracks',
    value: function checkPendingTracks() {
      var bufferCodecEventsExpected = this.bufferCodecEventsExpected,
          pendingTracks = this.pendingTracks;
      // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.
      // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after
      // data has been appended to existing ones.
      // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.

      var pendingTracksCount = Object.keys(pendingTracks).length;
      if (pendingTracksCount && !bufferCodecEventsExpected || pendingTracksCount === 2) {
        // ok, let's create them now !
        this.createSourceBuffers(pendingTracks);
        this.pendingTracks = {};
        // append any pending segments now !
        this.doAppending();
      }
    }
  }, {
    key: 'onMediaSourceClose',
    value: function onMediaSourceClose() {
      _logger.logger.log('media source closed');
    }
  }, {
    key: 'onMediaSourceEnded',
    value: function onMediaSourceEnded() {
      _logger.logger.log('media source ended');
    }
  }, {
    key: 'onSBUpdateEnd',
    value: function onSBUpdateEnd() {
      // update timestampOffset
      if (this.audioTimestampOffset) {
        var audioBuffer = this.sourceBuffer.audio;
        _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + this.audioTimestampOffset);
        audioBuffer.timestampOffset = this.audioTimestampOffset;
        delete this.audioTimestampOffset;
      }

      if (this._needsFlush) {
        this.doFlush();
      }

      if (this._needsEos) {
        this.checkEos();
      }

      this.appending = false;
      var parent = this.parent;
      // count nb of pending segments waiting for appending on this sourcebuffer
      var pending = this.segments.reduce(function (counter, segment) {
        return segment.parent === parent ? counter + 1 : counter;
      }, 0);

      // this.sourceBuffer is better to use than media.buffered as it is closer to the PTS data from the fragments
      var timeRanges = {};
      var sourceBuffer = this.sourceBuffer;
      for (var streamType in sourceBuffer) {
        timeRanges[streamType] = sourceBuffer[streamType].buffered;
      }

      // Seek
      if (this._paused === false && timeRanges["video"] && timeRanges["video"].length > 0 && timeRanges["audio"] && timeRanges["audio"].length > 0) {

        if (timeRanges["video"].end(0) - timeRanges["video"].start(0) > 1 && timeRanges["audio"].end(0) - timeRanges["audio"].start(0) > 1) {
          // Seek to the point that can play;
          var startTime = Math.max(timeRanges["video"].start(0), timeRanges["audio"].start(0));
          this.media.currentTime = startTime;
          this.media.play();
          delete this["_paused"];
        } else {
          // Try to seek more
          var endTime = Math.max(timeRanges["video"].end(0), timeRanges["audio"].end(0));
          this.media.currentTime = endTime;
          this.media.play();
        }
      }

      this.hls.trigger(_events2.default.BUFFER_APPENDED, { parent: parent, pending: pending, timeRanges: timeRanges });
      // don't append in flushing mode
      if (!this._needsFlush) {
        this.doAppending();
      }

      this.updateMediaElementDuration();

      // appending goes first
      if (pending === 0) {
        this.flushLiveBackBuffer();
      }
    }
  }, {
    key: 'onSBUpdateError',
    value: function onSBUpdateError(event) {
      _logger.logger.error('sourceBuffer error:', event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
      // we don't need to do more than that, as accordin to the spec, updateend will be fired just after
    }
  }, {
    key: 'onBufferReset',
    value: function onBufferReset() {
      var sourceBuffer = this.sourceBuffer;
      for (var type in sourceBuffer) {
        var sb = sourceBuffer[type];
        try {
          this.mediaSource.removeSourceBuffer(sb);
          sb.removeEventListener('updateend', this.onsbue);
          sb.removeEventListener('error', this.onsbe);
        } catch (err) {}
      }
      this.sourceBuffer = {};
      this.flushRange = [];
      this.segments = [];
      this.appended = 0;
    }
  }, {
    key: 'onBufferCodecs',
    value: function onBufferCodecs(tracks) {
      var _this2 = this;

      // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
      // if sourcebuffers already created, do nothing ...
      /** tracks, trackbuffer 
      if (Object.keys(this.sourceBuffer).length) {
        return;
      }*/

      Object.keys(tracks).forEach(function (trackName) {
        _this2.pendingTracks[trackName] = tracks[trackName];
      });
      var mediaSource = this.mediaSource;

      this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);
      if (mediaSource && mediaSource.readyState === 'open') {
        this.checkPendingTracks();
      }
    }
  }, {
    key: 'createSourceBuffers',
    value: function createSourceBuffers(tracks) {
      var sourceBuffer = this.sourceBuffer,
          mediaSource = this.mediaSource;
      for (var trackName in tracks) {
        if (!sourceBuffer[trackName]) {
          var track = tracks[trackName];
          // use levelCodec as first priority
          var codec = track.levelCodec || track.codec;
          var mimeType = track.container + ';codecs=' + codec;
          _logger.logger.log('creating sourceBuffer(' + mimeType + ')');
          try {
            var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
            sb.addEventListener('updateend', this.onsbue);
            sb.addEventListener('error', this.onsbe);
            this.tracks[trackName] = { codec: codec, container: track.container };
            track.buffer = sb;
          } catch (err) {
            if (err.code == 22) {
              _logger.logger.log("Found new track, try to rebuild");
              this._paused = false;
              // setup the media source
              var ms = this.mediaSource = new MediaSource();
              // Media Source listeners
              this.onmso = this.onMediaSourceOpen.bind(this);
              this.onmse = this.onMediaSourceEnded.bind(this);
              this.onmsc = this.onMediaSourceClose.bind(this);

              for (var i = 0; i < Object.keys(this.tracks).length; i++) {
                var _track = this.tracks[Object.keys(this.tracks)[i]];
                this.pendingTracks[Object.keys(this.tracks)[i]] = _track;
              }
              this.tracks = {};
              this.sourceBuffer = {};
              ms.addEventListener('sourceopen', this.onmso);
              ms.addEventListener('sourceended', this.onmse);
              ms.addEventListener('sourceclose', this.onmsc);
              // link video and media Source
              this.media.src = window.URL.createObjectURL(ms);
              // cache the locally generated object url
              this._objectUrl = media.src;
            } else {
              _logger.logger.error('error while trying to add sourceBuffer:' + err.message);
              this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });
            }
          }
        }
      }

      this.hls.trigger(_events2.default.BUFFER_CREATED, { tracks: tracks });
    }
  }, {
    key: 'onBufferAppending',
    value: function onBufferAppending(data) {
      if (!this._needsFlush) {
        if (!this.segments) {
          this.segments = [data];
        } else {
          this.segments.push(data);
        }

        this.doAppending();
      }
    }
  }, {
    key: 'onBufferAppendFail',
    value: function onBufferAppendFail(data) {
      _logger.logger.error('sourceBuffer error:', data.event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
    }

    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()

  }, {
    key: 'onBufferEos',
    value: function onBufferEos(data) {
      var sb = this.sourceBuffer;
      var dataType = data.type;
      for (var type in sb) {
        if (!dataType || type === dataType) {
          if (!sb[type].ended) {
            sb[type].ended = true;
            _logger.logger.log(type + ' sourceBuffer now EOS');
          }
        }
      }
      this.checkEos();
    }

    // if all source buffers are marked as ended, signal endOfStream() to MediaSource.

  }, {
    key: 'checkEos',
    value: function checkEos() {
      var sb = this.sourceBuffer,
          mediaSource = this.mediaSource;
      if (!mediaSource || mediaSource.readyState !== 'open') {
        this._needsEos = false;
        return;
      }
      for (var type in sb) {
        var sbobj = sb[type];
        if (!sbobj.ended) {
          return;
        }

        if (sbobj.updating) {
          this._needsEos = true;
          return;
        }
      }
      _logger.logger.log('all media data are available, signal endOfStream() to MediaSource and stop loading fragment');
      // Notify the media element that it now has all of the media data
      try {
        mediaSource.endOfStream();
      } catch (e) {
        _logger.logger.warn('exception while calling mediaSource.endOfStream()');
      }
      this._needsEos = false;
    }
  }, {
    key: 'onBufferFlushing',
    value: function onBufferFlushing(data) {
      this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });
      // attempt flush immediately
      this.flushBufferCounter = 0;
      this.doFlush();
    }
  }, {
    key: 'flushLiveBackBuffer',
    value: function flushLiveBackBuffer() {
      // clear back buffer for live only
      if (!this._live) {
        return;
      }

      var liveBackBufferLength = this.hls.config.liveBackBufferLength;
      if (!isFinite(liveBackBufferLength) || liveBackBufferLength < 0) {
        return;
      }

      var currentTime = this.media.currentTime;
      var sourceBuffer = this.sourceBuffer;
      var bufferTypes = Object.keys(sourceBuffer);
      var targetBackBufferPosition = currentTime - Math.max(liveBackBufferLength, this._levelTargetDuration);

      for (var index = bufferTypes.length - 1; index >= 0; index--) {
        var bufferType = bufferTypes[index],
            buffered = sourceBuffer[bufferType].buffered;

        // when target buffer start exceeds actual buffer start
        if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
          // remove buffer up until current time minus minimum back buffer length (removing buffer too close to current
          // time will lead to playback freezing)
          // credits for level target duration - https://github.com/videojs/http-streaming/blob/3132933b6aa99ddefab29c10447624efd6fd6e52/src/segment-loader.js#L91
          this.removeBufferRange(bufferType, sourceBuffer[bufferType], 0, targetBackBufferPosition);
        }
      }
    }
  }, {
    key: 'onLevelUpdated',
    value: function onLevelUpdated(_ref) {
      var details = _ref.details;

      if (details.fragments.length > 0) {
        this._levelDuration = details.totalduration + details.fragments[0].start;
        this._levelTargetDuration = details.averagetargetduration || details.targetduration || 10;
        this._live = details.live;
        this.updateMediaElementDuration();
      }
    }

    /**
     * Update Media Source duration to current level duration or override to Infinity if configuration parameter
     * 'liveDurationInfinity` is set to `true`
     * More details: https://github.com/video-dev/hls.js/issues/355
     */

  }, {
    key: 'updateMediaElementDuration',
    value: function updateMediaElementDuration() {
      var config = this.hls.config;

      var duration = void 0;

      if (this._levelDuration === null || !this.media || !this.mediaSource || !this.sourceBuffer || this.media.readyState === 0 || this.mediaSource.readyState !== 'open') {
        return;
      }

      for (var type in this.sourceBuffer) {
        if (this.sourceBuffer[type].updating === true) {
          // can't set duration whilst a buffer is updating
          return;
        }
      }

      duration = this.media.duration;
      // initialise to the value that the media source is reporting
      if (this._msDuration === null) {
        this._msDuration = this.mediaSource.duration;
      }

      if (this._live === true && config.liveDurationInfinity === true) {
        // Override duration to Infinity
        _logger.logger.log('Media Source duration is set to Infinity');
        this._msDuration = this.mediaSource.duration = Infinity;
      } else if (this._levelDuration > this._msDuration && this._levelDuration > duration || !Number.isFinite(duration)) {
        // levelDuration was the last value we set.
        // not using mediaSource.duration as the browser may tweak this value
        // only update Media Source duration if its value increase, this is to avoid
        // flushing already buffered portion when switching between quality level
        _logger.logger.log('Updating Media Source duration to ' + this._levelDuration.toFixed(3));
        this._msDuration = this.mediaSource.duration = this._levelDuration;
      }
    }
  }, {
    key: 'doFlush',
    value: function doFlush() {
      // loop through all buffer ranges to flush
      while (this.flushRange.length) {
        var range = this.flushRange[0];
        // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
        if (this.flushBuffer(range.start, range.end, range.type)) {
          // range flushed, remove from flush array
          this.flushRange.shift();
          this.flushBufferCounter = 0;
        } else {
          this._needsFlush = true;
          // avoid looping, wait for SB update end to retrigger a flush
          return;
        }
      }
      if (this.flushRange.length === 0) {
        // everything flushed
        this._needsFlush = false;

        // let's recompute this.appended, which is used to avoid flush looping
        var appended = 0;
        var sourceBuffer = this.sourceBuffer;
        try {
          for (var type in sourceBuffer) {
            appended += sourceBuffer[type].buffered.length;
          }
        } catch (error) {
          // error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource
          // this is harmess at this stage, catch this to avoid reporting an internal exception
          _logger.logger.error('error while accessing sourceBuffer.buffered');
        }
        this.appended = appended;
        this.hls.trigger(_events2.default.BUFFER_FLUSHED);
      }
    }
  }, {
    key: 'doAppending',
    value: function doAppending() {
      var hls = this.hls,
          segments = this.segments,
          sourceBuffer = this.sourceBuffer;

      if (Object.keys(sourceBuffer).length) {
        if (this.media.error) {
          this.segments = [];
          _logger.logger.error('trying to append although a media error occured, flush segment and abort');
          return;
        }
        if (this.appending) {
          // logger.log(`sb appending in progress`);
          return;
        }
        if (segments && segments.length) {
          var segment = segments.shift();
          try {
            var type = segment.type,
                sb = sourceBuffer[type];
            if (sb) {
              if (!sb.updating) {
                // reset sourceBuffer ended flag before appending segment
                sb.ended = false;
                // logger.log(`appending ${segment.content} ${type} SB, size:${segment.data.length}, ${segment.parent}`);
                this.parent = segment.parent;
                console.log('append buffer ', segment);
                sb.appendBuffer(segment.data);
                this.appendError = 0;
                this.appended++;
                this.appending = true;
              } else {
                segments.unshift(segment);
              }
            } else {
              // in case we don't have any source buffer matching with this segment type,
              // it means that Mediasource fails to create sourcebuffer
              // discard this segment, and trigger update end
              this.onSBUpdateEnd();
            }
          } catch (err) {
            // in case any error occured while appending, put back segment in segments table
            _logger.logger.error('error while trying to append buffer:' + err.message);
            segments.unshift(segment);
            var event = { type: _errors.ErrorTypes.MEDIA_ERROR, parent: segment.parent };
            if (err.code !== 22) {
              if (this.appendError) {
                this.appendError++;
              } else {
                this.appendError = 1;
              }

              event.details = _errors.ErrorDetails.BUFFER_APPEND_ERROR;
              /* with UHD content, we could get loop of quota exceeded error until
                browser is able to evict some data from sourcebuffer. retrying help recovering this
              */
              if (this.appendError > hls.config.appendErrorMaxRetry) {
                _logger.logger.log('fail ' + hls.config.appendErrorMaxRetry + ' times to append segment in sourceBuffer');
                this.segments = [];
                event.fatal = true;
                hls.trigger(_events2.default.ERROR, event);
              } else {
                event.fatal = false;
                hls.trigger(_events2.default.ERROR, event);
              }
            } else {
              // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
              // let's stop appending any segments, and report BUFFER_FULL_ERROR error
              this.segments = [];
              event.details = _errors.ErrorDetails.BUFFER_FULL_ERROR;
              event.fatal = false;
              hls.trigger(_events2.default.ERROR, event);
            }
          }
        }
      }
    }

    /*
      flush specified buffered range,
      return true once range has been flushed.
      as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
    */

  }, {
    key: 'flushBuffer',
    value: function flushBuffer(startOffset, endOffset, typeIn) {
      var sb = void 0;
      var sourceBuffer = this.sourceBuffer;
      if (Object.keys(sourceBuffer).length) {
        _logger.logger.log('flushBuffer,pos/start/end: ' + this.media.currentTime.toFixed(3) + '/' + startOffset + '/' + endOffset);
        // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
        if (this.flushBufferCounter < this.appended) {
          for (var type in sourceBuffer) {
            // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
            // if no, let's flush all sourcebuffers
            if (typeIn && type !== typeIn) {
              continue;
            }

            sb = sourceBuffer[type];
            // we are going to flush buffer, mark source buffer as 'not ended'
            sb.ended = false;
            if (!sb.updating) {
              if (this.removeBufferRange(type, sb, startOffset, endOffset)) {
                this.flushBufferCounter++;
                return false;
              }
            } else {
              _logger.logger.warn('cannot flush, sb updating in progress');
              return false;
            }
          }
        } else {
          _logger.logger.warn('abort flushing too many retries');
        }
        _logger.logger.log('buffer flushed');
      }
      // everything flushed !
      return true;
    }

    /**
     * Removes first buffered range from provided source buffer that lies within given start and end offsets.
     *
     * @param type Type of the source buffer, logging purposes only.
     * @param sb Target SourceBuffer instance.
     * @param startOffset
     * @param endOffset
     *
     * @returns {boolean} True when source buffer remove requested.
     */

  }, {
    key: 'removeBufferRange',
    value: function removeBufferRange(type, sb, startOffset, endOffset) {
      try {
        for (var i = 0; i < sb.buffered.length; i++) {
          var bufStart = sb.buffered.start(i);
          var bufEnd = sb.buffered.end(i);
          var removeStart = Math.max(bufStart, startOffset);
          var removeEnd = Math.min(bufEnd, endOffset);

          /* sometimes sourcebuffer.remove() does not flush
            the exact expected time range.
            to avoid rounding issues/infinite loop,
            only flush buffer range of length greater than 500ms.
          */
          if (Math.min(removeEnd, bufEnd) - removeStart > 0.5) {
            _logger.logger.log('sb remove ' + type + ' [' + removeStart + ',' + removeEnd + '], of [' + bufStart + ',' + bufEnd + '], pos:' + this.media.currentTime);
            sb.remove(removeStart, removeEnd);
            return true;
          }
        }
      } catch (error) {
        _logger.logger.warn('removeBufferRange failed', error);
      }

      return false;
    }
  }]);

  return BufferController;
}(_eventHandler2.default);

exports.default = BufferController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/cap-level-controller.js":
/*!*******************************************************!*\
  !*** ./src/hls.js/controller/cap-level-controller.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * cap stream level to media size dimension controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var CapLevelController = function (_EventHandler) {
  _inherits(CapLevelController, _EventHandler);

  function CapLevelController(hls) {
    _classCallCheck(this, CapLevelController);

    var _this = _possibleConstructorReturn(this, (CapLevelController.__proto__ || Object.getPrototypeOf(CapLevelController)).call(this, hls, _events2.default.FPS_DROP_LEVEL_CAPPING, _events2.default.MEDIA_ATTACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_CODECS, _events2.default.MEDIA_DETACHING));

    _this.autoLevelCapping = Number.POSITIVE_INFINITY;
    _this.firstLevel = null;
    _this.levels = [];
    _this.media = null;
    _this.restrictedLevels = [];
    _this.timer = null;
    return _this;
  }

  _createClass(CapLevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.hls.config.capLevelToPlayerSize) {
        this.media = null;
        this._stopCapping();
      }
    }
  }, {
    key: 'onFpsDropLevelCapping',
    value: function onFpsDropLevelCapping(data) {
      // Don't add a restricted level more than once
      if (CapLevelController.isLevelAllowed(data.droppedLevel, this.restrictedLevels)) {
        this.restrictedLevels.push(data.droppedLevel);
      }
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media instanceof window.HTMLVideoElement ? data.media : null;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var hls = this.hls;
      this.restrictedLevels = [];
      this.levels = data.levels;
      this.firstLevel = data.firstLevel;
      if (hls.config.capLevelToPlayerSize && data.video) {
        // Start capping immediately if the manifest has signaled video codecs
        this._startCapping();
      }
    }

    // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted
    // to the first level

  }, {
    key: 'onBufferCodecs',
    value: function onBufferCodecs(data) {
      var hls = this.hls;
      if (hls.config.capLevelToPlayerSize && data.video) {
        // If the manifest did not signal a video codec capping has been deferred until we're certain video is present
        this._startCapping();
      }
    }
  }, {
    key: 'onLevelsUpdated',
    value: function onLevelsUpdated(data) {
      this.levels = data.levels;
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      this._stopCapping();
    }
  }, {
    key: 'detectPlayerSize',
    value: function detectPlayerSize() {
      if (this.media) {
        var levelsLength = this.levels ? this.levels.length : 0;
        if (levelsLength) {
          var hls = this.hls;
          hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
          if (hls.autoLevelCapping > this.autoLevelCapping) {
            // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
            // usually happen when the user go to the fullscreen mode.
            hls.streamController.nextLevelSwitch();
          }
          this.autoLevelCapping = hls.autoLevelCapping;
        }
      }
    }

    /*
    * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
    */

  }, {
    key: 'getMaxLevel',
    value: function getMaxLevel(capLevelIndex) {
      var _this2 = this;

      if (!this.levels) {
        return -1;
      }

      var validLevels = this.levels.filter(function (level, index) {
        return CapLevelController.isLevelAllowed(index, _this2.restrictedLevels) && index <= capLevelIndex;
      });

      return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
    }
  }, {
    key: '_startCapping',
    value: function _startCapping() {
      if (this.timer) {
        // Don't reset capping if started twice; this can happen if the manifest signals a video codec
        return;
      }
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      this.hls.firstLevel = this.getMaxLevel(this.firstLevel);
      clearInterval(this.timer);
      this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);
      this.detectPlayerSize();
    }
  }, {
    key: '_stopCapping',
    value: function _stopCapping() {
      this.restrictedLevels = [];
      this.firstLevel = null;
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      if (this.timer) {
        this.timer = clearInterval(this.timer);
        this.timer = null;
      }
    }
  }, {
    key: 'mediaWidth',
    get: function get() {
      var width = void 0;
      var media = this.media;
      if (media) {
        width = media.width || media.clientWidth || media.offsetWidth;
        width *= CapLevelController.contentScaleFactor;
      }
      return width;
    }
  }, {
    key: 'mediaHeight',
    get: function get() {
      var height = void 0;
      var media = this.media;
      if (media) {
        height = media.height || media.clientHeight || media.offsetHeight;
        height *= CapLevelController.contentScaleFactor;
      }
      return height;
    }
  }], [{
    key: 'isLevelAllowed',
    value: function isLevelAllowed(level) {
      var restrictedLevels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      return restrictedLevels.indexOf(level) === -1;
    }
  }, {
    key: 'getMaxLevelByMediaSize',
    value: function getMaxLevelByMediaSize(levels, width, height) {
      if (!levels || levels && !levels.length) {
        return -1;
      }

      // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next
      // to determine whether we've chosen the greatest bandwidth for the media's dimensions
      var atGreatestBandiwdth = function atGreatestBandiwdth(curLevel, nextLevel) {
        if (!nextLevel) {
          return true;
        }

        return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
      };

      // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to
      // the max level
      var maxLevelIndex = levels.length - 1;

      for (var i = 0; i < levels.length; i += 1) {
        var level = levels[i];
        if ((level.width >= width || level.height >= height) && atGreatestBandiwdth(level, levels[i + 1])) {
          maxLevelIndex = i;
          break;
        }
      }

      return maxLevelIndex;
    }
  }, {
    key: 'contentScaleFactor',
    get: function get() {
      var pixelRatio = 1;
      try {
        pixelRatio = window.devicePixelRatio;
      } catch (e) {}
      return pixelRatio;
    }
  }]);

  return CapLevelController;
}(_eventHandler2.default);

exports.default = CapLevelController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/eme-controller.js":
/*!*************************************************!*\
  !*** ./src/hls.js/controller/eme-controller.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author Stephan Hesse <disparat@gmail.com> | <tchakabam@gmail.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * DRM support for Hls.js
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _window = window,
    XMLHttpRequest = _window.XMLHttpRequest;


var MAX_LICENSE_REQUEST_FAILURES = 3;

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess
 */
var KeySystems = {
  WIDEVINE: 'com.widevine.alpha',
  PLAYREADY: 'com.microsoft.playready'
};

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration
 * @param {Array<string>} audioCodecs List of required audio codecs to support
 * @param {Array<string>} videoCodecs List of required video codecs to support
 * @param {object} drmSystemOptions Optional parameters/requirements for the key-system
 * @returns {Array<MediaSystemConfiguration>} An array of supported configurations
 */

var createWidevineMediaKeySystemConfigurations = function createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs, drmSystemOptions) {
  /* jshint ignore:line */
  var baseConfig = {
    // initDataTypes: ['keyids', 'mp4'],
    // label: "",
    // persistentState: "not-allowed", // or "required" ?
    // distinctiveIdentifier: "not-allowed", // or "required" ?
    // sessionTypes: ['temporary'],
    videoCapabilities: [
      // { contentType: 'video/mp4; codecs="avc1.42E01E"' }
    ]
  };

  videoCodecs.forEach(function (codec) {
    baseConfig.videoCapabilities.push({
      contentType: 'video/mp4; codecs="' + codec + '"'
    });
  });

  return [baseConfig];
};

/**
 * The idea here is to handle key-system (and their respective platforms) specific configuration differences
 * in order to work with the local requestMediaKeySystemAccess method.
 *
 * We can also rule-out platform-related key-system support at this point by throwing an error or returning null.
 *
 * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
 * @param {Array<string>} audioCodecs List of required audio codecs to support
 * @param {Array<string>} videoCodecs List of required video codecs to support
 * @returns {Array<MediaSystemConfiguration> | null} A non-empty Array of MediaKeySystemConfiguration objects or `null`
 */
var getSupportedMediaKeySystemConfigurations = function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs) {
  switch (keySystem) {
    case KeySystems.WIDEVINE:
      return createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs);
    default:
      throw Error('Unknown key-system: ' + keySystem);
  }
};

/**
 * Controller to deal with encrypted media extensions (EME)
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API
 *
 * @class
 * @constructor
 */

var EMEController = function (_EventHandler) {
  _inherits(EMEController, _EventHandler);

  /**
     * @constructs
     * @param {Hls} hls Our Hls.js instance
     */
  function EMEController(hls) {
    _classCallCheck(this, EMEController);

    var _this = _possibleConstructorReturn(this, (EMEController.__proto__ || Object.getPrototypeOf(EMEController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MANIFEST_PARSED));

    _this._widevineLicenseUrl = hls.config.widevineLicenseUrl;
    _this._licenseXhrSetup = hls.config.licenseXhrSetup;
    _this._emeEnabled = hls.config.emeEnabled;

    _this._requestMediaKeySystemAccess = hls.config.requestMediaKeySystemAccessFunc;

    _this._mediaKeysList = [];
    _this._media = null;

    _this._hasSetMediaKeys = false;
    _this._isMediaEncrypted = false;

    _this._requestLicenseFailureCount = 0;
    return _this;
  }

  /**
     *
     * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
     * @returns {string} License server URL for key-system (if any configured, otherwise causes error)
     */


  _createClass(EMEController, [{
    key: 'getLicenseServerUrl',
    value: function getLicenseServerUrl(keySystem) {
      var url = void 0;
      switch (keySystem) {
        case KeySystems.WIDEVINE:
          url = this._widevineLicenseUrl;
          break;
        default:
          url = null;
          break;
      }

      if (!url) {
        _logger.logger.error('No license server URL configured for key-system "' + keySystem + '"');
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
          fatal: true
        });
      }

      return url;
    }

    /**
       * Requests access object and adds it to our list upon success
       * @private
       * @param {string} keySystem System ID (see `KeySystems`)
       * @param {Array<string>} audioCodecs List of required audio codecs to support
       * @param {Array<string>} videoCodecs List of required video codecs to support
       */

  }, {
    key: '_attemptKeySystemAccess',
    value: function _attemptKeySystemAccess(keySystem, audioCodecs, videoCodecs) {
      var _this2 = this;

      // TODO: add other DRM "options"

      var mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs);

      if (!mediaKeySystemConfigs) {
        _logger.logger.warn('Can not create config for key-system (maybe because platform is not supported):', keySystem);
        return;
      }

      _logger.logger.log('Requesting encrypted media key-system access');

      // expecting interface like window.navigator.requestMediaKeySystemAccess
      this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs).then(function (mediaKeySystemAccess) {
        _this2._onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess);
      }).catch(function (err) {
        _logger.logger.error('Failed to obtain key-system "' + keySystem + '" access:', err);
      });
    }
  }, {
    key: '_onMediaKeySystemAccessObtained',


    /**
       * Handles obtaining access to a key-system
       *
       * @param {string} keySystem
       * @param {MediaKeySystemAccess} mediaKeySystemAccess https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemAccess
       */
    value: function _onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess) {
      var _this3 = this;

      _logger.logger.log('Access for key-system "' + keySystem + '" obtained');

      var mediaKeysListItem = {
        mediaKeys: null,
        mediaKeysSession: null,
        mediaKeysSessionInitialized: false,
        mediaKeySystemAccess: mediaKeySystemAccess,
        mediaKeySystemDomain: keySystem
      };

      this._mediaKeysList.push(mediaKeysListItem);

      mediaKeySystemAccess.createMediaKeys().then(function (mediaKeys) {
        mediaKeysListItem.mediaKeys = mediaKeys;

        _logger.logger.log('Media-keys created for key-system "' + keySystem + '"');

        _this3._onMediaKeysCreated();
      }).catch(function (err) {
        _logger.logger.error('Failed to create media-keys:', err);
      });
    }

    /**
       * Handles key-creation (represents access to CDM). We are going to create key-sessions upon this
       * for all existing keys where no session exists yet.
       */

  }, {
    key: '_onMediaKeysCreated',
    value: function _onMediaKeysCreated() {
      var _this4 = this;

      // check for all key-list items if a session exists, otherwise, create one
      this._mediaKeysList.forEach(function (mediaKeysListItem) {
        if (!mediaKeysListItem.mediaKeysSession) {
          mediaKeysListItem.mediaKeysSession = mediaKeysListItem.mediaKeys.createSession();
          _this4._onNewMediaKeySession(mediaKeysListItem.mediaKeysSession);
        }
      });
    }

    /**
       *
       * @param {*} keySession
       */

  }, {
    key: '_onNewMediaKeySession',
    value: function _onNewMediaKeySession(keySession) {
      var _this5 = this;

      _logger.logger.log('New key-system session ' + keySession.sessionId);

      keySession.addEventListener('message', function (event) {
        _this5._onKeySessionMessage(keySession, event.message);
      }, false);
    }
  }, {
    key: '_onKeySessionMessage',
    value: function _onKeySessionMessage(keySession, message) {
      _logger.logger.log('Got EME message event, creating license request');

      this._requestLicense(message, function (data) {
        _logger.logger.log('Received license data, updating key-session');
        keySession.update(data);
      });
    }
  }, {
    key: '_onMediaEncrypted',
    value: function _onMediaEncrypted(initDataType, initData) {
      _logger.logger.log('Media is encrypted using "' + initDataType + '" init data type');

      this._isMediaEncrypted = true;
      this._mediaEncryptionInitDataType = initDataType;
      this._mediaEncryptionInitData = initData;

      this._attemptSetMediaKeys();
      this._generateRequestWithPreferredKeySession();
    }
  }, {
    key: '_attemptSetMediaKeys',
    value: function _attemptSetMediaKeys() {
      if (!this._hasSetMediaKeys) {
        // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
        var keysListItem = this._mediaKeysList[0];
        if (!keysListItem || !keysListItem.mediaKeys) {
          _logger.logger.error('Fatal: Media is encrypted but no CDM access or no keys have been obtained yet');
          this.hls.trigger(_events2.default.ERROR, {
            type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
            details: _errors.ErrorDetails.KEY_SYSTEM_NO_KEYS,
            fatal: true
          });
          return;
        }

        _logger.logger.log('Setting keys for encrypted media');

        this._media.setMediaKeys(keysListItem.mediaKeys);
        this._hasSetMediaKeys = true;
      }
    }
  }, {
    key: '_generateRequestWithPreferredKeySession',
    value: function _generateRequestWithPreferredKeySession() {
      var _this6 = this;

      // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
      var keysListItem = this._mediaKeysList[0];
      if (!keysListItem) {
        _logger.logger.error('Fatal: Media is encrypted but not any key-system access has been obtained yet');
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
          fatal: true
        });
        return;
      }

      if (keysListItem.mediaKeysSessionInitialized) {
        _logger.logger.warn('Key-Session already initialized but requested again');
        return;
      }

      var keySession = keysListItem.mediaKeysSession;
      if (!keySession) {
        _logger.logger.error('Fatal: Media is encrypted but no key-session existing');
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_NO_SESSION,
          fatal: true
        });
      }

      var initDataType = this._mediaEncryptionInitDataType;
      var initData = this._mediaEncryptionInitData;

      _logger.logger.log('Generating key-session request for "' + initDataType + '" init data type');

      keysListItem.mediaKeysSessionInitialized = true;

      keySession.generateRequest(initDataType, initData).then(function () {
        _logger.logger.debug('Key-session generation succeeded');
      }).catch(function (err) {
        _logger.logger.error('Error generating key-session request:', err);
        _this6.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_NO_SESSION,
          fatal: false
        });
      });
    }

    /**
       * @param {string} url License server URL
       * @param {ArrayBuffer} keyMessage Message data issued by key-system
       * @param {function} callback Called when XHR has succeeded
       * @returns {XMLHttpRequest} Unsent (but opened state) XHR object
       */

  }, {
    key: '_createLicenseXhr',
    value: function _createLicenseXhr(url, keyMessage, callback) {
      var xhr = new XMLHttpRequest();
      var licenseXhrSetup = this._licenseXhrSetup;

      try {
        if (licenseXhrSetup) {
          try {
            licenseXhrSetup(xhr, url);
          } catch (e) {
            // let's try to open before running setup
            xhr.open('POST', url, true);
            licenseXhrSetup(xhr, url);
          }
        }
        // if licenseXhrSetup did not yet call open, let's do it now
        if (!xhr.readyState) {
          xhr.open('POST', url, true);
        }
      } catch (e) {
        // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
        _logger.logger.error('Error setting up key-system license XHR', e);
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
          fatal: true
        });
        return;
      }

      xhr.responseType = 'arraybuffer';
      xhr.onreadystatechange = this._onLicenseRequestReadyStageChange.bind(this, xhr, url, keyMessage, callback);
      return xhr;
    }

    /**
       * @param {XMLHttpRequest} xhr
       * @param {string} url License server URL
       * @param {ArrayBuffer} keyMessage Message data issued by key-system
       * @param {function} callback Called when XHR has succeeded
       *
       */

  }, {
    key: '_onLicenseRequestReadyStageChange',
    value: function _onLicenseRequestReadyStageChange(xhr, url, keyMessage, callback) {
      switch (xhr.readyState) {
        case 4:
          if (xhr.status === 200) {
            this._requestLicenseFailureCount = 0;
            _logger.logger.log('License request succeeded');
            callback(xhr.response);
          } else {
            _logger.logger.error('License Request XHR failed (' + url + '). Status: ' + xhr.status + ' (' + xhr.statusText + ')');

            this._requestLicenseFailureCount++;
            if (this._requestLicenseFailureCount <= MAX_LICENSE_REQUEST_FAILURES) {
              var attemptsLeft = MAX_LICENSE_REQUEST_FAILURES - this._requestLicenseFailureCount + 1;
              _logger.logger.warn('Retrying license request, ' + attemptsLeft + ' attempts left');
              this._requestLicense(keyMessage, callback);
              return;
            }

            this.hls.trigger(_events2.default.ERROR, {
              type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
              details: _errors.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
              fatal: true
            });
          }
          break;
      }
    }

    /**
       * @param {object} keysListItem
       * @param {ArrayBuffer} keyMessage
       * @returns {ArrayBuffer} Challenge data posted to license server
       */

  }, {
    key: '_generateLicenseRequestChallenge',
    value: function _generateLicenseRequestChallenge(keysListItem, keyMessage) {
      var challenge = void 0;

      if (keysListItem.mediaKeySystemDomain === KeySystems.PLAYREADY) {
        _logger.logger.error('PlayReady is not supported (yet)');

        // from https://github.com/MicrosoftEdge/Demos/blob/master/eme/scripts/demo.js
        /*
          if (this.licenseType !== this.LICENSE_TYPE_WIDEVINE) {
              // For PlayReady CDMs, we need to dig the Challenge out of the XML.
              var keyMessageXml = new DOMParser().parseFromString(String.fromCharCode.apply(null, new Uint16Array(keyMessage)), 'application/xml');
              if (keyMessageXml.getElementsByTagName('Challenge')[0]) {
                  challenge = atob(keyMessageXml.getElementsByTagName('Challenge')[0].childNodes[0].nodeValue);
              } else {
                  throw 'Cannot find <Challenge> in key message';
              }
              var headerNames = keyMessageXml.getElementsByTagName('name');
              var headerValues = keyMessageXml.getElementsByTagName('value');
              if (headerNames.length !== headerValues.length) {
                  throw 'Mismatched header <name>/<value> pair in key message';
              }
              for (var i = 0; i < headerNames.length; i++) {
                  xhr.setRequestHeader(headerNames[i].childNodes[0].nodeValue, headerValues[i].childNodes[0].nodeValue);
              }
          }
          */
      } else if (keysListItem.mediaKeySystemDomain === KeySystems.WIDEVINE) {
        // For Widevine CDMs, the challenge is the keyMessage.
        challenge = keyMessage;
      } else {
        _logger.logger.error('Unsupported key-system:', keysListItem.mediaKeySystemDomain);
      }

      return challenge;
    }
  }, {
    key: '_requestLicense',
    value: function _requestLicense(keyMessage, callback) {
      _logger.logger.log('Requesting content license for key-system');

      var keysListItem = this._mediaKeysList[0];
      if (!keysListItem) {
        _logger.logger.error('Fatal error: Media is encrypted but no key-system access has been obtained yet');
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
          fatal: true
        });
        return;
      }

      var url = this.getLicenseServerUrl(keysListItem.mediaKeySystemDomain);
      var xhr = this._createLicenseXhr(url, keyMessage, callback);

      _logger.logger.log('Sending license request to URL: ' + url);

      xhr.send(this._generateLicenseRequestChallenge(keysListItem, keyMessage));
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var _this7 = this;

      if (!this._emeEnabled) {
        return;
      }

      var media = data.media;

      // keep reference of media
      this._media = media;

      // FIXME: also handle detaching media !

      media.addEventListener('encrypted', function (e) {
        _this7._onMediaEncrypted(e.initDataType, e.initData);
      });
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      if (!this._emeEnabled) {
        return;
      }

      var audioCodecs = data.levels.map(function (level) {
        return level.audioCodec;
      });
      var videoCodecs = data.levels.map(function (level) {
        return level.videoCodec;
      });

      this._attemptKeySystemAccess(KeySystems.WIDEVINE, audioCodecs, videoCodecs);
    }
  }, {
    key: 'requestMediaKeySystemAccess',
    get: function get() {
      if (!this._requestMediaKeySystemAccess) {
        throw new Error('No requestMediaKeySystemAccess function configured');
      }

      return this._requestMediaKeySystemAccess;
    }
  }]);

  return EMEController;
}(_eventHandler2.default);

exports.default = EMEController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/fps-controller.js":
/*!*************************************************!*\
  !*** ./src/hls.js/controller/fps-controller.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FPS Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var _window = window,
    performance = _window.performance;

var FPSController = function (_EventHandler) {
  _inherits(FPSController, _EventHandler);

  function FPSController(hls) {
    _classCallCheck(this, FPSController);

    return _possibleConstructorReturn(this, (FPSController.__proto__ || Object.getPrototypeOf(FPSController)).call(this, hls, _events2.default.MEDIA_ATTACHING));
  }

  _createClass(FPSController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearInterval(this.timer);
      }

      this.isVideoPlaybackQualityAvailable = false;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var config = this.hls.config;
      if (config.capLevelOnFPSDrop) {
        var video = this.video = data.media instanceof window.HTMLVideoElement ? data.media : null;
        if (typeof video.getVideoPlaybackQuality === 'function') {
          this.isVideoPlaybackQualityAvailable = true;
        }

        clearInterval(this.timer);
        this.timer = setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
      }
    }
  }, {
    key: 'checkFPS',
    value: function checkFPS(video, decodedFrames, droppedFrames) {
      var currentTime = performance.now();
      if (decodedFrames) {
        if (this.lastTime) {
          var currentPeriod = currentTime - this.lastTime,
              currentDropped = droppedFrames - this.lastDroppedFrames,
              currentDecoded = decodedFrames - this.lastDecodedFrames,
              droppedFPS = 1000 * currentDropped / currentPeriod,
              hls = this.hls;
          hls.trigger(_events2.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
          if (droppedFPS > 0) {
            // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
            if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
              var currentLevel = hls.currentLevel;
              _logger.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
              if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
                currentLevel = currentLevel - 1;
                hls.trigger(_events2.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: hls.currentLevel });
                hls.autoLevelCapping = currentLevel;
                hls.streamController.nextLevelSwitch();
              }
            }
          }
        }
        this.lastTime = currentTime;
        this.lastDroppedFrames = droppedFrames;
        this.lastDecodedFrames = decodedFrames;
      }
    }
  }, {
    key: 'checkFPSInterval',
    value: function checkFPSInterval() {
      var video = this.video;
      if (video) {
        if (this.isVideoPlaybackQualityAvailable) {
          var videoPlaybackQuality = video.getVideoPlaybackQuality();
          this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
        } else {
          this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
        }
      }
    }
  }]);

  return FPSController;
}(_eventHandler2.default);

exports.default = FPSController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/fragment-finders.js":
/*!***************************************************!*\
  !*** ./src/hls.js/controller/fragment-finders.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findFragmentByPDT = findFragmentByPDT;
exports.findFragmentByPTS = findFragmentByPTS;
exports.fragmentWithinToleranceTest = fragmentWithinToleranceTest;
exports.pdtWithinToleranceTest = pdtWithinToleranceTest;

var _binarySearch = __webpack_require__(/*! ../utils/binary-search */ "./src/hls.js/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns first fragment whose endPdt value exceeds the given PDT.
 * @param {Array<Fragment>} fragments - The array of candidate fragments
 * @param {number|null} [PDTValue = null] - The PDT value which must be exceeded
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start/end can be within in order to be considered contiguous
 * @returns {*|null} fragment - The best matching fragment
 */
function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
  if (!Array.isArray(fragments) || !fragments.length || !Number.isFinite(PDTValue)) {
    return null;
  }

  // if less than start
  if (PDTValue < fragments[0].programDateTime) {
    return null;
  }

  if (PDTValue >= fragments[fragments.length - 1].endProgramDateTime) {
    return null;
  }

  maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
  for (var seg = 0; seg < fragments.length; ++seg) {
    var frag = fragments[seg];
    if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
      return frag;
    }
  }

  return null;
}

/**
 * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.
 * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus
 * breaking any traps which would cause the same fragment to be continuously selected within a small range.
 * @param {*} fragPrevious - The last frag successfully appended
 * @param {Array<Fragment>} fragments - The array of candidate fragments
 * @param {number} [bufferEnd = 0] - The end of the contiguous buffered range the playhead is currently within
 * @param {number} maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous
 * @returns {*} foundFrag - The best matching fragment
 */
function findFragmentByPTS(fragPrevious, fragments) {
  var bufferEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var maxFragLookUpTolerance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : null;
  // Prefer the next fragment if it's within tolerance
  if (fragNext && !fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext)) {
    return fragNext;
  }
  return _binarySearch2.default.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
}

/**
 * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.
 * @param {*} candidate - The fragment to test
 * @param {number} [bufferEnd = 0] - The end of the current buffered range the playhead is currently within
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous
 * @returns {number} - 0 if it matches, 1 if too low, -1 if too high
 */
function fragmentWithinToleranceTest() {
  var bufferEnd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var maxFragLookUpTolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var candidate = arguments[2];

  // offset should be within fragment boundary - config.maxFragLookUpTolerance
  // this is to cope with situations like
  // bufferEnd = 9.991
  // frag[] : [0,10]
  // frag[1] : [10,20]
  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
  //              frag start               frag start+duration
  //                  |-----------------------------|
  //              <--->                         <--->
  //  ...--------><-----------------------------><---------....
  // previous frag         matching fragment         next frag
  //  return -1             return 0                 return 1
  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
    return 1;
  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
    return -1;
  }

  return 0;
}

/**
 * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.
 * This function tests the candidate's program date time values, as represented in Unix time
 * @param {*} candidate - The fragment to test
 * @param {number} [pdtBufferEnd = 0] - The Unix time representing the end of the current buffered range
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous
 * @returns {boolean} True if contiguous, false otherwise
 */
function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;
  return candidate.endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
}

/***/ }),

/***/ "./src/hls.js/controller/fragment-tracker.js":
/*!***************************************************!*\
  !*** ./src/hls.js/controller/fragment-tracker.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FragmentTracker = exports.FragmentState = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FragmentState = exports.FragmentState = {
  NOT_LOADED: 'NOT_LOADED',
  APPENDING: 'APPENDING',
  PARTIAL: 'PARTIAL',
  OK: 'OK'
};

var FragmentTracker = exports.FragmentTracker = function (_EventHandler) {
  _inherits(FragmentTracker, _EventHandler);

  function FragmentTracker(hls) {
    _classCallCheck(this, FragmentTracker);

    var _this = _possibleConstructorReturn(this, (FragmentTracker.__proto__ || Object.getPrototypeOf(FragmentTracker)).call(this, hls, _events2.default.BUFFER_APPENDED, _events2.default.FRAG_BUFFERED, _events2.default.FRAG_LOADED));

    _this.bufferPadding = 0.2;

    _this.fragments = Object.create(null);
    _this.timeRanges = Object.create(null);

    _this.config = hls.config;
    return _this;
  }

  _createClass(FragmentTracker, [{
    key: 'destroy',
    value: function destroy() {
      this.fragments = Object.create(null);
      this.timeRanges = Object.create(null);
      this.config = null;
      _eventHandler2.default.prototype.destroy.call(this);
      _get(FragmentTracker.prototype.__proto__ || Object.getPrototypeOf(FragmentTracker.prototype), 'destroy', this).call(this);
    }

    /**
     * Return a Fragment that match the position and levelType.
     * If not found any Fragment, return null
     * @param {number} position
     * @param {LevelType} levelType
     * @returns {Fragment|null}
     */

  }, {
    key: 'getBufferedFrag',
    value: function getBufferedFrag(position, levelType) {
      var fragments = this.fragments;
      var bufferedFrags = Object.keys(fragments).filter(function (key) {
        var fragmentEntity = fragments[key];
        if (fragmentEntity.body.type !== levelType) {
          return false;
        }

        if (!fragmentEntity.buffered) {
          return false;
        }

        var frag = fragmentEntity.body;
        return frag.startPTS <= position && position <= frag.endPTS;
      });
      if (bufferedFrags.length === 0) {
        return null;
      } else {
        // https://github.com/video-dev/hls.js/pull/1545#discussion_r166229566
        var bufferedFragKey = bufferedFrags.pop();
        return fragments[bufferedFragKey].body;
      }
    }

    /**
     * Partial fragments effected by coded frame eviction will be removed
     * The browser will unload parts of the buffer to free up memory for new buffer data
     * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
     * @param {String} elementaryStream The elementaryStream of media this is (eg. video/audio)
     * @param {TimeRanges} timeRange TimeRange object from a sourceBuffer
     */

  }, {
    key: 'detectEvictedFragments',
    value: function detectEvictedFragments(elementaryStream, timeRange) {
      var _this2 = this;

      var fragmentTimes = void 0,
          time = void 0;
      // Check if any flagged fragments have been unloaded
      Object.keys(this.fragments).forEach(function (key) {
        var fragmentEntity = _this2.fragments[key];
        if (fragmentEntity.buffered === true) {
          var esData = fragmentEntity.range[elementaryStream];
          if (esData) {
            fragmentTimes = esData.time;
            for (var i = 0; i < fragmentTimes.length; i++) {
              time = fragmentTimes[i];

              if (_this2.isTimeBuffered(time.startPTS, time.endPTS, timeRange) === false) {
                // Unregister partial fragment as it needs to load again to be reused
                _this2.removeFragment(fragmentEntity.body);
                break;
              }
            }
          }
        }
      });
    }

    /**
     * Checks if the fragment passed in is loaded in the buffer properly
     * Partially loaded fragments will be registered as a partial fragment
     * @param {Object} fragment Check the fragment against all sourceBuffers loaded
     */

  }, {
    key: 'detectPartialFragments',
    value: function detectPartialFragments(fragment) {
      var _this3 = this;

      var fragKey = this.getFragmentKey(fragment);
      var fragmentEntity = this.fragments[fragKey];
      if (fragmentEntity) {
        fragmentEntity.buffered = true;

        Object.keys(this.timeRanges).forEach(function (elementaryStream) {
          if (fragment.hasElementaryStream(elementaryStream)) {
            var timeRange = _this3.timeRanges[elementaryStream];
            // Check for malformed fragments
            // Gaps need to be calculated for each elementaryStream
            fragmentEntity.range[elementaryStream] = _this3.getBufferedTimes(fragment.startPTS, fragment.endPTS, timeRange);
          }
        });
      }
    }
  }, {
    key: 'getBufferedTimes',
    value: function getBufferedTimes(startPTS, endPTS, timeRange) {
      var fragmentTimes = [];
      var startTime = void 0,
          endTime = void 0;
      var fragmentPartial = false;
      for (var i = 0; i < timeRange.length; i++) {
        startTime = timeRange.start(i) - this.bufferPadding;
        endTime = timeRange.end(i) + this.bufferPadding;
        if (startPTS >= startTime && endPTS <= endTime) {
          // Fragment is entirely contained in buffer
          // No need to check the other timeRange times since it's completely playable
          fragmentTimes.push({
            startPTS: Math.max(startPTS, timeRange.start(i)),
            endPTS: Math.min(endPTS, timeRange.end(i))
          });
          break;
        } else if (startPTS < endTime && endPTS > startTime) {
          // Check for intersection with buffer
          // Get playable sections of the fragment
          fragmentTimes.push({
            startPTS: Math.max(startPTS, timeRange.start(i)),
            endPTS: Math.min(endPTS, timeRange.end(i))
          });
          fragmentPartial = true;
        } else if (endPTS <= startTime) {
          // No need to check the rest of the timeRange as it is in order
          break;
        }
      }

      return {
        time: fragmentTimes,
        partial: fragmentPartial
      };
    }
  }, {
    key: 'getFragmentKey',
    value: function getFragmentKey(fragment) {
      return fragment.type + '_' + fragment.levels + '_' + fragment.urlId + '_' + fragment.sn;
    }

    /**
     * Gets the partial fragment for a certain time
     * @param {Number} time
     * @returns {Object} fragment Returns a partial fragment at a time or null if there is no partial fragment
     */

  }, {
    key: 'getPartialFragment',
    value: function getPartialFragment(time) {
      var _this4 = this;

      var timePadding = void 0,
          startTime = void 0,
          endTime = void 0;
      var bestFragment = null;
      var bestOverlap = 0;
      Object.keys(this.fragments).forEach(function (key) {
        var fragmentEntity = _this4.fragments[key];
        if (_this4.isPartial(fragmentEntity)) {
          startTime = fragmentEntity.body.startPTS - _this4.bufferPadding;
          endTime = fragmentEntity.body.endPTS + _this4.bufferPadding;
          if (time >= startTime && time <= endTime) {
            // Use the fragment that has the most padding from start and end time
            timePadding = Math.min(time - startTime, endTime - time);
            if (bestOverlap <= timePadding) {
              bestFragment = fragmentEntity.body;
              bestOverlap = timePadding;
            }
          }
        }
      });
      return bestFragment;
    }

    /**
     * @param {Object} fragment The fragment to check
     * @returns {String} Returns the fragment state when a fragment never loaded or if it partially loaded
     */

  }, {
    key: 'getState',
    value: function getState(fragment) {
      var fragKey = this.getFragmentKey(fragment);
      var fragmentEntity = this.fragments[fragKey];
      var state = FragmentState.NOT_LOADED;

      if (fragmentEntity !== undefined) {
        if (!fragmentEntity.buffered) {
          state = FragmentState.APPENDING;
        } else if (this.isPartial(fragmentEntity) === true) {
          state = FragmentState.PARTIAL;
        } else {
          state = FragmentState.OK;
        }
      }

      return state;
    }
  }, {
    key: 'isPartial',
    value: function isPartial(fragmentEntity) {
      return fragmentEntity.buffered === true && (fragmentEntity.range.video !== undefined && fragmentEntity.range.video.partial === true || fragmentEntity.range.audio !== undefined && fragmentEntity.range.audio.partial === true);
    }
  }, {
    key: 'isTimeBuffered',
    value: function isTimeBuffered(startPTS, endPTS, timeRange) {
      var startTime = void 0,
          endTime = void 0;
      for (var i = 0; i < timeRange.length; i++) {
        startTime = timeRange.start(i) - this.bufferPadding;
        endTime = timeRange.end(i) + this.bufferPadding;
        if (startPTS >= startTime && endPTS <= endTime) {
          return true;
        }

        if (endPTS <= startTime) {
          // No need to check the rest of the timeRange as it is in order
          return false;
        }
      }

      return false;
    }

    /**
     * Fires when a fragment loading is completed
     */

  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(e) {
      var fragment = e.frag;
      // don't track initsegment (for which sn is not a number)
      // don't track frags used for bitrateTest, they're irrelevant.
      if (!Number.isFinite(fragment.sn) || fragment.bitrateTest) {
        return;
      }

      this.fragments[this.getFragmentKey(fragment)] = {
        body: fragment,
        range: Object.create(null),
        buffered: false
      };
    }

    /**
     * Fires when the buffer is updated
     */

  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(e) {
      var _this5 = this;

      // Store the latest timeRanges loaded in the buffer
      this.timeRanges = e.timeRanges;
      Object.keys(this.timeRanges).forEach(function (elementaryStream) {
        var timeRange = _this5.timeRanges[elementaryStream];
        _this5.detectEvictedFragments(elementaryStream, timeRange);
      });
    }

    /**
     * Fires after a fragment has been loaded into the source buffer
     */

  }, {
    key: 'onFragBuffered',
    value: function onFragBuffered(e) {
      this.detectPartialFragments(e.frag);
    }

    /**
     * Return true if fragment tracker has the fragment.
     * @param {Object} fragment
     * @returns {boolean}
     */

  }, {
    key: 'hasFragment',
    value: function hasFragment(fragment) {
      var fragKey = this.getFragmentKey(fragment);
      return this.fragments[fragKey] !== undefined;
    }

    /**
     * Remove a fragment from fragment tracker until it is loaded again
     * @param {Object} fragment The fragment to remove
     */

  }, {
    key: 'removeFragment',
    value: function removeFragment(fragment) {
      var fragKey = this.getFragmentKey(fragment);
      delete this.fragments[fragKey];
    }

    /**
     * Remove all fragments from fragment tracker.
     */

  }, {
    key: 'removeAllFragments',
    value: function removeAllFragments() {
      this.fragments = Object.create(null);
    }
  }]);

  return FragmentTracker;
}(_eventHandler2.default);

/***/ }),

/***/ "./src/hls.js/controller/gap-controller.js":
/*!*************************************************!*\
  !*** ./src/hls.js/controller/gap-controller.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var stallDebounceInterval = 1000;
var jumpThreshold = 0.5; // tolerance needed as some browsers stalls playback before reaching buffered range end

var GapController = function () {
  function GapController(config, media, fragmentTracker, hls) {
    _classCallCheck(this, GapController);

    this.config = config;
    this.media = media;
    this.fragmentTracker = fragmentTracker;
    this.hls = hls;
    this.stallReported = false;
  }

  /**
   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.
   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).
   * @param lastCurrentTime
   * @param buffered
   */


  _createClass(GapController, [{
    key: 'poll',
    value: function poll(lastCurrentTime, buffered) {
      var config = this.config,
          media = this.media;

      var currentTime = media.currentTime;
      var tnow = window.performance.now();

      if (currentTime !== lastCurrentTime) {
        // The playhead is now moving, but was previously stalled
        if (this.stallReported) {
          _logger.logger.warn('playback not stuck anymore @' + currentTime + ', after ' + Math.round(tnow - this.stalled) + 'ms');
          this.stallReported = false;
        }
        this.stalled = null;
        this.nudgeRetry = 0;
        return;
      }

      if (media.ended || !media.buffered.length || media.readyState > 2) {
        return;
      }

      if (media.seeking && _bufferHelper.BufferHelper.isBuffered(media, currentTime)) {
        return;
      }

      // The playhead isn't moving but it should be
      // Allow some slack time to for small stalls to resolve themselves
      var stalledDuration = tnow - this.stalled;
      var bufferInfo = _bufferHelper.BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);
      if (!this.stalled) {
        this.stalled = tnow;
        return;
      } else if (stalledDuration >= stallDebounceInterval) {
        // Report stalling after trying to fix
        this._reportStall(bufferInfo.len);
      }

      this._tryFixBufferStall(bufferInfo, stalledDuration);
    }

    /**
     * Detects and attempts to fix known buffer stalling issues.
     * @param bufferInfo - The properties of the current buffer.
     * @param stalledDuration - The amount of time Hls.js has been stalling for.
     * @private
     */

  }, {
    key: '_tryFixBufferStall',
    value: function _tryFixBufferStall(bufferInfo, stalledDuration) {
      var config = this.config,
          fragmentTracker = this.fragmentTracker,
          media = this.media;

      var currentTime = media.currentTime;

      var partial = fragmentTracker.getPartialFragment(currentTime);
      if (partial) {
        // Try to skip over the buffer hole caused by a partial fragment
        // This method isn't limited by the size of the gap between buffered ranges
        this._trySkipBufferHole(partial);
      }

      if (bufferInfo.len > jumpThreshold && stalledDuration > config.highBufferWatchdogPeriod * 1000) {
        // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds
        // We only try to jump the hole if it's under the configured size
        // Reset stalled so to rearm watchdog timer
        this.stalled = null;
        this._tryNudgeBuffer();
      }
    }

    /**
     * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.
     * @param bufferLen - The playhead distance from the end of the current buffer segment.
     * @private
     */

  }, {
    key: '_reportStall',
    value: function _reportStall(bufferLen) {
      var hls = this.hls,
          media = this.media,
          stallReported = this.stallReported;

      if (!stallReported) {
        // Report stalled error once
        this.stallReported = true;
        _logger.logger.warn('Playback stalling at @' + media.currentTime + ' due to low buffer');
        hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.BUFFER_STALLED_ERROR,
          fatal: false,
          buffer: bufferLen
        });
      }
    }

    /**
     * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments
     * @param partial - The partial fragment found at the current time (where playback is stalling).
     * @private
     */

  }, {
    key: '_trySkipBufferHole',
    value: function _trySkipBufferHole(partial) {
      var hls = this.hls,
          media = this.media;

      var currentTime = media.currentTime;
      var lastEndTime = 0;
      // Check if currentTime is between unbuffered regions of partial fragments
      for (var i = 0; i < media.buffered.length; i++) {
        var startTime = media.buffered.start(i);
        if (currentTime >= lastEndTime && currentTime < startTime) {
          media.currentTime = Math.max(startTime, media.currentTime + 0.1);
          _logger.logger.warn('skipping hole, adjusting currentTime from ' + currentTime + ' to ' + media.currentTime);
          this.stalled = null;
          hls.trigger(_events2.default.ERROR, {
            type: _errors.ErrorTypes.MEDIA_ERROR,
            details: _errors.ErrorDetails.BUFFER_SEEK_OVER_HOLE,
            fatal: false,
            reason: 'fragment loaded with buffer holes, seeking from ' + currentTime + ' to ' + media.currentTime,
            frag: partial
          });
          return;
        }
        lastEndTime = media.buffered.end(i);
      }
    }

    /**
     * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.
     * @private
     */

  }, {
    key: '_tryNudgeBuffer',
    value: function _tryNudgeBuffer() {
      var config = this.config,
          hls = this.hls,
          media = this.media;

      var currentTime = media.currentTime;
      var nudgeRetry = (this.nudgeRetry || 0) + 1;
      this.nudgeRetry = nudgeRetry;

      if (nudgeRetry < config.nudgeMaxRetry) {
        var targetTime = currentTime + nudgeRetry * config.nudgeOffset;
        _logger.logger.log('adjust currentTime from ' + currentTime + ' to ' + targetTime);
        // playback stalled in buffered area ... let's nudge currentTime to try to overcome this
        media.currentTime = targetTime;
        hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.BUFFER_NUDGE_ON_STALL,
          fatal: false
        });
      } else {
        _logger.logger.error('still stuck in high buffer @' + currentTime + ' after ' + config.nudgeMaxRetry + ', raise fatal error');
        hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.BUFFER_STALLED_ERROR,
          fatal: true
        });
      }
    }
  }]);

  return GapController;
}();

exports.default = GapController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/id3-track-controller.js":
/*!*******************************************************!*\
  !*** ./src/hls.js/controller/id3-track-controller.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _id = __webpack_require__(/*! ../demux/id3 */ "./src/hls.js/demux/id3.js");

var _id2 = _interopRequireDefault(_id);

var _texttrackUtils = __webpack_require__(/*! ../utils/texttrack-utils */ "./src/hls.js/utils/texttrack-utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * id3 metadata track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var ID3TrackController = function (_EventHandler) {
  _inherits(ID3TrackController, _EventHandler);

  function ID3TrackController(hls) {
    _classCallCheck(this, ID3TrackController);

    var _this = _possibleConstructorReturn(this, (ID3TrackController.__proto__ || Object.getPrototypeOf(ID3TrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_METADATA));

    _this.id3Track = undefined;
    _this.media = undefined;
    return _this;
  }

  _createClass(ID3TrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Add ID3 metatadata text track.

  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      this.media = data.media;
      if (!this.media) {}
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      (0, _texttrackUtils.clearCurrentCues)(this.id3Track);
      this.id3Track = undefined;
      this.media = undefined;
    }
  }, {
    key: 'getID3Track',
    value: function getID3Track(textTracks) {
      for (var i = 0; i < textTracks.length; i++) {
        var textTrack = textTracks[i];
        if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {
          // send 'addtrack' when reusing the textTrack for metadata,
          // same as what we do for captions
          (0, _texttrackUtils.sendAddTrackEvent)(textTrack, this.media);

          return textTrack;
        }
      }
      return this.media.addTextTrack('metadata', 'id3');
    }
  }, {
    key: 'onFragParsingMetadata',
    value: function onFragParsingMetadata(data) {
      var fragment = data.frag;
      var samples = data.samples;

      // create track dynamically
      if (!this.id3Track) {
        this.id3Track = this.getID3Track(this.media.textTracks);
        this.id3Track.mode = 'hidden';
      }

      // Attempt to recreate Safari functionality by creating
      // WebKitDataCue objects when available and store the decoded
      // ID3 data in the value property of the cue
      var Cue = window.WebKitDataCue || window.VTTCue || window.TextTrackCue;

      for (var i = 0; i < samples.length; i++) {
        var frames = _id2.default.getID3Frames(samples[i].data);
        if (frames) {
          var startTime = samples[i].pts;
          var endTime = i < samples.length - 1 ? samples[i + 1].pts : fragment.endPTS;

          // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
          if (startTime === endTime) {
            endTime += 0.0001;
          }

          for (var j = 0; j < frames.length; j++) {
            var frame = frames[j];
            // Safari doesn't put the timestamp frame in the TextTrack
            if (!_id2.default.isTimeStampFrame(frame)) {
              var cue = new Cue(startTime, endTime, '');
              cue.value = frame;
              this.id3Track.addCue(cue);
            }
          }
        }
      }
    }
  }]);

  return ID3TrackController;
}(_eventHandler2.default);

exports.default = ID3TrackController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/level-controller.js":
/*!***************************************************!*\
  !*** ./src/hls.js/controller/level-controller.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _codecs = __webpack_require__(/*! ../utils/codecs */ "./src/hls.js/utils/codecs.js");

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Level Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var _window = window,
    performance = _window.performance;

var chromeOrFirefox = void 0;

var LevelController = function (_EventHandler) {
  _inherits(LevelController, _EventHandler);

  function LevelController(hls) {
    _classCallCheck(this, LevelController);

    var _this = _possibleConstructorReturn(this, (LevelController.__proto__ || Object.getPrototypeOf(LevelController)).call(this, hls, _events2.default.MANIFEST_LOADED, _events2.default.LEVEL_LOADED, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.FRAG_LOADED, _events2.default.ERROR));

    _this.canload = false;
    _this.currentLevelIndex = null;
    _this.manualLevelIndex = -1;
    _this.timer = null;

    chromeOrFirefox = /chrome|firefox/.test(navigator.userAgent.toLowerCase());
    return _this;
  }

  _createClass(LevelController, [{
    key: 'onHandlerDestroying',
    value: function onHandlerDestroying() {
      this.clearTimer();
      this.manualLevelIndex = -1;
    }
  }, {
    key: 'clearTimer',
    value: function clearTimer() {
      if (this.timer !== null) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      var levels = this._levels;

      this.canload = true;
      this.levelRetryCount = 0;

      // clean up live level details to force reload them, and reset load errors
      if (levels) {
        levels.forEach(function (level) {
          level.loadError = 0;
          var levelDetails = level.details;
          if (levelDetails && levelDetails.live) {
            level.details = undefined;
          }
        });
      }
      // speed up live playlist refresh if timer exists
      if (this.timer !== null) {
        this.loadLevel();
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.canload = false;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var levels = [];
      var audioTracks = [];
      var bitrateStart = void 0;
      var levelSet = {};
      var levelFromSet = null;
      var videoCodecFound = false;
      var audioCodecFound = false;

      // regroup redundant levels together
      data.levels.forEach(function (level) {
        var attributes = level.attrs;
        level.loadError = 0;
        level.fragmentError = false;

        videoCodecFound = videoCodecFound || !!level.videoCodec;
        audioCodecFound = audioCodecFound || !!level.audioCodec;

        // erase audio codec info if browser does not support mp4a.40.34.
        // demuxer will autodetect codec and fallback to mpeg/audio
        if (chromeOrFirefox && level.audioCodec && level.audioCodec.indexOf('mp4a.40.34') !== -1) {
          level.audioCodec = undefined;
        }

        levelFromSet = levelSet[level.bitrate]; // FIXME: we would also have to match the resolution here

        if (!levelFromSet) {
          level.url = [level.url];
          level.urlId = 0;
          levelSet[level.bitrate] = level;
          levels.push(level);
        } else {
          levelFromSet.url.push(level.url);
        }

        if (attributes) {
          if (attributes.AUDIO) {
            audioCodecFound = true;
            (0, _levelHelper.addGroupId)(levelFromSet || level, 'audio', attributes.AUDIO);
          }
          if (attributes.SUBTITLES) {
            (0, _levelHelper.addGroupId)(levelFromSet || level, 'text', attributes.SUBTITLES);
          }
        }
      });

      // remove audio-only level if we also have levels with audio+video codecs signalled
      if (videoCodecFound && audioCodecFound) {
        levels = levels.filter(function (_ref) {
          var videoCodec = _ref.videoCodec;
          return !!videoCodec;
        });
      }

      // only keep levels with supported audio/video codecs
      levels = levels.filter(function (_ref2) {
        var audioCodec = _ref2.audioCodec,
            videoCodec = _ref2.videoCodec;

        return (!audioCodec || (0, _codecs.isCodecSupportedInMp4)(audioCodec, 'audio')) && (!videoCodec || (0, _codecs.isCodecSupportedInMp4)(videoCodec, 'video'));
      });

      if (data.audioTracks) {
        audioTracks = data.audioTracks.filter(function (track) {
          return !track.audioCodec || (0, _codecs.isCodecSupportedInMp4)(track.audioCodec, 'audio');
        });
        // Reassign id's after filtering since they're used as array indices
        audioTracks.forEach(function (track, index) {
          track.id = index;
        });
      }

      if (levels.length > 0) {
        // start bitrate is the first bitrate of the manifest
        bitrateStart = levels[0].bitrate;
        // sort level on bitrate
        levels.sort(function (a, b) {
          return a.bitrate - b.bitrate;
        });
        this._levels = levels;
        // find index of first level in sorted levels
        for (var i = 0; i < levels.length; i++) {
          if (levels[i].bitrate === bitrateStart) {
            this._firstLevel = i;
            _logger.logger.log('manifest loaded,' + levels.length + ' level(s) found, first bitrate:' + bitrateStart);
            break;
          }
        }

        // Audio is only alternate if manifest include a URI along with the audio group tag
        this.hls.trigger(_events2.default.MANIFEST_PARSED, {
          levels: levels,
          audioTracks: audioTracks,
          firstLevel: this._firstLevel,
          stats: data.stats,
          audio: audioCodecFound,
          video: videoCodecFound,
          altAudio: audioTracks.some(function (t) {
            return !!t.url;
          })
        });
      } else {
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
          fatal: true,
          url: this.hls.url,
          reason: 'no level with compatible codecs found in manifest'
        });
      }
    }
  }, {
    key: 'setLevelInternal',
    value: function setLevelInternal(newLevel) {
      var levels = this._levels;
      var hls = this.hls;
      // check if level idx is valid
      if (newLevel >= 0 && newLevel < levels.length) {
        // stopping live reloading timer if any
        this.clearTimer();
        if (this.currentLevelIndex !== newLevel) {
          _logger.logger.log('switching to level ' + newLevel);
          this.currentLevelIndex = newLevel;
          var levelProperties = levels[newLevel];
          levelProperties.level = newLevel;
          hls.trigger(_events2.default.LEVEL_SWITCHING, levelProperties);
        }
        var level = levels[newLevel];
        var levelDetails = level.details;

        // check if we need to load playlist for this level
        if (!levelDetails || levelDetails.live) {
          // level not retrieved yet, or live playlist we need to (re)load it
          var urlId = level.urlId;
          hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });
        }
      } else {
        // invalid level id given, trigger error
        hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.OTHER_ERROR,
          details: _errors.ErrorDetails.LEVEL_SWITCH_ERROR,
          level: newLevel,
          fatal: false,
          reason: 'invalid level idx'
        });
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      if (data.fatal) {
        if (data.type === _errors.ErrorTypes.NETWORK_ERROR) {
          this.clearTimer();
        }

        return;
      }

      var levelError = false,
          fragmentError = false;
      var levelIndex = void 0;

      // try to recover not fatal errors
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          levelIndex = data.frag.levels;
          fragmentError = true;
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          levelIndex = data.context.levels;
          levelError = true;
          break;
        case _errors.ErrorDetails.REMUX_ALLOC_ERROR:
          levelIndex = data.levels;
          levelError = true;
          break;
      }

      if (levelIndex !== undefined) {
        this.recoverLevel(data, levelIndex, levelError, fragmentError);
      }
    }

    /**
     * Switch to a redundant stream if any available.
     * If redundant stream is not available, emergency switch down if ABR mode is enabled.
     *
     * @param {Object} errorEvent
     * @param {Number} levelIndex current level index
     * @param {Boolean} levelError
     * @param {Boolean} fragmentError
     */
    // FIXME Find a better abstraction where fragment/level retry management is well decoupled

  }, {
    key: 'recoverLevel',
    value: function recoverLevel(errorEvent, levelIndex, levelError, fragmentError) {
      var _this2 = this;

      var config = this.hls.config;
      var errorDetails = errorEvent.details;

      var level = this._levels[levelIndex];
      var redundantLevels = void 0,
          delay = void 0,
          nextLevel = void 0;

      level.loadError++;
      level.fragmentError = fragmentError;

      if (levelError) {
        if (this.levelRetryCount + 1 <= config.levelLoadingMaxRetry) {
          // exponential backoff capped to max retry timeout
          delay = Math.min(Math.pow(2, this.levelRetryCount) * config.levelLoadingRetryDelay, config.levelLoadingMaxRetryTimeout);
          // Schedule level reload
          this.timer = setTimeout(function () {
            return _this2.loadLevel();
          }, delay);
          // boolean used to inform stream controller not to switch back to IDLE on non fatal error
          errorEvent.levelRetry = true;
          this.levelRetryCount++;
          _logger.logger.warn('level controller, ' + errorDetails + ', retry in ' + delay + ' ms, current retry count is ' + this.levelRetryCount);
        } else {
          _logger.logger.error('level controller, cannot recover from ' + errorDetails + ' error');
          this.currentLevelIndex = null;
          // stopping live reloading timer if any
          this.clearTimer();
          // switch error to fatal
          errorEvent.fatal = true;
          return;
        }
      }

      // Try any redundant streams if available for both errors: level and fragment
      // If level.loadError reaches redundantLevels it means that we tried them all, no hope  => let's switch down
      if (levelError || fragmentError) {
        redundantLevels = level.url.length;

        if (redundantLevels > 1 && level.loadError < redundantLevels) {
          level.urlId = (level.urlId + 1) % redundantLevels;
          level.details = undefined;

          _logger.logger.warn('level controller, ' + errorDetails + ' for level ' + levelIndex + ': switching to redundant URL-id ' + level.urlId);

          // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);
          // console.log('New video quality level audio group id:', level.attrs.AUDIO);
        } else {
          // Search for available level
          if (this.manualLevelIndex === -1) {
            // When lowest level has been reached, let's start hunt from the top
            nextLevel = levelIndex === 0 ? this._levels.length - 1 : levelIndex - 1;
            _logger.logger.warn('level controller, ' + errorDetails + ': switch to ' + nextLevel);
            this.hls.nextAutoLevel = this.currentLevelIndex = nextLevel;
          } else if (fragmentError) {
            // Allow fragment retry as long as configuration allows.
            // reset this._level so that another call to set level() will trigger again a frag load
            _logger.logger.warn('level controller, ' + errorDetails + ': reload a fragment');
            this.currentLevelIndex = null;
          }
        }
      }
    }

    // reset errors on the successful load of a fragment

  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(_ref3) {
      var frag = _ref3.frag;

      if (frag !== undefined && frag.type === 'main') {
        var level = this._levels[frag.levels];
        if (level !== undefined) {
          level.fragmentError = false;
          level.loadError = 0;
          this.levelRetryCount = 0;
        }
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var _this3 = this;

      var level = data.level,
          details = data.details;
      // only process level loaded events matching with expected level

      if (level !== this.currentLevelIndex) {
        return;
      }

      var curLevel = this._levels[level];
      // reset level load error counter on successful level loaded only if there is no issues with fragments
      if (!curLevel.fragmentError) {
        curLevel.loadError = 0;
        this.levelRetryCount = 0;
      }
      // if current playlist is a live playlist, arm a timer to reload it
      if (details.live) {
        var reloadInterval = (0, _levelHelper.computeReloadInterval)(curLevel.details, details, data.stats.trequest);
        _logger.logger.log('live playlist, reload in ' + Math.round(reloadInterval) + ' ms');
        this.timer = setTimeout(function () {
          return _this3.loadLevel();
        }, reloadInterval);
      } else {
        this.clearTimer();
      }
    }
  }, {
    key: 'onAudioTrackSwitched',
    value: function onAudioTrackSwitched(data) {
      var audioGroupId = this.hls.audioTracks[data.id].groupId;

      var currentLevel = this.hls.levels[this.currentLevelIndex];
      if (!currentLevel) {
        return;
      }

      if (currentLevel.audioGroupIds) {
        var urlId = -1;

        for (var i = 0; i < currentLevel.audioGroupIds.length; i++) {
          if (currentLevel.audioGroupIds[i] === audioGroupId) {
            urlId = i;
            break;
          }
        }

        if (urlId !== currentLevel.urlId) {
          currentLevel.urlId = urlId;
          this.startLoad();
        }
      }
    }
  }, {
    key: 'loadLevel',
    value: function loadLevel() {
      _logger.logger.debug('call to loadLevel');

      if (this.currentLevelIndex !== null && this.canload) {
        var levelObject = this._levels[this.currentLevelIndex];

        if ((typeof levelObject === 'undefined' ? 'undefined' : _typeof(levelObject)) === 'object' && levelObject.url.length > 0) {
          var level = this.currentLevelIndex;
          var id = levelObject.urlId;
          var url = levelObject.url[id];

          _logger.logger.log('Attempt loading level index ' + level + ' with URL-id ' + id);

          // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);
          // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);

          this.hls.trigger(_events2.default.LEVEL_LOADING, { url: url, level: level, id: id });
        }
      }
    }
  }, {
    key: 'levels',
    get: function get() {
      return this._levels;
    }
  }, {
    key: 'level',
    get: function get() {
      return this.currentLevelIndex;
    },
    set: function set(newLevel) {
      var levels = this._levels;
      if (levels) {
        newLevel = Math.min(newLevel, levels.length - 1);
        if (this.currentLevelIndex !== newLevel || !levels[newLevel].details) {
          this.setLevelInternal(newLevel);
        }
      }
    }
  }, {
    key: 'manualLevel',
    get: function get() {
      return this.manualLevelIndex;
    },
    set: function set(newLevel) {
      this.manualLevelIndex = newLevel;
      if (this._startLevel === undefined) {
        this._startLevel = newLevel;
      }

      if (newLevel !== -1) {
        this.level = newLevel;
      }
    }
  }, {
    key: 'firstLevel',
    get: function get() {
      return this._firstLevel;
    },
    set: function set(newLevel) {
      this._firstLevel = newLevel;
    }
  }, {
    key: 'startLevel',
    get: function get() {
      // hls.startLevel takes precedence over config.startLevel
      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)
      if (this._startLevel === undefined) {
        var configStartLevel = this.hls.config.startLevel;
        if (configStartLevel !== undefined) {
          return configStartLevel;
        } else {
          return this._firstLevel;
        }
      } else {
        return this._startLevel;
      }
    },
    set: function set(newLevel) {
      this._startLevel = newLevel;
    }
  }, {
    key: 'nextLoadLevel',
    get: function get() {
      if (this.manualLevelIndex !== -1) {
        return this.manualLevelIndex;
      } else {
        return this.hls.nextAutoLevel;
      }
    },
    set: function set(nextLevel) {
      this.level = nextLevel;
      if (this.manualLevelIndex === -1) {
        this.hls.nextAutoLevel = nextLevel;
      }
    }
  }]);

  return LevelController;
}(_eventHandler2.default);

exports.default = LevelController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/level-helper.js":
/*!***********************************************!*\
  !*** ./src/hls.js/controller/level-helper.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addGroupId = addGroupId;
exports.updatePTS = updatePTS;
exports.updateFragPTSDTS = updateFragPTSDTS;
exports.mergeDetails = mergeDetails;
exports.mergeSubtitlePlaylists = mergeSubtitlePlaylists;
exports.mapFragmentIntersection = mapFragmentIntersection;
exports.adjustSliding = adjustSliding;
exports.computeReloadInterval = computeReloadInterval;

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function addGroupId(level, type, id) {
  switch (type) {
    case 'audio':
      if (!level.audioGroupIds) {
        level.audioGroupIds = [];
      }
      level.audioGroupIds.push(id);
      break;
    case 'text':
      if (!level.textGroupIds) {
        level.textGroupIds = [];
      }
      level.textGroupIds.push(id);
      break;
  }
} /**
   * @module LevelHelper
   *
   * Providing methods dealing with playlist sliding and drift
   *
   * TODO: Create an actual `Level` class/model that deals with all this logic in an object-oriented-manner.
   *
   * */

function updatePTS(fragments, fromIdx, toIdx) {
  var fragFrom = fragments[fromIdx],
      fragTo = fragments[toIdx],
      fragToPTS = fragTo.startPTS;
  // if we know startPTS[toIdx]
  if (Number.isFinite(fragToPTS)) {
    // update fragment duration.
    // it helps to fix drifts between playlist reported duration and fragment real duration
    if (toIdx > fromIdx) {
      fragFrom.duration = fragToPTS - fragFrom.start;
      if (fragFrom.duration < 0) {
        _logger.logger.warn('negative duration computed for frag ' + fragFrom.sn + ',level ' + fragFrom.levels + ', there should be some duration drift between playlist and fragment!');
      }
    } else {
      fragTo.duration = fragFrom.start - fragToPTS;
      if (fragTo.duration < 0) {
        _logger.logger.warn('negative duration computed for frag ' + fragTo.sn + ',level ' + fragTo.levels + ', there should be some duration drift between playlist and fragment!');
      }
    }
  } else {
    // we dont know startPTS[toIdx]
    if (toIdx > fromIdx) {
      fragTo.start = fragFrom.start + fragFrom.duration;
    } else {
      fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
    }
  }
}

function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
  // update frag PTS/DTS
  var maxStartPTS = startPTS;
  if (Number.isFinite(frag.startPTS)) {
    // delta PTS between audio and video
    var deltaPTS = Math.abs(frag.startPTS - startPTS);
    if (!Number.isFinite(frag.deltaPTS)) {
      frag.deltaPTS = deltaPTS;
    } else {
      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
    }

    maxStartPTS = Math.max(startPTS, frag.startPTS);
    startPTS = Math.min(startPTS, frag.startPTS);
    endPTS = Math.max(endPTS, frag.endPTS);
    startDTS = Math.min(startDTS, frag.startDTS);
    endDTS = Math.max(endDTS, frag.endDTS);
  }

  var drift = startPTS - frag.start;
  frag.start = frag.startPTS = startPTS;
  frag.maxStartPTS = maxStartPTS;
  frag.endPTS = endPTS;
  frag.startDTS = startDTS;
  frag.endDTS = endDTS;
  frag.duration = endPTS - startPTS;

  var sn = frag.sn;
  // exit if sn out of range
  if (!details || sn < details.startSN || sn > details.endSN) {
    return 0;
  }

  var fragIdx = void 0,
      fragments = void 0,
      i = void 0;
  fragIdx = sn - details.startSN;
  fragments = details.fragments;
  // update frag reference in fragments array
  // rationale is that fragments array might not contain this frag object.
  // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()
  // if we don't update frag, we won't be able to propagate PTS info on the playlist
  // resulting in invalid sliding computation
  fragments[fragIdx] = frag;
  // adjust fragment PTS/duration from seqnum-1 to frag 0
  for (i = fragIdx; i > 0; i--) {
    updatePTS(fragments, i, i - 1);
  }

  // adjust fragment PTS/duration from seqnum to last frag
  for (i = fragIdx; i < fragments.length - 1; i++) {
    updatePTS(fragments, i, i + 1);
  }

  details.PTSKnown = true;
  return drift;
}

function mergeDetails(oldDetails, newDetails) {
  // potentially retrieve cached initsegment
  if (newDetails.initSegment && oldDetails.initSegment) {
    newDetails.initSegment = oldDetails.initSegment;
  }

  // check if old/new playlists have fragments in common
  // loop through overlapping SN and update startPTS , cc, and duration if any found
  var ccOffset = 0;
  var PTSFrag = void 0;
  mapFragmentIntersection(oldDetails, newDetails, function (oldFrag, newFrag) {
    ccOffset = oldFrag.cc - newFrag.cc;
    if (Number.isFinite(oldFrag.startPTS)) {
      newFrag.start = newFrag.startPTS = oldFrag.startPTS;
      newFrag.endPTS = oldFrag.endPTS;
      newFrag.duration = oldFrag.duration;
      newFrag.backtracked = oldFrag.backtracked;
      newFrag.dropped = oldFrag.dropped;
      PTSFrag = newFrag;
    }
    // PTS is known when there are overlapping segments
    newDetails.PTSKnown = true;
  });

  if (!newDetails.PTSKnown) {
    return;
  }

  if (ccOffset) {
    _logger.logger.log('discontinuity sliding from playlist, take drift into account');
    var newFragments = newDetails.fragments;
    for (var i = 0; i < newFragments.length; i++) {
      newFragments[i].cc += ccOffset;
    }
  }

  // if at least one fragment contains PTS info, recompute PTS information for all fragments
  if (PTSFrag) {
    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
  } else {
    // ensure that delta is within oldFragments range
    // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
    // in that case we also need to adjust start offset of all fragments
    adjustSliding(oldDetails, newDetails);
  }
  // if we are here, it means we have fragments overlapping between
  // old and new level. reliable PTS info is thus relying on old level
  newDetails.PTSKnown = oldDetails.PTSKnown;
}

function mergeSubtitlePlaylists(oldPlaylist, newPlaylist) {
  var referenceStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var lastIndex = -1;
  mapFragmentIntersection(oldPlaylist, newPlaylist, function (oldFrag, newFrag, index) {
    newFrag.start = oldFrag.start;
    lastIndex = index;
  });

  var frags = newPlaylist.fragments;
  if (lastIndex < 0) {
    frags.forEach(function (frag) {
      frag.start += referenceStart;
    });
    return;
  }

  for (var i = lastIndex + 1; i < frags.length; i++) {
    frags[i].start = frags[i - 1].start + frags[i - 1].duration;
  }
}

function mapFragmentIntersection(oldPlaylist, newPlaylist, intersectionFn) {
  if (!oldPlaylist || !newPlaylist) {
    return;
  }

  var start = Math.max(oldPlaylist.startSN, newPlaylist.startSN) - newPlaylist.startSN;
  var end = Math.min(oldPlaylist.endSN, newPlaylist.endSN) - newPlaylist.startSN;
  var delta = newPlaylist.startSN - oldPlaylist.startSN;

  for (var i = start; i <= end; i++) {
    var oldFrag = oldPlaylist.fragments[delta + i];
    var newFrag = newPlaylist.fragments[i];
    if (!oldFrag || !newFrag) {
      break;
    }
    intersectionFn(oldFrag, newFrag, i);
  }
}

function adjustSliding(oldPlaylist, newPlaylist) {
  var delta = newPlaylist.startSN - oldPlaylist.startSN;
  var oldFragments = oldPlaylist.fragments;
  var newFragments = newPlaylist.fragments;

  if (delta < 0 || delta > oldFragments.length) {
    return;
  }
  for (var i = 0; i < newFragments.length; i++) {
    newFragments[i].start += oldFragments[delta].start;
  }
}

function computeReloadInterval(currentPlaylist, newPlaylist, lastRequestTime) {
  var reloadInterval = 1000 * (newPlaylist.averagetargetduration ? newPlaylist.averagetargetduration : newPlaylist.targetduration);
  var minReloadInterval = reloadInterval / 2;
  if (currentPlaylist && newPlaylist.endSN === currentPlaylist.endSN) {
    // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
    // changed then it MUST wait for a period of one-half the target
    // duration before retrying.
    reloadInterval = minReloadInterval;
  }

  if (lastRequestTime) {
    reloadInterval = Math.max(minReloadInterval, reloadInterval - (window.performance.now() - lastRequestTime));
  }
  // in any case, don't reload more than half of target duration
  return Math.round(reloadInterval);
}

/***/ }),

/***/ "./src/hls.js/controller/stream-controller.js":
/*!****************************************************!*\
  !*** ./src/hls.js/controller/stream-controller.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _binarySearch = __webpack_require__(/*! ../utils/binary-search */ "./src/hls.js/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _demuxer = __webpack_require__(/*! ../demux/demuxer */ "./src/hls.js/demux/demuxer.js");

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _fragmentTracker = __webpack_require__(/*! ./fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _fragment = __webpack_require__(/*! ../loader/fragment */ "./src/hls.js/loader/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _playlistLoader = __webpack_require__(/*! ../loader/playlist-loader */ "./src/hls.js/loader/playlist-loader.js");

var _playlistLoader2 = _interopRequireDefault(_playlistLoader);

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

var LevelHelper = _interopRequireWildcard(_levelHelper);

var _timeRanges = __webpack_require__(/*! ../utils/time-ranges */ "./src/hls.js/utils/time-ranges.js");

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _discontinuities = __webpack_require__(/*! ../utils/discontinuities */ "./src/hls.js/utils/discontinuities.js");

var _fragmentFinders = __webpack_require__(/*! ./fragment-finders */ "./src/hls.js/controller/fragment-finders.js");

var _gapController = __webpack_require__(/*! ./gap-controller */ "./src/hls.js/controller/gap-controller.js");

var _gapController2 = _interopRequireDefault(_gapController);

var _baseStreamController = __webpack_require__(/*! ./base-stream-controller */ "./src/hls.js/controller/base-stream-controller.js");

var _baseStreamController2 = _interopRequireDefault(_baseStreamController);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var TICK_INTERVAL = 100; // how often to tick in ms

var StreamController = function (_BaseStreamController) {
  _inherits(StreamController, _BaseStreamController);

  function StreamController(hls, fragmentTracker) {
    _classCallCheck(this, StreamController);

    var _this = _possibleConstructorReturn(this, (StreamController.__proto__ || Object.getPrototypeOf(StreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.LEVEL_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_LOAD_EMERGENCY_ABORTED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED));

    _this.fragmentTracker = fragmentTracker;
    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this._state = _baseStreamController.State.STOPPED;
    _this.stallReported = false;
    _this.gapController = null;
    return _this;
  }

  _createClass(StreamController, [{
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.levels) {
        var lastCurrentTime = this.lastCurrentTime,
            hls = this.hls;
        this.stopLoad();
        this.setInterval(TICK_INTERVAL);
        this.level = -1;
        this.fragLoadError = 0;
        if (!this.startFragRequested) {
          // determine load level
          var startLevel = hls.startLevel;
          if (startLevel === -1) {
            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
            startLevel = 0;
            this.bitrateTest = true;
          }
          // set new level to playlist loader : this will trigger start level load
          // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
          this.level = hls.nextLoadLevel = startLevel;
          this.loadedmetadata = false;
        }
        // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime
        if (lastCurrentTime > 0 && startPosition === -1) {
          _logger.logger.log('override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
          startPosition = lastCurrentTime;
        }
        this.state = _baseStreamController.State.IDLE;
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
        this.tick();
      } else {
        this.forceStartLoad = true;
        this.state = _baseStreamController.State.STOPPED;
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.forceStartLoad = false;
      _get(StreamController.prototype.__proto__ || Object.getPrototypeOf(StreamController.prototype), 'stopLoad', this).call(this);
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      switch (this.state) {
        case _baseStreamController.State.BUFFER_FLUSHING:
          // in buffer flushing state, reset fragLoadError counter
          this.fragLoadError = 0;
          break;
        case _baseStreamController.State.IDLE:
          this._doTickIdle();
          break;
        case _baseStreamController.State.WAITING_LEVEL:
          var level = this.levels[this.level];
          // check if playlist is already loaded
          if (level && level.details) {
            this.state = _baseStreamController.State.IDLE;
          }

          break;
        case _baseStreamController.State.FRAG_LOADING_WAITING_RETRY:
          var now = window.performance.now();
          var retryDate = this.retryDate;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || this.media && this.media.seeking) {
            _logger.logger.log('mediaController: retryDate reached, switch back to IDLE state');
            this.state = _baseStreamController.State.IDLE;
          }
          break;
        case _baseStreamController.State.ERROR:
        case _baseStreamController.State.STOPPED:
        case _baseStreamController.State.FRAG_LOADING:
        case _baseStreamController.State.PARSING:
        case _baseStreamController.State.PARSED:
        case _baseStreamController.State.ENDED:
          break;
        default:
          break;
      }
      // check buffer
      this._checkBuffer();
      // check/update current fragment
      this._checkFragmentChanged();
    }

    // Ironically the "idle" state is the on we do the most logic in it seems ....
    // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
    //       played segment, or on pause/play/seek instead of naively checking every 100ms?

  }, {
    key: '_doTickIdle',
    value: function _doTickIdle() {
      var hls = this.hls,
          config = hls.config,
          media = this.media;

      // if start level not parsed yet OR
      // if video not attached AND start fragment already requested OR start frag prefetch disable
      // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment
      if (this.levelLastLoaded === undefined || !media && (this.startFragRequested || !config.startFragPrefetch)) {
        return;
      }

      // if we have not yet loaded any fragment, start loading from start position
      var pos = void 0;
      if (this.loadedmetadata) {
        pos = media.currentTime;
      } else {
        pos = this.nextLoadPosition;
      }

      // determine next load level
      var level = hls.nextLoadLevel,
          levelInfo = this.levels[level];

      if (!levelInfo) {
        return;
      }

      var levelBitrate = levelInfo.bitrate,
          maxBufLen = void 0;

      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
      if (levelBitrate) {
        maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
      } else {
        maxBufLen = config.maxBufferLength;
      }

      maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);

      // determine next candidate fragment to be loaded, based on current position and end of buffer position
      // ensure up to `config.maxMaxBufferLength` of buffer upfront

      var bufferInfo = _bufferHelper.BufferHelper.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole),
          bufferLen = bufferInfo.len;
      // Stay idle if we are still with buffer margins
      if (bufferLen >= maxBufLen) {
        return;
      }

      // if buffer length is less than maxBufLen try to load a new fragment ...
      _logger.logger.trace('buffer length of ' + bufferLen.toFixed(3) + ' is below max of ' + maxBufLen.toFixed(3) + '. checking for more payload ...');

      // set next load level : this will trigger a playlist load if needed
      this.level = hls.nextLoadLevel = level;

      var levelDetails = levelInfo.details;
      // if level info not retrieved yet, switch state and wait for level retrieval
      // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
      // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
      if (!levelDetails || levelDetails.live && this.levelLastLoaded !== level) {
        this.state = _baseStreamController.State.WAITING_LEVEL;
        return;
      }

      if (this._streamEnded(bufferInfo, levelDetails)) {
        var data = {};
        if (this.altAudio) {
          data.type = 'video';
        }

        this.hls.trigger(_events2.default.BUFFER_EOS, data);
        this.state = _baseStreamController.State.ENDED;
        return;
      }
      // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)
      this._fetchPayloadOrEos(pos, bufferInfo, levelDetails);
    }
  }, {
    key: '_fetchPayloadOrEos',
    value: function _fetchPayloadOrEos(pos, bufferInfo, levelDetails) {
      var fragPrevious = this.fragPrevious,
          level = this.level,
          fragments = levelDetails.fragments,
          fragLen = fragments.length;

      // empty playlist
      if (fragLen === 0) {
        return;
      }

      // find fragment index, contiguous with end of buffer position
      var start = fragments[0].start,
          end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
          bufferEnd = bufferInfo.end,
          frag = void 0;

      if (levelDetails.initSegment && !levelDetails.initSegment.data) {
        frag = levelDetails.initSegment;
      } else {
        // in case of live playlist we need to ensure that requested position is not located before playlist start
        if (levelDetails.live) {
          var initialLiveManifestSize = this.config.initialLiveManifestSize;
          if (fragLen < initialLiveManifestSize) {
            _logger.logger.warn('Can not start playback of a level, reason: not enough fragments ' + fragLen + ' < ' + initialLiveManifestSize);
            return;
          }

          frag = this._ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen);
          // if it explicitely returns null don't load any fragment and exit function now
          if (frag === null) {
            return;
          }
        } else {
          // VoD playlist: if bufferEnd before start of playlist, load first fragment
          if (bufferEnd < start) {
            frag = fragments[0];
          }
        }
      }
      if (!frag) {
        frag = this._findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails);
      }

      if (frag) {
        if (frag.encrypted) {
          _logger.logger.log('Loading key for ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level);
          this._loadKey(frag);
        } else {
          _logger.logger.log('Loading ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level + ', currentTime:' + pos.toFixed(3) + ',bufferEnd:' + bufferEnd.toFixed(3));
          this._loadFragment(frag);
        }
      }
    }
  }, {
    key: '_ensureFragmentAtLivePoint',
    value: function _ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen) {
      var config = this.hls.config,
          media = this.media;

      var frag = void 0;

      // check if requested position is within seekable boundaries :
      // logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);
      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;

      if (bufferEnd < Math.max(start - config.maxFragLookUpTolerance, end - maxLatency)) {
        var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);
        _logger.logger.log('buffer end: ' + bufferEnd.toFixed(3) + ' is located too far from the end of live sliding playlist, reset currentTime to : ' + liveSyncPosition.toFixed(3));
        bufferEnd = liveSyncPosition;
        if (media && media.readyState && media.duration > liveSyncPosition) {
          media.currentTime = liveSyncPosition;
        }

        this.nextLoadPosition = liveSyncPosition;
      }

      // if end of buffer greater than live edge, don't load any fragment
      // this could happen if live playlist intermittently slides in the past.
      // level 1 loaded [182580161,182580167]
      // level 1 loaded [182580162,182580169]
      // Loading 182580168 of [182580162 ,182580169],level 1 ..
      // Loading 182580169 of [182580162 ,182580169],level 1 ..
      // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
      // level 1 loaded [182580164,182580171]
      //
      // don't return null in case media not loaded yet (readystate === 0)
      if (levelDetails.PTSKnown && bufferEnd > end && media && media.readyState) {
        return null;
      }

      if (this.startFragRequested && !levelDetails.PTSKnown) {
        /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
           try to load frag matching with next SN.
           even if SN are not synchronized between playlists, loading this frag will help us
           compute playlist sliding and find the right one after in case it was not the right consecutive one */
        if (fragPrevious) {
          if (levelDetails.hasProgramDateTime) {
            // Relies on PDT in order to switch bitrates (Support EXT-X-DISCONTINUITY without EXT-X-DISCONTINUITY-SEQUENCE)
            _logger.logger.log('live playlist, switching playlist, load frag with same PDT: ' + fragPrevious.programDateTime);
            frag = (0, _fragmentFinders.findFragmentByPDT)(fragments, fragPrevious.endProgramDateTime, config.maxFragLookUpTolerance);
          } else {
            // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)
            var targetSN = fragPrevious.sn + 1;
            if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
              var fragNext = fragments[targetSN - levelDetails.startSN];
              if (fragPrevious.cc === fragNext.cc) {
                frag = fragNext;
                _logger.logger.log('live playlist, switching playlist, load frag with next SN: ' + frag.sn);
              }
            }
            // next frag SN not available (or not with same continuity counter)
            // look for a frag sharing the same CC
            if (!frag) {
              frag = _binarySearch2.default.search(fragments, function (frag) {
                return fragPrevious.cc - frag.cc;
              });
              if (frag) {
                _logger.logger.log('live playlist, switching playlist, load frag with same CC: ' + frag.sn);
              }
            }
          }
        }
        if (!frag) {
          /* we have no idea about which fragment should be loaded.
             so let's load mid fragment. it will help computing playlist sliding and find the right one
          */
          frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];
          _logger.logger.log('live playlist, switching playlist, unknown, load middle frag : ' + frag.sn);
        }
      }

      return frag;
    }
  }, {
    key: '_findFragment',
    value: function _findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails) {
      var config = this.hls.config;
      var frag = void 0;

      if (bufferEnd < end) {
        var lookupTolerance = bufferEnd > end - config.maxFragLookUpTolerance ? 0 : config.maxFragLookUpTolerance;
        // Remove the tolerance if it would put the bufferEnd past the actual end of stream
        // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)
        frag = (0, _fragmentFinders.findFragmentByPTS)(fragPrevious, fragments, bufferEnd, lookupTolerance);
      } else {
        // reach end of playlist
        frag = fragments[fragLen - 1];
      }
      if (frag) {
        var curSNIdx = frag.sn - levelDetails.startSN;
        var sameLevel = fragPrevious && frag.levels === fragPrevious.levels;
        var prevFrag = fragments[curSNIdx - 1];
        var nextFrag = fragments[curSNIdx + 1];
        // logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
        if (fragPrevious && frag.sn === fragPrevious.sn) {
          if (sameLevel && !frag.backtracked) {
            if (frag.sn < levelDetails.endSN) {
              var deltaPTS = fragPrevious.deltaPTS;
              // if there is a significant delta between audio and video, larger than max allowed hole,
              // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
              // let's try to load previous fragment again to get last keyframe
              // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)
              if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx) {
                frag = prevFrag;
                _logger.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');
              } else {
                frag = nextFrag;
                _logger.logger.log('SN just loaded, load next one: ' + frag.sn, frag);
              }
            } else {
              frag = null;
            }
          } else if (frag.backtracked) {
            // Only backtrack a max of 1 consecutive fragment to prevent sliding back too far when little or no frags start with keyframes
            if (nextFrag && nextFrag.backtracked) {
              _logger.logger.warn('Already backtracked from fragment ' + nextFrag.sn + ', will not backtrack to fragment ' + frag.sn + '. Loading fragment ' + nextFrag.sn);
              frag = nextFrag;
            } else {
              // If a fragment has dropped frames and it's in a same level/sequence, load the previous fragment to try and find the keyframe
              // Reset the dropped count now since it won't be reset until we parse the fragment again, which prevents infinite backtracking on the same segment
              _logger.logger.warn('Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe');
              frag.dropped = 0;
              if (prevFrag) {
                frag = prevFrag;
                frag.backtracked = true;
              } else if (curSNIdx) {
                // can't backtrack on very first fragment
                frag = null;
              }
            }
          }
        }
      }
      return frag;
    }
  }, {
    key: '_loadKey',
    value: function _loadKey(frag) {
      this.state = _baseStreamController.State.KEY_LOADING;
      this.hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
    }
  }, {
    key: '_loadFragment',
    value: function _loadFragment(frag) {
      // Check if fragment is not loaded
      var fragState = this.fragmentTracker.getState(frag);

      this.fragCurrent = frag;
      this.startFragRequested = true;
      // Don't update nextLoadPosition for fragments which are not buffered
      if (Number.isFinite(frag.sn) && !frag.bitrateTest) {
        this.nextLoadPosition = frag.start + frag.duration;
      }

      // Allow backtracked fragments to load
      if (frag.backtracked || fragState === _fragmentTracker.FragmentState.NOT_LOADED || fragState === _fragmentTracker.FragmentState.PARTIAL) {
        frag.autoLevel = this.hls.autoLevelEnabled;
        frag.bitrateTest = this.bitrateTest;

        this.hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
        // lazy demuxer init, as this could take some time ... do it during frag loading
        if (!this.demuxer) {
          this.demuxer = new _demuxer2.default(this.hls, 'main');
        }

        this.state = _baseStreamController.State.FRAG_LOADING;
      } else if (fragState === _fragmentTracker.FragmentState.APPENDING) {
        // Lower the buffer size and try again
        if (this._reduceMaxBufferLength(frag.duration)) {
          this.fragmentTracker.removeFragment(frag);
        }
      }
    }
  }, {
    key: 'getBufferedFrag',
    value: function getBufferedFrag(position) {
      return this.fragmentTracker.getBufferedFrag(position, _playlistLoader2.default.LevelType.MAIN);
    }
  }, {
    key: 'followingBufferedFrag',
    value: function followingBufferedFrag(frag) {
      if (frag) {
        // try to get range of next fragment (500ms after this range)
        return this.getBufferedFrag(frag.endPTS + 0.5);
      }
      return null;
    }
  }, {
    key: '_checkFragmentChanged',
    value: function _checkFragmentChanged() {
      var fragPlayingCurrent = void 0,
          currentTime = void 0,
          video = this.media;
      if (video && video.readyState && video.seeking === false) {
        currentTime = video.currentTime;
        /* if video element is in seeked state, currentTime can only increase.
          (assuming that playback rate is positive ...)
          As sometimes currentTime jumps back to zero after a
          media decode error, check this, to avoid seeking back to
          wrong position after a media decode error
        */
        if (currentTime > this.lastCurrentTime) {
          this.lastCurrentTime = currentTime;
        }

        if (_bufferHelper.BufferHelper.isBuffered(video, currentTime)) {
          fragPlayingCurrent = this.getBufferedFrag(currentTime);
        } else if (_bufferHelper.BufferHelper.isBuffered(video, currentTime + 0.1)) {
          /* ensure that FRAG_CHANGED event is triggered at startup,
            when first video frame is displayed and playback is paused.
            add a tolerance of 100ms, in case current position is not buffered,
            check if current pos+100ms is buffered and use that buffer range
            for FRAG_CHANGED event reporting */
          fragPlayingCurrent = this.getBufferedFrag(currentTime + 0.1);
        }
        if (fragPlayingCurrent) {
          var fragPlaying = fragPlayingCurrent;
          if (fragPlaying !== this.fragPlaying) {
            this.hls.trigger(_events2.default.FRAG_CHANGED, { frag: fragPlaying });
            var fragPlayingLevel = fragPlaying.levels;
            if (!this.fragPlaying || this.fragPlaying.levels !== fragPlayingLevel) {
              this.hls.trigger(_events2.default.LEVEL_SWITCHED, { level: fragPlayingLevel });
            }

            this.fragPlaying = fragPlaying;
          }
        }
      }
    }

    /*
      on immediate level switch :
       - pause playback if playing
       - cancel any pending load request
       - and trigger a buffer flush
    */

  }, {
    key: 'immediateLevelSwitch',
    value: function immediateLevelSwitch() {
      _logger.logger.log('immediateLevelSwitch');
      if (!this.immediateSwitch) {
        this.immediateSwitch = true;
        var media = this.media,
            previouslyPaused = void 0;
        if (media) {
          previouslyPaused = media.paused;
          media.pause();
        } else {
          // don't restart playback after instant level switch in case media not attached
          previouslyPaused = true;
        }
        this.previouslyPaused = previouslyPaused;
      }
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && fragCurrent.loader) {
        fragCurrent.loader.abort();
      }

      this.fragCurrent = null;
      // flush everything
      this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
    }

    /**
     * on immediate level switch end, after new fragment has been buffered:
     * - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
     * - resume the playback if needed
     */

  }, {
    key: 'immediateLevelSwitchEnd',
    value: function immediateLevelSwitchEnd() {
      var media = this.media;
      if (media && media.buffered.length) {
        this.immediateSwitch = false;
        if (_bufferHelper.BufferHelper.isBuffered(media, media.currentTime)) {
          // only nudge if currentTime is buffered
          media.currentTime -= 0.0001;
        }
        if (!this.previouslyPaused) {
          media.play();
        }
      }
    }

    /**
     * try to switch ASAP without breaking video playback:
     * in order to ensure smooth but quick level switching,
     * we need to find the next flushable buffer range
     * we should take into account new segment fetch time
     */

  }, {
    key: 'nextLevelSwitch',
    value: function nextLevelSwitch() {
      var media = this.media;
      // ensure that media is defined and that metadata are available (to retrieve currentTime)
      if (media && media.readyState) {
        var fetchdelay = void 0,
            fragPlayingCurrent = void 0,
            nextBufferedFrag = void 0;
        fragPlayingCurrent = this.getBufferedFrag(media.currentTime);
        if (fragPlayingCurrent && fragPlayingCurrent.startPTS > 1) {
          // flush buffer preceding current fragment (flush until current fragment start offset)
          // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
          this.flushMainBuffer(0, fragPlayingCurrent.startPTS - 1);
        }
        if (!media.paused) {
          // add a safety delay of 1s
          var nextLevelId = this.hls.nextLoadLevel,
              nextLevel = this.levels[nextLevelId],
              fragLastKbps = this.fragLastKbps;
          if (fragLastKbps && this.fragCurrent) {
            fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;
          } else {
            fetchdelay = 0;
          }
        } else {
          fetchdelay = 0;
        }
        // logger.log('fetchdelay:'+fetchdelay);
        // find buffer range that will be reached once new fragment will be fetched
        nextBufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
        if (nextBufferedFrag) {
          // we can flush buffer range following this one without stalling playback
          nextBufferedFrag = this.followingBufferedFrag(nextBufferedFrag);
          if (nextBufferedFrag) {
            // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
            var fragCurrent = this.fragCurrent;
            if (fragCurrent && fragCurrent.loader) {
              fragCurrent.loader.abort();
            }

            this.fragCurrent = null;
            // start flush position is the start PTS of next buffered frag.
            // we use frag.naxStartPTS which is max(audio startPTS, video startPTS).
            // in case there is a small PTS Delta between audio and video, using maxStartPTS avoids flushing last samples from current fragment
            this.flushMainBuffer(nextBufferedFrag.maxStartPTS, Number.POSITIVE_INFINITY);
          }
        }
      }
    }
  }, {
    key: 'flushMainBuffer',
    value: function flushMainBuffer(startOffset, endOffset) {
      this.state = _baseStreamController.State.BUFFER_FLUSHING;
      var flushScope = { startOffset: startOffset, endOffset: endOffset };
      // if alternate audio tracks are used, only flush video, otherwise flush everything
      if (this.altAudio) {
        flushScope.type = 'video';
      }

      this.hls.trigger(_events2.default.BUFFER_FLUSHING, flushScope);
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvseeked = this.onMediaSeeked.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('seeked', this.onvseeked);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.levels && config.autoStartLoad) {
        this.hls.startLoad(config.startPosition);
      }

      this.gapController = new _gapController2.default(config, media, this.fragmentTracker, this.hls);
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // reset fragment backtracked flag
      var levels = this.levels;
      if (levels) {
        levels.forEach(function (level) {
          if (level.details) {
            level.details.fragments.forEach(function (fragment) {
              fragment.backtracked = undefined;
            });
          }
        });
      }
      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('seeked', this.onvseeked);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = this.mediaBuffer = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onMediaSeeked',
    value: function onMediaSeeked() {
      var media = this.media,
          currentTime = media ? media.currentTime : undefined;
      if (Number.isFinite(currentTime)) {
        _logger.logger.log('media seeked to ' + currentTime.toFixed(3));
      }

      // tick to speed up FRAGMENT_PLAYING triggering
      this.tick();
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset buffer on manifest loading
      _logger.logger.log('trigger BUFFER_RESET');
      this.hls.trigger(_events2.default.BUFFER_RESET);
      this.fragmentTracker.removeAllFragments();
      this.stalled = false;
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var aac = false,
          heaac = false,
          codec = void 0;
      data.levels.forEach(function (level) {
        // detect if we have different kind of audio codecs used amongst playlists
        codec = level.audioCodec;
        if (codec) {
          if (codec.indexOf('mp4a.40.2') !== -1) {
            aac = true;
          }

          if (codec.indexOf('mp4a.40.5') !== -1) {
            heaac = true;
          }
        }
      });
      this.audioCodecSwitch = aac && heaac;
      if (this.audioCodecSwitch) {
        _logger.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
      }

      this.levels = data.levels;
      this.startFragRequested = false;
      var config = this.config;
      if (config.autoStartLoad || this.forceStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var newDetails = data.details;
      var newLevelId = data.levels;
      var lastLevel = this.levels[this.levelLastLoaded];
      var curLevel = this.levels[newLevelId];
      var duration = newDetails.totalduration;
      var sliding = 0;

      _logger.logger.log('level ' + newLevelId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);

      if (newDetails.live) {
        var curDetails = curLevel.details;
        if (curDetails && newDetails.fragments.length > 0) {
          // we already have details for that level, merge them
          LevelHelper.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown && Number.isFinite(sliding)) {
            _logger.logger.log('live playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live playlist - outdated PTS, unknown sliding');
            (0, _discontinuities.alignStream)(this.fragPrevious, lastLevel, newDetails);
          }
        } else {
          _logger.logger.log('live playlist - first load, unknown sliding');
          newDetails.PTSKnown = false;
          (0, _discontinuities.alignStream)(this.fragPrevious, lastLevel, newDetails);
        }
      } else {
        newDetails.PTSKnown = false;
      }
      // override level info
      curLevel.details = newDetails;
      this.levelLastLoaded = newLevelId;
      this.hls.trigger(_events2.default.LEVEL_UPDATED, { details: newDetails, level: newLevelId });

      if (this.startFragRequested === false) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1 || this.lastCurrentTime === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (Number.isFinite(startTimeOffset)) {
            if (startTimeOffset < 0) {
              _logger.logger.log('negative start time offset ' + startTimeOffset + ', count from end of last fragment');
              startTimeOffset = sliding + duration + startTimeOffset;
            }
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
            if (newDetails.live) {
              this.startPosition = this.computeLivePosition(sliding, newDetails);
              _logger.logger.log('configure startPosition to ' + this.startPosition);
            } else {
              this.startPosition = 0;
            }
          }
          this.lastCurrentTime = this.startPosition;
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment
      if (this.state === _baseStreamController.State.WAITING_LEVEL) {
        this.state = _baseStreamController.State.IDLE;
      }

      // trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === _baseStreamController.State.KEY_LOADING) {
        this.state = _baseStreamController.State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent,
          hls = this.hls,
          levels = this.levels,
          media = this.media;

      var fragLoaded = data.frag;
      if (this.state === _baseStreamController.State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'main' && fragLoaded.levels === fragCurrent.levels && fragLoaded.sn === fragCurrent.sn) {
        var stats = data.stats;
        var currentLevel = levels[fragCurrent.levels];
        var details = currentLevel.details;
        // reset frag bitrate test in any case after frag loaded event
        // if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0
        // then this means that we should be able to load a fragment at a higher quality level
        this.bitrateTest = false;
        this.stats = stats;

        _logger.logger.log('Loaded ' + fragCurrent.sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + fragCurrent.levels);
        if (fragLoaded.bitrateTest && hls.nextLoadLevel) {
          // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
          this.state = _baseStreamController.State.IDLE;
          this.startFragRequested = false;
          stats.tparsed = stats.tbuffered = window.performance.now();
          hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
          this.tick();
        } else if (fragLoaded.sn === 'initSegment') {
          this.state = _baseStreamController.State.IDLE;
          stats.tparsed = stats.tbuffered = window.performance.now();
          details.initSegment.data = data.payload;
          hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
          this.tick();
        } else {
          _logger.logger.log('Parsing ' + fragCurrent.sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + fragCurrent.levels + ', cc ' + fragCurrent.cc);
          this.state = _baseStreamController.State.PARSING;
          this.pendingBuffering = true;
          this.appended = false;

          // Bitrate test frags are not usually buffered so the fragment tracker ignores them. If Hls.js decides to buffer
          // it (and therefore ends up at this line), then the fragment tracker needs to be manually informed.
          if (fragLoaded.bitrateTest) {
            fragLoaded.bitrateTest = false;
            this.fragmentTracker.onFragLoaded({
              frag: fragLoaded
            });
          }

          // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live) and if media is not seeking (this is to overcome potential timestamp drifts between playlists and fragments)
          var accurateTimeOffset = !(media && media.seeking) && (details.PTSKnown || !details.live);
          var initSegmentData = details.initSegment ? details.initSegment.data : [];
          var audioCodec = this._getAudioCodec(currentLevel);

          // transmux the MPEG-TS data to ISO-BMFF segments
          var demuxer = this.demuxer = this.demuxer || new _demuxer2.default(this.hls, 'main');
          demuxer.push(data.payload, initSegmentData, audioCodec, currentLevel.videoCodec, fragCurrent, details.totalduration, accurateTimeOffset);
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;

      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.levels === fragCurrent.levels && this.state === _baseStreamController.State.PARSING) {
        var tracks = data.tracks,
            trackName = void 0,
            track = void 0;

        // if audio track is expected to come from audio stream controller, discard any coming from main
        if (tracks.audio && this.altAudio) {
          delete tracks.audio;
        }

        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          var audioCodec = this.levels[this.level].audioCodec,
              ua = navigator.userAgent.toLowerCase();
          if (audioCodec && this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec.indexOf('mp4a.40.5') !== -1) {
              audioCodec = 'mp4a.40.2';
            } else {
              audioCodec = 'mp4a.40.5';
            }
          }
          // in case AAC and HE-AAC audio codecs are signalled in manifest
          // force HE-AAC , as it seems that most browsers prefers that way,
          // except for mono streams OR on FF
          // these conditions might need to be reviewed ...
          if (this.audioCodecSwitch) {
            // don't force HE-AAC if mono stream
            if (track.metadata.channelCount !== 1 &&
            // don't force HE-AAC if firefox
            ua.indexOf('firefox') === -1) {
              audioCodec = 'mp4a.40.5';
            }
          }
          // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
          if (ua.indexOf('android') !== -1 && track.container !== 'audio/mpeg') {
            // Exclude mpeg audio
            audioCodec = 'mp4a.40.2';
            _logger.logger.log('Android: force audio codec to ' + audioCodec);
          }
          track.levelCodec = audioCodec;
          track.id = data.id;
        }
        track = tracks.video;
        if (track) {
          track.levelCodec = this.levels[this.level].videoCodec;
          track.id = data.id;
        }
        this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
        // loop through tracks that are going to be provided to bufferController
        for (trackName in tracks) {
          track = tracks[trackName];
          _logger.logger.log('main track:' + trackName + ',container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            this.appended = true;
            // arm pending Buffering flag before appending a segment
            this.pendingBuffering = true;
            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });
          }
        }
        // trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.levels === fragCurrent.levels && !(data.type === 'audio' && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
      this.state === _baseStreamController.State.PARSING) {
        var level = this.levels[this.level],
            frag = fragCurrent;
        if (!Number.isFinite(data.endPTS)) {
          data.endPTS = data.startPTS + fragCurrent.duration;
          data.endDTS = data.startDTS + fragCurrent.duration;
        }

        if (data.hasAudio === true) {
          frag.addElementaryStream(_fragment2.default.ElementaryStreamTypes.AUDIO);
        }

        if (data.hasVideo === true) {
          frag.addElementaryStream(_fragment2.default.ElementaryStreamTypes.VIDEO);
        }

        _logger.logger.log('Parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb + ',dropped:' + (data.dropped || 0));

        // Detect gaps in a fragment  and try to fix it by finding a keyframe in the previous fragment (see _findFragments)
        if (data.type === 'video') {
          frag.dropped = data.dropped;
          if (frag.dropped) {
            if (!frag.backtracked) {
              var levelDetails = level.details;
              if (levelDetails && frag.sn === levelDetails.startSN) {
                _logger.logger.warn('missing video frame(s) on first frag, appending with gap', frag.sn);
              } else {
                _logger.logger.warn('missing video frame(s), backtracking fragment', frag.sn);
                // Return back to the IDLE state without appending to buffer
                // Causes findFragments to backtrack a segment and find the keyframe
                // Audio fragments arriving before video sets the nextLoadPosition, causing _findFragments to skip the backtracked fragment
                this.fragmentTracker.removeFragment(frag);
                frag.backtracked = true;
                this.nextLoadPosition = data.startPTS;
                this.state = _baseStreamController.State.IDLE;
                this.fragPrevious = frag;
                this.tick();
                return;
              }
            } else {
              _logger.logger.warn('Already backtracked on this fragment, appending with the gap', frag.sn);
            }
          } else {
            // Only reset the backtracked flag if we've loaded the frag without any dropped frames
            frag.backtracked = false;
          }
        }

        var drift = LevelHelper.updateFragPTSDTS(level.details, frag, data.startPTS, data.endPTS, data.startDTS, data.endDTS),
            hls = this.hls;
        hls.trigger(_events2.default.LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift, type: data.type, start: data.startPTS, end: data.endPTS });
        // has remuxer dropped video frames located before first keyframe ?
        [data.data1, data.data2].forEach(function (buffer) {
          // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
          // in that case it is useless to append following segments
          if (buffer && buffer.length && _this2.state === _baseStreamController.State.PARSING) {
            _this2.appended = true;
            // arm pending Buffering flag before appending a segment
            _this2.pendingBuffering = true;
            hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });
          }
        });
        // trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.levels === fragCurrent.levels && this.state === _baseStreamController.State.PARSING) {
        this.stats.tparsed = window.performance.now();
        this.state = _baseStreamController.State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onAudioTrackSwitching',
    value: function onAudioTrackSwitching(data) {
      // if any URL found on new audio track, it is an alternate audio track
      var altAudio = !!data.url,
          trackId = data.id;
      // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
      // don't do anything if we switch to alt audio: audio stream controller is handling it.
      // we will just have to change buffer scheduling on audioTrackSwitched
      if (!altAudio) {
        if (this.mediaBuffer !== this.media) {
          _logger.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');
          this.mediaBuffer = this.media;
          var fragCurrent = this.fragCurrent;
          // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
          if (fragCurrent.loader) {
            _logger.logger.log('switching to main audio track, cancel main fragment load');
            fragCurrent.loader.abort();
          }
          this.fragCurrent = null;
          this.fragPrevious = null;
          // destroy demuxer to force init segment generation (following audio switch)
          if (this.demuxer) {
            this.demuxer.destroy();
            this.demuxer = null;
          }
          // switch to IDLE state to load new fragment
          this.state = _baseStreamController.State.IDLE;
        }
        var hls = this.hls;
        // switching to main audio, flush all audio and trigger track switched
        hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
        this.altAudio = false;
      }
    }
  }, {
    key: 'onAudioTrackSwitched',
    value: function onAudioTrackSwitched(data) {
      var trackId = data.id,
          altAudio = !!this.hls.audioTracks[trackId].url;
      if (altAudio) {
        var videoBuffer = this.videoBuffer;
        // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
        if (videoBuffer && this.mediaBuffer !== videoBuffer) {
          _logger.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');
          this.mediaBuffer = videoBuffer;
        }
      }
      this.altAudio = altAudio;
      this.tick();
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var tracks = data.tracks,
          mediaTrack = void 0,
          name = void 0,
          alternate = false;
      for (var type in tracks) {
        var track = tracks[type];
        if (track.id === 'main') {
          name = type;
          mediaTrack = track;
          // keep video source buffer reference
          if (type === 'video') {
            this.videoBuffer = tracks[type].buffer;
          }
        } else {
          alternate = true;
        }
      }
      if (alternate && mediaTrack) {
        _logger.logger.log('alternate track found, use ' + name + '.buffered to schedule main fragment loading');
        this.mediaBuffer = mediaTrack.buffer;
      } else {
        this.mediaBuffer = this.media;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'main') {
        var state = this.state;
        if (state === _baseStreamController.State.PARSING || state === _baseStreamController.State.PARSED) {
          // check if all buffers have been appended
          this.pendingBuffering = data.pending > 0;
          this._checkAppendedParsed();
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      // trigger handler right now
      if (this.state === _baseStreamController.State.PARSED && (!this.appended || !this.pendingBuffering)) {
        var frag = this.fragCurrent;
        if (frag) {
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('main buffered : ' + _timeRanges2.default.toString(media.buffered));
          this.fragPrevious = frag;
          var stats = this.stats;
          stats.tbuffered = window.performance.now();
          // we should get rid of this.fragLastKbps
          this.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });
          this.state = _baseStreamController.State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag || this.fragCurrent;
      // don't handle frag error not related to main fragment
      if (frag && frag.type !== 'main') {
        return;
      }

      // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
      var mediaBuffered = !!this.media && _bufferHelper.BufferHelper.isBuffered(this.media, this.media.currentTime) && _bufferHelper.BufferHelper.isBuffered(this.media, this.media.currentTime + 0.5);

      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          if (!data.fatal) {
            // keep retrying until the limit will be reached
            if (this.fragLoadError + 1 <= this.config.fragLoadingMaxRetry) {
              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
              var delay = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout);
              _logger.logger.warn('mediaController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = window.performance.now() + delay;
              // retry loading state
              // if loadedmetadata is not set, it means that we are emergency switch down on first frag
              // in that case, reset startFragRequested flag
              if (!this.loadedmetadata) {
                this.startFragRequested = false;
                this.nextLoadPosition = this.startPosition;
              }
              this.fragLoadError++;
              this.state = _baseStreamController.State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('mediaController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // switch error to fatal
              data.fatal = true;
              this.state = _baseStreamController.State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          if (this.state !== _baseStreamController.State.ERROR) {
            if (data.fatal) {
              // if fatal error, stop processing
              this.state = _baseStreamController.State.ERROR;
              _logger.logger.warn('streamController: ' + data.details + ',switch to ' + this.state + ' state ...');
            } else {
              // in case of non fatal error while loading level, if level controller is not retrying to load level , switch back to IDLE
              if (!data.levelRetry && this.state === _baseStreamController.State.WAITING_LEVEL) {
                this.state = _baseStreamController.State.IDLE;
              }
            }
          }
          break;
        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
          // if in appending state
          if (data.parent === 'main' && (this.state === _baseStreamController.State.PARSING || this.state === _baseStreamController.State.PARSED)) {
            // reduce max buf len if current position is buffered
            if (mediaBuffered) {
              this._reduceMaxBufferLength(this.config.maxBufferLength);
              this.state = _baseStreamController.State.IDLE;
            } else {
              // current position is not buffered, but browser is still complaining about buffer full error
              // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
              // in that case flush the whole buffer to recover
              _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush everything');
              this.fragCurrent = null;
              // flush everything
              this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
            }
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: '_reduceMaxBufferLength',
    value: function _reduceMaxBufferLength(minLength) {
      var config = this.config;
      if (config.maxMaxBufferLength >= minLength) {
        // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
        config.maxMaxBufferLength /= 2;
        _logger.logger.warn('main:reduce max buffer length to ' + config.maxMaxBufferLength + 's');
        return true;
      }
      return false;
    }

    /**
     * Checks the health of the buffer and attempts to resolve playback stalls.
     * @private
     */

  }, {
    key: '_checkBuffer',
    value: function _checkBuffer() {
      var media = this.media;

      if (!media || media.readyState === 0) {
        // Exit early if we don't have media or if the media hasn't bufferd anything yet (readyState 0)
        return;
      }

      var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;
      var buffered = mediaBuffer.buffered;

      if (!this.loadedmetadata && buffered.length) {
        this.loadedmetadata = true;
        this._seekToStartPos();
      } else if (this.immediateSwitch) {
        this.immediateLevelSwitchEnd();
      } else {
        this.gapController.poll(this.lastCurrentTime, buffered);
      }
    }
  }, {
    key: 'onFragLoadEmergencyAborted',
    value: function onFragLoadEmergencyAborted() {
      this.state = _baseStreamController.State.IDLE;
      // if loadedmetadata is not set, it means that we are emergency switch down on first frag
      // in that case, reset startFragRequested flag
      if (!this.loadedmetadata) {
        this.startFragRequested = false;
        this.nextLoadPosition = this.startPosition;
      }
      this.tick();
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      /* after successful buffer flushing, filter flushed fragments from bufferedFrags
        use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)
      */
      var media = this.mediaBuffer ? this.mediaBuffer : this.media;
      if (media) {
        // filter fragments potentially evicted from buffer. this is to avoid memleak on live streams
        this.fragmentTracker.detectEvictedFragments(_fragment2.default.ElementaryStreamTypes.VIDEO, media.buffered);
      }
      // move to IDLE once flush complete. this should trigger new fragment loading
      this.state = _baseStreamController.State.IDLE;
      // reset reference to frag
      this.fragPrevious = null;
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      this.audioCodecSwap = !this.audioCodecSwap;
    }
  }, {
    key: 'computeLivePosition',
    value: function computeLivePosition(sliding, levelDetails) {
      var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;
      return sliding + Math.max(0, levelDetails.totalduration - targetLatency);
    }

    /**
     * Seeks to the set startPosition if not equal to the mediaElement's current time.
     * @private
     */

  }, {
    key: '_seekToStartPos',
    value: function _seekToStartPos() {
      var media = this.media;

      var currentTime = media.currentTime;
      // only adjust currentTime if different from startPosition or if startPosition not buffered
      // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
      var startPosition = media.seeking ? currentTime : this.startPosition;
      // if currentTime not matching with expected startPosition or startPosition not buffered but close to first buffered
      if (currentTime !== startPosition) {
        // if startPosition not buffered, let's seek to buffered.start(0)
        _logger.logger.log('target start position not buffered, seek to buffered.start(0) ' + startPosition + ' from current time ' + currentTime + ' ');
        media.currentTime = startPosition;
      }
    }
  }, {
    key: '_getAudioCodec',
    value: function _getAudioCodec(currentLevel) {
      var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
      if (this.audioCodecSwap) {
        _logger.logger.log('swapping playlist audio codec');
        if (audioCodec) {
          if (audioCodec.indexOf('mp4a.40.5') !== -1) {
            audioCodec = 'mp4a.40.2';
          } else {
            audioCodec = 'mp4a.40.5';
          }
        }
      }

      return audioCodec;
    }
  }, {
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('main stream:' + previousState + '->' + nextState);
        this.hls.trigger(_events2.default.STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });
      }
    },
    get: function get() {
      return this._state;
    }
  }, {
    key: 'currentLevel',
    get: function get() {
      var media = this.media;
      if (media) {
        var frag = this.getBufferedFrag(media.currentTime);
        if (frag) {
          return frag.levels;
        }
      }
      return -1;
    }
  }, {
    key: 'nextBufferedFrag',
    get: function get() {
      var media = this.media;
      if (media) {
        // first get end range of current fragment
        return this.followingBufferedFrag(this.getBufferedFrag(media.currentTime));
      } else {
        return null;
      }
    }
  }, {
    key: 'nextLevel',
    get: function get() {
      var frag = this.nextBufferedFrag;
      if (frag) {
        return frag.levels;
      } else {
        return -1;
      }
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this._liveSyncPosition;
    },
    set: function set(value) {
      this._liveSyncPosition = value;
    }
  }]);

  return StreamController;
}(_baseStreamController2.default);

exports.default = StreamController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/subtitle-stream-controller.js":
/*!*************************************************************!*\
  !*** ./src/hls.js/controller/subtitle-stream-controller.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SubtitleStreamController = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _decrypter = __webpack_require__(/*! ../crypt/decrypter */ "./src/hls.js/crypt/decrypter.js");

var _decrypter2 = _interopRequireDefault(_decrypter);

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _fragmentFinders = __webpack_require__(/*! ./fragment-finders */ "./src/hls.js/controller/fragment-finders.js");

var _fragmentTracker = __webpack_require__(/*! ./fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _baseStreamController = __webpack_require__(/*! ./base-stream-controller */ "./src/hls.js/controller/base-stream-controller.js");

var _baseStreamController2 = _interopRequireDefault(_baseStreamController);

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @class SubtitleStreamController
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _window = window,
    performance = _window.performance;

var TICK_INTERVAL = 500; // how often to tick in ms

var SubtitleStreamController = exports.SubtitleStreamController = function (_BaseStreamController) {
  _inherits(SubtitleStreamController, _BaseStreamController);

  function SubtitleStreamController(hls, fragmentTracker) {
    _classCallCheck(this, SubtitleStreamController);

    var _this = _possibleConstructorReturn(this, (SubtitleStreamController.__proto__ || Object.getPrototypeOf(SubtitleStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.ERROR, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.SUBTITLE_TRACKS_UPDATED, _events2.default.SUBTITLE_TRACK_SWITCH, _events2.default.SUBTITLE_TRACK_LOADED, _events2.default.SUBTITLE_FRAG_PROCESSED, _events2.default.LEVEL_UPDATED));

    _this.fragmentTracker = fragmentTracker;
    _this.config = hls.config;
    _this.state = _baseStreamController.State.STOPPED;
    _this.tracks = [];
    _this.tracksBuffered = [];
    _this.currentTrackId = -1;
    _this.decrypter = new _decrypter2.default(hls, hls.config);
    // lastAVStart stores the time in seconds for the start time of a level load
    _this.lastAVStart = 0;
    _this._onMediaSeeking = _this.onMediaSeeking.bind(_this);
    return _this;
  }

  _createClass(SubtitleStreamController, [{
    key: 'onSubtitleFragProcessed',
    value: function onSubtitleFragProcessed(data) {
      var frag = data.frag,
          success = data.success;

      this.fragPrevious = frag;
      this.state = _baseStreamController.State.IDLE;
      if (!success) {
        return;
      }

      var buffered = this.tracksBuffered[this.currentTrackId];
      if (!buffered) {
        return;
      }

      // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo
      // so we can re-use the logic used to detect how much have been buffered
      var timeRange = void 0;
      var fragStart = frag.start;
      for (var i = 0; i < buffered.length; i++) {
        if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {
          timeRange = buffered[i];
          break;
        }
      }

      var fragEnd = frag.start + frag.duration;
      if (timeRange) {
        timeRange.end = fragEnd;
      } else {
        timeRange = {
          start: fragStart,
          end: fragEnd
        };
        buffered.push(timeRange);
      }
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(_ref) {
      var media = _ref.media;

      this.media = media;
      media.addEventListener('seeking', this._onMediaSeeking);
      this.state = _baseStreamController.State.IDLE;
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      this.media.removeEventListener('seeking', this._onMediaSeeking);
      this.media = null;
      this.state = _baseStreamController.State.STOPPED;
    }

    // If something goes wrong, proceed to next frag, if we were processing one.

  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle error not related to subtitle fragment
      if (!frag || frag.type !== 'subtitle') {
        return;
      }
      this.state = _baseStreamController.State.IDLE;
    }

    // Got all new subtitle tracks.

  }, {
    key: 'onSubtitleTracksUpdated',
    value: function onSubtitleTracksUpdated(data) {
      var _this2 = this;

      _logger.logger.log('subtitle tracks updated');
      this.tracksBuffered = [];
      this.tracks = data.subtitleTracks;
      this.tracks.forEach(function (track) {
        _this2.tracksBuffered[track.id] = [];
      });
    }
  }, {
    key: 'onSubtitleTrackSwitch',
    value: function onSubtitleTrackSwitch(data) {
      this.currentTrackId = data.id;

      if (!this.tracks || this.currentTrackId === -1) {
        this.clearInterval();
        return;
      }

      // Check if track has the necessary details to load fragments
      var currentTrack = this.tracks[this.currentTrackId];
      if (currentTrack && currentTrack.details) {
        this.setInterval(TICK_INTERVAL);
      }
    }

    // Got a new set of subtitle fragments.

  }, {
    key: 'onSubtitleTrackLoaded',
    value: function onSubtitleTrackLoaded(data) {
      var id = data.id,
          details = data.details;
      var currentTrackId = this.currentTrackId,
          tracks = this.tracks;

      var currentTrack = tracks[currentTrackId];
      if (id >= tracks.length || id !== currentTrackId || !currentTrack) {
        return;
      }

      if (details.live) {
        (0, _levelHelper.mergeSubtitlePlaylists)(currentTrack.details, details, this.lastAVStart);
      }
      currentTrack.details = details;
      this.setInterval(TICK_INTERVAL);
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === _baseStreamController.State.KEY_LOADING) {
        this.state = _baseStreamController.State.IDLE;
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent;
      var decryptData = data.frag.decryptdata;
      var fragLoaded = data.frag;
      var hls = this.hls;

      if (this.state === _baseStreamController.State.FRAG_LOADING && fragCurrent && data.frag.type === 'subtitle' && fragCurrent.sn === data.frag.sn) {
        // check to see if the payload needs to be decrypted
        if (data.payload.byteLength > 0 && decryptData && decryptData.key && decryptData.method === 'AES-128') {
          var startTime = performance.now();

          // decrypt the subtitles
          this.decrypter.decrypt(data.payload, decryptData.key.buffer, decryptData.iv.buffer, function (decryptedData) {
            var endTime = performance.now();
            hls.trigger(_events2.default.FRAG_DECRYPTED, { frag: fragLoaded, payload: decryptedData, stats: { tstart: startTime, tdecrypt: endTime } });
          });
        }
      }
    }
  }, {
    key: 'onLevelUpdated',
    value: function onLevelUpdated(_ref2) {
      var details = _ref2.details;

      var frags = details.fragments;
      this.lastAVStart = frags.length ? frags[0].start : 0;
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      if (!this.media) {
        this.state = _baseStreamController.State.IDLE;
        return;
      }

      switch (this.state) {
        case _baseStreamController.State.IDLE:
          {
            var config = this.config,
                currentTrackId = this.currentTrackId,
                fragmentTracker = this.fragmentTracker,
                media = this.media,
                tracks = this.tracks;

            if (!tracks || !tracks[currentTrackId] || !tracks[currentTrackId].details) {
              break;
            }

            var maxBufferHole = config.maxBufferHole,
                maxFragLookUpTolerance = config.maxFragLookUpTolerance;

            var maxConfigBuffer = Math.min(config.maxBufferLength, config.maxMaxBufferLength);
            var bufferedInfo = _bufferHelper.BufferHelper.bufferedInfo(this._getBuffered(), media.currentTime, maxBufferHole);
            var bufferEnd = bufferedInfo.end,
                bufferLen = bufferedInfo.len;


            var trackDetails = tracks[currentTrackId].details;
            var fragments = trackDetails.fragments;
            var fragLen = fragments.length;
            var end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration;

            if (bufferLen > maxConfigBuffer) {
              return;
            }

            var foundFrag = void 0;
            var fragPrevious = this.fragPrevious;
            if (bufferEnd < end) {
              if (fragPrevious && trackDetails.hasProgramDateTime) {
                foundFrag = (0, _fragmentFinders.findFragmentByPDT)(fragments, fragPrevious.endProgramDateTime, maxFragLookUpTolerance);
              }
              if (!foundFrag) {
                foundFrag = (0, _fragmentFinders.findFragmentByPTS)(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance);
              }
            } else {
              foundFrag = fragments[fragLen - 1];
            }

            if (foundFrag && foundFrag.encrypted) {
              _logger.logger.log('Loading key for ' + foundFrag.sn);
              this.state = _baseStreamController.State.KEY_LOADING;
              this.hls.trigger(_events2.default.KEY_LOADING, { frag: foundFrag });
            } else if (foundFrag && fragmentTracker.getState(foundFrag) === _fragmentTracker.FragmentState.NOT_LOADED) {
              // only load if fragment is not loaded
              this.fragCurrent = foundFrag;
              this.state = _baseStreamController.State.FRAG_LOADING;
              this.hls.trigger(_events2.default.FRAG_LOADING, { frag: foundFrag });
            }
          }
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.lastAVStart = 0;
      _get(SubtitleStreamController.prototype.__proto__ || Object.getPrototypeOf(SubtitleStreamController.prototype), 'stopLoad', this).call(this);
    }
  }, {
    key: '_getBuffered',
    value: function _getBuffered() {
      return this.tracksBuffered[this.currentTrackId] || [];
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      this.fragPrevious = null;
    }
  }]);

  return SubtitleStreamController;
}(_baseStreamController2.default);

/***/ }),

/***/ "./src/hls.js/controller/subtitle-track-controller.js":
/*!************************************************************!*\
  !*** ./src/hls.js/controller/subtitle-track-controller.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SubtitleTrackController = function (_EventHandler) {
  _inherits(SubtitleTrackController, _EventHandler);

  function SubtitleTrackController(hls) {
    _classCallCheck(this, SubtitleTrackController);

    var _this = _possibleConstructorReturn(this, (SubtitleTrackController.__proto__ || Object.getPrototypeOf(SubtitleTrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADED, _events2.default.SUBTITLE_TRACK_LOADED));

    _this.tracks = [];
    _this.trackId = -1;
    _this.media = null;
    _this.stopped = true;

    /**
     * @member {boolean} subtitleDisplay Enable/disable subtitle display rendering
     */
    _this.subtitleDisplay = true;
    return _this;
  }

  _createClass(SubtitleTrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Listen for subtitle track change, then extract the current track ID.

  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var _this2 = this;

      this.media = data.media;
      if (!this.media) {
        return;
      }

      if (this.queuedDefaultTrack) {
        this.subtitleTrack = this.queuedDefaultTrack;
        delete this.queuedDefaultTrack;
      }

      this.trackChangeListener = this._onTextTracksChanged.bind(this);

      this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);
      if (this.useTextTrackPolling) {
        this.subtitlePollingInterval = setInterval(function () {
          _this2.trackChangeListener();
        }, 500);
      } else {
        this.media.textTracks.addEventListener('change', this.trackChangeListener);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      if (!this.media) {
        return;
      }

      if (this.useTextTrackPolling) {
        clearInterval(this.subtitlePollingInterval);
      } else {
        this.media.textTracks.removeEventListener('change', this.trackChangeListener);
      }

      this.media = null;
    }

    // Fired whenever a new manifest is loaded.

  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this3 = this;

      var tracks = data.subtitles || [];
      this.tracks = tracks;
      this.hls.trigger(_events2.default.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: tracks });

      // loop through available subtitle tracks and autoselect default if needed
      // TODO: improve selection logic to handle forced, etc
      tracks.forEach(function (track) {
        if (track.default) {
          // setting this.subtitleTrack will trigger internal logic
          // if media has not been attached yet, it will fail
          // we keep a reference to the default track id
          // and we'll set subtitleTrack when onMediaAttached is triggered
          if (_this3.media) {
            _this3.subtitleTrack = track.id;
          } else {
            _this3.queuedDefaultTrack = track.id;
          }
        }
      });
    }
  }, {
    key: 'onSubtitleTrackLoaded',
    value: function onSubtitleTrackLoaded(data) {
      var _this4 = this;

      var id = data.id,
          details = data.details;
      var trackId = this.trackId,
          tracks = this.tracks;

      var currentTrack = tracks[trackId];
      if (id >= tracks.length || id !== trackId || !currentTrack || this.stopped) {
        this._clearReloadTimer();
        return;
      }

      _logger.logger.log('subtitle track ' + id + ' loaded');
      if (details.live) {
        var reloadInterval = (0, _levelHelper.computeReloadInterval)(currentTrack.details, details, data.stats.trequest);
        _logger.logger.log('Reloading live subtitle playlist in ' + reloadInterval + 'ms');
        this.timer = setTimeout(function () {
          _this4._loadCurrentTrack();
        }, reloadInterval);
      } else {
        this._clearReloadTimer();
      }
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      this.stopped = false;
      this._loadCurrentTrack();
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.stopped = true;
      this._clearReloadTimer();
    }

    /** get alternate subtitle tracks list from playlist **/

  }, {
    key: '_clearReloadTimer',
    value: function _clearReloadTimer() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    }
  }, {
    key: '_loadCurrentTrack',
    value: function _loadCurrentTrack() {
      var trackId = this.trackId,
          tracks = this.tracks,
          hls = this.hls;

      var currentTrack = tracks[trackId];
      if (trackId < 0 || !currentTrack || currentTrack.details && !currentTrack.details.live) {
        return;
      }
      _logger.logger.log('Loading subtitle track ' + trackId);
      hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: currentTrack.url, id: trackId });
    }

    /**
     * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.
     * This operates on the DOM textTracks.
     * A value of -1 will disable all subtitle tracks.
     * @param newId - The id of the next track to enable
     * @private
     */

  }, {
    key: '_toggleTrackModes',
    value: function _toggleTrackModes(newId) {
      var media = this.media,
          subtitleDisplay = this.subtitleDisplay,
          trackId = this.trackId;

      if (!media) {
        return;
      }

      var textTracks = filterSubtitleTracks(media.textTracks);
      if (newId === -1) {
        [].slice.call(textTracks).forEach(function (track) {
          track.mode = 'disabled';
        });
      } else {
        var oldTrack = textTracks[trackId];
        if (oldTrack) {
          oldTrack.mode = 'disabled';
        }
      }

      var nextTrack = textTracks[newId];
      if (nextTrack) {
        nextTrack.mode = subtitleDisplay ? 'showing' : 'hidden';
      }
    }

    /**
       * This method is responsible for validating the subtitle index and periodically reloading if live.
       * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.
       * @param newId - The id of the subtitle track to activate.
       */

  }, {
    key: '_setSubtitleTrackInternal',
    value: function _setSubtitleTrackInternal(newId) {
      var hls = this.hls,
          tracks = this.tracks;

      if (!Number.isFinite(newId) || newId < -1 || newId >= tracks.length) {
        return;
      }

      this.trackId = newId;
      _logger.logger.log('Switching to subtitle track ' + newId);
      hls.trigger(_events2.default.SUBTITLE_TRACK_SWITCH, { id: newId });
      this._loadCurrentTrack();
    }
  }, {
    key: '_onTextTracksChanged',
    value: function _onTextTracksChanged() {
      // Media is undefined when switching streams via loadSource()
      if (!this.media) {
        return;
      }

      var trackId = -1;
      var tracks = filterSubtitleTracks(this.media.textTracks);
      for (var id = 0; id < tracks.length; id++) {
        if (tracks[id].mode === 'hidden') {
          // Do not break in case there is a following track with showing.
          trackId = id;
        } else if (tracks[id].mode === 'showing') {
          trackId = id;
          break;
        }
      }

      // Setting current subtitleTrack will invoke code.
      this.subtitleTrack = trackId;
    }
  }, {
    key: 'subtitleTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected subtitle track (index in subtitle track lists) **/

  }, {
    key: 'subtitleTrack',
    get: function get() {
      return this.trackId;
    }

    /** select a subtitle track, based on its index in subtitle track lists**/
    ,
    set: function set(subtitleTrackId) {
      if (this.trackId !== subtitleTrackId) {
        this._toggleTrackModes(subtitleTrackId);
        this._setSubtitleTrackInternal(subtitleTrackId);
      }
    }
  }]);

  return SubtitleTrackController;
}(_eventHandler2.default);

function filterSubtitleTracks(textTrackList) {
  var tracks = [];
  for (var i = 0; i < textTrackList.length; i++) {
    var track = textTrackList[i];
    // Edge adds a track without a label; we don't want to use it
    if (track.kind === 'subtitles' && track.label) {
      tracks.push(textTrackList[i]);
    }
  }
  return tracks;
}

exports.default = SubtitleTrackController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/timeline-controller.js":
/*!******************************************************!*\
  !*** ./src/hls.js/controller/timeline-controller.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _cea608Parser = __webpack_require__(/*! ../utils/cea-608-parser */ "./src/hls.js/utils/cea-608-parser.js");

var _cea608Parser2 = _interopRequireDefault(_cea608Parser);

var _outputFilter = __webpack_require__(/*! ../utils/output-filter */ "./src/hls.js/utils/output-filter.js");

var _outputFilter2 = _interopRequireDefault(_outputFilter);

var _webvttParser = __webpack_require__(/*! ../utils/webvtt-parser */ "./src/hls.js/utils/webvtt-parser.js");

var _webvttParser2 = _interopRequireDefault(_webvttParser);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _texttrackUtils = __webpack_require__(/*! ../utils/texttrack-utils */ "./src/hls.js/utils/texttrack-utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Timeline Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

function canReuseVttTextTrack(inUseTrack, manifestTrack) {
  return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
}

function intersection(x1, x2, y1, y2) {
  return Math.min(x2, y2) - Math.max(x1, y1);
}

var TimelineController = function (_EventHandler) {
  _inherits(TimelineController, _EventHandler);

  function TimelineController(hls) {
    _classCallCheck(this, TimelineController);

    var _this = _possibleConstructorReturn(this, (TimelineController.__proto__ || Object.getPrototypeOf(TimelineController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_USERDATA, _events2.default.FRAG_DECRYPTED, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.FRAG_LOADED, _events2.default.LEVEL_SWITCHING, _events2.default.INIT_PTS_FOUND));

    _this.hls = hls;
    _this.config = hls.config;
    _this.enabled = true;
    _this.Cues = hls.config.cueHandler;
    _this.textTracks = [];
    _this.tracks = [];
    _this.unparsedVttFrags = [];
    _this.initPTS = [];
    _this.cueRanges = [];
    _this.captionsTracks = {};

    _this.captionsProperties = {
      textTrack1: {
        label: _this.config.captionsTextTrack1Label,
        languageCode: _this.config.captionsTextTrack1LanguageCode
      },
      textTrack2: {
        label: _this.config.captionsTextTrack2Label,
        languageCode: _this.config.captionsTextTrack2LanguageCode
      }
    };

    if (_this.config.enableCEA708Captions) {
      var channel1 = new _outputFilter2.default(_this, 'textTrack1');
      var channel2 = new _outputFilter2.default(_this, 'textTrack2');

      _this.cea608Parser = new _cea608Parser2.default(0, channel1, channel2);
    }
    return _this;
  }

  _createClass(TimelineController, [{
    key: 'addCues',
    value: function addCues(trackName, startTime, endTime, screen) {
      // skip cues which overlap more than 50% with previously parsed time ranges
      var ranges = this.cueRanges;
      var merged = false;
      for (var i = ranges.length; i--;) {
        var cueRange = ranges[i];
        var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
        if (overlap >= 0) {
          cueRange[0] = Math.min(cueRange[0], startTime);
          cueRange[1] = Math.max(cueRange[1], endTime);
          merged = true;
          if (overlap / (endTime - startTime) > 0.5) {
            return;
          }
        }
      }
      if (!merged) {
        ranges.push([startTime, endTime]);
      }

      this.Cues.newCue(this.captionsTracks[trackName], startTime, endTime, screen);
    }

    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.

  }, {
    key: 'onInitPtsFound',
    value: function onInitPtsFound(data) {
      var _this2 = this;

      if (data.id === 'main') {
        this.initPTS[data.frag.cc] = data.initPTS;
      }

      // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.
      // Parse any unparsed fragments upon receiving the initial PTS.
      if (this.unparsedVttFrags.length) {
        var unparsedVttFrags = this.unparsedVttFrags;
        this.unparsedVttFrags = [];
        unparsedVttFrags.forEach(function (frag) {
          _this2.onFragLoaded(frag);
        });
      }
    }
  }, {
    key: 'getExistingTrack',
    value: function getExistingTrack(trackName) {
      var media = this.media;

      if (media) {
        for (var i = 0; i < media.textTracks.length; i++) {
          var textTrack = media.textTracks[i];
          if (textTrack[trackName]) {
            return textTrack;
          }
        }
      }
      return null;
    }
  }, {
    key: 'createCaptionsTrack',
    value: function createCaptionsTrack(trackName) {
      var _captionsProperties$t = this.captionsProperties[trackName],
          label = _captionsProperties$t.label,
          languageCode = _captionsProperties$t.languageCode;

      var captionsTracks = this.captionsTracks;
      if (!captionsTracks[trackName]) {
        // Enable reuse of existing text track.
        var existingTrack = this.getExistingTrack(trackName);
        if (!existingTrack) {
          var textTrack = this.createTextTrack('captions', label, languageCode);
          if (textTrack) {
            // Set a special property on the track so we know it's managed by Hls.js
            textTrack[trackName] = true;
            captionsTracks[trackName] = textTrack;
          }
        } else {
          captionsTracks[trackName] = existingTrack;
          (0, _texttrackUtils.clearCurrentCues)(captionsTracks[trackName]);
          (0, _texttrackUtils.sendAddTrackEvent)(captionsTracks[trackName], this.media);
        }
      }
    }
  }, {
    key: 'createTextTrack',
    value: function createTextTrack(kind, label, lang) {
      var media = this.media;
      if (media) {
        return media.addTextTrack(kind, label, lang);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media;
      this._cleanTracks();
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var captionsTracks = this.captionsTracks;

      Object.keys(captionsTracks).forEach(function (trackName) {
        (0, _texttrackUtils.clearCurrentCues)(captionsTracks[trackName]);
        delete captionsTracks[trackName];
      });
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.lastSn = -1; // Detect discontiguity in fragment parsing
      this.prevCC = -1;
      this.vttCCs = { // Detect discontinuity in subtitle manifests
        ccOffset: 0,
        presentationOffset: 0,
        0: {
          start: 0, prevCC: -1, new: false
        }
      };
      this._cleanTracks();
    }
  }, {
    key: '_cleanTracks',
    value: function _cleanTracks() {
      // clear outdated subtitles
      var media = this.media;
      if (media) {
        var textTracks = media.textTracks;
        if (textTracks) {
          for (var i = 0; i < textTracks.length; i++) {
            (0, _texttrackUtils.clearCurrentCues)(textTracks[i]);
          }
        }
      }
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this3 = this;

      this.textTracks = [];
      this.unparsedVttFrags = this.unparsedVttFrags || [];
      this.initPTS = [];
      this.cueRanges = [];

      if (this.config.enableWebVTT) {
        this.tracks = data.subtitles || [];
        var inUseTracks = this.media ? this.media.textTracks : [];

        this.tracks.forEach(function (track, index) {
          var textTrack = void 0;
          if (index < inUseTracks.length) {
            var inUseTrack = null;

            for (var i = 0; i < inUseTracks.length; i++) {
              if (canReuseVttTextTrack(inUseTracks[i], track)) {
                inUseTrack = inUseTracks[i];
                break;
              }
            }

            // Reuse tracks with the same label, but do not reuse 608/708 tracks
            if (inUseTrack) {
              textTrack = inUseTrack;
            }
          }
          if (!textTrack) {
            textTrack = _this3.createTextTrack('subtitles', track.name, track.lang);
          }

          if (track.default) {
            textTrack.mode = _this3.hls.subtitleDisplay ? 'showing' : 'hidden';
          } else {
            textTrack.mode = 'disabled';
          }

          _this3.textTracks.push(textTrack);
        });
      }
    }
  }, {
    key: 'onLevelSwitching',
    value: function onLevelSwitching() {
      this.enabled = this.hls.currentLevel.closedCaptions !== 'NONE';
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var frag = data.frag,
          payload = data.payload;
      if (frag.type === 'main') {
        var sn = frag.sn;
        // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack
        if (sn !== this.lastSn + 1) {
          var cea608Parser = this.cea608Parser;
          if (cea608Parser) {
            cea608Parser.reset();
          }
        }
        this.lastSn = sn;
      } // eslint-disable-line brace-style
      // If fragment is subtitle type, parse as WebVTT.
      else if (frag.type === 'subtitle') {
          if (payload.byteLength) {
            // We need an initial synchronisation PTS. Store fragments as long as none has arrived.
            if (!Number.isFinite(this.initPTS[frag.cc])) {
              this.unparsedVttFrags.push(data);
              if (this.initPTS.length) {
                // finish unsuccessfully, otherwise the subtitle-stream-controller could be blocked from loading new frags.
                this.hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
              }
              return;
            }

            var decryptData = frag.decryptdata;
            // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.
            if (decryptData == null || decryptData.key == null || decryptData.method !== 'AES-128') {
              this._parseVTTs(frag, payload);
            }
          } else {
            // In case there is no payload, finish unsuccessfully.
            this.hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
          }
        }
    }
  }, {
    key: '_parseVTTs',
    value: function _parseVTTs(frag, payload) {
      var vttCCs = this.vttCCs;
      if (!vttCCs[frag.cc]) {
        vttCCs[frag.cc] = { start: frag.start, prevCC: this.prevCC, new: true };
        this.prevCC = frag.cc;
      }
      var textTracks = this.textTracks,
          hls = this.hls;

      // Parse the WebVTT file contents.
      _webvttParser2.default.parse(payload, this.initPTS[frag.cc], vttCCs, frag.cc, function (cues) {
        var currentTrack = textTracks[frag.levels];
        // WebVTTParser.parse is an async method and if the currently selected text track mode is set to "disabled"
        // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null
        // and trying to access getCueById method of cues will throw an exception
        if (currentTrack.mode === 'disabled') {
          hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
          return;
        }
        // Add cues and trigger event with success true.
        cues.forEach(function (cue) {
          // Sometimes there are cue overlaps on segmented vtts so the same
          // cue can appear more than once in different vtt files.
          // This avoid showing duplicated cues with same timecode and text.
          if (!currentTrack.cues.getCueById(cue.id)) {
            try {
              currentTrack.addCue(cue);
            } catch (err) {
              var textTrackCue = new window.TextTrackCue(cue.startTime, cue.endTime, cue.text);
              textTrackCue.id = cue.id;
              currentTrack.addCue(textTrackCue);
            }
          }
        });
        hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: true, frag: frag });
      }, function (e) {
        // Something went wrong while parsing. Trigger event with success false.
        _logger.logger.log('Failed to parse VTT cue: ' + e);
        hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
      });
    }
  }, {
    key: 'onFragDecrypted',
    value: function onFragDecrypted(data) {
      var decryptedData = data.payload,
          frag = data.frag;

      if (frag.type === 'subtitle') {
        if (!Number.isFinite(this.initPTS[frag.cc])) {
          this.unparsedVttFrags.push(data);
          return;
        }

        this._parseVTTs(frag, decryptedData);
      }
    }
  }, {
    key: 'onFragParsingUserdata',
    value: function onFragParsingUserdata(data) {
      // push all of the CEA-708 messages into the interpreter
      // immediately. It will create the proper timestamps based on our PTS value
      if (this.enabled && this.config.enableCEA708Captions) {
        for (var i = 0; i < data.samples.length; i++) {
          var ccdatas = this.extractCea608Data(data.samples[i].bytes);
          this.cea608Parser.addData(data.samples[i].pts, ccdatas);
        }
      }
    }
  }, {
    key: 'extractCea608Data',
    value: function extractCea608Data(byteArray) {
      var count = byteArray[0] & 31;
      var position = 2;
      var tmpByte = void 0,
          ccbyte1 = void 0,
          ccbyte2 = void 0,
          ccValid = void 0,
          ccType = void 0;
      var actualCCBytes = [];

      for (var j = 0; j < count; j++) {
        tmpByte = byteArray[position++];
        ccbyte1 = 0x7F & byteArray[position++];
        ccbyte2 = 0x7F & byteArray[position++];
        ccValid = (4 & tmpByte) !== 0;
        ccType = 3 & tmpByte;

        if (ccbyte1 === 0 && ccbyte2 === 0) {
          continue;
        }

        if (ccValid) {
          if (ccType === 0) {
            // || ccType === 1
            actualCCBytes.push(ccbyte1);
            actualCCBytes.push(ccbyte2);
          }
        }
      }
      return actualCCBytes;
    }
  }]);

  return TimelineController;
}(_eventHandler2.default);

exports.default = TimelineController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/crypt/aes-crypto.js":
/*!****************************************!*\
  !*** ./src/hls.js/crypt/aes-crypto.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AESCrypto = function () {
  function AESCrypto(subtle, iv) {
    _classCallCheck(this, AESCrypto);

    this.subtle = subtle;
    this.aesIV = iv;
  }

  _createClass(AESCrypto, [{
    key: 'decrypt',
    value: function decrypt(data, key) {
      return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);
    }
  }]);

  return AESCrypto;
}();

exports.default = AESCrypto;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/crypt/aes-decryptor.js":
/*!*******************************************!*\
  !*** ./src/hls.js/crypt/aes-decryptor.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.removePadding = removePadding;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// PKCS7
function removePadding(buffer) {
  var outputBytes = buffer.byteLength;
  var paddingBytes = outputBytes && new DataView(buffer).getUint8(outputBytes - 1);
  if (paddingBytes) {
    return buffer.slice(0, outputBytes - paddingBytes);
  } else {
    return buffer;
  }
}

var AESDecryptor = function () {
  function AESDecryptor() {
    _classCallCheck(this, AESDecryptor);

    // Static after running initTable
    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.sBox = new Uint32Array(256);
    this.invSBox = new Uint32Array(256);

    // Changes during runtime
    this.key = new Uint32Array(0);

    this.initTable();
  }

  // Using view.getUint32() also swaps the byte order.


  _createClass(AESDecryptor, [{
    key: 'uint8ArrayToUint32Array_',
    value: function uint8ArrayToUint32Array_(arrayBuffer) {
      var view = new DataView(arrayBuffer);
      var newArray = new Uint32Array(4);
      for (var i = 0; i < 4; i++) {
        newArray[i] = view.getUint32(i * 4);
      }

      return newArray;
    }
  }, {
    key: 'initTable',
    value: function initTable() {
      var sBox = this.sBox;
      var invSBox = this.invSBox;
      var subMix = this.subMix;
      var subMix0 = subMix[0];
      var subMix1 = subMix[1];
      var subMix2 = subMix[2];
      var subMix3 = subMix[3];
      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var d = new Uint32Array(256);
      var x = 0;
      var xi = 0;
      var i = 0;
      for (i = 0; i < 256; i++) {
        if (i < 128) {
          d[i] = i << 1;
        } else {
          d[i] = i << 1 ^ 0x11b;
        }
      }

      for (i = 0; i < 256; i++) {
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        sBox[x] = sx;
        invSBox[sx] = x;

        // Compute multiplication
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];

        // Compute sub/invSub bytes, mix columns tables
        var t = d[sx] * 0x101 ^ sx * 0x1010100;
        subMix0[x] = t << 24 | t >>> 8;
        subMix1[x] = t << 16 | t >>> 16;
        subMix2[x] = t << 8 | t >>> 24;
        subMix3[x] = t;

        // Compute inv sub bytes, inv mix columns tables
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        invSubMix0[sx] = t << 24 | t >>> 8;
        invSubMix1[sx] = t << 16 | t >>> 16;
        invSubMix2[sx] = t << 8 | t >>> 24;
        invSubMix3[sx] = t;

        // Compute next counter
        if (!x) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
    }
  }, {
    key: 'expandKey',
    value: function expandKey(keyBuffer) {
      // convert keyBuffer to Uint32Array
      var key = this.uint8ArrayToUint32Array_(keyBuffer);
      var sameKey = true;
      var offset = 0;

      while (offset < key.length && sameKey) {
        sameKey = key[offset] === this.key[offset];
        offset++;
      }

      if (sameKey) {
        return;
      }

      this.key = key;
      var keySize = this.keySize = key.length;

      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
        throw new Error('Invalid aes key size=' + keySize);
      }

      var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
      var ksRow = void 0;
      var invKsRow = void 0;

      var keySchedule = this.keySchedule = new Uint32Array(ksRows);
      var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
      var sbox = this.sBox;
      var rcon = this.rcon;

      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var prev = void 0;
      var t = void 0;

      for (ksRow = 0; ksRow < ksRows; ksRow++) {
        if (ksRow < keySize) {
          prev = keySchedule[ksRow] = key[ksRow];
          continue;
        }
        t = prev;

        if (ksRow % keySize === 0) {
          // Rot word
          t = t << 8 | t >>> 24;

          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];

          // Mix Rcon
          t ^= rcon[ksRow / keySize | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
        }

        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
      }

      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;
        if (invKsRow & 3) {
          t = keySchedule[ksRow];
        } else {
          t = keySchedule[ksRow - 4];
        }

        if (invKsRow < 4 || ksRow <= 4) {
          invKeySchedule[invKsRow] = t;
        } else {
          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
        }

        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
      }
    }

    // Adding this as a method greatly improves performance.

  }, {
    key: 'networkToHostOrderSwap',
    value: function networkToHostOrderSwap(word) {
      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
    }
  }, {
    key: 'decrypt',
    value: function decrypt(inputArrayBuffer, offset, aesIV, removePKCS7Padding) {
      var nRounds = this.keySize + 6;
      var invKeySchedule = this.invKeySchedule;
      var invSBOX = this.invSBox;

      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var initVector = this.uint8ArrayToUint32Array_(aesIV);
      var initVector0 = initVector[0];
      var initVector1 = initVector[1];
      var initVector2 = initVector[2];
      var initVector3 = initVector[3];

      var inputInt32 = new Int32Array(inputArrayBuffer);
      var outputInt32 = new Int32Array(inputInt32.length);

      var t0 = void 0,
          t1 = void 0,
          t2 = void 0,
          t3 = void 0;
      var s0 = void 0,
          s1 = void 0,
          s2 = void 0,
          s3 = void 0;
      var inputWords0 = void 0,
          inputWords1 = void 0,
          inputWords2 = void 0,
          inputWords3 = void 0;

      var ksRow = void 0,
          i = void 0;
      var swapWord = this.networkToHostOrderSwap;

      while (offset < inputInt32.length) {
        inputWords0 = swapWord(inputInt32[offset]);
        inputWords1 = swapWord(inputInt32[offset + 1]);
        inputWords2 = swapWord(inputInt32[offset + 2]);
        inputWords3 = swapWord(inputInt32[offset + 3]);

        s0 = inputWords0 ^ invKeySchedule[0];
        s1 = inputWords3 ^ invKeySchedule[1];
        s2 = inputWords2 ^ invKeySchedule[2];
        s3 = inputWords1 ^ invKeySchedule[3];

        ksRow = 4;

        // Iterate through the rounds of decryption
        for (i = 1; i < nRounds; i++) {
          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
          // Update state
          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;

          ksRow = ksRow + 4;
        }

        // Shift rows, sub bytes, add round key
        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];
        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
        ksRow = ksRow + 3;

        // Write
        outputInt32[offset] = swapWord(t0 ^ initVector0);
        outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
        outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
        outputInt32[offset + 3] = swapWord(t1 ^ initVector3);

        // reset initVector to last 4 unsigned int
        initVector0 = inputWords0;
        initVector1 = inputWords1;
        initVector2 = inputWords2;
        initVector3 = inputWords3;

        offset = offset + 4;
      }

      return removePKCS7Padding ? removePadding(outputInt32.buffer) : outputInt32.buffer;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.key = undefined;
      this.keySize = undefined;
      this.ksRows = undefined;

      this.sBox = undefined;
      this.invSBox = undefined;
      this.subMix = undefined;
      this.invSubMix = undefined;
      this.keySchedule = undefined;
      this.invKeySchedule = undefined;

      this.rcon = undefined;
    }
  }]);

  return AESDecryptor;
}();

exports.default = AESDecryptor;

/***/ }),

/***/ "./src/hls.js/crypt/decrypter.js":
/*!***************************************!*\
  !*** ./src/hls.js/crypt/decrypter.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _aesCrypto = __webpack_require__(/*! ./aes-crypto */ "./src/hls.js/crypt/aes-crypto.js");

var _aesCrypto2 = _interopRequireDefault(_aesCrypto);

var _fastAesKey = __webpack_require__(/*! ./fast-aes-key */ "./src/hls.js/crypt/fast-aes-key.js");

var _fastAesKey2 = _interopRequireDefault(_fastAesKey);

var _aesDecryptor = __webpack_require__(/*! ./aes-decryptor */ "./src/hls.js/crypt/aes-decryptor.js");

var _aesDecryptor2 = _interopRequireDefault(_aesDecryptor);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _getSelfScope = __webpack_require__(/*! ../utils/get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// see https://stackoverflow.com/a/11237259/589493
var global = (0, _getSelfScope.getSelfScope)(); // safeguard for code that might run both on worker and main thread

var Decrypter = function () {
  function Decrypter(observer, config) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$removePKCS7Paddi = _ref.removePKCS7Padding,
        removePKCS7Padding = _ref$removePKCS7Paddi === undefined ? true : _ref$removePKCS7Paddi;

    _classCallCheck(this, Decrypter);

    this.logEnabled = true;
    this.observer = observer;
    this.config = config;
    this.removePKCS7Padding = removePKCS7Padding;
    // built in decryptor expects PKCS7 padding
    if (removePKCS7Padding) {
      try {
        var browserCrypto = global.crypto;
        if (browserCrypto) {
          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
        }
      } catch (e) {}
    }
    this.disableWebCrypto = !this.subtle;
  }

  _createClass(Decrypter, [{
    key: 'isSync',
    value: function isSync() {
      return this.disableWebCrypto && this.config.enableSoftwareAES;
    }
  }, {
    key: 'decrypt',
    value: function decrypt(data, key, iv, callback) {
      var _this = this;

      if (this.disableWebCrypto && this.config.enableSoftwareAES) {
        if (this.logEnabled) {
          _logger.logger.log('JS AES decrypt');
          this.logEnabled = false;
        }
        var decryptor = this.decryptor;
        if (!decryptor) {
          this.decryptor = decryptor = new _aesDecryptor2.default();
        }

        decryptor.expandKey(key);
        callback(decryptor.decrypt(data, 0, iv, this.removePKCS7Padding));
      } else {
        if (this.logEnabled) {
          _logger.logger.log('WebCrypto AES decrypt');
          this.logEnabled = false;
        }
        var subtle = this.subtle;
        if (this.key !== key) {
          this.key = key;
          this.fastAesKey = new _fastAesKey2.default(subtle, key);
        }

        this.fastAesKey.expandKey().then(function (aesKey) {
          // decrypt using web crypto
          var crypto = new _aesCrypto2.default(subtle, iv);
          crypto.decrypt(data, aesKey).catch(function (err) {
            _this.onWebCryptoError(err, data, key, iv, callback);
          }).then(function (result) {
            callback(result);
          });
        }).catch(function (err) {
          _this.onWebCryptoError(err, data, key, iv, callback);
        });
      }
    }
  }, {
    key: 'onWebCryptoError',
    value: function onWebCryptoError(err, data, key, iv, callback) {
      if (this.config.enableSoftwareAES) {
        _logger.logger.log('WebCrypto Error, disable WebCrypto API');
        this.disableWebCrypto = true;
        this.logEnabled = true;
        this.decrypt(data, key, iv, callback);
      } else {
        _logger.logger.error('decrypting error : ' + err.message);
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var decryptor = this.decryptor;
      if (decryptor) {
        decryptor.destroy();
        this.decryptor = undefined;
      }
    }
  }]);

  return Decrypter;
}();

exports.default = Decrypter;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/crypt/fast-aes-key.js":
/*!******************************************!*\
  !*** ./src/hls.js/crypt/fast-aes-key.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FastAESKey = function () {
  function FastAESKey(subtle, key) {
    _classCallCheck(this, FastAESKey);

    this.subtle = subtle;
    this.key = key;
  }

  _createClass(FastAESKey, [{
    key: 'expandKey',
    value: function expandKey() {
      return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);
    }
  }]);

  return FastAESKey;
}();

exports.default = FastAESKey;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/aacdemuxer.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/aacdemuxer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AAC demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _adts = __webpack_require__(/*! ./adts */ "./src/hls.js/demux/adts.js");

var ADTS = _interopRequireWildcard(_adts);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _id = __webpack_require__(/*! ../demux/id3 */ "./src/hls.js/demux/id3.js");

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AACDemuxer = function () {
  function AACDemuxer(observer, remuxer, config) {
    _classCallCheck(this, AACDemuxer);

    this.observer = observer;
    this.config = config;
    this.remuxer = remuxer;
  }

  _createClass(AACDemuxer, [{
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this._audioTrack = { container: 'audio/adts', type: 'audio', id: 0, sequenceNumber: 0, isAAC: true, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
    }
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var track = this._audioTrack;
      var id3Data = _id2.default.getID3Data(data, 0) || [];
      var timestamp = _id2.default.getTimeStamp(id3Data);
      var pts = Number.isFinite(timestamp) ? timestamp * 90 : timeOffset * 90000;
      var frameIndex = 0;
      var stamp = pts;
      var length = data.length;
      var offset = id3Data.length;

      var id3Samples = [{ pts: stamp, dts: stamp, data: id3Data }];

      while (offset < length - 1) {
        if (ADTS.isHeader(data, offset) && offset + 5 < length) {
          ADTS.initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
          var frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);
          if (frame) {
            offset += frame.length;
            stamp = frame.sample.pts;
            frameIndex++;
          } else {
            _logger.logger.log('Unable to parse AAC frame');
            break;
          }
        } else if (_id2.default.isHeader(data, offset)) {
          id3Data = _id2.default.getID3Data(data, offset);
          id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
          offset += id3Data.length;
        } else {
          // nothing found, keep looking
          offset++;
        }
      }

      this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      if (!data) {
        return false;
      }

      // Check for the ADTS sync word
      // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
      // Layer bits (position 14 and 15) in header should be always 0 for ADTS
      // More info https://wiki.multimedia.cx/index.php?title=ADTS
      var id3Data = _id2.default.getID3Data(data, 0) || [];
      var offset = id3Data.length;

      for (var length = data.length; offset < length; offset++) {
        if (ADTS.probe(data, offset)) {
          _logger.logger.log('ADTS sync word found !');
          return true;
        }
      }
      return false;
    }
  }]);

  return AACDemuxer;
}();

exports.default = AACDemuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/adts.js":
/*!**********************************!*\
  !*** ./src/hls.js/demux/adts.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAudioConfig = getAudioConfig;
exports.isHeaderPattern = isHeaderPattern;
exports.getHeaderLength = getHeaderLength;
exports.getFullFrameLength = getFullFrameLength;
exports.isHeader = isHeader;
exports.probe = probe;
exports.initTrackConfig = initTrackConfig;
exports.getFrameDuration = getFrameDuration;
exports.parseFrameHeader = parseFrameHeader;
exports.appendFrame = appendFrame;

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _getSelfScope = __webpack_require__(/*! ../utils/get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *  ADTS parser helper
 */
function getAudioConfig(observer, data, offset, audioCodec) {
  var adtsObjectType = void 0,
      // :int
  adtsSampleingIndex = void 0,
      // :int
  adtsExtensionSampleingIndex = void 0,
      // :int
  adtsChanelConfig = void 0,
      // :int
  config = void 0,
      userAgent = navigator.userAgent.toLowerCase(),
      manifestCodec = audioCodec,
      adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
  // byte 2
  adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
  adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;
  if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
    observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });
    return;
  }
  adtsChanelConfig = (data[offset + 2] & 0x01) << 2;
  // byte 3
  adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;
  _logger.logger.log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);
  // firefox: freq less than 24kHz = AAC SBR (HE-AAC)
  if (/firefox/i.test(userAgent)) {
    if (adtsSampleingIndex >= 6) {
      adtsObjectType = 5;
      config = new Array(4);
      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
      // there is a factor 2 between frame sample rate and output sample rate
      // multiply frequency by 2 (see table below, equivalent to substract 3)
      adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
    } else {
      adtsObjectType = 2;
      config = new Array(2);
      adtsExtensionSampleingIndex = adtsSampleingIndex;
    }
    // Android : always use AAC
  } else if (userAgent.indexOf('android') !== -1) {
    adtsObjectType = 2;
    config = new Array(2);
    adtsExtensionSampleingIndex = adtsSampleingIndex;
  } else {
    /*  for other browsers (Chrome/Vivaldi/Opera ...)
        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
    */
    adtsObjectType = 5;
    config = new Array(4);
    // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
    if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
      // there is a factor 2 between frame sample rate and output sample rate
      // multiply frequency by 2 (see table below, equivalent to substract 3)
      adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
    } else {
      // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
      // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
      if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChanelConfig === 1) {
        adtsObjectType = 2;
        config = new Array(2);
      }
      adtsExtensionSampleingIndex = adtsSampleingIndex;
    }
  }
  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
      ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()
    Audio Profile / Audio Object Type
    0: Null
    1: AAC Main
    2: AAC LC (Low Complexity)
    3: AAC SSR (Scalable Sample Rate)
    4: AAC LTP (Long Term Prediction)
    5: SBR (Spectral Band Replication)
    6: AAC Scalable
   sampling freq
    0: 96000 Hz
    1: 88200 Hz
    2: 64000 Hz
    3: 48000 Hz
    4: 44100 Hz
    5: 32000 Hz
    6: 24000 Hz
    7: 22050 Hz
    8: 16000 Hz
    9: 12000 Hz
    10: 11025 Hz
    11: 8000 Hz
    12: 7350 Hz
    13: Reserved
    14: Reserved
    15: frequency is written explictly
    Channel Configurations
    These are the channel configurations:
    0: Defined in AOT Specifc Config
    1: 1 channel: front-center
    2: 2 channels: front-left, front-right
  */
  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
  config[0] = adtsObjectType << 3;
  // samplingFrequencyIndex
  config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
  config[1] |= (adtsSampleingIndex & 0x01) << 7;
  // channelConfiguration
  config[1] |= adtsChanelConfig << 3;
  if (adtsObjectType === 5) {
    // adtsExtensionSampleingIndex
    config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
    config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
    // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
    //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
    config[2] |= 2 << 2;
    config[3] = 0;
  }
  return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: 'mp4a.40.' + adtsObjectType, manifestCodec: manifestCodec };
}

function isHeaderPattern(data, offset) {
  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;
}

function getHeaderLength(data, offset) {
  return data[offset + 1] & 0x01 ? 7 : 9;
}

function getFullFrameLength(data, offset) {
  return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
}

function isHeader(data, offset) {
  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
  // Layer bits (position 14 and 15) in header should be always 0 for ADTS
  // More info https://wiki.multimedia.cx/index.php?title=ADTS
  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
    return true;
  }

  return false;
}

function probe(data, offset) {
  // same as isHeader but we also check that ADTS frame follows last ADTS frame
  // or end of data is reached
  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
    // ADTS header Length
    var headerLength = getHeaderLength(data, offset);
    // ADTS frame Length
    var frameLength = headerLength;
    if (offset + 5 < data.length) {
      frameLength = getFullFrameLength(data, offset);
    }

    var newOffset = offset + frameLength;
    if (newOffset === data.length || newOffset + 1 < data.length && isHeaderPattern(data, newOffset)) {
      return true;
    }
  }
  return false;
}

function initTrackConfig(track, observer, data, offset, audioCodec) {
  if (!track.samplerate) {
    var config = getAudioConfig(observer, data, offset, audioCodec);
    track.config = config.config;
    track.samplerate = config.samplerate;
    track.channelCount = config.channelCount;
    track.codec = config.codec;
    track.manifestCodec = config.manifestCodec;
    _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
  }
}

function getFrameDuration(samplerate) {
  return 1024 * 90000 / samplerate;
}

function parseFrameHeader(data, offset, pts, frameIndex, frameDuration) {
  var headerLength = void 0,
      frameLength = void 0,
      stamp = void 0;
  var length = data.length;

  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
  headerLength = getHeaderLength(data, offset);
  // retrieve frame size
  frameLength = getFullFrameLength(data, offset);
  frameLength -= headerLength;

  if (frameLength > 0 && offset + headerLength + frameLength <= length) {
    stamp = pts + frameIndex * frameDuration;
    // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
    return { headerLength: headerLength, frameLength: frameLength, stamp: stamp };
  }

  return undefined;
}

function appendFrame(track, data, offset, pts, frameIndex) {
  var frameDuration = getFrameDuration(track.samplerate);
  var header = parseFrameHeader(data, offset, pts, frameIndex, frameDuration);
  if (header) {
    var stamp = header.stamp;
    var headerLength = header.headerLength;
    var frameLength = header.frameLength;

    // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
    var aacSample = {
      unit: data.subarray(offset + headerLength, offset + headerLength + frameLength),
      pts: stamp,
      dts: stamp
    };

    track.samples.push(aacSample);
    track.len += frameLength;

    return { sample: aacSample, length: frameLength + headerLength };
  }

  return undefined;
}

/***/ }),

/***/ "./src/hls.js/demux/demuxer-inline.js":
/*!********************************************!*\
  !*** ./src/hls.js/demux/demuxer-inline.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * inline demuxer: probe fragments and instantiate
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _decrypter = __webpack_require__(/*! ../crypt/decrypter */ "./src/hls.js/crypt/decrypter.js");

var _decrypter2 = _interopRequireDefault(_decrypter);

var _aacdemuxer = __webpack_require__(/*! ../demux/aacdemuxer */ "./src/hls.js/demux/aacdemuxer.js");

var _aacdemuxer2 = _interopRequireDefault(_aacdemuxer);

var _mp4demuxer = __webpack_require__(/*! ../demux/mp4demuxer */ "./src/hls.js/demux/mp4demuxer.js");

var _mp4demuxer2 = _interopRequireDefault(_mp4demuxer);

var _tsdemuxer = __webpack_require__(/*! ../demux/tsdemuxer */ "./src/hls.js/demux/tsdemuxer.js");

var _tsdemuxer2 = _interopRequireDefault(_tsdemuxer);

var _mp3demuxer = __webpack_require__(/*! ../demux/mp3demuxer */ "./src/hls.js/demux/mp3demuxer.js");

var _mp3demuxer2 = _interopRequireDefault(_mp3demuxer);

var _mp4Remuxer = __webpack_require__(/*! ../remux/mp4-remuxer */ "./src/hls.js/remux/mp4-remuxer.js");

var _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);

var _passthroughRemuxer = __webpack_require__(/*! ../remux/passthrough-remuxer */ "./src/hls.js/remux/passthrough-remuxer.js");

var _passthroughRemuxer2 = _interopRequireDefault(_passthroughRemuxer);

var _getSelfScope = __webpack_require__(/*! ../utils/get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// see https://stackoverflow.com/a/11237259/589493
var global = (0, _getSelfScope.getSelfScope)(); // safeguard for code that might run both on worker and main thread

var now = void 0;
// performance.now() not available on WebWorker, at least on Safari Desktop
try {
  now = global.performance.now.bind(global.performance);
} catch (err) {
  _logger.logger.debug('Unable to use Performance API on this environment');
  now = global.Date.now;
}

var DemuxerInline = function () {
  function DemuxerInline(observer, typeSupported, config, vendor) {
    _classCallCheck(this, DemuxerInline);

    this.observer = observer;
    this.typeSupported = typeSupported;
    this.config = config;
    this.vendor = vendor;
  }

  _createClass(DemuxerInline, [{
    key: 'destroy',
    value: function destroy() {
      var demuxer = this.demuxer;
      if (demuxer) {
        demuxer.destroy();
      }
    }
  }, {
    key: 'push',
    value: function push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
      var _this = this;

      if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === 'AES-128') {
        var decrypter = this.decrypter;
        if (decrypter == null) {
          decrypter = this.decrypter = new _decrypter2.default(this.observer, this.config);
        }

        var startTime = now();
        decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {
          var endTime = now();
          _this.observer.trigger(_events2.default.FRAG_DECRYPTED, { stats: { tstart: startTime, tdecrypt: endTime } });
          _this.pushDecrypted(new Uint8Array(decryptedData), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
        });
      } else {
        this.pushDecrypted(new Uint8Array(data), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
      }
    }
  }, {
    key: 'pushDecrypted',
    value: function pushDecrypted(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
      var demuxer = this.demuxer;
      if (!demuxer ||
      // in case of continuity change, or track switch
      // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)
      // so let's check that current demuxer is still valid
      (discontinuity || trackSwitch) && !this.probe(data)) {
        var observer = this.observer;
        var typeSupported = this.typeSupported;
        var config = this.config;
        // probing order is TS/AAC/MP3/MP4
        var muxConfig = [{ demux: _tsdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp4demuxer2.default, remux: _passthroughRemuxer2.default }, { demux: _aacdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp3demuxer2.default, remux: _mp4Remuxer2.default }];

        // probe for content type
        for (var i = 0, len = muxConfig.length; i < len; i++) {
          var mux = muxConfig[i];
          var probe = mux.demux.probe;
          if (probe(data)) {
            var _remuxer = this.remuxer = new mux.remux(observer, config, typeSupported, this.vendor);
            demuxer = new mux.demux(observer, _remuxer, config, typeSupported);
            this.probe = probe;
            break;
          }
        }
        if (!demuxer) {
          observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });
          return;
        }
        this.demuxer = demuxer;
      }
      var remuxer = this.remuxer;

      if (discontinuity || trackSwitch) {
        demuxer.resetInitSegment(initSegment, audioCodec, videoCodec, duration);
        remuxer.resetInitSegment();
      }
      if (discontinuity) {
        demuxer.resetTimeStamp(defaultInitPTS);
        remuxer.resetTimeStamp(defaultInitPTS);
      }
      if (typeof demuxer.setDecryptData === 'function') {
        demuxer.setDecryptData(decryptdata);
      }

      demuxer.append(data, timeOffset, contiguous, accurateTimeOffset);
    }
  }]);

  return DemuxerInline;
}();

exports.default = DemuxerInline;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/demuxer-worker.js":
/*!********************************************!*\
  !*** ./src/hls.js/demux/demuxer-worker.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _demuxerInline = __webpack_require__(/*! ../demux/demuxer-inline */ "./src/hls.js/demux/demuxer-inline.js");

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _events3 = __webpack_require__(/*! events */ "../../node_modules/events/events.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* demuxer web worker.
 *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
 *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
 */

var DemuxerWorker = function DemuxerWorker(self) {
  // observer setup
  var observer = new _events3.EventEmitter();
  observer.trigger = function trigger(event) {
    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    observer.emit.apply(observer, [event, event].concat(data));
  };

  observer.off = function off(event) {
    for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      data[_key2 - 1] = arguments[_key2];
    }

    observer.removeListener.apply(observer, [event].concat(data));
  };

  var forwardMessage = function forwardMessage(ev, data) {
    self.postMessage({ event: ev, data: data });
  };

  self.addEventListener('message', function (ev) {
    var data = ev.data;
    // console.log('demuxer cmd:' + data.cmd);
    switch (data.cmd) {
      case 'init':
        var config = JSON.parse(data.config);
        self.demuxer = new _demuxerInline2.default(observer, data.typeSupported, config, data.vendor);

        (0, _logger.enableLogs)(config.debug);

        // signal end of worker init
        forwardMessage('init', null);
        break;
      case 'demux':
        self.demuxer.push(data.data, data.decryptdata, data.initSegment, data.audioCodec, data.videoCodec, data.timeOffset, data.discontinuity, data.trackSwitch, data.contiguous, data.duration, data.accurateTimeOffset, data.defaultInitPTS);
        break;
      default:
        break;
    }
  });

  // forward events to main thread
  observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
  observer.on(_events2.default.FRAG_PARSED, forwardMessage);
  observer.on(_events2.default.ERROR, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);
  observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);

  // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
  observer.on(_events2.default.FRAG_PARSING_DATA, function (ev, data) {
    var transferable = [];
    var message = { event: ev, data: data };
    if (data.data1) {
      message.data1 = data.data1.buffer;
      transferable.push(data.data1.buffer);
      delete data.data1;
    }
    if (data.data2) {
      message.data2 = data.data2.buffer;
      transferable.push(data.data2.buffer);
      delete data.data2;
    }
    self.postMessage(message, transferable);
  });
};

exports.default = DemuxerWorker;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/demuxer.js":
/*!*************************************!*\
  !*** ./src/hls.js/demux/demuxer.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! events */ "../../node_modules/events/events.js");

var _webworkifyWebpack = __webpack_require__(/*! webworkify-webpack */ "../../node_modules/webworkify-webpack/index.js");

var work = _interopRequireWildcard(_webworkifyWebpack);

var _events2 = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events3 = _interopRequireDefault(_events2);

var _demuxerInline = __webpack_require__(/*! ../demux/demuxer-inline */ "./src/hls.js/demux/demuxer-inline.js");

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _mediasourceHelper = __webpack_require__(/*! ../utils/mediasource-helper */ "./src/hls.js/utils/mediasource-helper.js");

var _getSelfScope = __webpack_require__(/*! ../utils/get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

var _observer = __webpack_require__(/*! ../observer */ "./src/hls.js/observer.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// see https://stackoverflow.com/a/11237259/589493
var global = (0, _getSelfScope.getSelfScope)(); // safeguard for code that might run both on worker and main thread
var MediaSource = (0, _mediasourceHelper.getMediaSource)();

var Demuxer = function () {
  function Demuxer(hls, id) {
    var _this = this;

    _classCallCheck(this, Demuxer);

    this.hls = hls;
    this.id = id;

    var observer = this.observer = new _observer.Observer();
    var config = hls.config;

    var forwardMessage = function forwardMessage(ev, data) {
      data = data || {};
      data.frag = _this.frag;
      data.id = _this.id;
      hls.trigger(ev, data);
    };

    // forward events to main thread
    observer.on(_events3.default.FRAG_DECRYPTED, forwardMessage);
    observer.on(_events3.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
    observer.on(_events3.default.FRAG_PARSING_DATA, forwardMessage);
    observer.on(_events3.default.FRAG_PARSED, forwardMessage);
    observer.on(_events3.default.ERROR, forwardMessage);
    observer.on(_events3.default.FRAG_PARSING_METADATA, forwardMessage);
    observer.on(_events3.default.FRAG_PARSING_USERDATA, forwardMessage);
    observer.on(_events3.default.INIT_PTS_FOUND, forwardMessage);

    var typeSupported = {
      mp4: MediaSource.isTypeSupported('video/mp4'),
      mpeg: MediaSource.isTypeSupported('audio/mpeg'),
      mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"')
    };
    // navigator.vendor is not always available in Web Worker
    // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator
    var vendor = navigator.vendor;
    if (config.enableWorker && typeof Worker !== 'undefined') {
      _logger.logger.log('demuxing in webworker');
      var w = void 0;
      try {
        w = this.w = work(/*require.resolve*/(/*! ../demux/demuxer-worker.js */ "./src/hls.js/demux/demuxer-worker.js"));
        this.onwmsg = this.onWorkerMessage.bind(this);
        w.addEventListener('message', this.onwmsg);
        w.onerror = function (event) {
          hls.trigger(_events3.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });
        };
        w.postMessage({ cmd: 'init', typeSupported: typeSupported, vendor: vendor, id: id, config: JSON.stringify(config) });
      } catch (err) {
        _logger.logger.warn('Error in worker:', err);
        _logger.logger.error('Error while initializing DemuxerWorker, fallback on DemuxerInline');
        if (w) {
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          global.URL.revokeObjectURL(w.objectURL);
        }
        this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
        this.w = undefined;
      }
    } else {
      this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
    }
  }

  _createClass(Demuxer, [{
    key: 'destroy',
    value: function destroy() {
      var w = this.w;
      if (w) {
        w.removeEventListener('message', this.onwmsg);
        w.terminate();
        this.w = null;
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.destroy();
          this.demuxer = null;
        }
      }
      var observer = this.observer;
      if (observer) {
        observer.removeAllListeners();
        this.observer = null;
      }
    }
  }, {
    key: 'push',
    value: function push(data, initSegment, audioCodec, videoCodec, frag, duration, accurateTimeOffset, defaultInitPTS) {
      var w = this.w;
      var timeOffset = Number.isFinite(frag.startPTS) ? frag.startPTS : frag.start;
      var decryptdata = frag.decryptdata;
      var lastFrag = this.frag;
      var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
      var trackSwitch = !(lastFrag && frag.levels === lastFrag.levels);
      var nextSN = lastFrag && frag.sn === lastFrag.sn + 1;
      var contiguous = !trackSwitch && nextSN;
      if (discontinuity) {
        _logger.logger.log(this.id + ':discontinuity detected');
      }

      if (trackSwitch) {
        _logger.logger.log(this.id + ':switch detected');
      }

      this.frag = frag;
      if (w) {
        // post fragment payload as transferable objects for ArrayBuffer (no copy)
        w.postMessage({ cmd: 'demux', data: data, decryptdata: decryptdata, initSegment: initSegment, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, discontinuity: discontinuity, trackSwitch: trackSwitch, contiguous: contiguous, duration: duration, accurateTimeOffset: accurateTimeOffset, defaultInitPTS: defaultInitPTS }, data instanceof ArrayBuffer ? [data] : []);
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
        }
      }
    }
  }, {
    key: 'onWorkerMessage',
    value: function onWorkerMessage(ev) {
      var data = ev.data,
          hls = this.hls;
      switch (data.event) {
        case 'init':
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          global.URL.revokeObjectURL(this.w.objectURL);
          break;
        // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
        case _events3.default.FRAG_PARSING_DATA:
          data.data.data1 = new Uint8Array(data.data1);
          if (data.data2) {
            data.data.data2 = new Uint8Array(data.data2);
          }

        /* falls through */
        default:
          data.data = data.data || {};
          data.data.frag = this.frag;
          data.data.id = this.id;
          hls.trigger(data.event, data.data);
          break;
      }
    }
  }]);

  return Demuxer;
}();

exports.default = Demuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/exp-golomb.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/exp-golomb.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ExpGolomb = function () {
  function ExpGolomb(data) {
    _classCallCheck(this, ExpGolomb);

    this.data = data;
    // the number of bytes left to examine in this.data
    this.bytesAvailable = data.byteLength;
    // the current word being examined
    this.word = 0; // :uint
    // the number of bits left to examine in the current word
    this.bitsAvailable = 0; // :uint
  }

  // ():void


  _createClass(ExpGolomb, [{
    key: 'loadWord',
    value: function loadWord() {
      var data = this.data,
          bytesAvailable = this.bytesAvailable,
          position = data.byteLength - bytesAvailable,
          workingBytes = new Uint8Array(4),
          availableBytes = Math.min(4, bytesAvailable);
      if (availableBytes === 0) {
        throw new Error('no bytes available');
      }

      workingBytes.set(data.subarray(position, position + availableBytes));
      this.word = new DataView(workingBytes.buffer).getUint32(0);
      // track the amount of this.data that has been processed
      this.bitsAvailable = availableBytes * 8;
      this.bytesAvailable -= availableBytes;
    }

    // (count:int):void

  }, {
    key: 'skipBits',
    value: function skipBits(count) {
      var skipBytes = void 0; // :int
      if (this.bitsAvailable > count) {
        this.word <<= count;
        this.bitsAvailable -= count;
      } else {
        count -= this.bitsAvailable;
        skipBytes = count >> 3;
        count -= skipBytes >> 3;
        this.bytesAvailable -= skipBytes;
        this.loadWord();
        this.word <<= count;
        this.bitsAvailable -= count;
      }
    }

    // (size:int):uint

  }, {
    key: 'readBits',
    value: function readBits(size) {
      var bits = Math.min(this.bitsAvailable, size),
          // :uint
      valu = this.word >>> 32 - bits; // :uint
      if (size > 32) {
        _logger.logger.error('Cannot read more than 32 bits at a time');
      }

      this.bitsAvailable -= bits;
      if (this.bitsAvailable > 0) {
        this.word <<= bits;
      } else if (this.bytesAvailable > 0) {
        this.loadWord();
      }

      bits = size - bits;
      if (bits > 0 && this.bitsAvailable) {
        return valu << bits | this.readBits(bits);
      } else {
        return valu;
      }
    }

    // ():uint

  }, {
    key: 'skipLZ',
    value: function skipLZ() {
      var leadingZeroCount = void 0; // :uint
      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
        if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {
          // the first bit of working word is 1
          this.word <<= leadingZeroCount;
          this.bitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      // we exhausted word and still have not found a 1
      this.loadWord();
      return leadingZeroCount + this.skipLZ();
    }

    // ():void

  }, {
    key: 'skipUEG',
    value: function skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():void

  }, {
    key: 'skipEG',
    value: function skipEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():uint

  }, {
    key: 'readUEG',
    value: function readUEG() {
      var clz = this.skipLZ(); // :uint
      return this.readBits(clz + 1) - 1;
    }

    // ():int

  }, {
    key: 'readEG',
    value: function readEG() {
      var valu = this.readUEG(); // :int
      if (0x01 & valu) {
        // the number is odd if the low order bit is set
        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
      } else {
        return -1 * (valu >>> 1); // divide by two then make it negative
      }
    }

    // Some convenience functions
    // :Boolean

  }, {
    key: 'readBoolean',
    value: function readBoolean() {
      return this.readBits(1) === 1;
    }

    // ():int

  }, {
    key: 'readUByte',
    value: function readUByte() {
      return this.readBits(8);
    }

    // ():int

  }, {
    key: 'readUShort',
    value: function readUShort() {
      return this.readBits(16);
    }
    // ():int

  }, {
    key: 'readUInt',
    value: function readUInt() {
      return this.readBits(32);
    }

    /**
     * Advance the ExpGolomb decoder past a scaling list. The scaling
     * list is optionally transmitted as part of a sequence parameter
     * set and is not relevant to transmuxing.
     * @param count {number} the number of entries in this scaling list
     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
     */

  }, {
    key: 'skipScalingList',
    value: function skipScalingList(count) {
      var lastScale = 8,
          nextScale = 8,
          j = void 0,
          deltaScale = void 0;
      for (j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = this.readEG();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    }

    /**
     * Read a sequence parameter set and return some interesting video
     * properties. A sequence parameter set is the H264 metadata that
     * describes the properties of upcoming video frames.
     * @param data {Uint8Array} the bytes of a sequence parameter set
     * @return {object} an object with configuration parsed from the
     * sequence parameter set, including the dimensions of the
     * associated video frames.
     */

  }, {
    key: 'readSPS',
    value: function readSPS() {
      var frameCropLeftOffset = 0,
          frameCropRightOffset = 0,
          frameCropTopOffset = 0,
          frameCropBottomOffset = 0,
          profileIdc = void 0,
          profileCompat = void 0,
          levelIdc = void 0,
          numRefFramesInPicOrderCntCycle = void 0,
          picWidthInMbsMinus1 = void 0,
          picHeightInMapUnitsMinus1 = void 0,
          frameMbsOnlyFlag = void 0,
          scalingListCount = void 0,
          i = void 0,
          readUByte = this.readUByte.bind(this),
          readBits = this.readBits.bind(this),
          readUEG = this.readUEG.bind(this),
          readBoolean = this.readBoolean.bind(this),
          skipBits = this.skipBits.bind(this),
          skipEG = this.skipEG.bind(this),
          skipUEG = this.skipUEG.bind(this),
          skipScalingList = this.skipScalingList.bind(this);

      readUByte();
      profileIdc = readUByte(); // profile_idc
      profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)
      skipBits(3); // reserved_zero_3bits u(3),
      levelIdc = readUByte(); // level_idc u(8)
      skipUEG(); // seq_parameter_set_id
      // some profiles have more optional data we don't need
      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
        var chromaFormatIdc = readUEG();
        if (chromaFormatIdc === 3) {
          skipBits(1);
        } // separate_colour_plane_flag

        skipUEG(); // bit_depth_luma_minus8
        skipUEG(); // bit_depth_chroma_minus8
        skipBits(1); // qpprime_y_zero_transform_bypass_flag
        if (readBoolean()) {
          // seq_scaling_matrix_present_flag
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i = 0; i < scalingListCount; i++) {
            if (readBoolean()) {
              // seq_scaling_list_present_flag[ i ]
              if (i < 6) {
                skipScalingList(16);
              } else {
                skipScalingList(64);
              }
            }
          }
        }
      }
      skipUEG(); // log2_max_frame_num_minus4
      var picOrderCntType = readUEG();
      if (picOrderCntType === 0) {
        readUEG(); // log2_max_pic_order_cnt_lsb_minus4
      } else if (picOrderCntType === 1) {
        skipBits(1); // delta_pic_order_always_zero_flag
        skipEG(); // offset_for_non_ref_pic
        skipEG(); // offset_for_top_to_bottom_field
        numRefFramesInPicOrderCntCycle = readUEG();
        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
          skipEG();
        } // offset_for_ref_frame[ i ]
      }
      skipUEG(); // max_num_ref_frames
      skipBits(1); // gaps_in_frame_num_value_allowed_flag
      picWidthInMbsMinus1 = readUEG();
      picHeightInMapUnitsMinus1 = readUEG();
      frameMbsOnlyFlag = readBits(1);
      if (frameMbsOnlyFlag === 0) {
        skipBits(1);
      } // mb_adaptive_frame_field_flag

      skipBits(1); // direct_8x8_inference_flag
      if (readBoolean()) {
        // frame_cropping_flag
        frameCropLeftOffset = readUEG();
        frameCropRightOffset = readUEG();
        frameCropTopOffset = readUEG();
        frameCropBottomOffset = readUEG();
      }
      var pixelRatio = [1, 1];
      if (readBoolean()) {
        // vui_parameters_present_flag
        if (readBoolean()) {
          // aspect_ratio_info_present_flag
          var aspectRatioIdc = readUByte();
          switch (aspectRatioIdc) {
            case 1:
              pixelRatio = [1, 1];break;
            case 2:
              pixelRatio = [12, 11];break;
            case 3:
              pixelRatio = [10, 11];break;
            case 4:
              pixelRatio = [16, 11];break;
            case 5:
              pixelRatio = [40, 33];break;
            case 6:
              pixelRatio = [24, 11];break;
            case 7:
              pixelRatio = [20, 11];break;
            case 8:
              pixelRatio = [32, 11];break;
            case 9:
              pixelRatio = [80, 33];break;
            case 10:
              pixelRatio = [18, 11];break;
            case 11:
              pixelRatio = [15, 11];break;
            case 12:
              pixelRatio = [64, 33];break;
            case 13:
              pixelRatio = [160, 99];break;
            case 14:
              pixelRatio = [4, 3];break;
            case 15:
              pixelRatio = [3, 2];break;
            case 16:
              pixelRatio = [2, 1];break;
            case 255:
              {
                pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
                break;
              }
          }
        }
      }
      return {
        width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
        pixelRatio: pixelRatio
      };
    }
  }, {
    key: 'readSliceType',
    value: function readSliceType() {
      // skip NALu type
      this.readUByte();
      // discard first_mb_in_slice
      this.readUEG();
      // return slice_type
      return this.readUEG();
    }
  }]);

  return ExpGolomb;
}();

exports.default = ExpGolomb;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/id3.js":
/*!*********************************!*\
  !*** ./src/hls.js/demux/id3.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * ID3 parser
 */
var ID3 = function () {
  function ID3() {
    _classCallCheck(this, ID3);
  }

  _createClass(ID3, null, [{
    key: 'isHeader',

    /**
     * Returns true if an ID3 header can be found at offset in data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {boolean} - True if an ID3 header is found
     */
    value: function isHeader(data, offset) {
      /*
      * http://id3.org/id3v2.3.0
      * [0]     = 'I'
      * [1]     = 'D'
      * [2]     = '3'
      * [3,4]   = {Version}
      * [5]     = {Flags}
      * [6-9]   = {ID3 Size}
      *
      * An ID3v2 tag can be detected with the following pattern:
      *  $49 44 33 yy yy xx zz zz zz zz
      * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80
      */
      if (offset + 10 <= data.length) {
        // look for 'ID3' identifier
        if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {
          // check version is within range
          if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
            // check size is within range
            if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
              return true;
            }
          }
        }
      }

      return false;
    }

    /**
     * Returns true if an ID3 footer can be found at offset in data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {boolean} - True if an ID3 footer is found
     */

  }, {
    key: 'isFooter',
    value: function isFooter(data, offset) {
      /*
      * The footer is a copy of the header, but with a different identifier
      */
      if (offset + 10 <= data.length) {
        // look for '3DI' identifier
        if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {
          // check version is within range
          if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
            // check size is within range
            if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
              return true;
            }
          }
        }
      }

      return false;
    }

    /**
     * Returns any adjacent ID3 tags found in data starting at offset, as one block of data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {Uint8Array} - The block of data containing any ID3 tags found
     */

  }, {
    key: 'getID3Data',
    value: function getID3Data(data, offset) {
      var front = offset;
      var length = 0;

      while (ID3.isHeader(data, offset)) {
        // ID3 header is 10 bytes
        length += 10;

        var size = ID3._readSize(data, offset + 6);
        length += size;

        if (ID3.isFooter(data, offset + 10)) {
          // ID3 footer is 10 bytes
          length += 10;
        }

        offset += length;
      }

      if (length > 0) {
        return data.subarray(front, front + length);
      }

      return undefined;
    }
  }, {
    key: '_readSize',
    value: function _readSize(data, offset) {
      var size = 0;
      size = (data[offset] & 0x7f) << 21;
      size |= (data[offset + 1] & 0x7f) << 14;
      size |= (data[offset + 2] & 0x7f) << 7;
      size |= data[offset + 3] & 0x7f;
      return size;
    }

    /**
     * Searches for the Elementary Stream timestamp found in the ID3 data chunk
     * @param {Uint8Array} data - Block of data containing one or more ID3 tags
     * @return {number} - The timestamp
     */

  }, {
    key: 'getTimeStamp',
    value: function getTimeStamp(data) {
      var frames = ID3.getID3Frames(data);
      for (var i = 0; i < frames.length; i++) {
        var frame = frames[i];
        if (ID3.isTimeStampFrame(frame)) {
          return ID3._readTimeStamp(frame);
        }
      }

      return undefined;
    }

    /**
     * Returns true if the ID3 frame is an Elementary Stream timestamp frame
     * @param {ID3 frame} frame
     */

  }, {
    key: 'isTimeStampFrame',
    value: function isTimeStampFrame(frame) {
      return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';
    }
  }, {
    key: '_getFrameData',
    value: function _getFrameData(data) {
      /*
      Frame ID       $xx xx xx xx (four characters)
      Size           $xx xx xx xx
      Flags          $xx xx
      */
      var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
      var size = ID3._readSize(data, 4);

      // skip frame id, size, and flags
      var offset = 10;

      return { type: type, size: size, data: data.subarray(offset, offset + size) };
    }

    /**
     * Returns an array of ID3 frames found in all the ID3 tags in the id3Data
     * @param {Uint8Array} id3Data - The ID3 data containing one or more ID3 tags
     * @return {ID3 frame[]} - Array of ID3 frame objects
     */

  }, {
    key: 'getID3Frames',
    value: function getID3Frames(id3Data) {
      var offset = 0;
      var frames = [];

      while (ID3.isHeader(id3Data, offset)) {
        var size = ID3._readSize(id3Data, offset + 6);
        // skip past ID3 header
        offset += 10;
        var end = offset + size;
        // loop through frames in the ID3 tag
        while (offset + 8 < end) {
          var frameData = ID3._getFrameData(id3Data.subarray(offset));
          var frame = ID3._decodeFrame(frameData);
          if (frame) {
            frames.push(frame);
          }

          // skip frame header and frame data
          offset += frameData.size + 10;
        }

        if (ID3.isFooter(id3Data, offset)) {
          offset += 10;
        }
      }

      return frames;
    }
  }, {
    key: '_decodeFrame',
    value: function _decodeFrame(frame) {
      if (frame.type === 'PRIV') {
        return ID3._decodePrivFrame(frame);
      } else if (frame.type[0] === 'T') {
        return ID3._decodeTextFrame(frame);
      } else if (frame.type[0] === 'W') {
        return ID3._decodeURLFrame(frame);
      }

      return undefined;
    }
  }, {
    key: '_readTimeStamp',
    value: function _readTimeStamp(timeStampFrame) {
      if (timeStampFrame.data.byteLength === 8) {
        var data = new Uint8Array(timeStampFrame.data);
        // timestamp is 33 bit expressed as a big-endian eight-octet number,
        // with the upper 31 bits set to zero.
        var pts33Bit = data[3] & 0x1;
        var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
        timestamp /= 45;

        if (pts33Bit) {
          timestamp += 47721858.84;
        } // 2^32 / 90

        return Math.round(timestamp);
      }

      return undefined;
    }
  }, {
    key: '_decodePrivFrame',
    value: function _decodePrivFrame(frame) {
      /*
      Format: <text string>\0<binary data>
      */
      if (frame.size < 2) {
        return undefined;
      }

      var owner = ID3._utf8ArrayToStr(frame.data, true);
      var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));

      return { key: frame.type, info: owner, data: privateData.buffer };
    }
  }, {
    key: '_decodeTextFrame',
    value: function _decodeTextFrame(frame) {
      if (frame.size < 2) {
        return undefined;
      }

      if (frame.type === 'TXXX') {
        /*
        Format:
        [0]   = {Text Encoding}
        [1-?] = {Description}\0{Value}
        */
        var index = 1;
        var description = ID3._utf8ArrayToStr(frame.data.subarray(index));

        index += description.length + 1;
        var value = ID3._utf8ArrayToStr(frame.data.subarray(index));

        return { key: frame.type, info: description, data: value };
      } else {
        /*
        Format:
        [0]   = {Text Encoding}
        [1-?] = {Value}
        */
        var text = ID3._utf8ArrayToStr(frame.data.subarray(1));
        return { key: frame.type, data: text };
      }
    }
  }, {
    key: '_decodeURLFrame',
    value: function _decodeURLFrame(frame) {
      if (frame.type === 'WXXX') {
        /*
        Format:
        [0]   = {Text Encoding}
        [1-?] = {Description}\0{URL}
        */
        if (frame.size < 2) {
          return undefined;
        }

        var index = 1;
        var description = ID3._utf8ArrayToStr(frame.data.subarray(index));

        index += description.length + 1;
        var value = ID3._utf8ArrayToStr(frame.data.subarray(index));

        return { key: frame.type, info: description, data: value };
      } else {
        /*
        Format:
        [0-?] = {URL}
        */
        var url = ID3._utf8ArrayToStr(frame.data);
        return { key: frame.type, data: url };
      }
    }

    // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
    // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
    /* utf.js - UTF-8 <=> UTF-16 convertion
     *
     * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
     * Version: 1.0
     * LastModified: Dec 25 1999
     * This library is free.  You can redistribute it and/or modify it.
     */

  }, {
    key: '_utf8ArrayToStr',
    value: function _utf8ArrayToStr(array) {
      var exitOnNull = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var len = array.length;
      var c = void 0;
      var char2 = void 0;
      var char3 = void 0;
      var out = '';
      var i = 0;
      while (i < len) {
        c = array[i++];
        if (c === 0x00 && exitOnNull) {
          return out;
        } else if (c === 0x00 || c === 0x03) {
          // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it
          continue;
        }
        switch (c >> 4) {
          case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:
            // 0xxxxxxx
            out += String.fromCharCode(c);
            break;
          case 12:case 13:
            // 110x xxxx   10xx xxxx
            char2 = array[i++];
            out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);
            break;
          case 14:
            // 1110 xxxx  10xx xxxx  10xx xxxx
            char2 = array[i++];
            char3 = array[i++];
            out += String.fromCharCode((c & 0x0F) << 12 | (char2 & 0x3F) << 6 | (char3 & 0x3F) << 0);
            break;
          default:
        }
      }
      return out;
    }
  }]);

  return ID3;
}();

var utf8ArrayToStr = ID3._utf8ArrayToStr;

exports.default = ID3;
exports.utf8ArrayToStr = utf8ArrayToStr;

/***/ }),

/***/ "./src/hls.js/demux/mp3demuxer.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/mp3demuxer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * MP3 demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _id = __webpack_require__(/*! ../demux/id3 */ "./src/hls.js/demux/id3.js");

var _id2 = _interopRequireDefault(_id);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _mpegaudio = __webpack_require__(/*! ./mpegaudio */ "./src/hls.js/demux/mpegaudio.js");

var _mpegaudio2 = _interopRequireDefault(_mpegaudio);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MP3Demuxer = function () {
  function MP3Demuxer(observer, remuxer, config) {
    _classCallCheck(this, MP3Demuxer);

    this.observer = observer;
    this.config = config;
    this.remuxer = remuxer;
  }

  _createClass(MP3Demuxer, [{
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this._audioTrack = { container: 'audio/mpeg', type: 'audio', id: -1, sequenceNumber: 0, isAAC: false, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
    }
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var id3Data = _id2.default.getID3Data(data, 0);
      var timestamp = _id2.default.getTimeStamp(id3Data);
      var pts = timestamp ? 90 * timestamp : timeOffset * 90000;
      var offset = id3Data.length;
      var length = data.length;
      var frameIndex = 0,
          stamp = 0;
      var track = this._audioTrack;

      var id3Samples = [{ pts: pts, dts: pts, data: id3Data }];

      while (offset < length) {
        if (_mpegaudio2.default.isHeader(data, offset)) {
          var frame = _mpegaudio2.default.appendFrame(track, data, offset, pts, frameIndex);
          if (frame) {
            offset += frame.length;
            stamp = frame.sample.pts;
            frameIndex++;
          } else {
            // logger.log('Unable to parse Mpeg audio frame');
            break;
          }
        } else if (_id2.default.isHeader(data, offset)) {
          id3Data = _id2.default.getID3Data(data, offset);
          id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
          offset += id3Data.length;
        } else {
          // nothing found, keep looking
          offset++;
        }
      }

      this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      // check if data contains ID3 timestamp and MPEG sync word
      var offset = void 0,
          length = void 0;
      var id3Data = _id2.default.getID3Data(data, 0);
      if (id3Data && _id2.default.getTimeStamp(id3Data) !== undefined) {
        // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
        // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
        // More info http://www.mp3-tech.org/programmer/frame_header.html
        for (offset = id3Data.length, length = Math.min(data.length - 1, offset + 100); offset < length; offset++) {
          if (_mpegaudio2.default.probe(data, offset)) {
            _logger.logger.log('MPEG Audio sync word found !');
            return true;
          }
        }
      }
      return false;
    }
  }]);

  return MP3Demuxer;
}();

exports.default = MP3Demuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/mp4demuxer.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/mp4demuxer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * MP4 demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UINT32_MAX = Math.pow(2, 32) - 1;

var MP4Demuxer = function () {
  function MP4Demuxer(observer, remuxer) {
    _classCallCheck(this, MP4Demuxer);

    this.observer = observer;
    this.remuxer = remuxer;
  }

  _createClass(MP4Demuxer, [{
    key: 'resetTimeStamp',
    value: function resetTimeStamp(initPTS) {
      this.initPTS = initPTS;
    }
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      // jshint unused:false
      if (initSegment && initSegment.byteLength) {
        var initData = this.initData = MP4Demuxer.parseInitSegment(initSegment);

        // default audio codec if nothing specified
        // TODO : extract that from initsegment
        if (audioCodec == null) {
          audioCodec = 'mp4a.40.5';
        }

        if (videoCodec == null) {
          videoCodec = 'avc1.42e01e';
        }

        var tracks = {};
        if (initData.audio && initData.video) {
          tracks.audiovideo = { container: 'video/mp4', codec: audioCodec + ',' + videoCodec, initSegment: duration ? initSegment : null };
        } else {
          if (initData.audio) {
            tracks.audio = { container: 'audio/mp4', codec: audioCodec, initSegment: duration ? initSegment : null };
          }

          if (initData.video) {
            tracks.video = { container: 'video/mp4', codec: videoCodec, initSegment: duration ? initSegment : null };
          }
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, { tracks: tracks });
      } else {
        if (audioCodec) {
          this.audioCodec = audioCodec;
        }

        if (videoCodec) {
          this.videoCodec = videoCodec;
        }
      }
    }
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var initData = this.initData;
      if (!initData) {
        this.resetInitSegment(data, this.audioCodec, this.videoCodec, false);
        initData = this.initData;
      }
      var startDTS = void 0,
          initPTS = this.initPTS;
      if (initPTS === undefined) {
        var _startDTS = MP4Demuxer.getStartDTS(initData, data);
        this.initPTS = initPTS = _startDTS - timeOffset;
        this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });
      }
      MP4Demuxer.offsetStartDTS(initData, data, initPTS);
      startDTS = MP4Demuxer.getStartDTS(initData, data);
      this.remuxer.remux(initData.audio, initData.video, null, null, startDTS, contiguous, accurateTimeOffset, data);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      // ensure we find a moof box in the first 16 kB
      return MP4Demuxer.findBox({ data: data, start: 0, end: Math.min(data.length, 16384) }, ['moof']).length > 0;
    }
  }, {
    key: 'bin2str',
    value: function bin2str(buffer) {
      return String.fromCharCode.apply(null, buffer);
    }
  }, {
    key: 'readUint16',
    value: function readUint16(buffer, offset) {
      if (buffer.data) {
        offset += buffer.start;
        buffer = buffer.data;
      }

      var val = buffer[offset] << 8 | buffer[offset + 1];

      return val < 0 ? 65536 + val : val;
    }
  }, {
    key: 'readUint32',
    value: function readUint32(buffer, offset) {
      if (buffer.data) {
        offset += buffer.start;
        buffer = buffer.data;
      }

      var val = buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
      return val < 0 ? 4294967296 + val : val;
    }
  }, {
    key: 'writeUint32',
    value: function writeUint32(buffer, offset, value) {
      if (buffer.data) {
        offset += buffer.start;
        buffer = buffer.data;
      }
      buffer[offset] = value >> 24;
      buffer[offset + 1] = value >> 16 & 0xff;
      buffer[offset + 2] = value >> 8 & 0xff;
      buffer[offset + 3] = value & 0xff;
    }

    // Find the data for a box specified by its path

  }, {
    key: 'findBox',
    value: function findBox(data, path) {
      var results = [],
          i = void 0,
          size = void 0,
          type = void 0,
          end = void 0,
          subresults = void 0,
          start = void 0,
          endbox = void 0;

      if (data.data) {
        start = data.start;
        end = data.end;
        data = data.data;
      } else {
        start = 0;
        end = data.byteLength;
      }

      if (!path.length) {
        // short-circuit the search for empty paths
        return null;
      }

      for (i = start; i < end;) {
        size = MP4Demuxer.readUint32(data, i);
        type = MP4Demuxer.bin2str(data.subarray(i + 4, i + 8));
        endbox = size > 1 ? i + size : end;

        if (type === path[0]) {
          if (path.length === 1) {
            // this is the end of the path and we've found the box we were
            // looking for
            results.push({ data: data, start: i + 8, end: endbox });
          } else {
            // recursively search for the next box along the path
            subresults = MP4Demuxer.findBox({ data: data, start: i + 8, end: endbox }, path.slice(1));
            if (subresults.length) {
              results = results.concat(subresults);
            }
          }
        }
        i = endbox;
      }

      // we've finished searching all of data
      return results;
    }
  }, {
    key: 'parseSegmentIndex',
    value: function parseSegmentIndex(initSegment) {
      var moov = MP4Demuxer.findBox(initSegment, ['moov'])[0];
      var moovEndOffset = moov ? moov.end : null; // we need this in case we need to chop of garbage of the end of current data

      var index = 0;
      var sidx = MP4Demuxer.findBox(initSegment, ['sidx']);
      var references = void 0;

      if (!sidx || !sidx[0]) {
        return null;
      }

      references = [];
      sidx = sidx[0];

      var version = sidx.data[0];

      // set initial offset, we skip the reference ID (not needed)
      index = version === 0 ? 8 : 16;

      var timescale = MP4Demuxer.readUint32(sidx, index);
      index += 4;

      // TODO: parse earliestPresentationTime and firstOffset
      // usually zero in our case
      var earliestPresentationTime = 0;
      var firstOffset = 0;

      if (version === 0) {
        index += 8;
      } else {
        index += 16;
      }

      // skip reserved
      index += 2;

      var startByte = sidx.end + firstOffset;

      var referencesCount = MP4Demuxer.readUint16(sidx, index);
      index += 2;

      for (var i = 0; i < referencesCount; i++) {
        var referenceIndex = index;

        var referenceInfo = MP4Demuxer.readUint32(sidx, referenceIndex);
        referenceIndex += 4;

        var referenceSize = referenceInfo & 0x7FFFFFFF;
        var referenceType = (referenceInfo & 0x80000000) >>> 31;

        if (referenceType === 1) {
          console.warn('SIDX has hierarchical references (not supported)');
          return;
        }

        var subsegmentDuration = MP4Demuxer.readUint32(sidx, referenceIndex);
        referenceIndex += 4;

        references.push({
          referenceSize: referenceSize,
          subsegmentDuration: subsegmentDuration, // unscaled
          info: {
            duration: subsegmentDuration / timescale,
            start: startByte,
            end: startByte + referenceSize - 1
          }
        });

        startByte += referenceSize;

        // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits
        // for |sapDelta|.
        referenceIndex += 4;

        // skip to next ref
        index = referenceIndex;
      }

      return {
        earliestPresentationTime: earliestPresentationTime,
        timescale: timescale,
        version: version,
        referencesCount: referencesCount,
        references: references,
        moovEndOffset: moovEndOffset
      };
    }

    /**
     * Parses an MP4 initialization segment and extracts stream type and
     * timescale values for any declared tracks. Timescale values indicate the
     * number of clock ticks per second to assume for time-based values
     * elsewhere in the MP4.
     *
     * To determine the start time of an MP4, you need two pieces of
     * information: the timescale unit and the earliest base media decode
     * time. Multiple timescales can be specified within an MP4 but the
     * base media decode time is always expressed in the timescale from
     * the media header box for the track:
     * ```
     * moov > trak > mdia > mdhd.timescale
     * moov > trak > mdia > hdlr
     * ```
     * @param init {Uint8Array} the bytes of the init segment
     * @return {object} a hash of track type to timescale values or null if
     * the init segment is malformed.
     */

  }, {
    key: 'parseInitSegment',
    value: function parseInitSegment(initSegment) {
      var result = [];
      var traks = MP4Demuxer.findBox(initSegment, ['moov', 'trak']);

      traks.forEach(function (trak) {
        var tkhd = MP4Demuxer.findBox(trak, ['tkhd'])[0];
        if (tkhd) {
          var version = tkhd.data[tkhd.start];
          var index = version === 0 ? 12 : 20;
          var trackId = MP4Demuxer.readUint32(tkhd, index);

          var mdhd = MP4Demuxer.findBox(trak, ['mdia', 'mdhd'])[0];
          if (mdhd) {
            version = mdhd.data[mdhd.start];
            index = version === 0 ? 12 : 20;
            var timescale = MP4Demuxer.readUint32(mdhd, index);

            var hdlr = MP4Demuxer.findBox(trak, ['mdia', 'hdlr'])[0];
            if (hdlr) {
              var hdlrType = MP4Demuxer.bin2str(hdlr.data.subarray(hdlr.start + 8, hdlr.start + 12));
              var type = { 'soun': 'audio', 'vide': 'video' }[hdlrType];
              if (type) {
                // extract codec info. TODO : parse codec details to be able to build MIME type
                var codecBox = MP4Demuxer.findBox(trak, ['mdia', 'minf', 'stbl', 'stsd']);
                if (codecBox.length) {
                  codecBox = codecBox[0];
                  var codecType = MP4Demuxer.bin2str(codecBox.data.subarray(codecBox.start + 12, codecBox.start + 16));
                  _logger.logger.log('MP4Demuxer:' + type + ':' + codecType + ' found');
                }
                result[trackId] = { timescale: timescale, type: type };
                result[type] = { timescale: timescale, id: trackId };
              }
            }
          }
        }
      });
      return result;
    }

    /**
    * Determine the base media decode start time, in seconds, for an MP4
    * fragment. If multiple fragments are specified, the earliest time is
    * returned.
    *
    * The base media decode time can be parsed from track fragment
    * metadata:
    * ```
    * moof > traf > tfdt.baseMediaDecodeTime
    * ```
    * It requires the timescale value from the mdhd to interpret.
    *
    * @param timescale {object} a hash of track ids to timescale values.
    * @return {number} the earliest base media decode start time for the
    * fragment, in seconds
    */

  }, {
    key: 'getStartDTS',
    value: function getStartDTS(initData, fragment) {
      var trafs = void 0,
          baseTimes = void 0,
          result = void 0;

      // we need info from two childrend of each track fragment box
      trafs = MP4Demuxer.findBox(fragment, ['moof', 'traf']);

      // determine the start times for each track
      baseTimes = [].concat.apply([], trafs.map(function (traf) {
        return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
          var id = void 0,
              scale = void 0,
              baseTime = void 0;

          // get the track id from the tfhd
          id = MP4Demuxer.readUint32(tfhd, 4);
          // assume a 90kHz clock if no timescale was specified
          scale = initData[id].timescale || 90e3;

          // get the base media decode time from the tfdt
          baseTime = MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
            var version = void 0,
                result = void 0;

            version = tfdt.data[tfdt.start];
            result = MP4Demuxer.readUint32(tfdt, 4);
            if (version === 1) {
              result *= Math.pow(2, 32);

              result += MP4Demuxer.readUint32(tfdt, 8);
            }
            return result;
          })[0];
          // convert base time to seconds
          return baseTime / scale;
        });
      }));

      // return the minimum
      result = Math.min.apply(null, baseTimes);
      return isFinite(result) ? result : 0;
    }
  }, {
    key: 'offsetStartDTS',
    value: function offsetStartDTS(initData, fragment, timeOffset) {
      MP4Demuxer.findBox(fragment, ['moof', 'traf']).map(function (traf) {
        return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
          // get the track id from the tfhd
          var id = MP4Demuxer.readUint32(tfhd, 4);
          // assume a 90kHz clock if no timescale was specified
          var timescale = initData[id].timescale || 90e3;

          // get the base media decode time from the tfdt
          MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
            var version = tfdt.data[tfdt.start];
            var baseMediaDecodeTime = MP4Demuxer.readUint32(tfdt, 4);
            if (version === 0) {
              MP4Demuxer.writeUint32(tfdt, 4, baseMediaDecodeTime - timeOffset * timescale);
            } else {
              baseMediaDecodeTime *= Math.pow(2, 32);
              baseMediaDecodeTime += MP4Demuxer.readUint32(tfdt, 8);
              baseMediaDecodeTime -= timeOffset * timescale;
              baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
              var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
              var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
              MP4Demuxer.writeUint32(tfdt, 4, upper);
              MP4Demuxer.writeUint32(tfdt, 8, lower);
            }
          });
        });
      });
    }
  }]);

  return MP4Demuxer;
}();

exports.default = MP4Demuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/mpegaudio.js":
/*!***************************************!*\
  !*** ./src/hls.js/demux/mpegaudio.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 *  MPEG parser helper
 */

var MpegAudio = {

  BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],

  SamplingRateMap: [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000],

  SamplesCoefficients: [
  // MPEG 2.5
  [0, // Reserved
  72, // Layer3
  144, // Layer2
  12 // Layer1
  ],
  // Reserved
  [0, // Reserved
  0, // Layer3
  0, // Layer2
  0 // Layer1
  ],
  // MPEG 2
  [0, // Reserved
  72, // Layer3
  144, // Layer2
  12 // Layer1
  ],
  // MPEG 1
  [0, // Reserved
  144, // Layer3
  144, // Layer2
  12 // Layer1
  ]],

  BytesInSlot: [0, // Reserved
  1, // Layer3
  1, // Layer2
  4 // Layer1
  ],

  appendFrame: function appendFrame(track, data, offset, pts, frameIndex) {
    // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
    if (offset + 24 > data.length) {
      return undefined;
    }

    var header = this.parseHeader(data, offset);
    if (header && offset + header.frameLength <= data.length) {
      var frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;
      var stamp = pts + frameIndex * frameDuration;
      var sample = { unit: data.subarray(offset, offset + header.frameLength), pts: stamp, dts: stamp };

      track.config = [];
      track.channelCount = header.channelCount;
      track.samplerate = header.sampleRate;
      track.samples.push(sample);
      track.len += header.frameLength;

      return { sample: sample, length: header.frameLength };
    }

    return undefined;
  },

  parseHeader: function parseHeader(data, offset) {
    var headerB = data[offset + 1] >> 3 & 3;
    var headerC = data[offset + 1] >> 1 & 3;
    var headerE = data[offset + 2] >> 4 & 15;
    var headerF = data[offset + 2] >> 2 & 3;
    var headerG = data[offset + 2] >> 1 & 1;
    if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {
      var columnInBitrates = headerB === 3 ? 3 - headerC : headerC === 3 ? 3 : 4;
      var bitRate = MpegAudio.BitratesMap[columnInBitrates * 14 + headerE - 1] * 1000;
      var columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;
      var sampleRate = MpegAudio.SamplingRateMap[columnInSampleRates * 3 + headerF];
      var channelCount = data[offset + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)
      var sampleCoefficient = MpegAudio.SamplesCoefficients[headerB][headerC];
      var bytesInSlot = MpegAudio.BytesInSlot[headerC];
      var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
      var frameLength = parseInt(sampleCoefficient * bitRate / sampleRate + headerG, 10) * bytesInSlot;

      return { sampleRate: sampleRate, channelCount: channelCount, frameLength: frameLength, samplesPerFrame: samplesPerFrame };
    }

    return undefined;
  },

  isHeaderPattern: function isHeaderPattern(data, offset) {
    return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;
  },

  isHeader: function isHeader(data, offset) {
    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
    // More info http://www.mp3-tech.org/programmer/frame_header.html
    if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
      return true;
    }

    return false;
  },

  probe: function probe(data, offset) {
    // same as isHeader but we also check that MPEG frame follows last MPEG frame
    // or end of data is reached
    if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
      // MPEG header Length
      var headerLength = 4;
      // MPEG frame Length
      var header = this.parseHeader(data, offset);
      var frameLength = headerLength;
      if (header && header.frameLength) {
        frameLength = header.frameLength;
      }

      var newOffset = offset + frameLength;
      if (newOffset === data.length || newOffset + 1 < data.length && this.isHeaderPattern(data, newOffset)) {
        return true;
      }
    }
    return false;
  }
};

exports.default = MpegAudio;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/demux/sample-aes.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/sample-aes.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SAMPLE-AES decrypter
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _decrypter = __webpack_require__(/*! ../crypt/decrypter */ "./src/hls.js/crypt/decrypter.js");

var _decrypter2 = _interopRequireDefault(_decrypter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SampleAesDecrypter = function () {
  function SampleAesDecrypter(observer, config, decryptdata, discardEPB) {
    _classCallCheck(this, SampleAesDecrypter);

    this.decryptdata = decryptdata;
    this.discardEPB = discardEPB;
    this.decrypter = new _decrypter2.default(observer, config, { removePKCS7Padding: false });
  }

  _createClass(SampleAesDecrypter, [{
    key: 'decryptBuffer',
    value: function decryptBuffer(encryptedData, callback) {
      this.decrypter.decrypt(encryptedData, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, callback);
    }

    // AAC - encrypt all full 16 bytes blocks starting from offset 16

  }, {
    key: 'decryptAacSample',
    value: function decryptAacSample(samples, sampleIndex, callback, sync) {
      var curUnit = samples[sampleIndex].unit;
      var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
      var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);

      var localthis = this;
      this.decryptBuffer(encryptedBuffer, function (decryptedData) {
        decryptedData = new Uint8Array(decryptedData);
        curUnit.set(decryptedData, 16);

        if (!sync) {
          localthis.decryptAacSamples(samples, sampleIndex + 1, callback);
        }
      });
    }
  }, {
    key: 'decryptAacSamples',
    value: function decryptAacSamples(samples, sampleIndex, callback) {
      for (;; sampleIndex++) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }

        if (samples[sampleIndex].unit.length < 32) {
          continue;
        }

        var sync = this.decrypter.isSync();

        this.decryptAacSample(samples, sampleIndex, callback, sync);

        if (!sync) {
          return;
        }
      }
    }

    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32

  }, {
    key: 'getAvcEncryptedData',
    value: function getAvcEncryptedData(decodedData) {
      var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
      var encryptedData = new Int8Array(encryptedDataLen);
      var outputPos = 0;
      for (var inputPos = 32; inputPos <= decodedData.length - 16; inputPos += 160, outputPos += 16) {
        encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
      }

      return encryptedData;
    }
  }, {
    key: 'getAvcDecryptedUnit',
    value: function getAvcDecryptedUnit(decodedData, decryptedData) {
      decryptedData = new Uint8Array(decryptedData);
      var inputPos = 0;
      for (var outputPos = 32; outputPos <= decodedData.length - 16; outputPos += 160, inputPos += 16) {
        decodedData.set(decryptedData.subarray(inputPos, inputPos + 16), outputPos);
      }

      return decodedData;
    }
  }, {
    key: 'decryptAvcSample',
    value: function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync) {
      var decodedData = this.discardEPB(curUnit.data);
      var encryptedData = this.getAvcEncryptedData(decodedData);
      var localthis = this;

      this.decryptBuffer(encryptedData.buffer, function (decryptedData) {
        curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedData);

        if (!sync) {
          localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
        }
      });
    }
  }, {
    key: 'decryptAvcSamples',
    value: function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
      for (;; sampleIndex++, unitIndex = 0) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }

        var curUnits = samples[sampleIndex].units;
        for (;; unitIndex++) {
          if (unitIndex >= curUnits.length) {
            break;
          }

          var curUnit = curUnits[unitIndex];
          if (curUnit.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
            continue;
          }

          var sync = this.decrypter.isSync();

          this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);

          if (!sync) {
            return;
          }
        }
      }
    }
  }]);

  return SampleAesDecrypter;
}();

exports.default = SampleAesDecrypter;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/tsdemuxer.js":
/*!***************************************!*\
  !*** ./src/hls.js/demux/tsdemuxer.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * highly optimized TS demuxer:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * parse PAT, PMT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract PES packet from audio and video PIDs
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * trigger the remuxer upon parsing completion
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also controls the remuxing process :
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

// import Hex from '../utils/hex';


var _adts = __webpack_require__(/*! ./adts */ "./src/hls.js/demux/adts.js");

var ADTS = _interopRequireWildcard(_adts);

var _mpegaudio = __webpack_require__(/*! ./mpegaudio */ "./src/hls.js/demux/mpegaudio.js");

var _mpegaudio2 = _interopRequireDefault(_mpegaudio);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _expGolomb = __webpack_require__(/*! ./exp-golomb */ "./src/hls.js/demux/exp-golomb.js");

var _expGolomb2 = _interopRequireDefault(_expGolomb);

var _sampleAes = __webpack_require__(/*! ./sample-aes */ "./src/hls.js/demux/sample-aes.js");

var _sampleAes2 = _interopRequireDefault(_sampleAes);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// We are using fixed track IDs for driving the MP4 remuxer
// instead of following the TS PIDs.
// There is no reason not to do this and some browsers/SourceBuffer-demuxers
// may not like if there are TrackID "switches"
// See https://github.com/video-dev/hls.js/issues/1331
// Here we are mapping our internal track types to constant MP4 track IDs
// With MSE currently one can only have one track of each, and we are muxing
// whatever video/audio rendition in them.
var RemuxerTrackIdConfig = {
  video: 1,
  audio: 2,
  id3: 3,
  text: 4
};

var TSDemuxer = function () {
  function TSDemuxer(observer, remuxer, config, typeSupported) {
    _classCallCheck(this, TSDemuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    this.remuxer = remuxer;
    this.sampleAes = null;
  }

  _createClass(TSDemuxer, [{
    key: 'setDecryptData',
    value: function setDecryptData(decryptdata) {
      if (decryptdata != null && decryptdata.key != null && decryptdata.method === 'SAMPLE-AES') {
        this.sampleAes = new _sampleAes2.default(this.observer, this.config, decryptdata, this.discardEPB);
      } else {
        this.sampleAes = null;
      }
    }
  }, {
    key: 'resetInitSegment',


    /**
     * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
     * Resets all internal track instances of the demuxer.
     *
     * @override Implements generic demuxing/remuxing interface (see DemuxerInline)
     * @param {object} initSegment
     * @param {string} audioCodec
     * @param {string} videoCodec
     * @param {number} duration (in TS timescale = 90kHz)
     */
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this.pmtParsed = false;
      this._pmtId = -1;

      this._avcTrack = TSDemuxer.createTrack('video', duration);
      this._audioTrack = TSDemuxer.createTrack('audio', duration);
      this._id3Track = TSDemuxer.createTrack('id3', duration);
      this._txtTrack = TSDemuxer.createTrack('text', duration);

      // flush any partial content
      this.aacOverFlow = null;
      this.aacLastPTS = null;
      this.avcSample = null;
      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this._duration = duration;
    }

    /**
     *
     * @override
     */

  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}

    // feed incoming data to the front of the parsing pipeline

  }, {
    key: 'append',
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var start = void 0,
          len = data.length,
          stt = void 0,
          pid = void 0,
          atf = void 0,
          offset = void 0,
          pes = void 0,
          unknownPIDs = false;
      this.contiguous = contiguous;
      var pmtParsed = this.pmtParsed,
          avcTrack = this._avcTrack,
          audioTrack = this._audioTrack,
          id3Track = this._id3Track,
          avcId = avcTrack.pid,
          audioId = audioTrack.pid,
          id3Id = id3Track.pid,
          pmtId = this._pmtId,
          avcData = avcTrack.pesData,
          audioData = audioTrack.pesData,
          id3Data = id3Track.pesData,
          parsePAT = this._parsePAT,
          parsePMT = this._parsePMT,
          parsePES = this._parsePES,
          parseAVCPES = this._parseAVCPES.bind(this),
          parseAACPES = this._parseAACPES.bind(this),
          parseMPEGPES = this._parseMPEGPES.bind(this),
          parseID3PES = this._parseID3PES.bind(this);

      var syncOffset = TSDemuxer._syncOffset(data);

      // don't parse last TS packet if incomplete
      len -= (len + syncOffset) % 188;

      // loop through TS packets
      for (start = syncOffset; start < len; start += 188) {
        if (data[start] === 0x47) {
          stt = !!(data[start + 1] & 0x40);
          // pid is a 13-bit field starting at the last bit of TS[1]
          pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
          atf = (data[start + 3] & 0x30) >> 4;
          // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
          if (atf > 1) {
            offset = start + 5 + data[start + 4];
            // continue if there is only adaptation field
            if (offset === start + 188) {
              continue;
            }
          } else {
            offset = start + 4;
          }
          switch (pid) {
            case avcId:
              if (stt) {
                if (avcData && (pes = parsePES(avcData)) && pes.pts !== undefined) {
                  parseAVCPES(pes, false);
                }

                avcData = { data: [], size: 0 };
              }
              if (avcData) {
                avcData.data.push(data.subarray(offset, start + 188));
                avcData.size += start + 188 - offset;
              }
              break;
            case audioId:
              if (stt) {
                if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {
                  if (audioTrack.isAAC) {
                    parseAACPES(pes);
                  } else {
                    parseMPEGPES(pes);
                  }
                }
                audioData = { data: [], size: 0 };
              }
              if (audioData) {
                audioData.data.push(data.subarray(offset, start + 188));
                audioData.size += start + 188 - offset;
              }
              break;
            case id3Id:
              if (stt) {
                if (id3Data && (pes = parsePES(id3Data)) && pes.pts !== undefined) {
                  parseID3PES(pes);
                }

                id3Data = { data: [], size: 0 };
              }
              if (id3Data) {
                id3Data.data.push(data.subarray(offset, start + 188));
                id3Data.size += start + 188 - offset;
              }
              break;
            case 0:
              if (stt) {
                offset += data[offset] + 1;
              }

              pmtId = this._pmtId = parsePAT(data, offset);
              break;
            case pmtId:
              if (stt) {
                offset += data[offset] + 1;
              }

              var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, this.sampleAes != null);

              // only update track id if track PID found while parsing PMT
              // this is to avoid resetting the PID to -1 in case
              // track PID transiently disappears from the stream
              // this could happen in case of transient missing audio samples for example
              // NOTE this is only the PID of the track as found in TS,
              // but we are not using this for MP4 track IDs.
              avcId = parsedPIDs.avc;
              if (avcId > 0) {
                avcTrack.pid = avcId;
              }

              audioId = parsedPIDs.audio;
              if (audioId > 0) {
                audioTrack.pid = audioId;
                audioTrack.isAAC = parsedPIDs.isAAC;
              }
              id3Id = parsedPIDs.id3;
              if (id3Id > 0) {
                id3Track.pid = id3Id;
              }

              if (unknownPIDs && !pmtParsed) {
                _logger.logger.log('reparse from beginning');
                unknownPIDs = false;
                // we set it to -188, the += 188 in the for loop will reset start to 0
                start = syncOffset - 188;
              }
              pmtParsed = this.pmtParsed = true;
              break;
            case 17:
            case 0x1fff:
              break;
            default:
              unknownPIDs = true;
              break;
          }
        } else {
          this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });
        }
      }
      // try to parse last PES packets
      if (avcData && (pes = parsePES(avcData)) && pes.pts !== undefined) {
        parseAVCPES(pes, true);
        avcTrack.pesData = null;
      } else {
        // either avcData null or PES truncated, keep it for next frag parsing
        avcTrack.pesData = avcData;
      }

      if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {
        if (audioTrack.isAAC) {
          parseAACPES(pes);
        } else {
          parseMPEGPES(pes);
        }

        audioTrack.pesData = null;
      } else {
        if (audioData && audioData.size) {
          _logger.logger.log('last AAC PES packet truncated,might overlap between fragments');
        }

        // either audioData null or PES truncated, keep it for next frag parsing
        audioTrack.pesData = audioData;
      }

      if (id3Data && (pes = parsePES(id3Data)) && pes.pts !== undefined) {
        parseID3PES(pes);
        id3Track.pesData = null;
      } else {
        // either id3Data null or PES truncated, keep it for next frag parsing
        id3Track.pesData = id3Data;
      }

      if (this.sampleAes == null) {
        this.remuxer.remux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
      } else {
        this.decryptAndRemux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'decryptAndRemux',
    value: function decryptAndRemux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      if (audioTrack.samples && audioTrack.isAAC) {
        var localthis = this;
        this.sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {
          localthis.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
        });
      } else {
        this.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'decryptAndRemuxAvc',
    value: function decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      if (videoTrack.samples) {
        var localthis = this;
        this.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {
          localthis.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
        });
      } else {
        this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this._initPTS = this._initDTS = undefined;
      this._duration = 0;
    }
  }, {
    key: '_parsePAT',
    value: function _parsePAT(data, offset) {
      // skip the PSI header and parse the first PMT entry
      return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];
      // logger.log('PMT PID:'  + this._pmtId);
    }
  }, {
    key: '_parsePMT',
    value: function _parsePMT(data, offset, mpegSupported, isSampleAes) {
      var sectionLength = void 0,
          tableEnd = void 0,
          programInfoLength = void 0,
          pid = void 0,
          result = { audio: -1, avc: -1, id3: -1, isAAC: true };
      sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
      tableEnd = offset + 3 + sectionLength - 4;
      // to determine where the table is, we have to figure out how
      // long the program info descriptors are
      programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
      // advance the offset to the first entry in the mapping table
      offset += 12 + programInfoLength;
      while (offset < tableEnd) {
        pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];
        switch (data[offset]) {
          case 0xcf:
            // SAMPLE-AES AAC
            if (!isSampleAes) {
              _logger.logger.log('unkown stream type:' + data[offset]);
              break;
            }
          /* falls through */

          // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
          case 0x0f:
            // logger.log('AAC PID:'  + pid);
            if (result.audio === -1) {
              result.audio = pid;
            }

            break;

          // Packetized metadata (ID3)
          case 0x15:
            // logger.log('ID3 PID:'  + pid);
            if (result.id3 === -1) {
              result.id3 = pid;
            }

            break;

          case 0xdb:
            // SAMPLE-AES AVC
            if (!isSampleAes) {
              _logger.logger.log('unkown stream type:' + data[offset]);
              break;
            }
          /* falls through */

          // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
          case 0x1b:
            // logger.log('AVC PID:'  + pid);
            if (result.avc === -1) {
              result.avc = pid;
            }

            break;

          // ISO/IEC 11172-3 (MPEG-1 audio)
          // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
          case 0x03:
          case 0x04:
            // logger.log('MPEG PID:'  + pid);
            if (!mpegSupported) {
              _logger.logger.log('MPEG audio found, not supported in this browser for now');
            } else if (result.audio === -1) {
              result.audio = pid;
              result.isAAC = false;
            }
            break;

          case 0x24:
            _logger.logger.warn('HEVC stream type found, not supported for now');
            break;

          default:
            _logger.logger.log('unkown stream type:' + data[offset]);
            break;
        }
        // move to the next table entry
        // skip past the elementary stream descriptors, if present
        offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;
      }
      return result;
    }
  }, {
    key: '_parsePES',
    value: function _parsePES(stream) {
      var i = 0,
          frag = void 0,
          pesFlags = void 0,
          pesPrefix = void 0,
          pesLen = void 0,
          pesHdrLen = void 0,
          pesData = void 0,
          pesPts = void 0,
          pesDts = void 0,
          payloadStartOffset = void 0,
          data = stream.data;
      // safety check
      if (!stream || stream.size === 0) {
        return null;
      }

      // we might need up to 19 bytes to read PES header
      // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
      // usually only one merge is needed (and this is rare ...)
      while (data[0].length < 19 && data.length > 1) {
        var newData = new Uint8Array(data[0].length + data[1].length);
        newData.set(data[0]);
        newData.set(data[1], data[0].length);
        data[0] = newData;
        data.splice(1, 1);
      }
      // retrieve PTS/DTS from first fragment
      frag = data[0];
      pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
      if (pesPrefix === 1) {
        pesLen = (frag[4] << 8) + frag[5];
        // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
        // minus 6 : PES header size
        if (pesLen && pesLen > stream.size - 6) {
          return null;
        }

        pesFlags = frag[7];
        if (pesFlags & 0xC0) {
          /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
              as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
              as Bitwise operators treat their operands as a sequence of 32 bits */
          pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
          (frag[10] & 0xFF) * 4194304 + // 1 << 22
          (frag[11] & 0xFE) * 16384 + // 1 << 14
          (frag[12] & 0xFF) * 128 + // 1 << 7
          (frag[13] & 0xFE) / 2;
          // check if greater than 2^32 -1
          if (pesPts > 4294967295) {
            // decrement 2^33
            pesPts -= 8589934592;
          }
          if (pesFlags & 0x40) {
            pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
            (frag[15] & 0xFF) * 4194304 + // 1 << 22
            (frag[16] & 0xFE) * 16384 + // 1 << 14
            (frag[17] & 0xFF) * 128 + // 1 << 7
            (frag[18] & 0xFE) / 2;
            // check if greater than 2^32 -1
            if (pesDts > 4294967295) {
              // decrement 2^33
              pesDts -= 8589934592;
            }
            if (pesPts - pesDts > 60 * 90000) {
              _logger.logger.warn(Math.round((pesPts - pesDts) / 90000) + 's delta between PTS and DTS, align them');
              pesPts = pesDts;
            }
          } else {
            pesDts = pesPts;
          }
        }
        pesHdrLen = frag[8];
        // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension
        payloadStartOffset = pesHdrLen + 9;

        stream.size -= payloadStartOffset;
        // reassemble PES packet
        pesData = new Uint8Array(stream.size);
        for (var j = 0, dataLen = data.length; j < dataLen; j++) {
          frag = data[j];
          var len = frag.byteLength;
          if (payloadStartOffset) {
            if (payloadStartOffset > len) {
              // trim full frag if PES header bigger than frag
              payloadStartOffset -= len;
              continue;
            } else {
              // trim partial frag if PES header smaller than frag
              frag = frag.subarray(payloadStartOffset);
              len -= payloadStartOffset;
              payloadStartOffset = 0;
            }
          }
          pesData.set(frag, i);
          i += len;
        }
        if (pesLen) {
          // payload size : remove PES header + PES extension
          pesLen -= pesHdrLen + 3;
        }
        return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
      } else {
        return null;
      }
    }
  }, {
    key: 'pushAccesUnit',
    value: function pushAccesUnit(avcSample, avcTrack) {
      if (avcSample.units.length && avcSample.frame) {
        var samples = avcTrack.samples;
        var nbSamples = samples.length;
        // only push AVC sample if starting with a keyframe is not mandatory OR
        //    if keyframe already found in this fragment OR
        //       keyframe found in last fragment (track.sps) AND
        //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
        if (!this.config.forceKeyFrameOnDiscontinuity || avcSample.key === true || avcTrack.sps && (nbSamples || this.contiguous)) {
          avcSample.id = nbSamples;
          samples.push(avcSample);
        } else {
          // dropped samples, track it
          avcTrack.dropped++;
        }
      }
      if (avcSample.debug.length) {
        _logger.logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);
      }
    }
  }, {
    key: '_parseAVCPES',
    value: function _parseAVCPES(pes, last) {
      var _this = this;

      // logger.log('parse new PES');
      var track = this._avcTrack,
          units = this._parseAVCNALu(pes.data),
          debug = false,
          expGolombDecoder = void 0,
          avcSample = this.avcSample,
          push = void 0,
          spsfound = false,
          i = void 0,
          pushAccesUnit = this.pushAccesUnit.bind(this),
          createAVCSample = function createAVCSample(key, pts, dts, debug) {
        return { key: key, pts: pts, dts: dts, units: [], debug: debug };
      };
      // free pes.data to save up some memory
      pes.data = null;

      // if new NAL units found and last sample still there, let's push ...
      // this helps parsing streams with missing AUD (only do this if AUD never found)
      if (avcSample && units.length && !track.audFound) {
        pushAccesUnit(avcSample, track);
        avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');
      }

      units.forEach(function (unit) {
        switch (unit.type) {
          // NDR
          case 1:
            push = true;
            if (!avcSample) {
              avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');
            }

            if (debug) {
              avcSample.debug += 'NDR ';
            }

            avcSample.frame = true;
            var data = unit.data;
            // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)
            if (spsfound && data.length > 4) {
              // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
              var sliceType = new _expGolomb2.default(data).readSliceType();
              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.
              // if (sliceType === 2 || sliceType === 7) {
              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                avcSample.key = true;
              }
            }
            break;
          // IDR
          case 5:
            push = true;
            // handle PES not starting with AUD
            if (!avcSample) {
              avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');
            }

            if (debug) {
              avcSample.debug += 'IDR ';
            }

            avcSample.key = true;
            avcSample.frame = true;
            break;
          // SEI
          case 6:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'SEI ';
            }

            expGolombDecoder = new _expGolomb2.default(_this.discardEPB(unit.data));

            // skip frameType
            expGolombDecoder.readUByte();

            var payloadType = 0;
            var payloadSize = 0;
            var endOfCaptions = false;
            var b = 0;

            while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
              payloadType = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadType += b;
              } while (b === 0xFF);

              // Parse payload size.
              payloadSize = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadSize += b;
              } while (b === 0xFF);

              // TODO: there can be more than one payload in an SEI packet...
              // TODO: need to read type and size in a while loop to get them all
              if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {
                endOfCaptions = true;

                var countryCode = expGolombDecoder.readUByte();

                if (countryCode === 181) {
                  var providerCode = expGolombDecoder.readUShort();

                  if (providerCode === 49) {
                    var userStructure = expGolombDecoder.readUInt();

                    if (userStructure === 0x47413934) {
                      var userDataType = expGolombDecoder.readUByte();

                      // Raw CEA-608 bytes wrapped in CEA-708 packet
                      if (userDataType === 3) {
                        var firstByte = expGolombDecoder.readUByte();
                        var secondByte = expGolombDecoder.readUByte();

                        var totalCCs = 31 & firstByte;
                        var byteArray = [firstByte, secondByte];

                        for (i = 0; i < totalCCs; i++) {
                          // 3 bytes per CC
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                        }

                        _this._insertSampleInOrder(_this._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });
                      }
                    }
                  }
                }
              } else if (payloadSize < expGolombDecoder.bytesAvailable) {
                for (i = 0; i < payloadSize; i++) {
                  expGolombDecoder.readUByte();
                }
              }
            }
            break;
          // SPS
          case 7:
            push = true;
            spsfound = true;
            if (debug && avcSample) {
              avcSample.debug += 'SPS ';
            }

            if (!track.sps) {
              expGolombDecoder = new _expGolomb2.default(unit.data);
              var config = expGolombDecoder.readSPS();
              track.width = config.width;
              track.height = config.height;
              track.pixelRatio = config.pixelRatio;
              track.sps = [unit.data];
              track.duration = _this._duration;
              var codecarray = unit.data.subarray(1, 4);
              var codecstring = 'avc1.';
              for (i = 0; i < 3; i++) {
                var h = codecarray[i].toString(16);
                if (h.length < 2) {
                  h = '0' + h;
                }

                codecstring += h;
              }
              track.codec = codecstring;
            }
            break;
          // PPS
          case 8:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'PPS ';
            }

            if (!track.pps) {
              track.pps = [unit.data];
            }

            break;
          // AUD
          case 9:
            push = false;
            track.audFound = true;
            if (avcSample) {
              pushAccesUnit(avcSample, track);
            }

            avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');
            break;
          // Filler Data
          case 12:
            push = false;
            break;
          default:
            push = false;
            if (avcSample) {
              avcSample.debug += 'unknown NAL ' + unit.type + ' ';
            }

            break;
        }
        if (avcSample && push) {
          var _units = avcSample.units;
          _units.push(unit);
        }
      });
      // if last PES packet, push samples
      if (last && avcSample) {
        pushAccesUnit(avcSample, track);
        this.avcSample = null;
      }
    }
  }, {
    key: '_insertSampleInOrder',
    value: function _insertSampleInOrder(arr, data) {
      var len = arr.length;
      if (len > 0) {
        if (data.pts >= arr[len - 1].pts) {
          arr.push(data);
        } else {
          for (var pos = len - 1; pos >= 0; pos--) {
            if (data.pts < arr[pos].pts) {
              arr.splice(pos, 0, data);
              break;
            }
          }
        }
      } else {
        arr.push(data);
      }
    }
  }, {
    key: '_getLastNalUnit',
    value: function _getLastNalUnit() {
      var avcSample = this.avcSample,
          lastUnit = void 0;
      // try to fallback to previous sample if current one is empty
      if (!avcSample || avcSample.units.length === 0) {
        var track = this._avcTrack,
            samples = track.samples;
        avcSample = samples[samples.length - 1];
      }
      if (avcSample) {
        var units = avcSample.units;
        lastUnit = units[units.length - 1];
      }
      return lastUnit;
    }
  }, {
    key: '_parseAVCNALu',
    value: function _parseAVCNALu(array) {
      var i = 0,
          len = array.byteLength,
          value = void 0,
          overflow = void 0,
          track = this._avcTrack,
          state = track.naluState || 0,
          lastState = state;
      var units = [],
          unit = void 0,
          unitType = void 0,
          lastUnitStart = -1,
          lastUnitType = void 0;
      // logger.log('PES:' + Hex.hexDump(array));

      if (state === -1) {
        // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
        lastUnitStart = 0;
        // NALu type is value read from offset 0
        lastUnitType = array[0] & 0x1f;
        state = 0;
        i = 1;
      }

      while (i < len) {
        value = array[i++];
        // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case
        if (!state) {
          state = value ? 0 : 1;
          continue;
        }
        if (state === 1) {
          state = value ? 0 : 2;
          continue;
        }
        // here we have state either equal to 2 or 3
        if (!value) {
          state = 3;
        } else if (value === 1) {
          if (lastUnitStart >= 0) {
            unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
            // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
            units.push(unit);
          } else {
            // lastUnitStart is undefined => this is the first start code found in this PES packet
            // first check if start code delimiter is overlapping between 2 PES packets,
            // ie it started in last packet (lastState not zero)
            // and ended at the beginning of this PES packet (i <= 4 - lastState)
            var lastUnit = this._getLastNalUnit();
            if (lastUnit) {
              if (lastState && i <= 4 - lastState) {
                // start delimiter overlapping between PES packets
                // strip start delimiter bytes from the end of last NAL unit
                // check if lastUnit had a state different from zero
                if (lastUnit.state) {
                  // strip last bytes
                  lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                }
              }
              // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
              overflow = i - state - 1;
              if (overflow > 0) {
                // logger.log('first NALU found with overflow:' + overflow);
                var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
                tmp.set(lastUnit.data, 0);
                tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
                lastUnit.data = tmp;
              }
            }
          }
          // check if we can read unit type
          if (i < len) {
            unitType = array[i] & 0x1f;
            // logger.log('find NALU @ offset:' + i + ',type:' + unitType);
            lastUnitStart = i;
            lastUnitType = unitType;
            state = 0;
          } else {
            // not enough byte to read unit type. let's read it on next PES parsing
            state = -1;
          }
        } else {
          state = 0;
        }
      }
      if (lastUnitStart >= 0 && state >= 0) {
        unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
        units.push(unit);
        // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
      }
      // no NALu found
      if (units.length === 0) {
        // append pes.data to previous NAL unit
        var _lastUnit = this._getLastNalUnit();
        if (_lastUnit) {
          var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);
          _tmp.set(_lastUnit.data, 0);
          _tmp.set(array, _lastUnit.data.byteLength);
          _lastUnit.data = _tmp;
        }
      }
      track.naluState = state;
      return units;
    }

    /**
     * remove Emulation Prevention bytes from a RBSP
     */

  }, {
    key: 'discardEPB',
    value: function discardEPB(data) {
      var length = data.byteLength,
          EPBPositions = [],
          i = 1,
          newLength = void 0,
          newData = void 0;

      // Find all `Emulation Prevention Bytes`
      while (i < length - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
          EPBPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }

      // If no Emulation Prevention Bytes were found just return the original
      // array
      if (EPBPositions.length === 0) {
        return data;
      }

      // Create a new array to hold the NAL unit data
      newLength = length - EPBPositions.length;
      newData = new Uint8Array(newLength);
      var sourceIndex = 0;

      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === EPBPositions[0]) {
          // Skip this byte
          sourceIndex++;
          // Remove this position index
          EPBPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    }
  }, {
    key: '_parseAACPES',
    value: function _parseAACPES(pes) {
      var track = this._audioTrack,
          data = pes.data,
          pts = pes.pts,
          startOffset = 0,
          aacOverFlow = this.aacOverFlow,
          aacLastPTS = this.aacLastPTS,
          frameDuration = void 0,
          frameIndex = void 0,
          offset = void 0,
          stamp = void 0,
          len = void 0;
      if (aacOverFlow) {
        var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
        tmp.set(aacOverFlow, 0);
        tmp.set(data, aacOverFlow.byteLength);
        // logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
        data = tmp;
      }
      // look for ADTS header (0xFFFx)
      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
        if (ADTS.isHeader(data, offset)) {
          break;
        }
      }
      // if ADTS header does not start straight from the beginning of the PES payload, raise an error
      if (offset) {
        var reason = void 0,
            fatal = void 0;
        if (offset < len - 1) {
          reason = 'AAC PES did not start with ADTS header,offset:' + offset;
          fatal = false;
        } else {
          reason = 'no ADTS header found in AAC PES';
          fatal = true;
        }
        _logger.logger.warn('parsing error:' + reason);
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });
        if (fatal) {
          return;
        }
      }

      ADTS.initTrackConfig(track, this.observer, data, offset, this.audioCodec);
      frameIndex = 0;
      frameDuration = ADTS.getFrameDuration(track.samplerate);

      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
      // first sample PTS should be equal to last sample PTS + frameDuration
      if (aacOverFlow && aacLastPTS) {
        var newPTS = aacLastPTS + frameDuration;
        if (Math.abs(newPTS - pts) > 1) {
          _logger.logger.log('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));
          pts = newPTS;
        }
      }

      // scan for aac samples
      while (offset < len) {
        if (ADTS.isHeader(data, offset) && offset + 5 < len) {
          var frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);
          if (frame) {
            // logger.log(`${Math.round(frame.sample.pts)} : AAC`);
            offset += frame.length;
            stamp = frame.sample.pts;
            frameIndex++;
          } else {
            // logger.log('Unable to parse AAC frame');
            break;
          }
        } else {
          // nothing found, keep looking
          offset++;
        }
      }

      if (offset < len) {
        aacOverFlow = data.subarray(offset, len);
        // logger.log(`AAC: overflow detected:${len-offset}`);
      } else {
        aacOverFlow = null;
      }

      this.aacOverFlow = aacOverFlow;
      this.aacLastPTS = stamp;
    }
  }, {
    key: '_parseMPEGPES',
    value: function _parseMPEGPES(pes) {
      var data = pes.data;
      var length = data.length;
      var frameIndex = 0;
      var offset = 0;
      var pts = pes.pts;

      while (offset < length) {
        if (_mpegaudio2.default.isHeader(data, offset)) {
          var frame = _mpegaudio2.default.appendFrame(this._audioTrack, data, offset, pts, frameIndex);
          if (frame) {
            offset += frame.length;
            frameIndex++;
          } else {
            // logger.log('Unable to parse Mpeg audio frame');
            break;
          }
        } else {
          // nothing found, keep looking
          offset++;
        }
      }
    }
  }, {
    key: '_parseID3PES',
    value: function _parseID3PES(pes) {
      this._id3Track.samples.push(pes);
    }
  }], [{
    key: 'probe',
    value: function probe(data) {
      var syncOffset = TSDemuxer._syncOffset(data);
      if (syncOffset < 0) {
        return false;
      } else {
        if (syncOffset) {
          _logger.logger.warn('MPEG2-TS detected but first sync word found @ offset ' + syncOffset + ', junk ahead ?');
        }

        return true;
      }
    }
  }, {
    key: '_syncOffset',
    value: function _syncOffset(data) {
      // scan 1000 first bytes
      var scanwindow = Math.min(1000, data.length - 3 * 188);
      var i = 0;
      while (i < scanwindow) {
        // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
        if (data[i] === 0x47 && data[i + 188] === 0x47 && data[i + 2 * 188] === 0x47) {
          return i;
        } else {
          i++;
        }
      }
      return -1;
    }

    /**
     * Creates a track model internal to demuxer used to drive remuxing input
     *
     * @param {string} type 'audio' | 'video' | 'id3' | 'text'
     * @param {number} duration
     * @return {object} TSDemuxer's internal track model
     */

  }, {
    key: 'createTrack',
    value: function createTrack(type, duration) {
      return {
        container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,
        type: type,
        id: RemuxerTrackIdConfig[type],
        pid: -1,
        inputTimeScale: 90000,
        sequenceNumber: 0,
        samples: [],
        len: 0,
        dropped: type === 'video' ? 0 : undefined,
        isAAC: type === 'audio' ? true : undefined,
        duration: type === 'audio' ? duration : undefined
      };
    }
  }]);

  return TSDemuxer;
}();

exports.default = TSDemuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/errors.js":
/*!******************************!*\
  !*** ./src/hls.js/errors.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var ErrorTypes = exports.ErrorTypes = {
  // Identifier for a network error (loading error / timeout ...)
  NETWORK_ERROR: 'networkError',
  // Identifier for a media Error (video/parsing/mediasource error)
  MEDIA_ERROR: 'mediaError',
  // EME (encrypted media extensions) errors
  KEY_SYSTEM_ERROR: 'keySystemError',
  // Identifier for a mux Error (demuxing/remuxing)
  MUX_ERROR: 'muxError',
  // Identifier for all other errors
  OTHER_ERROR: 'otherError'
};

/**
 * @enum {ErrorDetails}
 * @typedef {string} ErrorDetail
 */
var ErrorDetails = exports.ErrorDetails = {
  KEY_SYSTEM_NO_KEYS: 'keySystemNoKeys',
  KEY_SYSTEM_NO_ACCESS: 'keySystemNoAccess',
  KEY_SYSTEM_NO_SESSION: 'keySystemNoSession',
  KEY_SYSTEM_LICENSE_REQUEST_FAILED: 'keySystemLicenseRequestFailed',
  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_ERROR: 'manifestLoadError',
  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',
  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
  MANIFEST_PARSING_ERROR: 'manifestParsingError',
  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
  MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',
  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_ERROR: 'levelLoadError',
  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',
  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
  LEVEL_SWITCH_ERROR: 'levelSwitchError',
  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',
  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',
  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  FRAG_LOAD_ERROR: 'fragLoadError',
  // Identifier for fragment load timeout error - data: { frag : fragment object}
  FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',
  // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
  FRAG_DECRYPT_ERROR: 'fragDecryptError',
  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
  FRAG_PARSING_ERROR: 'fragParsingError',
  // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
  REMUX_ALLOC_ERROR: 'remuxAllocError',
  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  KEY_LOAD_ERROR: 'keyLoadError',
  // Identifier for decrypt key load timeout error - data: { frag : fragment object}
  KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',
  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
  BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',
  // Identifier for a buffer append error - data: append error description
  BUFFER_APPEND_ERROR: 'bufferAppendError',
  // Identifier for a buffer appending error event - data: appending error description
  BUFFER_APPENDING_ERROR: 'bufferAppendingError',
  // Identifier for a buffer stalled error event
  BUFFER_STALLED_ERROR: 'bufferStalledError',
  // Identifier for a buffer full event
  BUFFER_FULL_ERROR: 'bufferFullError',
  // Identifier for a buffer seek over hole event
  BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',
  // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
  BUFFER_NUDGE_ON_STALL: 'bufferNudgeOnStall',
  // Identifier for an internal exception happening inside hls.js while handling an event
  INTERNAL_EXCEPTION: 'internalException'
};

/***/ }),

/***/ "./src/hls.js/event-handler.js":
/*!*************************************!*\
  !*** ./src/hls.js/event-handler.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * All objects in the event handling chain should inherit from this class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = __webpack_require__(/*! ./utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ./errors */ "./src/hls.js/errors.js");

var _events = __webpack_require__(/*! ./events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FORBIDDEN_EVENT_NAMES = {
  'hlsEventGeneric': true,
  'hlsHandlerDestroying': true,
  'hlsHandlerDestroyed': true
};

var EventHandler = function () {
  function EventHandler(hls) {
    _classCallCheck(this, EventHandler);

    this.hls = hls;
    this.onEvent = this.onEvent.bind(this);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    this.handledEvents = events;
    this.useGenericHandler = true;

    this.registerListeners();
  }

  _createClass(EventHandler, [{
    key: 'destroy',
    value: function destroy() {
      this.onHandlerDestroying();
      this.unregisterListeners();
      this.onHandlerDestroyed();
    }
  }, {
    key: 'onHandlerDestroying',
    value: function onHandlerDestroying() {}
  }, {
    key: 'onHandlerDestroyed',
    value: function onHandlerDestroyed() {}
  }, {
    key: 'isEventHandler',
    value: function isEventHandler() {
      return _typeof(this.handledEvents) === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';
    }
  }, {
    key: 'registerListeners',
    value: function registerListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          if (FORBIDDEN_EVENT_NAMES[event]) {
            throw new Error('Forbidden event-name: ' + event);
          }

          this.hls.on(event, this.onEvent);
        }, this);
      }
    }
  }, {
    key: 'unregisterListeners',
    value: function unregisterListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          this.hls.off(event, this.onEvent);
        }, this);
      }
    }

    /**
     * arguments: event (string), data (any)
     */

  }, {
    key: 'onEvent',
    value: function onEvent(event, data) {
      this.onEventGeneric(event, data);
    }
  }, {
    key: 'onEventGeneric',
    value: function onEventGeneric(event, data) {
      var eventToFunction = function eventToFunction(event, data) {
        var funcName = 'on' + event.replace('hls', '');
        if (typeof this[funcName] !== 'function') {
          throw new Error('Event ' + event + ' has no generic handler in this ' + this.constructor.name + ' class (tried ' + funcName + ')');
        }

        return this[funcName].bind(this, data);
      };
      try {
        eventToFunction.call(this, event, data).call();
      } catch (err) {
        _logger.logger.error('An internal error happened while handling event ' + event + '. Error message: "' + err.message + '". Here is a stacktrace:', err);
        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });
      }
    }
  }]);

  return EventHandler;
}();

exports.default = EventHandler;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/events.js":
/*!******************************!*\
  !*** ./src/hls.js/events.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @readonly
 * @enum {string}
 */
var HlsEvents = {
  // fired before MediaSource is attaching to media element - data: { media }
  MEDIA_ATTACHING: 'hlsMediaAttaching',
  // fired when MediaSource has been succesfully attached to media element - data: { }
  MEDIA_ATTACHED: 'hlsMediaAttached',
  // fired before detaching MediaSource from media element - data: { }
  MEDIA_DETACHING: 'hlsMediaDetaching',
  // fired when MediaSource has been detached from media element - data: { }
  MEDIA_DETACHED: 'hlsMediaDetached',
  // fired when we buffer is going to be reset - data: { }
  BUFFER_RESET: 'hlsBufferReset',
  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
  BUFFER_CODECS: 'hlsBufferCodecs',
  // fired when sourcebuffers have been created - data: { tracks : tracks }
  BUFFER_CREATED: 'hlsBufferCreated',
  // fired when we append a segment to the buffer - data: { segment: segment object }
  BUFFER_APPENDING: 'hlsBufferAppending',
  // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
  BUFFER_APPENDED: 'hlsBufferAppended',
  // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
  BUFFER_EOS: 'hlsBufferEos',
  // fired when the media buffer should be flushed - data { startOffset, endOffset }
  BUFFER_FLUSHING: 'hlsBufferFlushing',
  // fired when the media buffer has been flushed - data: { }
  BUFFER_FLUSHED: 'hlsBufferFlushed',
  // fired to signal that a manifest loading starts - data: { url : manifestURL}
  MANIFEST_LOADING: 'hlsManifestLoading',
  // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
  MANIFEST_LOADED: 'hlsManifestLoaded',
  // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
  MANIFEST_PARSED: 'hlsManifestParsed',
  // fired when a level switch is requested - data: { level : id of new level }
  LEVEL_SWITCHING: 'hlsLevelSwitching',
  // fired when a level switch is effective - data: { level : id of new level }
  LEVEL_SWITCHED: 'hlsLevelSwitched',
  // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
  LEVEL_LOADING: 'hlsLevelLoading',
  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
  LEVEL_LOADED: 'hlsLevelLoaded',
  // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
  LEVEL_UPDATED: 'hlsLevelUpdated',
  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
  // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
  // fired when an audio track switching is requested - data: { id : audio track id }
  AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',
  // fired when an audio track switch actually occurs - data: { id : audio track id }
  AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',
  // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
  // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
  // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
  SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',
  // fired when an subtitle track switch occurs - data: { id : subtitle track id }
  SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',
  // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
  SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',
  // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
  SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',
  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
  SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',
  // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
  INIT_PTS_FOUND: 'hlsInitPtsFound',
  // fired when a fragment loading starts - data: { frag : fragment object }
  FRAG_LOADING: 'hlsFragLoading',
  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
  // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
  FRAG_LOADED: 'hlsFragLoaded',
  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }
  FRAG_DECRYPTED: 'hlsFragDecrypted',
  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
  // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
  FRAG_PARSING_DATA: 'hlsFragParsingData',
  // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
  FRAG_PARSED: 'hlsFragParsed',
  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
  FRAG_BUFFERED: 'hlsFragBuffered',
  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
  FRAG_CHANGED: 'hlsFragChanged',
  // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
  FPS_DROP: 'hlsFpsDrop',
  // triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
  ERROR: 'hlsError',
  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
  DESTROYING: 'hlsDestroying',
  // fired when a decrypt key loading starts - data: { frag : fragment object }
  KEY_LOADING: 'hlsKeyLoading',
  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
  KEY_LOADED: 'hlsKeyLoaded',
  // fired upon stream controller state transitions - data: { previousState, nextState }
  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
};

exports.default = HlsEvents;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/hls.js":
/*!***************************!*\
  !*** ./src/hls.js/hls.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "../../node_modules/url-toolkit/src/url-toolkit.js");

var URLToolkit = _interopRequireWildcard(_urlToolkit);

var _errors = __webpack_require__(/*! ./errors */ "./src/hls.js/errors.js");

var _playlistLoader = __webpack_require__(/*! ./loader/playlist-loader */ "./src/hls.js/loader/playlist-loader.js");

var _playlistLoader2 = _interopRequireDefault(_playlistLoader);

var _fragmentLoader = __webpack_require__(/*! ./loader/fragment-loader */ "./src/hls.js/loader/fragment-loader.js");

var _fragmentLoader2 = _interopRequireDefault(_fragmentLoader);

var _keyLoader = __webpack_require__(/*! ./loader/key-loader */ "./src/hls.js/loader/key-loader.js");

var _keyLoader2 = _interopRequireDefault(_keyLoader);

var _fragmentTracker = __webpack_require__(/*! ./controller/fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _streamController = __webpack_require__(/*! ./controller/stream-controller */ "./src/hls.js/controller/stream-controller.js");

var _streamController2 = _interopRequireDefault(_streamController);

var _levelController = __webpack_require__(/*! ./controller/level-controller */ "./src/hls.js/controller/level-controller.js");

var _levelController2 = _interopRequireDefault(_levelController);

var _id3TrackController = __webpack_require__(/*! ./controller/id3-track-controller */ "./src/hls.js/controller/id3-track-controller.js");

var _id3TrackController2 = _interopRequireDefault(_id3TrackController);

var _isSupported2 = __webpack_require__(/*! ./is-supported */ "./src/hls.js/is-supported.js");

var _logger = __webpack_require__(/*! ./utils/logger */ "./src/hls.js/utils/logger.js");

var _config = __webpack_require__(/*! ./config */ "./src/hls.js/config.js");

var _events = __webpack_require__(/*! ./events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _observer = __webpack_require__(/*! ./observer */ "./src/hls.js/observer.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module Hls
 * @class
 * @constructor
 */
var Hls = function (_Observer) {
  _inherits(Hls, _Observer);

  _createClass(Hls, null, [{
    key: 'isSupported',


    /**
     * @type {boolean}
     */
    value: function isSupported() {
      return (0, _isSupported2.isSupported)();
    }

    /**
     * @type {HlsEvents}
     */

  }, {
    key: 'version',

    /**
     * @type {string}
     */
    get: function get() {
      return __VERSION__;
    }
  }, {
    key: 'Events',
    get: function get() {
      return _events2.default;
    }

    /**
     * @type {HlsErrorTypes}
     */

  }, {
    key: 'ErrorTypes',
    get: function get() {
      return _errors.ErrorTypes;
    }

    /**
     * @type {HlsErrorDetails}
     */

  }, {
    key: 'ErrorDetails',
    get: function get() {
      return _errors.ErrorDetails;
    }

    /**
     * @type {HlsConfig}
     */

  }, {
    key: 'DefaultConfig',
    get: function get() {
      if (!Hls.defaultConfig) {
        return _config.hlsDefaultConfig;
      }

      return Hls.defaultConfig;
    }

    /**
     * @type {HlsConfig}
     */
    ,
    set: function set(defaultConfig) {
      Hls.defaultConfig = defaultConfig;
    }

    /**
     * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
     *
     * @constructs Hls
     * @param {HlsConfig} config
     */

  }]);

  function Hls() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Hls);

    var _this = _possibleConstructorReturn(this, (Hls.__proto__ || Object.getPrototypeOf(Hls)).call(this));

    var defaultConfig = Hls.DefaultConfig;

    if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {
      throw new Error('Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');
    }

    for (var prop in defaultConfig) {
      if (prop in config) continue;
      config[prop] = defaultConfig[prop];
    }

    if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
    }

    if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
    }

    (0, _logger.enableLogs)(config.debug);
    _this.config = config;
    _this._autoLevelCapping = -1;

    // core controllers and network loaders

    /**
     * @member {AbrController} abrController
     */
    var abrController = _this.abrController = new config.abrController(_this);

    var bufferController = new config.bufferController(_this);
    var capLevelController = new config.capLevelController(_this);
    var fpsController = new config.fpsController(_this);
    var playListLoader = new _playlistLoader2.default(_this);
    var fragmentLoader = new _fragmentLoader2.default(_this);
    var keyLoader = new _keyLoader2.default(_this);
    var id3TrackController = new _id3TrackController2.default(_this);

    // network controllers

    /**
     * @member {LevelController} levelController
     */
    var levelController = _this.levelController = new _levelController2.default(_this);

    // FIXME: FragmentTracker must be defined before StreamController because the order of event handling is important
    var fragmentTracker = new _fragmentTracker.FragmentTracker(_this);

    /**
     * @member {StreamController} streamController
     */
    var streamController = _this.streamController = new _streamController2.default(_this, fragmentTracker);

    var networkControllers = [levelController, streamController];

    // optional audio stream controller
    /**
     * @var {ICoreComponent | Controller}
     */
    var Controller = config.audioStreamController;
    if (Controller) {
      networkControllers.push(new Controller(_this, fragmentTracker));
    }

    /**
     * @member {INetworkController[]} networkControllers
     */
    _this.networkControllers = networkControllers;

    /**
     * @var {ICoreComponent[]}
     */
    var coreComponents = [playListLoader, fragmentLoader, keyLoader, abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];

    // optional audio track and subtitle controller
    Controller = config.audioTrackController;
    if (Controller) {
      var audioTrackController = new Controller(_this);

      /**
       * @member {AudioTrackController} audioTrackController
       */
      _this.audioTrackController = audioTrackController;
      coreComponents.push(audioTrackController);
    }

    Controller = config.subtitleTrackController;
    if (Controller) {
      var subtitleTrackController = new Controller(_this);

      /**
       * @member {SubtitleTrackController} subtitleTrackController
       */
      _this.subtitleTrackController = subtitleTrackController;
      networkControllers.push(subtitleTrackController);
    }

    Controller = config.emeController;
    if (Controller) {
      var emeController = new Controller(_this);

      /**
       * @member {EMEController} emeController
       */
      _this.emeController = emeController;
      coreComponents.push(emeController);
    }

    // optional subtitle controllers
    Controller = config.subtitleStreamController;
    if (Controller) {
      networkControllers.push(new Controller(_this, fragmentTracker));
    }
    Controller = config.timelineController;
    if (Controller) {
      coreComponents.push(new Controller(_this));
    }

    /**
     * @member {ICoreComponent[]}
     */
    _this.coreComponents = coreComponents;
    return _this;
  }

  /**
   * Dispose of the instance
   */


  _createClass(Hls, [{
    key: 'destroy',
    value: function destroy() {
      _logger.logger.log('destroy');
      this.trigger(_events2.default.DESTROYING);
      this.detachMedia();
      this.coreComponents.concat(this.networkControllers).forEach(function (component) {
        component.destroy();
      });
      this.url = null;
      this.removeAllListeners();
      this._autoLevelCapping = -1;
    }

    /**
     * Attach a media element
     * @param {HTMLMediaElement} media
     */

  }, {
    key: 'attachMedia',
    value: function attachMedia(media) {
      _logger.logger.log('attachMedia');
      this.media = media;
      this.trigger(_events2.default.MEDIA_ATTACHING, { media: media });
    }

    /**
     * Detach from the media
     */

  }, {
    key: 'detachMedia',
    value: function detachMedia() {
      _logger.logger.log('detachMedia');
      this.trigger(_events2.default.MEDIA_DETACHING);
      this.media = null;
    }

    /**
     * Set the source URL. Can be relative or absolute.
     * @param {string} url
     */

  }, {
    key: 'loadSource',
    value: function loadSource(url) {
      url = URLToolkit.buildAbsoluteURL(window.location.href, url, { alwaysNormalize: true });
      _logger.logger.log('loadSource:' + url);
      this.url = url;
      // when attaching to a source URL, trigger a playlist load
      this.trigger(_events2.default.MANIFEST_LOADING, { url: url });
    }

    /**
     * Start loading data from the stream source.
     * Depending on default config, client starts loading automatically when a source is set.
     *
     * @param {number} startPosition Set the start position to stream from
     * @default -1 None (from earliest point)
     */

  }, {
    key: 'startLoad',
    value: function startLoad() {
      var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

      _logger.logger.log('startLoad(' + startPosition + ')');
      this.networkControllers.forEach(function (controller) {
        controller.startLoad(startPosition);
      });
    }

    /**
     * Stop loading of any stream data.
     */

  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      _logger.logger.log('stopLoad');
      this.networkControllers.forEach(function (controller) {
        controller.stopLoad();
      });
    }

    /**
     * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)
     */

  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      _logger.logger.log('swapAudioCodec');
      this.streamController.swapAudioCodec();
    }

    /**
     * When the media-element fails, this allows to detach and then re-attach it
     * as one call (convenience method).
     *
     * Automatic recovery of media-errors by this process is configurable.
     */

  }, {
    key: 'recoverMediaError',
    value: function recoverMediaError() {
      _logger.logger.log('recoverMediaError');
      var media = this.media;
      this.detachMedia();
      this.attachMedia(media);
    }

    /**
     * @type {QualityLevel[]}
     */

  }, {
    key: 'levels',
    get: function get() {
      return this.levelController.levels;
    }

    /**
     * Index of quality level currently played
     * @type {number}
     */

  }, {
    key: 'currentLevel',
    get: function get() {
      return this.streamController.currentLevel;
    }

    /**
     * Set quality level index immediately .
     * This will flush the current buffer to replace the quality asap.
     * That means playback will interrupt at least shortly to re-buffer and re-sync eventually.
     * @type {number} -1 for automatic level selection
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set currentLevel:' + newLevel);
      this.loadLevel = newLevel;
      this.streamController.immediateLevelSwitch();
    }

    /**
     * Index of next quality level loaded as scheduled by stream controller.
     * @type {number}
     */

  }, {
    key: 'nextLevel',
    get: function get() {
      return this.streamController.nextLevel;
    }

    /**
     * Set quality level index for next loaded data.
     * This will switch the video quality asap, without interrupting playback.
     * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).
     * @type {number} -1 for automatic level selection
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set nextLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
      this.streamController.nextLevelSwitch();
    }

    /**
     * Return the quality level of the currently or last (of none is loaded currently) segment
     * @type {number}
     */

  }, {
    key: 'loadLevel',
    get: function get() {
      return this.levelController.level;
    }

    /**
     * Set quality level index for next loaded data in a conservative way.
     * This will switch the quality without flushing, but interrupt current loading.
     * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.
     * @type {number} newLevel -1 for automatic level selection
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set loadLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
    }

    /**
     * get next quality level loaded
     * @type {number}
     */

  }, {
    key: 'nextLoadLevel',
    get: function get() {
      return this.levelController.nextLoadLevel;
    }

    /**
     * Set quality level of next loaded segment in a fully "non-destructive" way.
     * Same as `loadLevel` but will wait for next switch (until current loading is done).
     * @type {number} level
     */
    ,
    set: function set(level) {
      this.levelController.nextLoadLevel = level;
    }

    /**
     * Return "first level": like a default level, if not set,
     * falls back to index of first level referenced in manifest
     * @type {number}
     */

  }, {
    key: 'firstLevel',
    get: function get() {
      return Math.max(this.levelController.firstLevel, this.minAutoLevel);
    }

    /**
     * Sets "first-level", see getter.
     * @type {number}
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set firstLevel:' + newLevel);
      this.levelController.firstLevel = newLevel;
    }

    /**
     * Return start level (level of first fragment that will be played back)
     * if not overrided by user, first level appearing in manifest will be used as start level
     * if -1 : automatic start level selection, playback will start from level matching download bandwidth
     * (determined from download of first segment)
     * @type {number}
     */

  }, {
    key: 'startLevel',
    get: function get() {
      return this.levelController.startLevel;
    }

    /**
     * set  start level (level of first fragment that will be played back)
     * if not overrided by user, first level appearing in manifest will be used as start level
     * if -1 : automatic start level selection, playback will start from level matching download bandwidth
     * (determined from download of first segment)
     * @type {number} newLevel
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set startLevel:' + newLevel);
      var hls = this;
      // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel
      if (newLevel !== -1) {
        newLevel = Math.max(newLevel, hls.minAutoLevel);
      }

      hls.levelController.startLevel = newLevel;
    }

    /**
     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
     * @type {number}
     */

  }, {
    key: 'autoLevelCapping',
    get: function get() {
      return this._autoLevelCapping;
    }

    /**
     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
     * @type {number}
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set autoLevelCapping:' + newLevel);
      this._autoLevelCapping = newLevel;
    }

    /**
     * True when automatic level selection enabled
     * @type {boolean}
     */

  }, {
    key: 'autoLevelEnabled',
    get: function get() {
      return this.levelController.manualLevel === -1;
    }

    /**
     * Level set manually (if any)
     * @type {number}
     */

  }, {
    key: 'manualLevel',
    get: function get() {
      return this.levelController.manualLevel;
    }

    /**
     * min level selectable in auto mode according to config.minAutoBitrate
     * @type {number}
     */

  }, {
    key: 'minAutoLevel',
    get: function get() {
      var hls = this,
          levels = hls.levels,
          minAutoBitrate = hls.config.minAutoBitrate,
          len = levels ? levels.length : 0;
      for (var i = 0; i < len; i++) {
        var levelNextBitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate;
        if (levelNextBitrate > minAutoBitrate) {
          return i;
        }
      }
      return 0;
    }

    /**
     * max level selectable in auto mode according to autoLevelCapping
     * @type {number}
     */

  }, {
    key: 'maxAutoLevel',
    get: function get() {
      var hls = this;
      var levels = hls.levels;
      var autoLevelCapping = hls.autoLevelCapping;
      var maxAutoLevel = void 0;
      if (autoLevelCapping === -1 && levels && levels.length) {
        maxAutoLevel = levels.length - 1;
      } else {
        maxAutoLevel = autoLevelCapping;
      }

      return maxAutoLevel;
    }

    /**
     * next automatically selected quality level
     * @type {number}
     */

  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var hls = this;
      // ensure next auto level is between  min and max auto level
      return Math.min(Math.max(hls.abrController.nextAutoLevel, hls.minAutoLevel), hls.maxAutoLevel);
    }

    /**
     * this setter is used to force next auto level.
     * this is useful to force a switch down in auto mode:
     * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
     * forced value is valid for one fragment. upon succesful frag loading at forced level,
     * this value will be resetted to -1 by ABR controller.
     * @type {number}
     */
    ,
    set: function set(nextLevel) {
      var hls = this;
      hls.abrController.nextAutoLevel = Math.max(hls.minAutoLevel, nextLevel);
    }

    /**
     * @type {AudioTrack[]}
     */

  }, {
    key: 'audioTracks',
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTracks : [];
    }

    /**
     * index of the selected audio track (index in audio track lists)
     * @type {number}
     */

  }, {
    key: 'audioTrack',
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTrack : -1;
    }

    /**
     * selects an audio track, based on its index in audio track lists
     * @type {number}
     */
    ,
    set: function set(audioTrackId) {
      var audioTrackController = this.audioTrackController;
      if (audioTrackController) {
        audioTrackController.audioTrack = audioTrackId;
      }
    }

    /**
     * @type {Seconds}
     */

  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this.streamController.liveSyncPosition;
    }

    /**
     * get alternate subtitle tracks list from playlist
     * @type {SubtitleTrack[]}
     */

  }, {
    key: 'subtitleTracks',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
    }

    /**
     * index of the selected subtitle track (index in subtitle track lists)
     * @type {number}
     */

  }, {
    key: 'subtitleTrack',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
    }

    /**
     * select an subtitle track, based on its index in subtitle track lists
     * @type{number}
     */
    ,
    set: function set(subtitleTrackId) {
      var subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleTrack = subtitleTrackId;
      }
    }

    /**
     * @type {boolean}
     */

  }, {
    key: 'subtitleDisplay',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
    }

    /**
     * Enable/disable subtitle display rendering
     * @type {boolean}
     */
    ,
    set: function set(value) {
      var subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleDisplay = value;
      }
    }
  }]);

  return Hls;
}(_observer.Observer);

exports.default = Hls;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/is-supported.js":
/*!************************************!*\
  !*** ./src/hls.js/is-supported.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSupported = isSupported;

var _mediasourceHelper = __webpack_require__(/*! ./utils/mediasource-helper */ "./src/hls.js/utils/mediasource-helper.js");

function isSupported() {
  var mediaSource = (0, _mediasourceHelper.getMediaSource)();
  var sourceBuffer = window.SourceBuffer || window.WebKitSourceBuffer;
  var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === 'function' && mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');

  // if SourceBuffer is exposed ensure its API is valid
  // safari and old version of Chrome doe not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible
  var sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';
  return !!isTypeSupported && !!sourceBufferValidAPI;
}

/***/ }),

/***/ "./src/hls.js/loader/fragment-loader.js":
/*!**********************************************!*\
  !*** ./src/hls.js/loader/fragment-loader.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Fragment Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FragmentLoader = function (_EventHandler) {
  _inherits(FragmentLoader, _EventHandler);

  function FragmentLoader(hls) {
    _classCallCheck(this, FragmentLoader);

    var _this = _possibleConstructorReturn(this, (FragmentLoader.__proto__ || Object.getPrototypeOf(FragmentLoader)).call(this, hls, _events2.default.FRAG_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(FragmentLoader, [{
    key: 'destroy',
    value: function destroy() {
      var loaders = this.loaders;
      for (var loaderName in loaders) {
        var loader = loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};

      _get(FragmentLoader.prototype.__proto__ || Object.getPrototypeOf(FragmentLoader.prototype), 'destroy', this).call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loaders = this.loaders,
          config = this.hls.config,
          FragmentILoader = config.fLoader,
          DefaultILoader = config.loader;

      // reset fragment state
      frag.loaded = 0;

      var loader = loaders[type];
      if (loader) {
        _logger.logger.warn('abort previous fragment loader for type: ' + type);
        loader.abort();
      }

      loader = loaders[type] = frag.loader = config.fLoader ? new FragmentILoader(config) : new DefaultILoader(config);

      var loaderContext = void 0,
          loaderConfig = void 0,
          loaderCallbacks = void 0;

      loaderContext = { url: frag.url, frag: frag, responseType: 'arraybuffer', progressData: false };

      var start = frag.byteRangeStartOffset,
          end = frag.byteRangeEndOffset;

      if (Number.isFinite(start) && Number.isFinite(end)) {
        loaderContext.rangeStart = start;
        loaderContext.rangeEnd = end;
      }

      loaderConfig = {
        timeout: config.fragLoadingTimeOut,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: config.fragLoadingMaxRetryTimeout
      };

      loaderCallbacks = {
        onSuccess: this.loadsuccess.bind(this),
        onError: this.loaderror.bind(this),
        onTimeout: this.loadtimeout.bind(this),
        onProgress: this.loadprogress.bind(this)
      };

      loader.load(loaderContext, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var payload = response.data,
          frag = context.frag;
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.FRAG_LOADED, { payload: payload, frag: frag, stats: stats, networkDetails: networkDetails });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var frag = context.frag;
      var loader = frag.loader;
      if (loader) {
        loader.abort();
      }

      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response, networkDetails: networkDetails });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var frag = context.frag;
      var loader = frag.loader;
      if (loader) {
        loader.abort();
      }

      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag, networkDetails: networkDetails });
    }

    // data will be used for progressive parsing

  }, {
    key: 'loadprogress',
    value: function loadprogress(stats, context, data) {
      var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      // jshint ignore:line
      var frag = context.frag;
      frag.loaded = stats.loaded;
      this.hls.trigger(_events2.default.FRAG_LOAD_PROGRESS, { frag: frag, stats: stats, networkDetails: networkDetails });
    }
  }]);

  return FragmentLoader;
}(_eventHandler2.default);

exports.default = FragmentLoader;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/fragment.js":
/*!***************************************!*\
  !*** ./src/hls.js/loader/fragment.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "../../node_modules/url-toolkit/src/url-toolkit.js");

var URLToolkit = _interopRequireWildcard(_urlToolkit);

var _levelKey = __webpack_require__(/*! ./level-key */ "./src/hls.js/loader/level-key.js");

var _levelKey2 = _interopRequireDefault(_levelKey);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Fragment = function () {
  function Fragment() {
    var _elementaryStreams;

    _classCallCheck(this, Fragment);

    this._url = null;
    this._byteRange = null;
    this._decryptdata = null;
    this.tagList = [];
    this.programDateTime = null;
    this.rawProgramDateTime = null;

    // Holds the types of data this fragment supports
    this._elementaryStreams = (_elementaryStreams = {}, _defineProperty(_elementaryStreams, Fragment.ElementaryStreamTypes.AUDIO, false), _defineProperty(_elementaryStreams, Fragment.ElementaryStreamTypes.VIDEO, false), _elementaryStreams);
  }

  /**
   * `type` property for this._elementaryStreams
   *
   * @enum
   */


  _createClass(Fragment, [{
    key: 'addElementaryStream',


    /**
     * @param {ElementaryStreamType} type
     */
    value: function addElementaryStream(type) {
      this._elementaryStreams[type] = true;
    }

    /**
     * @param {ElementaryStreamType} type
     */

  }, {
    key: 'hasElementaryStream',
    value: function hasElementaryStream(type) {
      return this._elementaryStreams[type] === true;
    }

    /**
     * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
     * @returns {Uint8Array}
     */

  }, {
    key: 'createInitializationVector',
    value: function createInitializationVector(segmentNumber) {
      var uint8View = new Uint8Array(16);

      for (var i = 12; i < 16; i++) {
        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
      }

      return uint8View;
    }

    /**
     * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
     * @param levelkey - a playlist's encryption info
     * @param segmentNumber - the fragment's segment number
     * @returns {*} - an object to be applied as a fragment's decryptdata
     */

  }, {
    key: 'fragmentDecryptdataFromLevelkey',
    value: function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {
      var decryptdata = levelkey;

      if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {
        decryptdata = new _levelKey2.default();
        decryptdata.method = levelkey.method;
        decryptdata.baseuri = levelkey.baseuri;
        decryptdata.reluri = levelkey.reluri;
        decryptdata.iv = this.createInitializationVector(segmentNumber);
      }

      return decryptdata;
    }
  }, {
    key: 'url',
    get: function get() {
      if (!this._url && this.relurl) {
        this._url = URLToolkit.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: true });
      }

      return this._url;
    },
    set: function set(value) {
      this._url = value;
    }
  }, {
    key: 'byteRange',
    get: function get() {
      if (!this._byteRange && !this.rawByteRange) {
        return [];
      }

      if (this._byteRange) {
        return this._byteRange;
      }

      var byteRange = [];
      if (this.rawByteRange) {
        var params = this.rawByteRange.split('@', 2);
        if (params.length === 1) {
          var lastByteRangeEndOffset = this.lastByteRangeEndOffset;
          byteRange[0] = lastByteRangeEndOffset || 0;
        } else {
          byteRange[0] = parseInt(params[1]);
        }
        byteRange[1] = parseInt(params[0]) + byteRange[0];
        this._byteRange = byteRange;
      }
      return byteRange;
    }

    /**
     * @type {number}
     */

  }, {
    key: 'byteRangeStartOffset',
    get: function get() {
      return this.byteRange[0];
    }
  }, {
    key: 'byteRangeEndOffset',
    get: function get() {
      return this.byteRange[1];
    }
  }, {
    key: 'decryptdata',
    get: function get() {
      if (!this._decryptdata) {
        this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn);
      }

      return this._decryptdata;
    }
  }, {
    key: 'endProgramDateTime',
    get: function get() {
      if (!Number.isFinite(this.programDateTime)) {
        return null;
      }

      var duration = !Number.isFinite(this.duration) ? 0 : this.duration;

      return this.programDateTime + duration * 1000;
    }
  }, {
    key: 'encrypted',
    get: function get() {
      return !!(this.decryptdata && this.decryptdata.uri !== null && this.decryptdata.key === null);
    }
  }], [{
    key: 'ElementaryStreamTypes',
    get: function get() {
      return {
        AUDIO: 'audio',
        VIDEO: 'video'
      };
    }
  }]);

  return Fragment;
}();

exports.default = Fragment;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/key-loader.js":
/*!*****************************************!*\
  !*** ./src/hls.js/loader/key-loader.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Decrypt key Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var KeyLoader = function (_EventHandler) {
  _inherits(KeyLoader, _EventHandler);

  function KeyLoader(hls) {
    _classCallCheck(this, KeyLoader);

    var _this = _possibleConstructorReturn(this, (KeyLoader.__proto__ || Object.getPrototypeOf(KeyLoader)).call(this, hls, _events2.default.KEY_LOADING));

    _this.loaders = {};
    _this.decryptkey = null;
    _this.decrypturl = null;
    return _this;
  }

  _createClass(KeyLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onKeyLoading',
    value: function onKeyLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          decryptdata = frag.decryptdata,
          uri = decryptdata.uri;
      // if uri is different from previous one or if decrypt key not retrieved yet
      if (uri !== this.decrypturl || this.decryptkey === null) {
        var config = this.hls.config;

        if (loader) {
          _logger.logger.warn('abort previous key loader for type:' + type);
          loader.abort();
        }
        frag.loader = this.loaders[type] = new config.loader(config);
        this.decrypturl = uri;
        this.decryptkey = null;

        var loaderContext = void 0,
            loaderConfig = void 0,
            loaderCallbacks = void 0;
        loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };
        // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,
        // key-loader will trigger an error and rely on stream-controller to handle retry logic.
        // this will also align retry logic with fragment-loader
        loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
        loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
        frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);
      } else if (this.decryptkey) {
        // we already loaded this key, return it
        decryptdata.key = this.decryptkey;
        this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
      }
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var frag = context.frag;
      this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }

      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }

      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: frag });
    }
  }]);

  return KeyLoader;
}(_eventHandler2.default);

exports.default = KeyLoader;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/level-key.js":
/*!****************************************!*\
  !*** ./src/hls.js/loader/level-key.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "../../node_modules/url-toolkit/src/url-toolkit.js");

var URLToolkit = _interopRequireWildcard(_urlToolkit);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LevelKey = function () {
  function LevelKey() {
    _classCallCheck(this, LevelKey);

    this.method = null;
    this.key = null;
    this.iv = null;
    this._uri = null;
  }

  _createClass(LevelKey, [{
    key: 'uri',
    get: function get() {
      if (!this._uri && this.reluri) {
        this._uri = URLToolkit.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: true });
      }

      return this._uri;
    }
  }]);

  return LevelKey;
}();

exports.default = LevelKey;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/level.js":
/*!************************************!*\
  !*** ./src/hls.js/loader/level.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Level = function () {
  function Level(baseUrl) {
    _classCallCheck(this, Level);

    // Please keep properties in alphabetical order
    this.endCC = 0;
    this.endSN = 0;
    this.fragments = [];
    this.initSegment = null;
    this.live = true;
    this.needSidxRanges = false;
    this.startCC = 0;
    this.startSN = 0;
    this.startTimeOffset = null;
    this.targetduration = 0;
    this.totalduration = 0;
    this.type = null;
    this.url = baseUrl;
    this.version = null;
  }

  _createClass(Level, [{
    key: "hasProgramDateTime",
    get: function get() {
      return !!(this.fragments[0] && Number.isFinite(this.fragments[0].programDateTime));
    }
  }]);

  return Level;
}();

exports.default = Level;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/loader/m3u8-parser.js":
/*!******************************************!*\
  !*** ./src/hls.js/loader/m3u8-parser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "../../node_modules/url-toolkit/src/url-toolkit.js");

var URLToolkit = _interopRequireWildcard(_urlToolkit);

var _fragment = __webpack_require__(/*! ./fragment */ "./src/hls.js/loader/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _level = __webpack_require__(/*! ./level */ "./src/hls.js/loader/level.js");

var _level2 = _interopRequireDefault(_level);

var _levelKey = __webpack_require__(/*! ./level-key */ "./src/hls.js/loader/level-key.js");

var _levelKey2 = _interopRequireDefault(_levelKey);

var _attrList = __webpack_require__(/*! ../utils/attr-list */ "./src/hls.js/utils/attr-list.js");

var _attrList2 = _interopRequireDefault(_attrList);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _codecs = __webpack_require__(/*! ../utils/codecs */ "./src/hls.js/utils/codecs.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * M3U8 parser
 * @module
 */

// https://regex101.com is your friend
var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;

var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
/|(?!#)([\S+ ?]+)/.source, // segment URI, group 3 => the URI (note newline is not eaten)
/|#EXT-X-BYTERANGE:*(.+)/.source, // next segment's byterange, group 4 => range spec (x@y)
/|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, // next segment's program date/time group 5 => the datetime spec
/|#.*/.source // All other non-segment oriented tags will match with all groups empty
].join(''), 'g');

var LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)([^:]*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/;

var MP4_REGEX_SUFFIX = /\.(mp4|m4s|m4v|m4a)$/i;

var M3U8Parser = function () {
  function M3U8Parser() {
    _classCallCheck(this, M3U8Parser);
  }

  _createClass(M3U8Parser, null, [{
    key: 'findGroup',
    value: function findGroup(groups, mediaGroupId) {
      if (!groups) {
        return null;
      }

      var matchingGroup = null;

      for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        if (group.id === mediaGroupId) {
          matchingGroup = group;
        }
      }

      return matchingGroup;
    }
  }, {
    key: 'convertAVC1ToAVCOTI',
    value: function convertAVC1ToAVCOTI(codec) {
      var result = void 0,
          avcdata = codec.split('.');
      if (avcdata.length > 2) {
        result = avcdata.shift() + '.';
        result += parseInt(avcdata.shift()).toString(16);
        result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
      } else {
        result = codec;
      }
      return result;
    }
  }, {
    key: 'resolve',
    value: function resolve(url, baseUrl) {
      return URLToolkit.buildAbsoluteURL(baseUrl, url, { alwaysNormalize: true });
    }
  }, {
    key: 'parseMasterPlaylist',
    value: function parseMasterPlaylist(string, baseurl) {
      var levels = [],
          result = void 0;
      MASTER_PLAYLIST_REGEX.lastIndex = 0;

      function setCodecs(codecs, level) {
        ['video', 'audio'].forEach(function (type) {
          var filtered = codecs.filter(function (codec) {
            return (0, _codecs.isCodecType)(codec, type);
          });
          if (filtered.length) {
            var preferred = filtered.filter(function (codec) {
              return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;
            });
            level[type + 'Codec'] = preferred.length > 0 ? preferred[0] : filtered[0];

            // remove from list
            codecs = codecs.filter(function (codec) {
              return filtered.indexOf(codec) === -1;
            });
          }
        });

        level.unknownCodecs = codecs;
      }

      while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
        var level = {};

        var attrs = level.attrs = new _attrList2.default(result[1]);
        level.url = M3U8Parser.resolve(result[2], baseurl);

        var resolution = attrs.decimalResolution('RESOLUTION');
        if (resolution) {
          level.width = resolution.width;
          level.height = resolution.height;
        }
        level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');
        level.name = attrs.NAME;

        setCodecs([].concat((attrs.CODECS || '').split(/[ ,]+/)), level);

        if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) {
          level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);
        }

        levels.push(level);
      }
      return levels;
    }
  }, {
    key: 'parseMasterPlaylistMedia',
    value: function parseMasterPlaylistMedia(string, baseurl, type) {
      var audioGroups = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

      var result = void 0;
      var medias = [];
      var id = 0;
      MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
      while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
        var media = {};
        var attrs = new _attrList2.default(result[1]);
        if (attrs.TYPE === type) {
          media.groupId = attrs['GROUP-ID'];
          media.name = attrs.NAME;
          media.type = type;
          media.default = attrs.DEFAULT === 'YES';
          media.autoselect = attrs.AUTOSELECT === 'YES';
          media.forced = attrs.FORCED === 'YES';
          if (attrs.URI) {
            media.url = M3U8Parser.resolve(attrs.URI, baseurl);
          }

          media.lang = attrs.LANGUAGE;
          if (!media.name) {
            media.name = media.lang;
          }

          if (audioGroups.length) {
            var groupCodec = M3U8Parser.findGroup(audioGroups, media.groupId);
            media.audioCodec = groupCodec ? groupCodec.codec : audioGroups[0].codec;
          }
          media.id = id++;
          medias.push(media);
        }
      }
      return medias;
    }
  }, {
    key: 'parseLevelPlaylist',
    value: function parseLevelPlaylist(string, baseurl, id, type, levelUrlId) {
      var currentSN = 0;
      var totalduration = 0;
      var level = new _level2.default(baseurl);
      var levelkey = new _levelKey2.default();
      var cc = 0;
      var prevFrag = null;
      var frag = new _fragment2.default();
      var result = void 0;
      var i = void 0;

      var firstPdtIndex = null;

      LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;

      while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
        var duration = result[1];
        if (duration) {
          // INF
          frag.duration = parseFloat(duration);
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          var title = (' ' + result[2]).slice(1);
          frag.title = title || null;
          frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);
        } else if (result[3]) {
          // url
          if (Number.isFinite(frag.duration)) {
            var sn = currentSN++;
            frag.type = type;
            frag.start = totalduration;
            frag.levelkey = levelkey;
            frag.sn = sn;
            frag.level = id;
            frag.cc = cc;
            frag.urlId = levelUrlId;
            frag.baseurl = baseurl;
            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
            frag.relurl = (' ' + result[3]).slice(1);
            assignProgramDateTime(frag, prevFrag);

            level.fragments.push(frag);
            prevFrag = frag;
            totalduration += frag.duration;

            frag = new _fragment2.default();
          }
        } else if (result[4]) {
          // X-BYTERANGE
          frag.rawByteRange = (' ' + result[4]).slice(1);
          if (prevFrag) {
            var lastByteRangeEndOffset = prevFrag.byteRangeEndOffset;
            if (lastByteRangeEndOffset) {
              frag.lastByteRangeEndOffset = lastByteRangeEndOffset;
            }
          }
        } else if (result[5]) {
          // PROGRAM-DATE-TIME
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          frag.rawProgramDateTime = (' ' + result[5]).slice(1);
          frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);
          if (firstPdtIndex === null) {
            firstPdtIndex = level.fragments.length;
          }
        } else {
          result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
          for (i = 1; i < result.length; i++) {
            if (result[i] !== undefined) {
              break;
            }
          }

          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          var value1 = (' ' + result[i + 1]).slice(1);
          var value2 = (' ' + result[i + 2]).slice(1);

          switch (result[i]) {
            case '#':
              frag.tagList.push(value2 ? [value1, value2] : [value1]);
              break;
            case 'PLAYLIST-TYPE':
              level.type = value1.toUpperCase();
              break;
            case 'MEDIA-SEQUENCE':
              currentSN = level.startSN = parseInt(value1);
              break;
            case 'TARGETDURATION':
              level.targetduration = parseFloat(value1);
              break;
            case 'VERSION':
              level.version = parseInt(value1);
              break;
            case 'EXTM3U':
              break;
            case 'ENDLIST':
              level.live = false;
              break;
            case 'DIS':
              cc++;
              frag.tagList.push(['DIS']);
              break;
            case 'DISCONTINUITY-SEQ':
              cc = parseInt(value1);
              break;
            case 'KEY':
              // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
              var decryptparams = value1;
              var keyAttrs = new _attrList2.default(decryptparams);
              var decryptmethod = keyAttrs.enumeratedString('METHOD'),
                  decrypturi = keyAttrs.URI,
                  decryptiv = keyAttrs.hexadecimalInteger('IV');
              if (decryptmethod) {
                levelkey = new _levelKey2.default();
                if (decrypturi && ['AES-128', 'SAMPLE-AES', 'SAMPLE-AES-CENC'].indexOf(decryptmethod) >= 0) {
                  levelkey.method = decryptmethod;
                  // URI to get the key
                  levelkey.baseuri = baseurl;
                  levelkey.reluri = decrypturi;
                  levelkey.key = null;
                  // Initialization Vector (IV)
                  levelkey.iv = decryptiv;
                }
              }
              break;
            case 'START':
              var startParams = value1;
              var startAttrs = new _attrList2.default(startParams);
              var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
              // TIME-OFFSET can be 0
              if (Number.isFinite(startTimeOffset)) {
                level.startTimeOffset = startTimeOffset;
              }

              break;
            case 'MAP':
              var mapAttrs = new _attrList2.default(value1);
              frag.relurl = mapAttrs.URI;
              frag.rawByteRange = mapAttrs.BYTERANGE;
              frag.baseurl = baseurl;
              frag.level = id;
              frag.type = type;
              frag.sn = 'initSegment';
              level.initSegment = frag;
              frag = new _fragment2.default();
              frag.rawProgramDateTime = level.initSegment.rawProgramDateTime;
              break;
            default:
              _logger.logger.warn('line parsed but not handled: ' + result);
              break;
          }
        }
      }
      frag = prevFrag;
      // logger.log('found ' + level.fragments.length + ' fragments');
      if (frag && !frag.relurl) {
        level.fragments.pop();
        totalduration -= frag.duration;
      }
      level.totalduration = totalduration;
      level.averagetargetduration = totalduration / level.fragments.length;
      level.endSN = currentSN - 1;
      level.startCC = level.fragments[0] ? level.fragments[0].cc : 0;
      level.endCC = cc;

      if (!level.initSegment && level.fragments.length) {
        // this is a bit lurky but HLS really has no other way to tell us
        // if the fragments are TS or MP4, except if we download them :/
        // but this is to be able to handle SIDX.
        if (level.fragments.every(function (frag) {
          return MP4_REGEX_SUFFIX.test(frag.relurl);
        })) {
          _logger.logger.warn('MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX');

          frag = new _fragment2.default();
          frag.relurl = level.fragments[0].relurl;
          frag.baseurl = baseurl;
          frag.level = id;
          frag.type = type;
          frag.sn = 'initSegment';

          level.initSegment = frag;
          level.needSidxRanges = true;
        }
      }

      /**
       * Backfill any missing PDT values
         "If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after
         one or more Media Segment URIs, the client SHOULD extrapolate
         backward from that tag (using EXTINF durations and/or media
         timestamps) to associate dates with those segments."
       * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs
       * computed.
       */
      if (firstPdtIndex) {
        backfillProgramDateTimes(level.fragments, firstPdtIndex);
      }

      return level;
    }
  }]);

  return M3U8Parser;
}();

exports.default = M3U8Parser;


function backfillProgramDateTimes(fragments, startIndex) {
  var fragPrev = fragments[startIndex];
  for (var i = startIndex - 1; i >= 0; i--) {
    var frag = fragments[i];
    frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;
    fragPrev = frag;
  }
}

function assignProgramDateTime(frag, prevFrag) {
  if (frag.rawProgramDateTime) {
    frag.programDateTime = Date.parse(frag.rawProgramDateTime);
  } else if (prevFrag && prevFrag.programDateTime) {
    frag.programDateTime = prevFrag.endProgramDateTime;
  }

  if (!Number.isFinite(frag.programDateTime)) {
    frag.programDateTime = null;
    frag.rawProgramDateTime = null;
  }
}
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/playlist-loader.js":
/*!**********************************************!*\
  !*** ./src/hls.js/loader/playlist-loader.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _mp4demuxer = __webpack_require__(/*! ../demux/mp4demuxer */ "./src/hls.js/demux/mp4demuxer.js");

var _mp4demuxer2 = _interopRequireDefault(_mp4demuxer);

var _m3u8Parser = __webpack_require__(/*! ./m3u8-parser */ "./src/hls.js/loader/m3u8-parser.js");

var _m3u8Parser2 = _interopRequireDefault(_m3u8Parser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * PlaylistLoader - delegate for media manifest/playlist loading tasks. Takes care of parsing media to internal data-models.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Once loaded, dispatches events with parsed data-models of manifest/levels/audio/subtitle tracks.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Uses loader(s) set in config to do actual internal loading of resource tasks.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _window = window,
    performance = _window.performance;

/**
 * `type` property values for this loaders' context object
 * @enum
 *
 */

var ContextType = {
  MANIFEST: 'manifest',
  LEVEL: 'levels.js',
  AUDIO_TRACK: 'audioTrack',
  SUBTITLE_TRACK: 'subtitleTrack'
};

/**
 * @enum {string}
 */
var LevelType = {
  MAIN: 'main',
  AUDIO: 'audio',
  SUBTITLE: 'subtitle'
};

/**
 * @constructor
 */

var PlaylistLoader = function (_EventHandler) {
  _inherits(PlaylistLoader, _EventHandler);

  /**
   * @constructs
   * @param {Hls} hls
   */
  function PlaylistLoader(hls) {
    _classCallCheck(this, PlaylistLoader);

    var _this = _possibleConstructorReturn(this, (PlaylistLoader.__proto__ || Object.getPrototypeOf(PlaylistLoader)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.LEVEL_LOADING, _events2.default.AUDIO_TRACK_LOADING, _events2.default.SUBTITLE_TRACK_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(PlaylistLoader, [{
    key: 'createInternalLoader',


    /**
     * Returns defaults or configured loader-type overloads (pLoader and loader config params)
     * Default loader is XHRLoader (see utils)
     * @param {object} context
     * @returns {XHRLoader} or other compatible configured overload
     */
    value: function createInternalLoader(context) {
      var config = this.hls.config;
      var PLoader = config.pLoader;
      var Loader = config.loader;
      var InternalLoader = PLoader || Loader;

      var loader = new InternalLoader(config);

      context.loader = loader;
      this.loaders[context.type] = loader;

      return loader;
    }
  }, {
    key: 'getInternalLoader',
    value: function getInternalLoader(context) {
      return this.loaders[context.type];
    }
  }, {
    key: 'resetInternalLoader',
    value: function resetInternalLoader(contextType) {
      if (this.loaders[contextType]) {
        delete this.loaders[contextType];
      }
    }

    /**
     * Call `destroy` on all internal loader instances mapped (one per context type)
     */

  }, {
    key: 'destroyInternalLoaders',
    value: function destroyInternalLoaders() {
      for (var contextType in this.loaders) {
        var loader = this.loaders[contextType];
        if (loader) {
          loader.destroy();
        }

        this.resetInternalLoader(contextType);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.destroyInternalLoaders();

      _get(PlaylistLoader.prototype.__proto__ || Object.getPrototypeOf(PlaylistLoader.prototype), 'destroy', this).call(this);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading(data) {
      this.load(data.url, { type: ContextType.MANIFEST, level: 0, id: null });
    }
  }, {
    key: 'onLevelLoading',
    value: function onLevelLoading(data) {
      this.load(data.url, { type: ContextType.LEVEL, level: data.levels, id: data.id });
    }
  }, {
    key: 'onAudioTrackLoading',
    value: function onAudioTrackLoading(data) {
      this.load(data.url, { type: ContextType.AUDIO_TRACK, level: null, id: data.id });
    }
  }, {
    key: 'onSubtitleTrackLoading',
    value: function onSubtitleTrackLoading(data) {
      this.load(data.url, { type: ContextType.SUBTITLE_TRACK, level: null, id: data.id });
    }
  }, {
    key: 'load',
    value: function load(url, context) {
      var config = this.hls.config;

      _logger.logger.debug('Loading playlist of type ' + context.type + ', level: ' + context.levels + ', id: ' + context.id);

      // Check if a loader for this context already exists
      var loader = this.getInternalLoader(context);
      if (loader) {
        var loaderContext = loader.context;
        if (loaderContext && loaderContext.url === url) {
          // same URL can't overlap
          _logger.logger.trace('playlist request ongoing');
          return false;
        } else {
          _logger.logger.warn('aborting previous loader for type: ' + context.type);
          loader.abort();
        }
      }

      var maxRetry = void 0,
          timeout = void 0,
          retryDelay = void 0,
          maxRetryDelay = void 0;

      // apply different configs for retries depending on
      // context (manifest, level, audio/subs playlist)
      switch (context.type) {
        case ContextType.MANIFEST:
          maxRetry = config.manifestLoadingMaxRetry;
          timeout = config.manifestLoadingTimeOut;
          retryDelay = config.manifestLoadingRetryDelay;
          maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
          break;
        case ContextType.LEVEL:
          // Disable internal loader retry logic, since we are managing retries in Level Controller
          maxRetry = 0;
          timeout = config.levelLoadingTimeOut;
          // TODO Introduce retry settings for audio-track and subtitle-track, it should not use level retry config
          break;
        default:
          maxRetry = config.levelLoadingMaxRetry;
          timeout = config.levelLoadingTimeOut;
          retryDelay = config.levelLoadingRetryDelay;
          maxRetryDelay = config.levelLoadingMaxRetryTimeout;
          break;
      }

      loader = this.createInternalLoader(context);

      context.url = url;
      context.responseType = context.responseType || ''; // FIXME: (should not be necessary to do this)

      var loaderConfig = {
        timeout: timeout,
        maxRetry: maxRetry,
        retryDelay: retryDelay,
        maxRetryDelay: maxRetryDelay
      };

      var loaderCallbacks = {
        onSuccess: this.loadsuccess.bind(this),
        onError: this.loaderror.bind(this),
        onTimeout: this.loadtimeout.bind(this)
      };

      _logger.logger.debug('Calling internal loader delegate for URL: ' + url);

      loader.load(context, loaderConfig, loaderCallbacks);

      return true;
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      if (context.isSidxRequest) {
        this._handleSidxRequest(response, context);
        this._handlePlaylistLoaded(response, stats, context, networkDetails);
        return;
      }

      this.resetInternalLoader(context.type);

      var string = response.data;

      stats.tload = performance.now();
      // stats.mtime = new Date(target.getResponseHeader('Last-Modified'));

      // Validate if it is an M3U8 at all
      if (string.indexOf('#EXTM3U') !== 0) {
        this._handleManifestParsingError(response, context, 'no EXTM3U delimiter', networkDetails);
        return;
      }

      // Check if chunk-list or master. handle empty chunk list case (first EXTINF not signaled, but TARGETDURATION present)
      if (string.indexOf('#EXTINF:') > 0 || string.indexOf('#EXT-X-TARGETDURATION:') > 0) {
        this._handleTrackOrLevelPlaylist(response, stats, context, networkDetails);
      } else {
        this._handleMasterPlaylist(response, stats, context, networkDetails);
      }
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      this._handleNetworkError(context, networkDetails, false, response);
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      this._handleNetworkError(context, networkDetails, true);
    }
  }, {
    key: '_handleMasterPlaylist',
    value: function _handleMasterPlaylist(response, stats, context, networkDetails) {
      var hls = this.hls;
      var string = response.data;

      var url = PlaylistLoader.getResponseUrl(response, context);

      var levels = _m3u8Parser2.default.parseMasterPlaylist(string, url);
      if (!levels.length) {
        this._handleManifestParsingError(response, context, 'no level found in manifest', networkDetails);
        return;
      }

      // multi level playlist, parse level info

      var audioGroups = levels.map(function (level) {
        return {
          id: level.attrs.AUDIO,
          codec: level.audioCodec
        };
      });

      var audioTracks = _m3u8Parser2.default.parseMasterPlaylistMedia(string, url, 'AUDIO', audioGroups);
      var subtitles = _m3u8Parser2.default.parseMasterPlaylistMedia(string, url, 'SUBTITLES');

      if (audioTracks.length) {
        // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
        var embeddedAudioFound = false;
        audioTracks.forEach(function (audioTrack) {
          if (!audioTrack.url) {
            embeddedAudioFound = true;
          }
        });

        // if no embedded audio track defined, but audio codec signaled in quality level,
        // we need to signal this main audio track this could happen with playlists with
        // alt audio rendition in which quality levels (main)
        // contains both audio+video. but with mixed audio track not signaled
        if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
          _logger.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');
          audioTracks.unshift({
            type: 'main',
            name: 'main'
          });
        }
      }

      hls.trigger(_events2.default.MANIFEST_LOADED, {
        levels: levels,
        audioTracks: audioTracks,
        subtitles: subtitles,
        url: url,
        stats: stats,
        networkDetails: networkDetails
      });
    }
  }, {
    key: '_handleTrackOrLevelPlaylist',
    value: function _handleTrackOrLevelPlaylist(response, stats, context, networkDetails) {
      var hls = this.hls;

      var id = context.id,
          level = context.level,
          type = context.type;


      var url = PlaylistLoader.getResponseUrl(response, context);

      var levelUrlId = Number.isFinite(id) ? id : 0;
      var levelId = Number.isFinite(level) ? level : levelUrlId;
      var levelType = PlaylistLoader.mapContextToLevelType(context);

      var levelDetails = _m3u8Parser2.default.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId);

      // set stats on level structure
      levelDetails.tload = stats.tload;

      // We have done our first request (Manifest-type) and receive
      // not a master playlist but a chunk-list (track/level)
      // We fire the manifest-loaded event anyway with the parsed level-details
      // by creating a single-level structure for it.
      if (type === ContextType.MANIFEST) {
        var singleLevel = {
          url: url,
          details: levelDetails
        };

        hls.trigger(_events2.default.MANIFEST_LOADED, {
          levels: [singleLevel],
          audioTracks: [],
          url: url,
          stats: stats,
          networkDetails: networkDetails
        });
      }

      // save parsing time
      stats.tparsed = performance.now();

      // in case we need SIDX ranges
      // return early after calling load for
      // the SIDX box.
      if (levelDetails.needSidxRanges) {
        var sidxUrl = levelDetails.initSegment.url;
        this.load(sidxUrl, {
          isSidxRequest: true,
          type: type,
          level: level,
          levelDetails: levelDetails,
          id: id,
          rangeStart: 0,
          rangeEnd: 2048,
          responseType: 'arraybuffer'
        });
        return;
      }

      // extend the context with the new levelDetails property
      context.levelDetails = levelDetails;

      this._handlePlaylistLoaded(response, stats, context, networkDetails);
    }
  }, {
    key: '_handleSidxRequest',
    value: function _handleSidxRequest(response, context) {
      var sidxInfo = _mp4demuxer2.default.parseSegmentIndex(new Uint8Array(response.data));
      // if provided fragment does not contain sidx, early return
      if (!sidxInfo) {
        return;
      }
      var sidxReferences = sidxInfo.references;
      var levelDetails = context.levelDetails;
      sidxReferences.forEach(function (segmentRef, index) {
        var segRefInfo = segmentRef.info;
        var frag = levelDetails.fragments[index];

        if (frag.byteRange.length === 0) {
          frag.rawByteRange = String(1 + segRefInfo.end - segRefInfo.start) + '@' + String(segRefInfo.start);
        }
      });
      levelDetails.initSegment.rawByteRange = String(sidxInfo.moovEndOffset) + '@0';
    }
  }, {
    key: '_handleManifestParsingError',
    value: function _handleManifestParsingError(response, context, reason, networkDetails) {
      this.hls.trigger(_events2.default.ERROR, {
        type: _errors.ErrorTypes.NETWORK_ERROR,
        details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR,
        fatal: true,
        url: response.url,
        reason: reason,
        networkDetails: networkDetails
      });
    }
  }, {
    key: '_handleNetworkError',
    value: function _handleNetworkError(context, networkDetails) {
      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var response = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      _logger.logger.info('A network error occured while loading a ' + context.type + '-type playlist');

      var details = void 0;
      var fatal = void 0;

      var loader = this.getInternalLoader(context);

      switch (context.type) {
        case ContextType.MANIFEST:
          details = timeout ? _errors.ErrorDetails.MANIFEST_LOAD_TIMEOUT : _errors.ErrorDetails.MANIFEST_LOAD_ERROR;
          fatal = true;
          break;
        case ContextType.LEVEL:
          details = timeout ? _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT : _errors.ErrorDetails.LEVEL_LOAD_ERROR;
          fatal = false;
          break;
        case ContextType.AUDIO_TRACK:
          details = timeout ? _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
          fatal = false;
          break;
        default:
          // details = ...?
          fatal = false;
      }

      if (loader) {
        loader.abort();
        this.resetInternalLoader(context.type);
      }

      var errorData = {
        type: _errors.ErrorTypes.NETWORK_ERROR,
        details: details,
        fatal: fatal,
        url: loader.url,
        loader: loader,
        context: context,
        networkDetails: networkDetails
      };

      if (response) {
        errorData.response = response;
      }

      this.hls.trigger(_events2.default.ERROR, errorData);
    }
  }, {
    key: '_handlePlaylistLoaded',
    value: function _handlePlaylistLoaded(response, stats, context, networkDetails) {
      var type = context.type,
          level = context.level,
          id = context.id,
          levelDetails = context.levelDetails;


      if (!levelDetails.targetduration) {
        this._handleManifestParsingError(response, context, 'invalid target duration', networkDetails);
        return;
      }

      var canHaveLevels = PlaylistLoader.canHaveQualityLevels(context.type);
      if (canHaveLevels) {
        this.hls.trigger(_events2.default.LEVEL_LOADED, {
          details: levelDetails,
          level: level || 0,
          id: id || 0,
          stats: stats,
          networkDetails: networkDetails
        });
      } else {
        switch (type) {
          case ContextType.AUDIO_TRACK:
            this.hls.trigger(_events2.default.AUDIO_TRACK_LOADED, {
              details: levelDetails,
              id: id,
              stats: stats,
              networkDetails: networkDetails
            });
            break;
          case ContextType.SUBTITLE_TRACK:
            this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADED, {
              details: levelDetails,
              id: id,
              stats: stats,
              networkDetails: networkDetails
            });
            break;
        }
      }
    }
  }], [{
    key: 'canHaveQualityLevels',


    /**
     * @param {ContextType} type
     * @returns {boolean}
     */
    value: function canHaveQualityLevels(type) {
      return type !== ContextType.AUDIO_TRACK && type !== ContextType.SUBTITLE_TRACK;
    }

    /**
     * Map context.type to LevelType
     * @param {{type: ContextType}} context
     * @returns {LevelType}
     */

  }, {
    key: 'mapContextToLevelType',
    value: function mapContextToLevelType(context) {
      var type = context.type;


      switch (type) {
        case ContextType.AUDIO_TRACK:
          return LevelType.AUDIO;
        case ContextType.SUBTITLE_TRACK:
          return LevelType.SUBTITLE;
        default:
          return LevelType.MAIN;
      }
    }
  }, {
    key: 'getResponseUrl',
    value: function getResponseUrl(response, context) {
      var url = response.url;
      // responseURL not supported on some browsers (it is used to detect URL redirection)
      // data-uri mode also not supported (but no need to detect redirection)
      if (url === undefined || url.indexOf('data:') === 0) {
        // fallback to initial URL
        url = context.url;
      }
      return url;
    }
  }, {
    key: 'ContextType',
    get: function get() {
      return ContextType;
    }
  }, {
    key: 'LevelType',
    get: function get() {
      return LevelType;
    }
  }]);

  return PlaylistLoader;
}(_eventHandler2.default);

exports.default = PlaylistLoader;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/observer.js":
/*!********************************!*\
  !*** ./src/hls.js/observer.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Observer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventemitter = __webpack_require__(/*! eventemitter3 */ "../../node_modules/eventemitter3/index.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class
 *
 * Simple adapter sub-class of Nodejs-like EventEmitter.
 *
 * We simply want to pass along the event-name itself
 * in every call to a handler, which is the purpose of our `trigger` method
 * extending the standard API.
 *
 */
var Observer = exports.Observer = function (_EventEmitter) {
  _inherits(Observer, _EventEmitter);

  function Observer() {
    _classCallCheck(this, Observer);

    return _possibleConstructorReturn(this, (Observer.__proto__ || Object.getPrototypeOf(Observer)).apply(this, arguments));
  }

  _createClass(Observer, [{
    key: 'trigger',

    /**
     *
     * @param {string} event
     * @param {any} data
     */
    value: function trigger(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      this.emit.apply(this, [event, event].concat(data));
    }
  }]);

  return Observer;
}(_eventemitter.EventEmitter);

/***/ }),

/***/ "./src/hls.js/remux/aac-helper.js":
/*!****************************************!*\
  !*** ./src/hls.js/remux/aac-helper.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  AAC helper
 */

var AAC = function () {
  function AAC() {
    _classCallCheck(this, AAC);
  }

  _createClass(AAC, null, [{
    key: 'getSilentFrame',
    value: function getSilentFrame(codec, channelCount) {
      switch (codec) {
        case 'mp4a.40.2':
          if (channelCount === 1) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
          } else if (channelCount === 2) {
            return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
          } else if (channelCount === 3) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
          } else if (channelCount === 4) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
          } else if (channelCount === 5) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
          } else if (channelCount === 6) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
          }

          break;
        // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
        default:
          if (channelCount === 1) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          } else if (channelCount === 2) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          } else if (channelCount === 3) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          }
          break;
      }
      return null;
    }
  }]);

  return AAC;
}();

exports.default = AAC;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/remux/mp4-generator.js":
/*!*******************************************!*\
  !*** ./src/hls.js/remux/mp4-generator.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generate MP4 Box
*/

var UINT32_MAX = Math.pow(2, 32) - 1;

var MP4 = function () {
  function MP4() {
    _classCallCheck(this, MP4);
  }

  _createClass(MP4, null, [{
    key: 'init',
    value: function init() {
      MP4.types = {
        avc1: [], // codingname
        avcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        '.mp3': [],
        mvex: [],
        mvhd: [],
        pasp: [],
        sdtp: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        tfdt: [],
        tfhd: [],
        traf: [],
        trak: [],
        trun: [],
        trex: [],
        tkhd: [],
        vmhd: [],
        smhd: []
      };

      var i = void 0;
      for (i in MP4.types) {
        if (MP4.types.hasOwnProperty(i)) {
          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
        }
      }

      var videoHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
      ]);

      var audioHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
      ]);

      MP4.HDLR_TYPES = {
        'video': videoHdlr,
        'audio': audioHdlr
      };

      var dref = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01, // entry_count
      0x00, 0x00, 0x00, 0x0c, // entry_size
      0x75, 0x72, 0x6c, 0x20, // 'url' type
      0x00, // version 0
      0x00, 0x00, 0x01 // entry_flags
      ]);

      var stco = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00 // entry_count
      ]);

      MP4.STTS = MP4.STSC = MP4.STCO = stco;

      MP4.STSZ = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // sample_size
      0x00, 0x00, 0x00, 0x00 // sample_count
      ]);
      MP4.VMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x01, // flags
      0x00, 0x00, // graphicsmode
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
      ]);
      MP4.SMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, // balance
      0x00, 0x00 // reserved
      ]);

      MP4.STSD = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01]); // entry_count

      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
      var minorVersion = new Uint8Array([0, 0, 0, 1]);

      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
    }
  }, {
    key: 'box',
    value: function box(type) {
      var payload = Array.prototype.slice.call(arguments, 1),
          size = 8,
          i = payload.length,
          len = i,
          result = void 0;
      // calculate the total size we need to allocate
      while (i--) {
        size += payload[i].byteLength;
      }

      result = new Uint8Array(size);
      result[0] = size >> 24 & 0xff;
      result[1] = size >> 16 & 0xff;
      result[2] = size >> 8 & 0xff;
      result[3] = size & 0xff;
      result.set(type, 4);
      // copy the payload into the result
      for (i = 0, size = 8; i < len; i++) {
        // copy payload[i] array @ offset size
        result.set(payload[i], size);
        size += payload[i].byteLength;
      }
      return result;
    }
  }, {
    key: 'hdlr',
    value: function hdlr(type) {
      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
    }
  }, {
    key: 'mdat',
    value: function mdat(data) {
      return MP4.box(MP4.types.mdat, data);
    }
  }, {
    key: 'mdhd',
    value: function mdhd(timescale, duration) {
      duration *= timescale;
      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.mdhd, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x55, 0xc4, // 'und' language (undetermined)
      0x00, 0x00]));
    }
  }, {
    key: 'mdia',
    value: function mdia(track) {
      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
    }
  }, {
    key: 'mfhd',
    value: function mfhd(sequenceNumber) {
      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
      sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF // sequence_number
      ]));
    }
  }, {
    key: 'minf',
    value: function minf(track) {
      if (track.type === 'audio') {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
      } else {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
      }
    }
  }, {
    key: 'moof',
    value: function moof(sn, baseMediaDecodeTime, track) {
      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
    }
    /**
    * @param tracks... (optional) {array} the tracks associated with this movie
    */

  }, {
    key: 'moov',
    value: function moov(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trak(tracks[i]);
      }

      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
    }
  }, {
    key: 'mvex',
    value: function mvex(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trex(tracks[i]);
      }

      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
    }
  }, {
    key: 'mvhd',
    value: function mvhd(timescale, duration) {
      duration *= timescale;
      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      var bytes = new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x01, 0x00, 0x00, // 1.0 rate
      0x01, 0x00, // 1.0 volume
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      0xff, 0xff, 0xff, 0xff // next_track_ID
      ]);
      return MP4.box(MP4.types.mvhd, bytes);
    }
  }, {
    key: 'sdtp',
    value: function sdtp(track) {
      var samples = track.samples || [],
          bytes = new Uint8Array(4 + samples.length),
          flags = void 0,
          i = void 0;
      // leave the full box header (4 bytes) all zero
      // write the sample table
      for (i = 0; i < samples.length; i++) {
        flags = samples[i].flags;
        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
      }

      return MP4.box(MP4.types.sdtp, bytes);
    }
  }, {
    key: 'stbl',
    value: function stbl(track) {
      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
    }
  }, {
    key: 'avc1',
    value: function avc1(track) {
      var sps = [],
          pps = [],
          i = void 0,
          data = void 0,
          len = void 0;
      // assemble the SPSs

      for (i = 0; i < track.sps.length; i++) {
        data = track.sps[i];
        len = data.byteLength;
        sps.push(len >>> 8 & 0xFF);
        sps.push(len & 0xFF);

        // SPS
        sps = sps.concat(Array.prototype.slice.call(data));
      }

      // assemble the PPSs
      for (i = 0; i < track.pps.length; i++) {
        data = track.pps[i];
        len = data.byteLength;
        pps.push(len >>> 8 & 0xFF);
        pps.push(len & 0xFF);

        pps = pps.concat(Array.prototype.slice.call(data));
      }

      var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version
      sps[3], // profile
      sps[4], // profile compat
      sps[5], // level
      0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
      0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
      ].concat(sps).concat([track.pps.length // numOfPictureParameterSets
      ]).concat(pps))),
          // "PPS"
      width = track.width,
          height = track.height,
          hSpacing = track.pixelRatio[0],
          vSpacing = track.pixelRatio[1];

      return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, // pre_defined
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      width >> 8 & 0xFF, width & 0xff, // width
      height >> 8 & 0xFF, height & 0xff, // height
      0x00, 0x48, 0x00, 0x00, // horizresolution
      0x00, 0x48, 0x00, 0x00, // vertresolution
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // frame_count
      0x12, 0x64, 0x61, 0x69, 0x6C, // dailymotion/hls.js
      0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname
      0x00, 0x18, // depth = 24
      0x11, 0x11]), // pre_defined = -1
      avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB
      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate
      0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate
      MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24, // hSpacing
      hSpacing >> 16 & 0xFF, hSpacing >> 8 & 0xFF, hSpacing & 0xFF, vSpacing >> 24, // vSpacing
      vSpacing >> 16 & 0xFF, vSpacing >> 8 & 0xFF, vSpacing & 0xFF])));
    }
  }, {
    key: 'esds',
    value: function esds(track) {
      var configlen = track.config.length;
      return new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags

      0x03, // descriptor_type
      0x17 + configlen, // length
      0x00, 0x01, // es_id
      0x00, // stream_priority

      0x04, // descriptor_type
      0x0f + configlen, // length
      0x40, // codec : mpeg4_audio
      0x15, // stream_type
      0x00, 0x00, 0x00, // buffer_size
      0x00, 0x00, 0x00, 0x00, // maxBitrate
      0x00, 0x00, 0x00, 0x00, // avgBitrate

      0x05 // descriptor_type
      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
    }
  }, {
    key: 'mp4a',
    value: function mp4a(track) {
      var samplerate = track.samplerate;
      return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      samplerate >> 8 & 0xFF, samplerate & 0xff, //
      0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
    }
  }, {
    key: 'mp3',
    value: function mp3(track) {
      var samplerate = track.samplerate;
      return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      samplerate >> 8 & 0xFF, samplerate & 0xff, //
      0x00, 0x00]));
    }
  }, {
    key: 'stsd',
    value: function stsd(track) {
      if (track.type === 'audio') {
        if (!track.isAAC && track.codec === 'mp3') {
          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
        }

        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
      } else {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
      }
    }
  }, {
    key: 'tkhd',
    value: function tkhd(track) {
      var id = track.id,
          duration = track.duration * track.timescale,
          width = track.width,
          height = track.height,
          upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)),
          lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.tkhd, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x07, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x00, // reserved
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, // layer
      0x00, 0x00, // alternate_group
      0x00, 0x00, // non-audio track volume
      0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
      height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
      ]));
    }
  }, {
    key: 'traf',
    value: function traf(track, baseMediaDecodeTime) {
      var sampleDependencyTable = MP4.sdtp(track),
          id = track.id,
          upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)),
          lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF]) // track_ID
      ), MP4.box(MP4.types.tfdt, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0XFF, upperWordBaseMediaDecodeTime >> 8 & 0XFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0XFF, lowerWordBaseMediaDecodeTime >> 8 & 0XFF, lowerWordBaseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
      20 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8), // mdat header
      sampleDependencyTable);
    }

    /**
     * Generate a track box.
     * @param track {object} a track definition
     * @return {Uint8Array} the track box
     */

  }, {
    key: 'trak',
    value: function trak(track) {
      track.duration = track.duration || 0xffffffff;
      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
    }
  }, {
    key: 'trex',
    value: function trex(track) {
      var id = track.id;
      return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x01, // default_sample_description_index
      0x00, 0x00, 0x00, 0x00, // default_sample_duration
      0x00, 0x00, 0x00, 0x00, // default_sample_size
      0x00, 0x01, 0x00, 0x01 // default_sample_flags
      ]));
    }
  }, {
    key: 'trun',
    value: function trun(track, offset) {
      var samples = track.samples || [],
          len = samples.length,
          arraylen = 12 + 16 * len,
          array = new Uint8Array(arraylen),
          i = void 0,
          sample = void 0,
          duration = void 0,
          size = void 0,
          flags = void 0,
          cts = void 0;
      offset += 8 + arraylen;
      array.set([0x00, // version 0
      0x00, 0x0f, 0x01, // flags
      len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
      offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
      ], 0);
      for (i = 0; i < len; i++) {
        sample = samples[i];
        duration = sample.duration;
        size = sample.size;
        flags = sample.flags;
        cts = sample.cts;
        array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
        size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
        cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
        ], 12 + 16 * i);
      }
      return MP4.box(MP4.types.trun, array);
    }
  }, {
    key: 'initSegment',
    value: function initSegment(tracks) {
      if (!MP4.types) {
        MP4.init();
      }

      var movie = MP4.moov(tracks),
          result = void 0;
      result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
      result.set(MP4.FTYP);
      result.set(movie, MP4.FTYP.byteLength);
      return result;
    }
  }]);

  return MP4;
}();

exports.default = MP4;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/remux/mp4-remuxer.js":
/*!*****************************************!*\
  !*** ./src/hls.js/remux/mp4-remuxer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * fMP4 remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _aacHelper = __webpack_require__(/*! ./aac-helper */ "./src/hls.js/remux/aac-helper.js");

var _aacHelper2 = _interopRequireDefault(_aacHelper);

var _mp4Generator = __webpack_require__(/*! ./mp4-generator */ "./src/hls.js/remux/mp4-generator.js");

var _mp4Generator2 = _interopRequireDefault(_mp4Generator);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 10 seconds
var MAX_SILENT_FRAME_DURATION = 10 * 1000;

var MP4Remuxer = function () {
  function MP4Remuxer(observer, config, typeSupported, vendor) {
    _classCallCheck(this, MP4Remuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    var userAgent = navigator.userAgent;
    this.isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');
    this.ISGenerated = false;
  }

  _createClass(MP4Remuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp(defaultTimeStamp) {
      this._initPTS = this._initDTS = defaultTimeStamp;
    }
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment() {
      this.ISGenerated = false;
    }
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      // generate Init Segment if needed
      if (!this.ISGenerated) {
        this.generateIS(audioTrack, videoTrack, timeOffset);
      }

      if (this.ISGenerated) {
        var nbAudioSamples = audioTrack.samples.length;
        var nbVideoSamples = videoTrack.samples.length;
        var audioTimeOffset = timeOffset;
        var videoTimeOffset = timeOffset;
        if (nbAudioSamples && nbVideoSamples) {
          // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)
          // if first audio DTS is not aligned with first video DTS then we need to take that into account
          // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small
          // drift between audio and video streams
          var audiovideoDeltaDts = (audioTrack.samples[0].pts - videoTrack.samples[0].pts) / videoTrack.inputTimeScale;
          audioTimeOffset += Math.max(0, audiovideoDeltaDts);
          videoTimeOffset += Math.max(0, -audiovideoDeltaDts);
        }
        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is
        // calculated in remuxAudio.
        // logger.log('nb AAC samples:' + audioTrack.samples.length);
        if (nbAudioSamples) {
          // if initSegment was generated without video samples, regenerate it again
          if (!audioTrack.timescale) {
            _logger.logger.warn('regenerate InitSegment as audio detected');
            this.generateIS(audioTrack, videoTrack, timeOffset);
          }
          var audioData = this.remuxAudio(audioTrack, audioTimeOffset, contiguous, accurateTimeOffset);
          // logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (nbVideoSamples) {
            var audioTrackLength = void 0;
            if (audioData) {
              audioTrackLength = audioData.endPTS - audioData.startPTS;
            }

            // if initSegment was generated without video samples, regenerate it again
            if (!videoTrack.timescale) {
              _logger.logger.warn('regenerate InitSegment as video detected');
              this.generateIS(audioTrack, videoTrack, timeOffset);
            }
            this.remuxVideo(videoTrack, videoTimeOffset, contiguous, audioTrackLength, accurateTimeOffset);
          }
        } else {
          // logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (nbVideoSamples) {
            var videoData = this.remuxVideo(videoTrack, videoTimeOffset, contiguous, 0, accurateTimeOffset);
            if (videoData && audioTrack.codec) {
              this.remuxEmptyAudio(audioTrack, audioTimeOffset, contiguous, videoData);
            }
          }
        }
      }
      // logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (id3Track.samples.length) {
        this.remuxID3(id3Track, timeOffset);
      }

      // logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (textTrack.samples.length) {
        this.remuxText(textTrack, timeOffset);
      }

      // notify end of parsing
      this.observer.trigger(_events2.default.FRAG_PARSED);
    }
  }, {
    key: 'generateIS',
    value: function generateIS(audioTrack, videoTrack, timeOffset) {
      var observer = this.observer,
          audioSamples = audioTrack.samples,
          videoSamples = videoTrack.samples,
          typeSupported = this.typeSupported,
          container = 'audio/mp4',
          tracks = {},
          data = { tracks: tracks },
          computePTSDTS = this._initPTS === undefined,
          initPTS = void 0,
          initDTS = void 0;

      if (computePTSDTS) {
        initPTS = initDTS = Infinity;
      }

      if (audioTrack.config && audioSamples.length) {
        // let's use audio sampling rate as MP4 time scale.
        // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)
        // using audio sampling rate here helps having an integer MP4 frame duration
        // this avoids potential rounding issue and AV sync issue
        audioTrack.timescale = audioTrack.samplerate;
        _logger.logger.log('audio sampling rate : ' + audioTrack.samplerate);
        if (!audioTrack.isAAC) {
          if (typeSupported.mpeg) {
            // Chrome and Safari
            container = 'audio/mpeg';
            audioTrack.codec = '';
          } else if (typeSupported.mp3) {
            // Firefox
            audioTrack.codec = 'mp3';
          }
        }
        tracks.audio = {
          container: container,
          codec: audioTrack.codec,
          initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : _mp4Generator2.default.initSegment([audioTrack]),
          metadata: {
            channelCount: audioTrack.channelCount
          }
        };
        if (computePTSDTS) {
          // remember first PTS of this demuxing context. for audio, PTS = DTS
          initPTS = initDTS = audioSamples[0].pts - audioTrack.inputTimeScale * timeOffset;
        }
      }

      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
        // let's use input time scale as MP4 video timescale
        // we use input time scale straight away to avoid rounding issues on frame duration / cts computation
        var inputTimeScale = videoTrack.inputTimeScale;
        videoTrack.timescale = inputTimeScale;
        tracks.video = {
          container: 'video/mp4',
          codec: videoTrack.codec,
          initSegment: _mp4Generator2.default.initSegment([videoTrack]),
          metadata: {
            width: videoTrack.width,
            height: videoTrack.height
          }
        };
        if (computePTSDTS) {
          initPTS = Math.min(initPTS, videoSamples[0].pts - inputTimeScale * timeOffset);
          initDTS = Math.min(initDTS, videoSamples[0].dts - inputTimeScale * timeOffset);
          this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });
        }
      }

      if (Object.keys(tracks).length) {
        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
        this.ISGenerated = true;
        if (computePTSDTS) {
          this._initPTS = initPTS;
          this._initDTS = initDTS;
        }
      } else {
        observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });
      }
    }
  }, {
    key: 'remuxVideo',
    value: function remuxVideo(track, timeOffset, contiguous, audioTrackLength, accurateTimeOffset) {
      var offset = 8;
      var mp4SampleDuration = void 0;
      var mdat = void 0;
      var moof = void 0;
      var firstPTS = void 0;
      var firstDTS = void 0;
      var lastPTS = void 0;
      var lastDTS = void 0;
      var timeScale = track.timescale;
      var inputSamples = track.samples;
      var outputSamples = [];
      var nbSamples = inputSamples.length;
      var ptsNormalize = this._PTSNormalize;
      var initPTS = this._initPTS;

      // if parsed fragment is contiguous with last one, let's use last DTS value as reference
      var nextAvcDts = this.nextAvcDts;

      var isSafari = this.isSafari;

      if (nbSamples === 0) {
        return;
      }

      // Safari does not like overlapping DTS on consecutive fragments. let's use nextAvcDts to overcome this if fragments are consecutive
      if (isSafari) {
        // also consider consecutive fragments as being contiguous (even if a level switch occurs),
        // for sake of clarity:
        // consecutive fragments are frags with
        //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
        //  - less than 200 ms PTS gaps (timeScale/5)
        contiguous |= inputSamples.length && nextAvcDts && (accurateTimeOffset && Math.abs(timeOffset - nextAvcDts / timeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAvcDts - initPTS) < timeScale / 5);
      }

      if (!contiguous) {
        // if not contiguous, let's use target timeOffset
        nextAvcDts = timeOffset * timeScale;
      }

      // PTS is coded on 33bits, and can loop from -2^32 to 2^32
      // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
      inputSamples.forEach(function (sample) {
        sample.pts = ptsNormalize(sample.pts - initPTS, nextAvcDts);
        sample.dts = ptsNormalize(sample.dts - initPTS, nextAvcDts);
      });

      // sort video samples by DTS then PTS then demux id order
      inputSamples.sort(function (a, b) {
        var deltadts = a.dts - b.dts;
        var deltapts = a.pts - b.pts;
        return deltadts || deltapts || a.id - b.id;
      });

      // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)
      var PTSDTSshift = inputSamples.reduce(function (prev, curr) {
        return Math.max(Math.min(prev, curr.pts - curr.dts), -18000);
      }, 0);
      if (PTSDTSshift < 0) {
        _logger.logger.warn('PTS < DTS detected in video samples, shifting DTS by ' + Math.round(PTSDTSshift / 90) + ' ms to overcome this issue');
        for (var i = 0; i < inputSamples.length; i++) {
          inputSamples[i].dts += PTSDTSshift;
        }
      }

      // compute first DTS and last DTS, normalize them against reference value
      var sample = inputSamples[0];
      firstDTS = Math.max(sample.dts, 0);
      firstPTS = Math.max(sample.pts, 0);

      // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
      var delta = Math.round((firstDTS - nextAvcDts) / 90);
      // if fragment are contiguous, detect hole/overlapping between fragments
      if (contiguous) {
        if (delta) {
          if (delta > 1) {
            _logger.logger.log('AVC:' + delta + ' ms hole between fragments detected,filling it');
          } else if (delta < -1) {
            _logger.logger.log('AVC:' + -delta + ' ms overlapping between fragments detected');
          }

          // remove hole/gap : set DTS to next expected DTS
          firstDTS = nextAvcDts;
          inputSamples[0].dts = firstDTS;
          // offset PTS as well, ensure that PTS is smaller or equal than new DTS
          firstPTS = Math.max(firstPTS - delta, nextAvcDts);
          inputSamples[0].pts = firstPTS;
          _logger.logger.log('Video/PTS/DTS adjusted: ' + Math.round(firstPTS / 90) + '/' + Math.round(firstDTS / 90) + ',delta:' + delta + ' ms');
        }
      }

      // compute lastPTS/lastDTS
      sample = inputSamples[inputSamples.length - 1];
      lastDTS = Math.max(sample.dts, 0);
      lastPTS = Math.max(sample.pts, 0, lastDTS);

      // on Safari let's signal the same sample duration for all samples
      // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
      // set this constant duration as being the avg delta between consecutive DTS.
      if (isSafari) {
        mp4SampleDuration = Math.round((lastDTS - firstDTS) / (inputSamples.length - 1));
      }

      var nbNalu = 0,
          naluLen = 0;
      for (var _i = 0; _i < nbSamples; _i++) {
        // compute total/avc sample length and nb of NAL units
        var _sample = inputSamples[_i],
            units = _sample.units,
            nbUnits = units.length,
            sampleLen = 0;
        for (var j = 0; j < nbUnits; j++) {
          sampleLen += units[j].data.length;
        }

        naluLen += sampleLen;
        nbNalu += nbUnits;
        _sample.length = sampleLen;

        // normalize PTS/DTS
        if (isSafari) {
          // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
          _sample.dts = firstDTS + _i * mp4SampleDuration;
        } else {
          // ensure sample monotonic DTS
          _sample.dts = Math.max(_sample.dts, firstDTS);
        }
        // ensure that computed value is greater or equal than sample DTS
        _sample.pts = Math.max(_sample.pts, _sample.dts);
      }

      /* concatenate the video data and construct the mdat in place
        (need 8 more bytes to fill length and mpdat type) */
      var mdatSize = naluLen + 4 * nbNalu + 8;
      try {
        mdat = new Uint8Array(mdatSize);
      } catch (err) {
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating video mdat ' + mdatSize });
        return;
      }
      var view = new DataView(mdat.buffer);
      view.setUint32(0, mdatSize);
      mdat.set(_mp4Generator2.default.types.mdat, 4);

      for (var _i2 = 0; _i2 < nbSamples; _i2++) {
        var avcSample = inputSamples[_i2],
            avcSampleUnits = avcSample.units,
            mp4SampleLength = 0,
            compositionTimeOffset = void 0;
        // convert NALU bitstream to MP4 format (prepend NALU with size field)
        for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {
          var unit = avcSampleUnits[_j],
              unitData = unit.data,
              unitDataLen = unit.data.byteLength;
          view.setUint32(offset, unitDataLen);
          offset += 4;
          mdat.set(unitData, offset);
          offset += unitDataLen;
          mp4SampleLength += 4 + unitDataLen;
        }

        if (!isSafari) {
          // expected sample duration is the Decoding Timestamp diff of consecutive samples
          if (_i2 < nbSamples - 1) {
            mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;
          } else {
            var config = this.config,
                lastFrameDuration = avcSample.dts - inputSamples[_i2 > 0 ? _i2 - 1 : _i2].dts;
            if (config.stretchShortVideoTrack) {
              // In some cases, a segment's audio track duration may exceed the video track duration.
              // Since we've already remuxed audio, and we know how long the audio track is, we look to
              // see if the delta to the next segment is longer than maxBufferHole.
              // If so, playback would potentially get stuck, so we artificially inflate
              // the duration of the last frame to minimize any potential gap between segments.
              var maxBufferHole = config.maxBufferHole,
                  gapTolerance = Math.floor(maxBufferHole * timeScale),
                  deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;
              if (deltaToFrameEnd > gapTolerance) {
                // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
                // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.
                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                if (mp4SampleDuration < 0) {
                  mp4SampleDuration = lastFrameDuration;
                }

                _logger.logger.log('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');
              } else {
                mp4SampleDuration = lastFrameDuration;
              }
            } else {
              mp4SampleDuration = lastFrameDuration;
            }
          }
          compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
        } else {
          compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / mp4SampleDuration));
        }

        // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
        // console.log(`avcSample.dts: ${avcSample.dts / 90}, avcSample.pts: ${avcSample.pts / 90}, mp4SampleDuration: ${mp4SampleDuration / 90}`, avcSample)
        outputSamples.push({
          size: mp4SampleLength,
          // constant duration
          duration: mp4SampleDuration,
          cts: compositionTimeOffset,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: avcSample.key ? 2 : 1,
            isNonSync: avcSample.key ? 0 : 1
          }
        });
      }
      // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
      this.nextAvcDts = lastDTS + mp4SampleDuration;
      var dropped = track.dropped;
      track.len = 0;
      track.nbNalu = 0;
      track.dropped = 0;
      if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
        var flags = outputSamples[0].flags;
        // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
        // https://code.google.com/p/chromium/issues/detail?id=229412
        flags.dependsOn = 2;
        flags.isNonSync = 0;
      }
      track.samples = outputSamples;
      moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS, track);
      track.samples = [];

      var data = {
        data1: moof,
        data2: mdat,
        startPTS: firstPTS / timeScale,
        endPTS: (lastPTS + mp4SampleDuration) / timeScale,
        startDTS: firstDTS / timeScale,
        endDTS: this.nextAvcDts / timeScale,
        type: 'video',
        hasAudio: false,
        hasVideo: true,
        nb: outputSamples.length,
        dropped: dropped
      };
      this.observer.trigger(_events2.default.FRAG_PARSING_DATA, data);
      return data;
    }
  }, {
    key: 'remuxAudio',
    value: function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset) {
      var inputTimeScale = track.inputTimeScale;
      var mp4timeScale = track.timescale;
      var scaleFactor = inputTimeScale / mp4timeScale;
      var mp4SampleDuration = track.isAAC ? 1024 : 1152;
      var inputSampleDuration = mp4SampleDuration * scaleFactor;
      var ptsNormalize = this._PTSNormalize;
      var initPTS = this._initPTS;
      var rawMPEG = !track.isAAC && this.typeSupported.mpeg;

      var offset = void 0,
          mp4Sample = void 0,
          fillFrame = void 0,
          mdat = void 0,
          moof = void 0,
          firstPTS = void 0,
          lastPTS = void 0,
          inputSamples = track.samples,
          outputSamples = [],
          nextAudioPts = this.nextAudioPts;

      // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
      // for sake of clarity:
      // consecutive fragments are frags with
      //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
      //  - less than 20 audio frames distance
      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
      // this helps ensuring audio continuity
      // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame
      contiguous |= inputSamples.length && nextAudioPts && (accurateTimeOffset && Math.abs(timeOffset - nextAudioPts / inputTimeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAudioPts - initPTS) < 20 * inputSampleDuration);

      // compute normalized PTS
      inputSamples.forEach(function (sample) {
        sample.pts = sample.dts = ptsNormalize(sample.pts - initPTS, timeOffset * inputTimeScale);
      });

      // filter out sample with negative PTS that are not playable anyway
      // if we don't remove these negative samples, they will shift all audio samples forward.
      // leading to audio overlap between current / next fragment
      inputSamples = inputSamples.filter(function (sample) {
        return sample.pts >= 0;
      });

      // in case all samples have negative PTS, and have been filtered out, return now
      if (inputSamples.length === 0) {
        return;
      }

      if (!contiguous) {
        if (!accurateTimeOffset) {
          // if frag are mot contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS
          nextAudioPts = inputSamples[0].pts;
        } else {
          // if timeOffset is accurate, let's use it as predicted next audio PTS
          nextAudioPts = timeOffset * inputTimeScale;
        }
      }

      // If the audio track is missing samples, the frames seem to get "left-shifted" within the
      // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
      // In an effort to prevent this from happening, we inject frames here where there are gaps.
      // When possible, we inject a silent frame; when that's not possible, we duplicate the last
      // frame.

      if (track.isAAC) {
        var maxAudioFramesDrift = this.config.maxAudioFramesDrift;
        for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length;) {
          // First, let's see how far off this frame is from where we expect it to be
          var sample = inputSamples[i],
              delta;
          var pts = sample.pts;
          delta = pts - nextPts;

          var duration = Math.abs(1000 * delta / inputTimeScale);

          // If we're overlapping by more than a duration, drop this sample
          if (delta <= -maxAudioFramesDrift * inputSampleDuration) {
            _logger.logger.warn('Dropping 1 audio frame @ ' + (nextPts / inputTimeScale).toFixed(3) + 's due to ' + Math.round(duration) + ' ms overlap.');
            inputSamples.splice(i, 1);
            track.len -= sample.unit.length;
            // Don't touch nextPtsNorm or i
          } // eslint-disable-line brace-style

          // Insert missing frames if:
          // 1: We're more than maxAudioFramesDrift frame away
          // 2: Not more than MAX_SILENT_FRAME_DURATION away
          // 3: currentTime (aka nextPtsNorm) is not 0
          else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && nextPts) {
              var missing = Math.round(delta / inputSampleDuration);
              _logger.logger.warn('Injecting ' + missing + ' audio frame @ ' + (nextPts / inputTimeScale).toFixed(3) + 's due to ' + Math.round(1000 * delta / inputTimeScale) + ' ms gap.');
              for (var j = 0; j < missing; j++) {
                var newStamp = Math.max(nextPts, 0);
                fillFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                if (!fillFrame) {
                  _logger.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');
                  fillFrame = sample.unit.subarray();
                }
                inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });
                track.len += fillFrame.length;
                nextPts += inputSampleDuration;
                i++;
              }

              // Adjust sample to next expected pts
              sample.pts = sample.dts = nextPts;
              nextPts += inputSampleDuration;
              i++;
            } else {
              // Otherwise, just adjust pts
              if (Math.abs(delta) > 0.1 * inputSampleDuration) {
                // logger.log(`Invalid frame delta ${Math.round(delta + inputSampleDuration)} at PTS ${Math.round(pts / 90)} (should be ${Math.round(inputSampleDuration)}).`);
              }
              sample.pts = sample.dts = nextPts;
              nextPts += inputSampleDuration;
              i++;
            }
        }
      }

      for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {
        var audioSample = inputSamples[_j2];
        var unit = audioSample.unit;
        var _pts = audioSample.pts;
        // logger.log(`Audio/PTS:${Math.round(pts/90)}`);
        // if not first sample
        if (lastPTS !== undefined) {
          mp4Sample.duration = Math.round((_pts - lastPTS) / scaleFactor);
        } else {
          var _delta = Math.round(1000 * (_pts - nextAudioPts) / inputTimeScale),
              numMissingFrames = 0;
          // if fragment are contiguous, detect hole/overlapping between fragments
          // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
          if (contiguous && track.isAAC) {
            // log delta
            if (_delta) {
              if (_delta > 0 && _delta < MAX_SILENT_FRAME_DURATION) {
                numMissingFrames = Math.round((_pts - nextAudioPts) / inputSampleDuration);
                _logger.logger.log(_delta + ' ms hole between AAC samples detected,filling it');
                if (numMissingFrames > 0) {
                  fillFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                  if (!fillFrame) {
                    fillFrame = unit.subarray();
                  }

                  track.len += numMissingFrames * fillFrame.length;
                }
                // if we have frame overlap, overlapping for more than half a frame duraion
              } else if (_delta < -12) {
                // drop overlapping audio frames... browser will deal with it
                _logger.logger.log('drop overlapping AAC sample, expected/parsed/delta:' + (nextAudioPts / inputTimeScale).toFixed(3) + 's/' + (_pts / inputTimeScale).toFixed(3) + 's/' + -_delta + 'ms');
                track.len -= unit.byteLength;
                continue;
              }
              // set PTS/DTS to expected PTS/DTS
              _pts = nextAudioPts;
            }
          }
          // remember first PTS of our audioSamples
          firstPTS = _pts;
          if (track.len > 0) {
            /* concatenate the audio data and construct the mdat in place
              (need 8 more bytes to fill length and mdat type) */
            var mdatSize = rawMPEG ? track.len : track.len + 8;
            offset = rawMPEG ? 0 : 8;
            try {
              mdat = new Uint8Array(mdatSize);
            } catch (err) {
              this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating audio mdat ' + mdatSize });
              return;
            }
            if (!rawMPEG) {
              var view = new DataView(mdat.buffer);
              view.setUint32(0, mdatSize);
              mdat.set(_mp4Generator2.default.types.mdat, 4);
            }
          } else {
            // no audio samples
            return;
          }
          for (var _i3 = 0; _i3 < numMissingFrames; _i3++) {
            fillFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
            if (!fillFrame) {
              _logger.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');
              fillFrame = unit.subarray();
            }
            mdat.set(fillFrame, offset);
            offset += fillFrame.byteLength;
            mp4Sample = {
              size: fillFrame.byteLength,
              cts: 0,
              duration: 1024,
              flags: {
                isLeading: 0,
                isDependedOn: 0,
                hasRedundancy: 0,
                degradPrio: 0,
                dependsOn: 1
              }
            };
            outputSamples.push(mp4Sample);
          }
        }
        mdat.set(unit, offset);
        var unitLen = unit.byteLength;
        offset += unitLen;
        // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');
        mp4Sample = {
          size: unitLen,
          cts: 0,
          duration: 0,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: 1
          }
        };
        outputSamples.push(mp4Sample);
        lastPTS = _pts;
      }
      var lastSampleDuration = 0;
      var nbSamples = outputSamples.length;
      // set last sample duration as being identical to previous sample
      if (nbSamples >= 2) {
        lastSampleDuration = outputSamples[nbSamples - 2].duration;
        mp4Sample.duration = lastSampleDuration;
      }
      if (nbSamples) {
        // next audio sample PTS should be equal to last sample PTS + duration
        this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSampleDuration;
        // logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
        track.len = 0;
        track.samples = outputSamples;
        if (rawMPEG) {
          moof = new Uint8Array();
        } else {
          moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstPTS / scaleFactor, track);
        }

        track.samples = [];
        var start = firstPTS / inputTimeScale;
        var end = nextAudioPts / inputTimeScale;
        var audioData = {
          data1: moof,
          data2: mdat,
          startPTS: start,
          endPTS: end,
          startDTS: start,
          endDTS: end,
          type: 'audio',
          hasAudio: true,
          hasVideo: false,
          nb: nbSamples
        };
        this.observer.trigger(_events2.default.FRAG_PARSING_DATA, audioData);
        return audioData;
      }
      return null;
    }
  }, {
    key: 'remuxEmptyAudio',
    value: function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
      var inputTimeScale = track.inputTimeScale,
          mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale,
          scaleFactor = inputTimeScale / mp4timeScale,
          nextAudioPts = this.nextAudioPts,


      // sync with video's timestamp
      startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS,
          endDTS = videoData.endDTS * inputTimeScale + this._initDTS,

      // one sample's duration value
      sampleDuration = 1024,
          frameDuration = scaleFactor * sampleDuration,


      // samples count of this segment's duration
      nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),


      // silent frame
      silentFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);

      _logger.logger.warn('remux empty Audio');
      // Can't remux if we can't generate a silent frame...
      if (!silentFrame) {
        _logger.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
        return;
      }

      var samples = [];
      for (var i = 0; i < nbSamples; i++) {
        var stamp = startDTS + i * frameDuration;
        samples.push({ unit: silentFrame, pts: stamp, dts: stamp });
        track.len += silentFrame.length;
      }
      track.samples = samples;

      this.remuxAudio(track, timeOffset, contiguous);
    }
  }, {
    key: 'remuxID3',
    value: function remuxID3(track) {
      var length = track.samples.length,
          sample = void 0;
      var inputTimeScale = track.inputTimeScale;
      var initPTS = this._initPTS;
      var initDTS = this._initDTS;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting id3 pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - initPTS) / inputTimeScale;
          sample.dts = (sample.dts - initDTS) / inputTimeScale;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_METADATA, {
          samples: track.samples
        });
      }

      track.samples = [];
    }
  }, {
    key: 'remuxText',
    value: function remuxText(track) {
      track.samples.sort(function (a, b) {
        return a.pts - b.pts;
      });

      var length = track.samples.length,
          sample = void 0;
      var inputTimeScale = track.inputTimeScale;
      var initPTS = this._initPTS;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting text pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - initPTS) / inputTimeScale;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_USERDATA, {
          samples: track.samples
        });
      }

      track.samples = [];
    }
  }, {
    key: '_PTSNormalize',
    value: function _PTSNormalize(value, reference) {
      var offset = void 0;
      if (reference === undefined) {
        return value;
      }

      if (reference < value) {
        // - 2^33
        offset = -8589934592;
      } else {
        // + 2^33
        offset = 8589934592;
      }
      /* PTS is 33bit (from 0 to 2^33 -1)
        if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
        PTS looping occured. fill the gap */
      while (Math.abs(value - reference) > 4294967296) {
        value += offset;
      }

      return value;
    }
  }]);

  return MP4Remuxer;
}();

exports.default = MP4Remuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/remux/passthrough-remuxer.js":
/*!*************************************************!*\
  !*** ./src/hls.js/remux/passthrough-remuxer.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * passthrough remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */


var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PassThroughRemuxer = function () {
  function PassThroughRemuxer(observer) {
    _classCallCheck(this, PassThroughRemuxer);

    this.observer = observer;
  }

  _createClass(PassThroughRemuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment() {}
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset, rawData) {
      var observer = this.observer;
      var streamType = '';
      if (audioTrack) {
        streamType += 'audio';
      }

      if (videoTrack) {
        streamType += 'video';
      }

      observer.trigger(_events2.default.FRAG_PARSING_DATA, {
        data1: rawData,
        startPTS: timeOffset,
        startDTS: timeOffset,
        type: streamType,
        hasAudio: !!audioTrack,
        hasVideo: !!videoTrack,
        nb: 1,
        dropped: 0
      });
      // notify end of parsing
      observer.trigger(_events2.default.FRAG_PARSED);
    }
  }]);

  return PassThroughRemuxer;
}();

exports.default = PassThroughRemuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/task-loop.js":
/*!*********************************!*\
  !*** ./src/hls.js/task-loop.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventHandler = __webpack_require__(/*! ./event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Sub-class specialization of EventHandler base class.
 *
 * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,
 * scheduled asynchroneously, avoiding recursive calls in the same tick.
 *
 * The task itself is implemented in `doTick`. It can be requested and called for single execution
 * using the `tick` method.
 *
 * It will be assured that the task execution method (`tick`) only gets called once per main loop "tick",
 * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.
 *
 * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,
 * and cancelled with `clearNextTick`.
 *
 * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).
 *
 * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.
 *
 * Further explanations:
 *
 * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously
 * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.
 *
 * When the task execution (`tick` method) is called in re-entrant way this is detected and
 * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further
 * task processing on the next main loop iteration (also known as "next tick" in the Node/JS runtime lingo).
 */

var TaskLoop = function (_EventHandler) {
  _inherits(TaskLoop, _EventHandler);

  function TaskLoop(hls) {
    var _ref;

    _classCallCheck(this, TaskLoop);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = TaskLoop.__proto__ || Object.getPrototypeOf(TaskLoop)).call.apply(_ref, [this, hls].concat(events)));

    _this._tickInterval = null;
    _this._tickTimer = null;
    _this._tickCallCount = 0;
    _this._boundTick = _this.tick.bind(_this);
    return _this;
  }

  /**
   * @override
   */


  _createClass(TaskLoop, [{
    key: 'onHandlerDestroying',
    value: function onHandlerDestroying() {
      // clear all timers before unregistering from event bus
      this.clearNextTick();
      this.clearInterval();
    }

    /**
     * @returns {boolean}
     */

  }, {
    key: 'hasInterval',
    value: function hasInterval() {
      return !!this._tickInterval;
    }

    /**
     * @returns {boolean}
     */

  }, {
    key: 'hasNextTick',
    value: function hasNextTick() {
      return !!this._tickTimer;
    }

    /**
     * @param {number} millis Interval time (ms)
     * @returns {boolean} True when interval has been scheduled, false when already scheduled (no effect)
     */

  }, {
    key: 'setInterval',
    value: function (_setInterval) {
      function setInterval(_x) {
        return _setInterval.apply(this, arguments);
      }

      setInterval.toString = function () {
        return _setInterval.toString();
      };

      return setInterval;
    }(function (millis) {
      if (!this._tickInterval) {
        this._tickInterval = setInterval(this._boundTick, millis);
        return true;
      }
      return false;
    })

    /**
     * @returns {boolean} True when interval was cleared, false when none was set (no effect)
     */

  }, {
    key: 'clearInterval',
    value: function (_clearInterval) {
      function clearInterval() {
        return _clearInterval.apply(this, arguments);
      }

      clearInterval.toString = function () {
        return _clearInterval.toString();
      };

      return clearInterval;
    }(function () {
      if (this._tickInterval) {
        clearInterval(this._tickInterval);
        this._tickInterval = null;
        return true;
      }
      return false;
    })

    /**
     * @returns {boolean} True when timeout was cleared, false when none was set (no effect)
     */

  }, {
    key: 'clearNextTick',
    value: function clearNextTick() {
      if (this._tickTimer) {
        clearTimeout(this._tickTimer);
        this._tickTimer = null;
        return true;
      }
      return false;
    }

    /**
     * Will call the subclass doTick implementation in this main loop tick
     * or in the next one (via setTimeout(,0)) in case it has already been called
     * in this tick (in case this is a re-entrant call).
     */

  }, {
    key: 'tick',
    value: function tick() {
      this._tickCallCount++;
      if (this._tickCallCount === 1) {
        this.doTick();
        // re-entrant call to tick from previous doTick call stack
        // -> schedule a call on the next main loop iteration to process this task processing request
        if (this._tickCallCount > 1) {
          // make sure only one timer exists at any time at max
          this.clearNextTick();
          this._tickTimer = setTimeout(this._boundTick, 0);
        }
        this._tickCallCount = 0;
      }
    }

    /**
     * For subclass to implement task logic
     * @abstract
     */

  }, {
    key: 'doTick',
    value: function doTick() {}
  }]);

  return TaskLoop;
}(_eventHandler2.default);

exports.default = TaskLoop;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/attr-list.js":
/*!***************************************!*\
  !*** ./src/hls.js/utils/attr-list.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/; // eslint-disable-line no-useless-escape
var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g; // eslint-disable-line no-useless-escape

// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js

var AttrList = function () {
  function AttrList(attrs) {
    _classCallCheck(this, AttrList);

    if (typeof attrs === 'string') {
      attrs = AttrList.parseAttrList(attrs);
    }

    for (var attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        this[attr] = attrs[attr];
      }
    }
  }

  _createClass(AttrList, [{
    key: 'decimalInteger',
    value: function decimalInteger(attrName) {
      var intValue = parseInt(this[attrName], 10);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }

      return intValue;
    }
  }, {
    key: 'hexadecimalInteger',
    value: function hexadecimalInteger(attrName) {
      if (this[attrName]) {
        var stringValue = (this[attrName] || '0x').slice(2);
        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;

        var value = new Uint8Array(stringValue.length / 2);
        for (var i = 0; i < stringValue.length / 2; i++) {
          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
        }

        return value;
      } else {
        return null;
      }
    }
  }, {
    key: 'hexadecimalIntegerAsNumber',
    value: function hexadecimalIntegerAsNumber(attrName) {
      var intValue = parseInt(this[attrName], 16);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }

      return intValue;
    }
  }, {
    key: 'decimalFloatingPoint',
    value: function decimalFloatingPoint(attrName) {
      return parseFloat(this[attrName]);
    }
  }, {
    key: 'enumeratedString',
    value: function enumeratedString(attrName) {
      return this[attrName];
    }
  }, {
    key: 'decimalResolution',
    value: function decimalResolution(attrName) {
      var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
      if (res === null) {
        return undefined;
      }

      return {
        width: parseInt(res[1], 10),
        height: parseInt(res[2], 10)
      };
    }
  }], [{
    key: 'parseAttrList',
    value: function parseAttrList(input) {
      var match = void 0,
          attrs = {};
      ATTR_LIST_REGEX.lastIndex = 0;
      while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
        var value = match[2],
            quote = '"';

        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
          value = value.slice(1, -1);
        }

        attrs[match[1]] = value;
      }
      return attrs;
    }
  }]);

  return AttrList;
}();

exports.default = AttrList;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/binary-search.js":
/*!*******************************************!*\
  !*** ./src/hls.js/utils/binary-search.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var BinarySearch = {
  /**
     * Searches for an item in an array which matches a certain condition.
     * This requires the condition to only match one item in the array,
     * and for the array to be ordered.
     *
     * @param {Array} list The array to search.
     * @param {Function} comparisonFunction
     *      Called and provided a candidate item as the first argument.
     *      Should return:
     *          > -1 if the item should be located at a lower index than the provided item.
     *          > 1 if the item should be located at a higher index than the provided item.
     *          > 0 if the item is the item you're looking for.
     *
     * @return {*} The object if it is found or null otherwise.
     */
  search: function search(list, comparisonFunction) {
    var minIndex = 0;
    var maxIndex = list.length - 1;
    var currentIndex = null;
    var currentElement = null;

    while (minIndex <= maxIndex) {
      currentIndex = (minIndex + maxIndex) / 2 | 0;
      currentElement = list[currentIndex];

      var comparisonResult = comparisonFunction(currentElement);
      if (comparisonResult > 0) {
        minIndex = currentIndex + 1;
      } else if (comparisonResult < 0) {
        maxIndex = currentIndex - 1;
      } else {
        return currentElement;
      }
    }

    return null;
  }
};

exports.default = BinarySearch;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/utils/buffer-helper.js":
/*!*******************************************!*\
  !*** ./src/hls.js/utils/buffer-helper.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module BufferHelper
 *
 * Providing methods dealing with buffer length retrieval for example.
 *
 * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.
 *
 * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered
*/

var BufferHelper = exports.BufferHelper = function () {
  function BufferHelper() {
    _classCallCheck(this, BufferHelper);
  }

  _createClass(BufferHelper, null, [{
    key: "isBuffered",

    /**
     * Return true if `media`'s buffered include `position`
     * @param {HTMLMediaElement|SourceBuffer} media
     * @param {number} position
     * @returns {boolean}
     */
    value: function isBuffered(media, position) {
      try {
        if (media) {
          var buffered = media.buffered;
          for (var i = 0; i < buffered.length; i++) {
            if (position >= buffered.start(i) && position <= buffered.end(i)) {
              return true;
            }
          }
        }
      } catch (error) {
        // this is to catch
        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
        // This SourceBuffer has been removed from the parent media source
      }
      return false;
    }
  }, {
    key: "bufferInfo",
    value: function bufferInfo(media, pos, maxHoleDuration) {
      try {
        if (media) {
          var vbuffered = media.buffered,
              buffered = [],
              i = void 0;
          for (i = 0; i < vbuffered.length; i++) {
            buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
          }

          return this.bufferedInfo(buffered, pos, maxHoleDuration);
        }
      } catch (error) {
        // this is to catch
        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
        // This SourceBuffer has been removed from the parent media source
      }
      return { len: 0, start: pos, end: pos, nextStart: undefined };
    }
  }, {
    key: "bufferedInfo",
    value: function bufferedInfo(buffered, pos, maxHoleDuration) {
      var buffered2 = [],

      // bufferStart and bufferEnd are buffer boundaries around current video position
      bufferLen = void 0,
          bufferStart = void 0,
          bufferEnd = void 0,
          bufferStartNext = void 0,
          i = void 0;
      // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
      buffered.sort(function (a, b) {
        var diff = a.start - b.start;
        if (diff) {
          return diff;
        } else {
          return b.end - a.end;
        }
      });
      // there might be some small holes between buffer time range
      // consider that holes smaller than maxHoleDuration are irrelevant and build another
      // buffer time range representations that discards those holes
      for (i = 0; i < buffered.length; i++) {
        var buf2len = buffered2.length;
        if (buf2len) {
          var buf2end = buffered2[buf2len - 1].end;
          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
          if (buffered[i].start - buf2end < maxHoleDuration) {
            // merge overlapping time ranges
            // update lastRange.end only if smaller than item.end
            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
            if (buffered[i].end > buf2end) {
              buffered2[buf2len - 1].end = buffered[i].end;
            }
          } else {
            // big hole
            buffered2.push(buffered[i]);
          }
        } else {
          // first value
          buffered2.push(buffered[i]);
        }
      }
      for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
        var start = buffered2[i].start,
            end = buffered2[i].end;
        // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
        if (pos + maxHoleDuration >= start && pos < end) {
          // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
          bufferStart = start;
          bufferEnd = end;
          bufferLen = bufferEnd - pos;
        } else if (pos + maxHoleDuration < start) {
          bufferStartNext = start;
          break;
        }
      }
      return { len: bufferLen, start: bufferStart, end: bufferEnd, nextStart: bufferStartNext };
    }
  }]);

  return BufferHelper;
}();

/***/ }),

/***/ "./src/hls.js/utils/cea-608-parser.js":
/*!********************************************!*\
  !*** ./src/hls.js/utils/cea-608-parser.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * This code was ported from the dash.js project at:
 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
 *
 * The original copyright appears below:
 *
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2015-2016, DASH Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  2. Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
     *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
     */

var specialCea608CharsCodes = {
  0x2a: 0xe1, // lowercase a, acute accent
  0x5c: 0xe9, // lowercase e, acute accent
  0x5e: 0xed, // lowercase i, acute accent
  0x5f: 0xf3, // lowercase o, acute accent
  0x60: 0xfa, // lowercase u, acute accent
  0x7b: 0xe7, // lowercase c with cedilla
  0x7c: 0xf7, // division symbol
  0x7d: 0xd1, // uppercase N tilde
  0x7e: 0xf1, // lowercase n tilde
  0x7f: 0x2588, // Full block
  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
  // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
  0x80: 0xae, // Registered symbol (R)
  0x81: 0xb0, // degree sign
  0x82: 0xbd, // 1/2 symbol
  0x83: 0xbf, // Inverted (open) question mark
  0x84: 0x2122, // Trademark symbol (TM)
  0x85: 0xa2, // Cents symbol
  0x86: 0xa3, // Pounds sterling
  0x87: 0x266a, // Music 8'th note
  0x88: 0xe0, // lowercase a, grave accent
  0x89: 0x20, // transparent space (regular)
  0x8a: 0xe8, // lowercase e, grave accent
  0x8b: 0xe2, // lowercase a, circumflex accent
  0x8c: 0xea, // lowercase e, circumflex accent
  0x8d: 0xee, // lowercase i, circumflex accent
  0x8e: 0xf4, // lowercase o, circumflex accent
  0x8f: 0xfb, // lowercase u, circumflex accent
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
  0x90: 0xc1, // capital letter A with acute
  0x91: 0xc9, // capital letter E with acute
  0x92: 0xd3, // capital letter O with acute
  0x93: 0xda, // capital letter U with acute
  0x94: 0xdc, // capital letter U with diaresis
  0x95: 0xfc, // lowercase letter U with diaeresis
  0x96: 0x2018, // opening single quote
  0x97: 0xa1, // inverted exclamation mark
  0x98: 0x2a, // asterisk
  0x99: 0x2019, // closing single quote
  0x9a: 0x2501, // box drawings heavy horizontal
  0x9b: 0xa9, // copyright sign
  0x9c: 0x2120, // Service mark
  0x9d: 0x2022, // (round) bullet
  0x9e: 0x201c, // Left double quotation mark
  0x9f: 0x201d, // Right double quotation mark
  0xa0: 0xc0, // uppercase A, grave accent
  0xa1: 0xc2, // uppercase A, circumflex
  0xa2: 0xc7, // uppercase C with cedilla
  0xa3: 0xc8, // uppercase E, grave accent
  0xa4: 0xca, // uppercase E, circumflex
  0xa5: 0xcb, // capital letter E with diaresis
  0xa6: 0xeb, // lowercase letter e with diaresis
  0xa7: 0xce, // uppercase I, circumflex
  0xa8: 0xcf, // uppercase I, with diaresis
  0xa9: 0xef, // lowercase i, with diaresis
  0xaa: 0xd4, // uppercase O, circumflex
  0xab: 0xd9, // uppercase U, grave accent
  0xac: 0xf9, // lowercase u, grave accent
  0xad: 0xdb, // uppercase U, circumflex
  0xae: 0xab, // left-pointing double angle quotation mark
  0xaf: 0xbb, // right-pointing double angle quotation mark
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
  0xb0: 0xc3, // Uppercase A, tilde
  0xb1: 0xe3, // Lowercase a, tilde
  0xb2: 0xcd, // Uppercase I, acute accent
  0xb3: 0xcc, // Uppercase I, grave accent
  0xb4: 0xec, // Lowercase i, grave accent
  0xb5: 0xd2, // Uppercase O, grave accent
  0xb6: 0xf2, // Lowercase o, grave accent
  0xb7: 0xd5, // Uppercase O, tilde
  0xb8: 0xf5, // Lowercase o, tilde
  0xb9: 0x7b, // Open curly brace
  0xba: 0x7d, // Closing curly brace
  0xbb: 0x5c, // Backslash
  0xbc: 0x5e, // Caret
  0xbd: 0x5f, // Underscore
  0xbe: 0x7c, // Pipe (vertical line)
  0xbf: 0x223c, // Tilde operator
  0xc0: 0xc4, // Uppercase A, umlaut
  0xc1: 0xe4, // Lowercase A, umlaut
  0xc2: 0xd6, // Uppercase O, umlaut
  0xc3: 0xf6, // Lowercase o, umlaut
  0xc4: 0xdf, // Esszett (sharp S)
  0xc5: 0xa5, // Yen symbol
  0xc6: 0xa4, // Generic currency sign
  0xc7: 0x2503, // Box drawings heavy vertical
  0xc8: 0xc5, // Uppercase A, ring
  0xc9: 0xe5, // Lowercase A, ring
  0xca: 0xd8, // Uppercase O, stroke
  0xcb: 0xf8, // Lowercase o, strok
  0xcc: 0x250f, // Box drawings heavy down and right
  0xcd: 0x2513, // Box drawings heavy down and left
  0xce: 0x2517, // Box drawings heavy up and right
  0xcf: 0x251b // Box drawings heavy up and left
};

/**
 * Utils
 */
var getCharForByte = function getCharForByte(byte) {
  var charCode = byte;
  if (specialCea608CharsCodes.hasOwnProperty(byte)) {
    charCode = specialCea608CharsCodes[byte];
  }

  return String.fromCharCode(charCode);
};

var NR_ROWS = 15,
    NR_COLS = 100;
// Tables to look up row from PAC data
var rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };
var rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };
var rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };
var rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };

var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];

/**
 * Simple logger class to be able to write with time-stamps and filter on level.
 */
var logger = {
  verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },
  time: null,
  verboseLevel: 0, // Only write errors
  setTime: function setTime(newTime) {
    this.time = newTime;
  },
  log: function log(severity, msg) {
    var minLevel = this.verboseFilter[severity];
    if (this.verboseLevel >= minLevel) {
      // console.log(this.time + ' [' + severity + '] ' + msg);
    }
  }
};

var numArrayToHexArray = function numArrayToHexArray(numArray) {
  var hexArray = [];
  for (var j = 0; j < numArray.length; j++) {
    hexArray.push(numArray[j].toString(16));
  }

  return hexArray;
};

var PenState = function () {
  function PenState(foreground, underline, italics, background, flash) {
    _classCallCheck(this, PenState);

    this.foreground = foreground || 'white';
    this.underline = underline || false;
    this.italics = italics || false;
    this.background = background || 'black';
    this.flash = flash || false;
  }

  _createClass(PenState, [{
    key: 'reset',
    value: function reset() {
      this.foreground = 'white';
      this.underline = false;
      this.italics = false;
      this.background = 'black';
      this.flash = false;
    }
  }, {
    key: 'setStyles',
    value: function setStyles(styles) {
      var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
      for (var i = 0; i < attribs.length; i++) {
        var style = attribs[i];
        if (styles.hasOwnProperty(style)) {
          this[style] = styles[style];
        }
      }
    }
  }, {
    key: 'isDefault',
    value: function isDefault() {
      return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;
    }
  }, {
    key: 'equals',
    value: function equals(other) {
      return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
    }
  }, {
    key: 'copy',
    value: function copy(newPenState) {
      this.foreground = newPenState.foreground;
      this.underline = newPenState.underline;
      this.italics = newPenState.italics;
      this.background = newPenState.background;
      this.flash = newPenState.flash;
    }
  }, {
    key: 'toString',
    value: function toString() {
      return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;
    }
  }]);

  return PenState;
}();

/**
 * Unicode character with styling and background.
 * @constructor
 */


var StyledUnicodeChar = function () {
  function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
    _classCallCheck(this, StyledUnicodeChar);

    this.uchar = uchar || ' '; // unicode character
    this.penState = new PenState(foreground, underline, italics, background, flash);
  }

  _createClass(StyledUnicodeChar, [{
    key: 'reset',
    value: function reset() {
      this.uchar = ' ';
      this.penState.reset();
    }
  }, {
    key: 'setChar',
    value: function setChar(uchar, newPenState) {
      this.uchar = uchar;
      this.penState.copy(newPenState);
    }
  }, {
    key: 'setPenState',
    value: function setPenState(newPenState) {
      this.penState.copy(newPenState);
    }
  }, {
    key: 'equals',
    value: function equals(other) {
      return this.uchar === other.uchar && this.penState.equals(other.penState);
    }
  }, {
    key: 'copy',
    value: function copy(newChar) {
      this.uchar = newChar.uchar;
      this.penState.copy(newChar.penState);
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      return this.uchar === ' ' && this.penState.isDefault();
    }
  }]);

  return StyledUnicodeChar;
}();

/**
 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
 * @constructor
 */


var Row = function () {
  function Row() {
    _classCallCheck(this, Row);

    this.chars = [];
    for (var i = 0; i < NR_COLS; i++) {
      this.chars.push(new StyledUnicodeChar());
    }

    this.pos = 0;
    this.currPenState = new PenState();
  }

  _createClass(Row, [{
    key: 'equals',
    value: function equals(other) {
      var equal = true;
      for (var i = 0; i < NR_COLS; i++) {
        if (!this.chars[i].equals(other.chars[i])) {
          equal = false;
          break;
        }
      }
      return equal;
    }
  }, {
    key: 'copy',
    value: function copy(other) {
      for (var i = 0; i < NR_COLS; i++) {
        this.chars[i].copy(other.chars[i]);
      }
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      var empty = true;
      for (var i = 0; i < NR_COLS; i++) {
        if (!this.chars[i].isEmpty()) {
          empty = false;
          break;
        }
      }
      return empty;
    }

    /**
       *  Set the cursor to a valid column.
       */

  }, {
    key: 'setCursor',
    value: function setCursor(absPos) {
      if (this.pos !== absPos) {
        this.pos = absPos;
      }

      if (this.pos < 0) {
        logger.log('ERROR', 'Negative cursor position ' + this.pos);
        this.pos = 0;
      } else if (this.pos > NR_COLS) {
        logger.log('ERROR', 'Too large cursor position ' + this.pos);
        this.pos = NR_COLS;
      }
    }

    /**
       * Move the cursor relative to current position.
       */

  }, {
    key: 'moveCursor',
    value: function moveCursor(relPos) {
      var newPos = this.pos + relPos;
      if (relPos > 1) {
        for (var i = this.pos + 1; i < newPos + 1; i++) {
          this.chars[i].setPenState(this.currPenState);
        }
      }
      this.setCursor(newPos);
    }

    /**
       * Backspace, move one step back and clear character.
       */

  }, {
    key: 'backSpace',
    value: function backSpace() {
      this.moveCursor(-1);
      this.chars[this.pos].setChar(' ', this.currPenState);
    }
  }, {
    key: 'insertChar',
    value: function insertChar(byte) {
      if (byte >= 0x90) {
        // Extended char
        this.backSpace();
      }
      var char = getCharForByte(byte);
      if (this.pos >= NR_COLS) {
        logger.log('ERROR', 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');
        return;
      }
      this.chars[this.pos].setChar(char, this.currPenState);
      this.moveCursor(1);
    }
  }, {
    key: 'clearFromPos',
    value: function clearFromPos(startPos) {
      var i = void 0;
      for (i = startPos; i < NR_COLS; i++) {
        this.chars[i].reset();
      }
    }
  }, {
    key: 'clear',
    value: function clear() {
      this.clearFromPos(0);
      this.pos = 0;
      this.currPenState.reset();
    }
  }, {
    key: 'clearToEndOfRow',
    value: function clearToEndOfRow() {
      this.clearFromPos(this.pos);
    }
  }, {
    key: 'getTextString',
    value: function getTextString() {
      var chars = [];
      var empty = true;
      for (var i = 0; i < NR_COLS; i++) {
        var char = this.chars[i].uchar;
        if (char !== ' ') {
          empty = false;
        }

        chars.push(char);
      }
      if (empty) {
        return '';
      } else {
        return chars.join('');
      }
    }
  }, {
    key: 'setPenStyles',
    value: function setPenStyles(styles) {
      this.currPenState.setStyles(styles);
      var currChar = this.chars[this.pos];
      currChar.setPenState(this.currPenState);
    }
  }]);

  return Row;
}();

/**
 * Keep a CEA-608 screen of 32x15 styled characters
 * @constructor
*/


var CaptionScreen = function () {
  function CaptionScreen() {
    _classCallCheck(this, CaptionScreen);

    this.rows = [];
    for (var i = 0; i < NR_ROWS; i++) {
      this.rows.push(new Row());
    } // Note that we use zero-based numbering (0-14)

    this.currRow = NR_ROWS - 1;
    this.nrRollUpRows = null;
    this.reset();
  }

  _createClass(CaptionScreen, [{
    key: 'reset',
    value: function reset() {
      for (var i = 0; i < NR_ROWS; i++) {
        this.rows[i].clear();
      }

      this.currRow = NR_ROWS - 1;
    }
  }, {
    key: 'equals',
    value: function equals(other) {
      var equal = true;
      for (var i = 0; i < NR_ROWS; i++) {
        if (!this.rows[i].equals(other.rows[i])) {
          equal = false;
          break;
        }
      }
      return equal;
    }
  }, {
    key: 'copy',
    value: function copy(other) {
      for (var i = 0; i < NR_ROWS; i++) {
        this.rows[i].copy(other.rows[i]);
      }
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      var empty = true;
      for (var i = 0; i < NR_ROWS; i++) {
        if (!this.rows[i].isEmpty()) {
          empty = false;
          break;
        }
      }
      return empty;
    }
  }, {
    key: 'backSpace',
    value: function backSpace() {
      var row = this.rows[this.currRow];
      row.backSpace();
    }
  }, {
    key: 'clearToEndOfRow',
    value: function clearToEndOfRow() {
      var row = this.rows[this.currRow];
      row.clearToEndOfRow();
    }

    /**
       * Insert a character (without styling) in the current row.
       */

  }, {
    key: 'insertChar',
    value: function insertChar(char) {
      var row = this.rows[this.currRow];
      row.insertChar(char);
    }
  }, {
    key: 'setPen',
    value: function setPen(styles) {
      var row = this.rows[this.currRow];
      row.setPenStyles(styles);
    }
  }, {
    key: 'moveCursor',
    value: function moveCursor(relPos) {
      var row = this.rows[this.currRow];
      row.moveCursor(relPos);
    }
  }, {
    key: 'setCursor',
    value: function setCursor(absPos) {
      logger.log('INFO', 'setCursor: ' + absPos);
      var row = this.rows[this.currRow];
      row.setCursor(absPos);
    }
  }, {
    key: 'setPAC',
    value: function setPAC(pacData) {
      logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
      var newRow = pacData.row - 1;
      if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
        newRow = this.nrRollUpRows - 1;
      }

      // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows
      if (this.nrRollUpRows && this.currRow !== newRow) {
        // clear all rows first
        for (var i = 0; i < NR_ROWS; i++) {
          this.rows[i].clear();
        }

        // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
        // topRowIndex - the start of rows to copy (inclusive index)
        var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
        // We only copy if the last position was already shown.
        // We use the cueStartTime value to check this.
        var lastOutputScreen = this.lastOutputScreen;
        if (lastOutputScreen) {
          var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
          if (prevLineTime && prevLineTime < logger.time) {
            for (var _i = 0; _i < this.nrRollUpRows; _i++) {
              this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);
            }
          }
        }
      }

      this.currRow = newRow;
      var row = this.rows[this.currRow];
      if (pacData.indent !== null) {
        var indent = pacData.indent;
        var prevPos = Math.max(indent - 1, 0);
        row.setCursor(pacData.indent);
        pacData.color = row.chars[prevPos].penState.foreground;
      }
      var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };
      this.setPen(styles);
    }

    /**
       * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
       */

  }, {
    key: 'setBkgData',
    value: function setBkgData(bkgData) {
      logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
      this.backSpace();
      this.setPen(bkgData);
      this.insertChar(0x20); // Space
    }
  }, {
    key: 'setRollUpRows',
    value: function setRollUpRows(nrRows) {
      this.nrRollUpRows = nrRows;
    }
  }, {
    key: 'rollUp',
    value: function rollUp() {
      if (this.nrRollUpRows === null) {
        logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
        return; // Not properly setup
      }
      logger.log('TEXT', this.getDisplayText());
      var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
      var topRow = this.rows.splice(topRowIndex, 1)[0];
      topRow.clear();
      this.rows.splice(this.currRow, 0, topRow);
      logger.log('INFO', 'Rolling up');
      // logger.log('TEXT', this.get_display_text())
    }

    /**
      * Get all non-empty rows with as unicode text.
      */

  }, {
    key: 'getDisplayText',
    value: function getDisplayText(asOneRow) {
      asOneRow = asOneRow || false;
      var displayText = [];
      var text = '';
      var rowNr = -1;
      for (var i = 0; i < NR_ROWS; i++) {
        var rowText = this.rows[i].getTextString();
        if (rowText) {
          rowNr = i + 1;
          if (asOneRow) {
            displayText.push('Row ' + rowNr + ': \'' + rowText + '\'');
          } else {
            displayText.push(rowText.trim());
          }
        }
      }
      if (displayText.length > 0) {
        if (asOneRow) {
          text = '[' + displayText.join(' | ') + ']';
        } else {
          text = displayText.join('\n');
        }
      }
      return text;
    }
  }, {
    key: 'getTextAndFormat',
    value: function getTextAndFormat() {
      return this.rows;
    }
  }]);

  return CaptionScreen;
}();

// var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];

var Cea608Channel = function () {
  function Cea608Channel(channelNumber, outputFilter) {
    _classCallCheck(this, Cea608Channel);

    this.chNr = channelNumber;
    this.outputFilter = outputFilter;
    this.mode = null;
    this.verbose = 0;
    this.displayedMemory = new CaptionScreen();
    this.nonDisplayedMemory = new CaptionScreen();
    this.lastOutputScreen = new CaptionScreen();
    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
    this.writeScreen = this.displayedMemory;
    this.mode = null;
    this.cueStartTime = null; // Keeps track of where a cue started.
  }

  _createClass(Cea608Channel, [{
    key: 'reset',
    value: function reset() {
      this.mode = null;
      this.displayedMemory.reset();
      this.nonDisplayedMemory.reset();
      this.lastOutputScreen.reset();
      this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
      this.writeScreen = this.displayedMemory;
      this.mode = null;
      this.cueStartTime = null;
      this.lastCueEndTime = null;
    }
  }, {
    key: 'getHandler',
    value: function getHandler() {
      return this.outputFilter;
    }
  }, {
    key: 'setHandler',
    value: function setHandler(newHandler) {
      this.outputFilter = newHandler;
    }
  }, {
    key: 'setPAC',
    value: function setPAC(pacData) {
      this.writeScreen.setPAC(pacData);
    }
  }, {
    key: 'setBkgData',
    value: function setBkgData(bkgData) {
      this.writeScreen.setBkgData(bkgData);
    }
  }, {
    key: 'setMode',
    value: function setMode(newMode) {
      if (newMode === this.mode) {
        return;
      }

      this.mode = newMode;
      logger.log('INFO', 'MODE=' + newMode);
      if (this.mode === 'MODE_POP-ON') {
        this.writeScreen = this.nonDisplayedMemory;
      } else {
        this.writeScreen = this.displayedMemory;
        this.writeScreen.reset();
      }
      if (this.mode !== 'MODE_ROLL-UP') {
        this.displayedMemory.nrRollUpRows = null;
        this.nonDisplayedMemory.nrRollUpRows = null;
      }
      this.mode = newMode;
    }
  }, {
    key: 'insertChars',
    value: function insertChars(chars) {
      for (var i = 0; i < chars.length; i++) {
        this.writeScreen.insertChar(chars[i]);
      }

      var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
      logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));
      if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
        logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
        this.outputDataUpdate();
      }
    }
  }, {
    key: 'ccRCL',
    value: function ccRCL() {
      // Resume Caption Loading (switch mode to Pop On)
      logger.log('INFO', 'RCL - Resume Caption Loading');
      this.setMode('MODE_POP-ON');
    }
  }, {
    key: 'ccBS',
    value: function ccBS() {
      // BackSpace
      logger.log('INFO', 'BS - BackSpace');
      if (this.mode === 'MODE_TEXT') {
        return;
      }

      this.writeScreen.backSpace();
      if (this.writeScreen === this.displayedMemory) {
        this.outputDataUpdate();
      }
    }
  }, {
    key: 'ccAOF',
    value: function ccAOF() {// Reserved (formerly Alarm Off)

    }
  }, {
    key: 'ccAON',
    value: function ccAON() {// Reserved (formerly Alarm On)

    }
  }, {
    key: 'ccDER',
    value: function ccDER() {
      // Delete to End of Row
      logger.log('INFO', 'DER- Delete to End of Row');
      this.writeScreen.clearToEndOfRow();
      this.outputDataUpdate();
    }
  }, {
    key: 'ccRU',
    value: function ccRU(nrRows) {
      // Roll-Up Captions-2,3,or 4 Rows
      logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
      this.writeScreen = this.displayedMemory;
      this.setMode('MODE_ROLL-UP');
      this.writeScreen.setRollUpRows(nrRows);
    }
  }, {
    key: 'ccFON',
    value: function ccFON() {
      // Flash On
      logger.log('INFO', 'FON - Flash On');
      this.writeScreen.setPen({ flash: true });
    }
  }, {
    key: 'ccRDC',
    value: function ccRDC() {
      // Resume Direct Captioning (switch mode to PaintOn)
      logger.log('INFO', 'RDC - Resume Direct Captioning');
      this.setMode('MODE_PAINT-ON');
    }
  }, {
    key: 'ccTR',
    value: function ccTR() {
      // Text Restart in text mode (not supported, however)
      logger.log('INFO', 'TR');
      this.setMode('MODE_TEXT');
    }
  }, {
    key: 'ccRTD',
    value: function ccRTD() {
      // Resume Text Display in Text mode (not supported, however)
      logger.log('INFO', 'RTD');
      this.setMode('MODE_TEXT');
    }
  }, {
    key: 'ccEDM',
    value: function ccEDM() {
      // Erase Displayed Memory
      logger.log('INFO', 'EDM - Erase Displayed Memory');
      this.displayedMemory.reset();
      this.outputDataUpdate(true);
    }
  }, {
    key: 'ccCR',
    value: function ccCR() {
      // Carriage Return
      logger.log('CR - Carriage Return');
      this.writeScreen.rollUp();
      this.outputDataUpdate(true);
    }
  }, {
    key: 'ccENM',
    value: function ccENM() {
      // Erase Non-Displayed Memory
      logger.log('INFO', 'ENM - Erase Non-displayed Memory');
      this.nonDisplayedMemory.reset();
    }
  }, {
    key: 'ccEOC',
    value: function ccEOC() {
      // End of Caption (Flip Memories)
      logger.log('INFO', 'EOC - End Of Caption');
      if (this.mode === 'MODE_POP-ON') {
        var tmp = this.displayedMemory;
        this.displayedMemory = this.nonDisplayedMemory;
        this.nonDisplayedMemory = tmp;
        this.writeScreen = this.nonDisplayedMemory;
        logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());
      }
      this.outputDataUpdate(true);
    }
  }, {
    key: 'ccTO',
    value: function ccTO(nrCols) {
      // Tab Offset 1,2, or 3 columns
      logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
      this.writeScreen.moveCursor(nrCols);
    }
  }, {
    key: 'ccMIDROW',
    value: function ccMIDROW(secondByte) {
      // Parse MIDROW command
      var styles = { flash: false };
      styles.underline = secondByte % 2 === 1;
      styles.italics = secondByte >= 0x2e;
      if (!styles.italics) {
        var colorIndex = Math.floor(secondByte / 2) - 0x10;
        var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
        styles.foreground = colors[colorIndex];
      } else {
        styles.foreground = 'white';
      }
      logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
      this.writeScreen.setPen(styles);
    }
  }, {
    key: 'outputDataUpdate',
    value: function outputDataUpdate() {
      var dispatch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var t = logger.time;
      if (t === null) {
        return;
      }

      if (this.outputFilter) {
        if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
          // Start of a new cue
          this.cueStartTime = t;
        } else {
          if (!this.displayedMemory.equals(this.lastOutputScreen)) {
            if (this.outputFilter.newCue) {
              this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);
              if (dispatch === true && this.outputFilter.dispatchCue) {
                this.outputFilter.dispatchCue();
              }
            }
            this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;
          }
        }
        this.lastOutputScreen.copy(this.displayedMemory);
      }
    }
  }, {
    key: 'cueSplitAtTime',
    value: function cueSplitAtTime(t) {
      if (this.outputFilter) {
        if (!this.displayedMemory.isEmpty()) {
          if (this.outputFilter.newCue) {
            this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
          }

          this.cueStartTime = t;
        }
      }
    }
  }]);

  return Cea608Channel;
}();

var Cea608Parser = function () {
  function Cea608Parser(field, out1, out2) {
    _classCallCheck(this, Cea608Parser);

    this.field = field || 1;
    this.outputs = [out1, out2];
    this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];
    this.currChNr = -1; // Will be 1 or 2
    this.lastCmdA = null; // First byte of last command
    this.lastCmdB = null; // Second byte of last command
    this.bufferedData = [];
    this.startTime = null;
    this.lastTime = null;
    this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };
  }

  _createClass(Cea608Parser, [{
    key: 'getHandler',
    value: function getHandler(index) {
      return this.channels[index].getHandler();
    }
  }, {
    key: 'setHandler',
    value: function setHandler(index, newHandler) {
      this.channels[index].setHandler(newHandler);
    }

    /**
       * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
       */

  }, {
    key: 'addData',
    value: function addData(t, byteList) {
      var cmdFound = void 0,
          a = void 0,
          b = void 0,
          charsFound = false;

      this.lastTime = t;
      logger.setTime(t);

      for (var i = 0; i < byteList.length; i += 2) {
        a = byteList[i] & 0x7f;
        b = byteList[i + 1] & 0x7f;
        if (a === 0 && b === 0) {
          this.dataCounters.padding += 2;
          continue;
        } else {
          logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
        }
        cmdFound = this.parseCmd(a, b);
        if (!cmdFound) {
          cmdFound = this.parseMidrow(a, b);
        }

        if (!cmdFound) {
          cmdFound = this.parsePAC(a, b);
        }

        if (!cmdFound) {
          cmdFound = this.parseBackgroundAttributes(a, b);
        }

        if (!cmdFound) {
          charsFound = this.parseChars(a, b);
          if (charsFound) {
            if (this.currChNr && this.currChNr >= 0) {
              var channel = this.channels[this.currChNr - 1];
              channel.insertChars(charsFound);
            } else {
              logger.log('WARNING', 'No channel found yet. TEXT-MODE?');
            }
          }
        }
        if (cmdFound) {
          this.dataCounters.cmd += 2;
        } else if (charsFound) {
          this.dataCounters.char += 2;
        } else {
          this.dataCounters.other += 2;
          logger.log('WARNING', 'Couldn\'t parse cleaned data ' + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
        }
      }
    }

    /**
       * Parse Command.
       * @returns {Boolean} Tells if a command was found
       */

  }, {
    key: 'parseCmd',
    value: function parseCmd(a, b) {
      var chNr = null;

      var cond1 = (a === 0x14 || a === 0x1C) && b >= 0x20 && b <= 0x2F;
      var cond2 = (a === 0x17 || a === 0x1F) && b >= 0x21 && b <= 0x23;
      if (!(cond1 || cond2)) {
        return false;
      }

      if (a === this.lastCmdA && b === this.lastCmdB) {
        this.lastCmdA = null;
        this.lastCmdB = null; // Repeated commands are dropped (once)
        logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
        return true;
      }

      if (a === 0x14 || a === 0x17) {
        chNr = 1;
      } else {
        chNr = 2;
      } // (a === 0x1C || a=== 0x1f)

      var channel = this.channels[chNr - 1];

      if (a === 0x14 || a === 0x1C) {
        if (b === 0x20) {
          channel.ccRCL();
        } else if (b === 0x21) {
          channel.ccBS();
        } else if (b === 0x22) {
          channel.ccAOF();
        } else if (b === 0x23) {
          channel.ccAON();
        } else if (b === 0x24) {
          channel.ccDER();
        } else if (b === 0x25) {
          channel.ccRU(2);
        } else if (b === 0x26) {
          channel.ccRU(3);
        } else if (b === 0x27) {
          channel.ccRU(4);
        } else if (b === 0x28) {
          channel.ccFON();
        } else if (b === 0x29) {
          channel.ccRDC();
        } else if (b === 0x2A) {
          channel.ccTR();
        } else if (b === 0x2B) {
          channel.ccRTD();
        } else if (b === 0x2C) {
          channel.ccEDM();
        } else if (b === 0x2D) {
          channel.ccCR();
        } else if (b === 0x2E) {
          channel.ccENM();
        } else if (b === 0x2F) {
          channel.ccEOC();
        }
      } else {
        // a == 0x17 || a == 0x1F
        channel.ccTO(b - 0x20);
      }
      this.lastCmdA = a;
      this.lastCmdB = b;
      this.currChNr = chNr;
      return true;
    }

    /**
       * Parse midrow styling command
       * @returns {Boolean}
       */

  }, {
    key: 'parseMidrow',
    value: function parseMidrow(a, b) {
      var chNr = null;

      if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {
        if (a === 0x11) {
          chNr = 1;
        } else {
          chNr = 2;
        }

        if (chNr !== this.currChNr) {
          logger.log('ERROR', 'Mismatch channel in midrow parsing');
          return false;
        }
        var channel = this.channels[chNr - 1];
        channel.ccMIDROW(b);
        logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
        return true;
      }
      return false;
    }
    /**
       * Parse Preable Access Codes (Table 53).
       * @returns {Boolean} Tells if PAC found
       */

  }, {
    key: 'parsePAC',
    value: function parsePAC(a, b) {
      var chNr = null;
      var row = null;

      var case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1F) && b >= 0x40 && b <= 0x7F;
      var case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5F;
      if (!(case1 || case2)) {
        return false;
      }

      if (a === this.lastCmdA && b === this.lastCmdB) {
        this.lastCmdA = null;
        this.lastCmdB = null;
        return true; // Repeated commands are dropped (once)
      }

      chNr = a <= 0x17 ? 1 : 2;

      if (b >= 0x40 && b <= 0x5F) {
        row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
      } else {
        // 0x60 <= b <= 0x7F
        row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
      }
      var pacData = this.interpretPAC(row, b);
      var channel = this.channels[chNr - 1];
      channel.setPAC(pacData);
      this.lastCmdA = a;
      this.lastCmdB = b;
      this.currChNr = chNr;
      return true;
    }

    /**
       * Interpret the second byte of the pac, and return the information.
       * @returns {Object} pacData with style parameters.
       */

  }, {
    key: 'interpretPAC',
    value: function interpretPAC(row, byte) {
      var pacIndex = byte;
      var pacData = { color: null, italics: false, indent: null, underline: false, row: row };

      if (byte > 0x5F) {
        pacIndex = byte - 0x60;
      } else {
        pacIndex = byte - 0x40;
      }

      pacData.underline = (pacIndex & 1) === 1;
      if (pacIndex <= 0xd) {
        pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
      } else if (pacIndex <= 0xf) {
        pacData.italics = true;
        pacData.color = 'white';
      } else {
        pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
      }
      return pacData; // Note that row has zero offset. The spec uses 1.
    }

    /**
       * Parse characters.
       * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
       */

  }, {
    key: 'parseChars',
    value: function parseChars(a, b) {
      var channelNr = null,
          charCodes = null,
          charCode1 = null;

      if (a >= 0x19) {
        channelNr = 2;
        charCode1 = a - 8;
      } else {
        channelNr = 1;
        charCode1 = a;
      }
      if (charCode1 >= 0x11 && charCode1 <= 0x13) {
        // Special character
        var oneCode = b;
        if (charCode1 === 0x11) {
          oneCode = b + 0x50;
        } else if (charCode1 === 0x12) {
          oneCode = b + 0x70;
        } else {
          oneCode = b + 0x90;
        }

        logger.log('INFO', 'Special char \'' + getCharForByte(oneCode) + '\' in channel ' + channelNr);
        charCodes = [oneCode];
      } else if (a >= 0x20 && a <= 0x7f) {
        charCodes = b === 0 ? [a] : [a, b];
      }
      if (charCodes) {
        var hexCodes = numArrayToHexArray(charCodes);
        logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
        this.lastCmdA = null;
        this.lastCmdB = null;
      }
      return charCodes;
    }

    /**
      * Parse extended background attributes as well as new foreground color black.
      * @returns{Boolean} Tells if background attributes are found
      */

  }, {
    key: 'parseBackgroundAttributes',
    value: function parseBackgroundAttributes(a, b) {
      var bkgData = void 0,
          index = void 0,
          chNr = void 0,
          channel = void 0;

      var case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;
      var case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;
      if (!(case1 || case2)) {
        return false;
      }

      bkgData = {};
      if (a === 0x10 || a === 0x18) {
        index = Math.floor((b - 0x20) / 2);
        bkgData.background = backgroundColors[index];
        if (b % 2 === 1) {
          bkgData.background = bkgData.background + '_semi';
        }
      } else if (b === 0x2d) {
        bkgData.background = 'transparent';
      } else {
        bkgData.foreground = 'black';
        if (b === 0x2f) {
          bkgData.underline = true;
        }
      }
      chNr = a < 0x18 ? 1 : 2;
      channel = this.channels[chNr - 1];
      channel.setBkgData(bkgData);
      this.lastCmdA = null;
      this.lastCmdB = null;
      return true;
    }

    /**
       * Reset state of parser and its channels.
       */

  }, {
    key: 'reset',
    value: function reset() {
      for (var i = 0; i < this.channels.length; i++) {
        if (this.channels[i]) {
          this.channels[i].reset();
        }
      }
      this.lastCmdA = null;
      this.lastCmdB = null;
    }

    /**
       * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
       */

  }, {
    key: 'cueSplitAtTime',
    value: function cueSplitAtTime(t) {
      for (var i = 0; i < this.channels.length; i++) {
        if (this.channels[i]) {
          this.channels[i].cueSplitAtTime(t);
        }
      }
    }
  }]);

  return Cea608Parser;
}();

exports.default = Cea608Parser;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/codecs.js":
/*!************************************!*\
  !*** ./src/hls.js/utils/codecs.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// from http://mp4ra.org/codecs.html
var sampleEntryCodesISO = {
  audio: {
    'a3ds': true,
    'ac-3': true,
    'ac-4': true,
    'alac': true,
    'alaw': true,
    'dra1': true,
    'dts+': true,
    'dts-': true,
    'dtsc': true,
    'dtse': true,
    'dtsh': true,
    'ec-3': true,
    'enca': true,
    'g719': true,
    'g726': true,
    'm4ae': true,
    'mha1': true,
    'mha2': true,
    'mhm1': true,
    'mhm2': true,
    'mlpa': true,
    'mp4a': true,
    'raw ': true,
    'Opus': true,
    'samr': true,
    'sawb': true,
    'sawp': true,
    'sevc': true,
    'sqcp': true,
    'ssmv': true,
    'twos': true,
    'ulaw': true
  },
  video: {
    'avc1': true,
    'avc2': true,
    'avc3': true,
    'avc4': true,
    'avcp': true,
    'drac': true,
    'dvav': true,
    'dvhe': true,
    'encv': true,
    'hev1': true,
    'hvc1': true,
    'mjp2': true,
    'mp4v': true,
    'mvc1': true,
    'mvc2': true,
    'mvc3': true,
    'mvc4': true,
    'resv': true,
    'rv60': true,
    's263': true,
    'svc1': true,
    'svc2': true,
    'vc-1': true,
    'vp08': true,
    'vp09': true
  }
};

function isCodecType(codec, type) {
  var typeCodes = sampleEntryCodesISO[type];
  return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;
}

function isCodecSupportedInMp4(codec, type) {
  return window.MediaSource.isTypeSupported((type || 'video') + '/mp4;codecs="' + codec + '"');
}

exports.isCodecType = isCodecType;
exports.isCodecSupportedInMp4 = isCodecSupportedInMp4;

/***/ }),

/***/ "./src/hls.js/utils/cues.js":
/*!**********************************!*\
  !*** ./src/hls.js/utils/cues.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.newCue = newCue;

var _vttparser = __webpack_require__(/*! ./vttparser */ "./src/hls.js/utils/vttparser.js");

function newCue(track, startTime, endTime, captionScreen) {
  var row = void 0;
  var cue = void 0;
  var indenting = void 0;
  var indent = void 0;
  var text = void 0;
  var VTTCue = window.VTTCue || window.TextTrackCue;

  for (var r = 0; r < captionScreen.rows.length; r++) {
    row = captionScreen.rows[r];
    indenting = true;
    indent = 0;
    text = '';

    if (!row.isEmpty()) {
      for (var c = 0; c < row.chars.length; c++) {
        if (row.chars[c].uchar.match(/\s/) && indenting) {
          indent++;
        } else {
          text += row.chars[c].uchar;
          indenting = false;
        }
      }
      // To be used for cleaning-up orphaned roll-up captions
      row.cueStartTime = startTime;

      // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
      if (startTime === endTime) {
        endTime += 0.0001;
      }

      cue = new VTTCue(startTime, endTime, (0, _vttparser.fixLineBreaks)(text.trim()));

      if (indent >= 16) {
        indent--;
      } else {
        indent++;
      }

      // VTTCue.line get's flakey when using controls, so let's now include line 13&14
      // also, drop line 1 since it's to close to the top
      if (navigator.userAgent.match(/Firefox\//)) {
        cue.line = r + 1;
      } else {
        cue.line = r > 7 ? r - 2 : r + 1;
      }

      cue.align = 'left';
      // Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break
      cue.position = Math.max(0, Math.min(100, 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0)));
      track.addCue(cue);
    }
  }
}

/***/ }),

/***/ "./src/hls.js/utils/discontinuities.js":
/*!*********************************************!*\
  !*** ./src/hls.js/utils/discontinuities.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findFirstFragWithCC = findFirstFragWithCC;
exports.findFragWithCC = findFragWithCC;
exports.shouldAlignOnDiscontinuities = shouldAlignOnDiscontinuities;
exports.findDiscontinuousReferenceFrag = findDiscontinuousReferenceFrag;
exports.adjustPts = adjustPts;
exports.alignStream = alignStream;
exports.alignDiscontinuities = alignDiscontinuities;
exports.alignPDT = alignPDT;

var _binarySearch = __webpack_require__(/*! ./binary-search */ "./src/hls.js/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function findFirstFragWithCC(fragments, cc) {
  var firstFrag = null;

  for (var i = 0; i < fragments.length; i += 1) {
    var currentFrag = fragments[i];
    if (currentFrag && currentFrag.cc === cc) {
      firstFrag = currentFrag;
      break;
    }
  }

  return firstFrag;
}

function findFragWithCC(fragments, CC) {
  return _binarySearch2.default.search(fragments, function (candidate) {
    if (candidate.cc < CC) {
      return 1;
    } else if (candidate.cc > CC) {
      return -1;
    } else {
      return 0;
    }
  });
}

function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {
  var shouldAlign = false;
  if (lastLevel && lastLevel.details && details) {
    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {
      shouldAlign = true;
    }
  }
  return shouldAlign;
}

// Find the first frag in the previous level which matches the CC of the first frag of the new level
function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
  var prevFrags = prevDetails.fragments;
  var curFrags = curDetails.fragments;

  if (!curFrags.length || !prevFrags.length) {
    _logger.logger.log('No fragments to align');
    return;
  }

  var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);

  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
    _logger.logger.log('No frag in previous level to align on');
    return;
  }

  return prevStartFrag;
}

function adjustPts(sliding, details) {
  details.fragments.forEach(function (frag) {
    if (frag) {
      var start = frag.start + sliding;
      frag.start = frag.startPTS = start;
      frag.endPTS = start + frag.duration;
    }
  });
  details.PTSKnown = true;
}

/**
 * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a
 * contiguous stream with the last fragments.
 * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to
 * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time
 * and an extra download.
 * @param lastFrag
 * @param lastLevel
 * @param details
 */
function alignStream(lastFrag, lastLevel, details) {
  alignDiscontinuities(lastFrag, details, lastLevel);
  if (!details.PTSKnown && lastLevel) {
    // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.
    // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same
    // discontinuity sequence.
    alignPDT(details, lastLevel.details);
  }
}

/**
 * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same
 * discontinuity sequence.
 * @param lastLevel - The details of the last loaded level
 * @param details - The details of the new level
 */
function alignDiscontinuities(lastFrag, details, lastLevel) {
  if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {
    var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);
    if (referenceFrag) {
      _logger.logger.log('Adjusting PTS using last level due to CC increase within current level');
      adjustPts(referenceFrag.start, details);
    }
  }
}

/**
 * Computes the PTS of a new level's fragments using the difference in Program Date Time from the last level.
 * @param details - The details of the new level
 * @param lastDetails - The details of the last loaded level
 */
function alignPDT(details, lastDetails) {
  if (lastDetails && lastDetails.fragments.length) {
    if (!details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {
      return;
    }
    // if last level sliding is 1000 and its first frag PROGRAM-DATE-TIME is 2017-08-20 1:10:00 AM
    // and if new details first frag PROGRAM DATE-TIME is 2017-08-20 1:10:08 AM
    // then we can deduce that playlist B sliding is 1000+8 = 1008s
    var lastPDT = lastDetails.fragments[0].programDateTime;
    var newPDT = details.fragments[0].programDateTime;
    // date diff is in ms. frag.start is in seconds
    var sliding = (newPDT - lastPDT) / 1000 + lastDetails.fragments[0].start;
    if (Number.isFinite(sliding)) {
      _logger.logger.log('adjusting PTS using programDateTime delta, sliding:' + sliding.toFixed(3));
      adjustPts(sliding, details);
    }
  }
}

/***/ }),

/***/ "./src/hls.js/utils/ewma-bandwidth-estimator.js":
/*!******************************************************!*\
  !*** ./src/hls.js/utils/ewma-bandwidth-estimator.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EWMA Bandwidth Estimator
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  - heavily inspired from shaka-player
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Tracks bandwidth samples and estimates available bandwidth.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Based on the minimum of two exponentially-weighted moving averages with
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * different half-lives.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _ewma = __webpack_require__(/*! ../utils/ewma */ "./src/hls.js/utils/ewma.js");

var _ewma2 = _interopRequireDefault(_ewma);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EwmaBandWidthEstimator = function () {
  function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
    _classCallCheck(this, EwmaBandWidthEstimator);

    this.hls = hls;
    this.defaultEstimate_ = defaultEstimate;
    this.minWeight_ = 0.001;
    this.minDelayMs_ = 50;
    this.slow_ = new _ewma2.default(slow);
    this.fast_ = new _ewma2.default(fast);
  }

  _createClass(EwmaBandWidthEstimator, [{
    key: 'sample',
    value: function sample(durationMs, numBytes) {
      durationMs = Math.max(durationMs, this.minDelayMs_);
      var bandwidth = 8000 * numBytes / durationMs,

      // console.log('instant bw:'+ Math.round(bandwidth));
      // we weight sample using loading duration....
      weight = durationMs / 1000;
      this.fast_.sample(weight, bandwidth);
      this.slow_.sample(weight, bandwidth);
    }
  }, {
    key: 'canEstimate',
    value: function canEstimate() {
      var fast = this.fast_;
      return fast && fast.getTotalWeight() >= this.minWeight_;
    }
  }, {
    key: 'getEstimate',
    value: function getEstimate() {
      if (this.canEstimate()) {
        // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
        // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
        // Take the minimum of these two estimates.  This should have the effect of
        // adapting down quickly, but up more slowly.
        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
      } else {
        return this.defaultEstimate_;
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }]);

  return EwmaBandWidthEstimator;
}();

exports.default = EwmaBandWidthEstimator;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/ewma.js":
/*!**********************************!*\
  !*** ./src/hls.js/utils/ewma.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */

var EWMA = function () {
  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  function EWMA(halfLife) {
    _classCallCheck(this, EWMA);

    // Larger values of alpha expire historical data more slowly.
    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
    this.estimate_ = 0;
    this.totalWeight_ = 0;
  }

  _createClass(EWMA, [{
    key: "sample",
    value: function sample(weight, value) {
      var adjAlpha = Math.pow(this.alpha_, weight);
      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
      this.totalWeight_ += weight;
    }
  }, {
    key: "getTotalWeight",
    value: function getTotalWeight() {
      return this.totalWeight_;
    }
  }, {
    key: "getEstimate",
    value: function getEstimate() {
      if (this.alpha_) {
        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
        return this.estimate_ / zeroFactor;
      } else {
        return this.estimate_;
      }
    }
  }]);

  return EWMA;
}();

exports.default = EWMA;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/utils/get-self-scope.js":
/*!********************************************!*\
  !*** ./src/hls.js/utils/get-self-scope.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSelfScope = getSelfScope;
function getSelfScope() {
  // see https://stackoverflow.com/a/11237259/589493
  if (typeof window === 'undefined') {
    /* eslint-disable-next-line no-undef */
    return self;
  } else {
    return window;
  }
}

/***/ }),

/***/ "./src/hls.js/utils/logger.js":
/*!************************************!*\
  !*** ./src/hls.js/utils/logger.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logger = exports.enableLogs = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _getSelfScope = __webpack_require__(/*! ./get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

function noop() {}

var fakeLogger = {
  trace: noop,
  debug: noop,
  log: noop,
  warn: noop,
  info: noop,
  error: noop
};

var exportedLogger = fakeLogger;

// let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }

function formatMsg(type, msg) {
  msg = '[' + type + '] > ' + msg;
  return msg;
}

var global = (0, _getSelfScope.getSelfScope)();

function consolePrintFn(type) {
  var func = global.console[type];
  if (func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args[0]) {
        args[0] = formatMsg(type, args[0]);
      }

      func.apply(global.console, args);
    };
  }
  return noop;
}

function exportLoggerFunctions(debugConfig) {
  for (var _len2 = arguments.length, functions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    functions[_key2 - 1] = arguments[_key2];
  }

  functions.forEach(function (type) {
    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
  });
}

var enableLogs = exports.enableLogs = function enableLogs(debugConfig) {
  if (debugConfig === true || (typeof debugConfig === 'undefined' ? 'undefined' : _typeof(debugConfig)) === 'object') {
    exportLoggerFunctions(debugConfig,
    // Remove out from list here to hard-disable a log-level
    // 'trace',
    'debug', 'log', 'info', 'warn', 'error');
    // Some browsers don't allow to use bind on console object anyway
    // fallback to default if needed
    try {
      exportedLogger.log();
    } catch (e) {
      exportedLogger = fakeLogger;
    }
  } else {
    exportedLogger = fakeLogger;
  }
};

var logger = exports.logger = exportedLogger;

/***/ }),

/***/ "./src/hls.js/utils/mediakeys-helper.js":
/*!**********************************************!*\
  !*** ./src/hls.js/utils/mediakeys-helper.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var requestMediaKeySystemAccess = function () {
  if (typeof window !== 'undefined' && window.navigator && window.navigator.requestMediaKeySystemAccess) {
    return window.navigator.requestMediaKeySystemAccess.bind(window.navigator);
  } else {
    return null;
  }
}();

exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess;

/***/ }),

/***/ "./src/hls.js/utils/mediasource-helper.js":
/*!************************************************!*\
  !*** ./src/hls.js/utils/mediasource-helper.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMediaSource = getMediaSource;
/**
 * MediaSource helper
 */

function getMediaSource() {
  if (typeof window !== 'undefined') {
    return window.MediaSource || window.WebKitMediaSource;
  }
}

/***/ }),

/***/ "./src/hls.js/utils/output-filter.js":
/*!*******************************************!*\
  !*** ./src/hls.js/utils/output-filter.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var OutputFilter = function () {
  function OutputFilter(timelineController, trackName) {
    _classCallCheck(this, OutputFilter);

    this.timelineController = timelineController;
    this.trackName = trackName;
    this.startTime = null;
    this.endTime = null;
    this.screen = null;
  }

  _createClass(OutputFilter, [{
    key: "dispatchCue",
    value: function dispatchCue() {
      if (this.startTime === null) {
        return;
      }

      this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen);
      this.startTime = null;
    }
  }, {
    key: "newCue",
    value: function newCue(startTime, endTime, screen) {
      if (this.startTime === null || this.startTime > startTime) {
        this.startTime = startTime;
      }

      this.endTime = endTime;
      this.screen = screen;
      this.timelineController.createCaptionsTrack(this.trackName);
    }
  }]);

  return OutputFilter;
}();

exports.default = OutputFilter;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/utils/texttrack-utils.js":
/*!*********************************************!*\
  !*** ./src/hls.js/utils/texttrack-utils.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sendAddTrackEvent = sendAddTrackEvent;
exports.clearCurrentCues = clearCurrentCues;
function sendAddTrackEvent(track, videoEl) {
  var event = null;
  try {
    event = new window.Event('addtrack');
  } catch (err) {
    // for IE11
    event = document.createEvent('Event');
    event.initEvent('addtrack', false, false);
  }
  event.track = track;
  videoEl.dispatchEvent(event);
}

function clearCurrentCues(track) {
  if (track && track.cues) {
    while (track.cues.length > 0) {
      track.removeCue(track.cues[0]);
    }
  }
}

/***/ }),

/***/ "./src/hls.js/utils/time-ranges.js":
/*!*****************************************!*\
  !*** ./src/hls.js/utils/time-ranges.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 *  TimeRanges to string helper
 */

var TimeRanges = {
  toString: function toString(r) {
    var log = '',
        len = r.length;
    for (var i = 0; i < len; i++) {
      log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';
    }

    return log;
  }
};

exports.default = TimeRanges;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/vttcue.js":
/*!************************************!*\
  !*** ./src/hls.js/utils/vttcue.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

exports.default = function () {
  if (typeof window !== 'undefined' && window.VTTCue) {
    return window.VTTCue;
  }

  var autoKeyword = 'auto';
  var directionSetting = {
    '': true,
    lr: true,
    rl: true
  };
  var alignSetting = {
    start: true,
    middle: true,
    end: true,
    left: true,
    right: true
  };

  function findDirectionSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }

    var dir = directionSetting[value.toLowerCase()];
    return dir ? value.toLowerCase() : false;
  }

  function findAlignSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }

    var align = alignSetting[value.toLowerCase()];
    return align ? value.toLowerCase() : false;
  }

  function extend(obj) {
    var i = 1;
    for (; i < arguments.length; i++) {
      var cobj = arguments[i];
      for (var p in cobj) {
        obj[p] = cobj[p];
      }
    }

    return obj;
  }

  function VTTCue(startTime, endTime, text) {
    var cue = this;
    var isIE8 = function () {
      if (typeof navigator === 'undefined') {
        return;
      }

      return (/MSIE\s8\.0/.test(navigator.userAgent)
      );
    }();
    var baseObj = {};

    if (isIE8) {
      cue = document.createElement('custom');
    } else {
      baseObj.enumerable = true;
    }

    /**
     * Shim implementation specific properties. These properties are not in
     * the spec.
     */

    // Lets us know when the VTTCue's data has changed in such a way that we need
    // to recompute its display state. This lets us compute its display state
    // lazily.
    cue.hasBeenReset = false;

    /**
     * VTTCue and TextTrackCue properties
     * http://dev.w3.org/html5/webvtt/#vttcue-interface
     */

    var _id = '';
    var _pauseOnExit = false;
    var _startTime = startTime;
    var _endTime = endTime;
    var _text = text;
    var _region = null;
    var _vertical = '';
    var _snapToLines = true;
    var _line = 'auto';
    var _lineAlign = 'start';
    var _position = 50;
    var _positionAlign = 'middle';
    var _size = 50;
    var _align = 'middle';

    Object.defineProperty(cue, 'id', extend({}, baseObj, {
      get: function get() {
        return _id;
      },
      set: function set(value) {
        _id = '' + value;
      }
    }));

    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {
      get: function get() {
        return _pauseOnExit;
      },
      set: function set(value) {
        _pauseOnExit = !!value;
      }
    }));

    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {
      get: function get() {
        return _startTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('Start time must be set to a number.');
        }

        _startTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {
      get: function get() {
        return _endTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('End time must be set to a number.');
        }

        _endTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'text', extend({}, baseObj, {
      get: function get() {
        return _text;
      },
      set: function set(value) {
        _text = '' + value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'region', extend({}, baseObj, {
      get: function get() {
        return _region;
      },
      set: function set(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {
      get: function get() {
        return _vertical;
      },
      set: function set(value) {
        var setting = findDirectionSetting(value);
        // Have to check for false because the setting an be an empty string.
        if (setting === false) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {
      get: function get() {
        return _snapToLines;
      },
      set: function set(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'line', extend({}, baseObj, {
      get: function get() {
        return _line;
      },
      set: function set(value) {
        if (typeof value !== 'number' && value !== autoKeyword) {
          throw new SyntaxError('An invalid number or illegal string was specified.');
        }

        _line = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {
      get: function get() {
        return _lineAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'position', extend({}, baseObj, {
      get: function get() {
        return _position;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Position must be between 0 and 100.');
        }

        _position = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {
      get: function get() {
        return _positionAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'size', extend({}, baseObj, {
      get: function get() {
        return _size;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Size must be between 0 and 100.');
        }

        _size = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'align', extend({}, baseObj, {
      get: function get() {
        return _align;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _align = setting;
        this.hasBeenReset = true;
      }
    }));

    /**
     * Other <track> spec defined properties
     */

    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
    cue.displayState = undefined;

    if (isIE8) {
      return cue;
    }
  }

  /**
   * VTTCue methods
   */

  VTTCue.prototype.getCueAsHTML = function () {
    // Assume WebVTT.convertCueToDOMTree is on the global.
    var WebVTT = window.WebVTT;
    return WebVTT.convertCueToDOMTree(window, this.text);
  };

  return VTTCue;
}();

module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/vttparser.js":
/*!***************************************!*\
  !*** ./src/hls.js/utils/vttparser.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fixLineBreaks = undefined;

var _vttcue = __webpack_require__(/*! ./vttcue */ "./src/hls.js/utils/vttcue.js");

var _vttcue2 = _interopRequireDefault(_vttcue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StringDecoder = function StringDecoder() {
  return {
    decode: function decode(data) {
      if (!data) {
        return '';
      }

      if (typeof data !== 'string') {
        throw new Error('Error - expected string data.');
      }

      return decodeURIComponent(encodeURIComponent(data));
    }
  };
}; /*
    * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716
    */

function VTTParser() {
  this.window = window;
  this.state = 'INITIAL';
  this.buffer = '';
  this.decoder = new StringDecoder();
  this.regionList = [];
}

// Try to parse input as a time stamp.
function parseTimeStamp(input) {
  function computeSeconds(h, m, s, f) {
    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
  }

  var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
  if (!m) {
    return null;
  }

  if (m[3]) {
    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
    return computeSeconds(m[1], m[2], m[3].replace(':', ''), m[4]);
  } else if (m[1] > 59) {
    // Timestamp takes the form of [hours]:[minutes].[milliseconds]
    // First position is hours as it's over 59.
    return computeSeconds(m[1], m[2], 0, m[4]);
  } else {
    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
    return computeSeconds(0, m[1], m[2], m[4]);
  }
}

// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings() {
  this.values = Object.create(null);
}

Settings.prototype = {
  // Only accept the first assignment to any key.
  set: function set(k, v) {
    if (!this.get(k) && v !== '') {
      this.values[k] = v;
    }
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function get(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }

    return this.has(k) ? this.values[k] : dflt;
  },
  // Check whether we have a value for a key.
  has: function has(k) {
    return k in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function alt(k, v, a) {
    for (var n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function integer(k, v) {
    if (/^-?\d+$/.test(v)) {
      // integer
      this.set(k, parseInt(v, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function percent(k, v) {
    var m = void 0;
    if (m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
      v = parseFloat(v);
      if (v >= 0 && v <= 100) {
        this.set(k, v);
        return true;
      }
    }
    return false;
  }
};

// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input, callback, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];
  for (var i in groups) {
    if (typeof groups[i] !== 'string') {
      continue;
    }

    var kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }

    var k = kv[0];
    var v = kv[1];
    callback(k, v);
  }
}

var defaults = new _vttcue2.default(0, 0, 0);
// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244
//  Safari doesn't yet support this change, but FF and Chrome do.
var center = defaults.align === 'middle' ? 'middle' : 'center';

function parseCue(input, cue, regionList) {
  // Remember the original input if we need to throw an error.
  var oInput = input;
  // 4.1 WebVTT timestamp
  function consumeTimeStamp() {
    var ts = parseTimeStamp(input);
    if (ts === null) {
      throw new Error('Malformed timestamp: ' + oInput);
    }

    // Remove time stamp from input.
    input = input.replace(/^[^\sa-zA-Z-]+/, '');
    return ts;
  }

  // 4.4.2 WebVTT cue settings
  function consumeCueSettings(input, cue) {
    var settings = new Settings();

    parseOptions(input, function (k, v) {
      switch (k) {
        case 'region':
          // Find the last region we parsed with the same region id.
          for (var i = regionList.length - 1; i >= 0; i--) {
            if (regionList[i].id === v) {
              settings.set(k, regionList[i].region);
              break;
            }
          }
          break;
        case 'vertical':
          settings.alt(k, v, ['rl', 'lr']);
          break;
        case 'line':
          var vals = v.split(','),
              vals0 = vals[0];
          settings.integer(k, vals0);
          if (settings.percent(k, vals0)) {
            settings.set('snapToLines', false);
          }

          settings.alt(k, vals0, ['auto']);
          if (vals.length === 2) {
            settings.alt('lineAlign', vals[1], ['start', center, 'end']);
          }

          break;
        case 'position':
          vals = v.split(',');
          settings.percent(k, vals[0]);
          if (vals.length === 2) {
            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);
          }

          break;
        case 'size':
          settings.percent(k, v);
          break;
        case 'align':
          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);
          break;
      }
    }, /:/, /\s/);

    // Apply default values for any missing fields.
    cue.region = settings.get('region', null);
    cue.vertical = settings.get('vertical', '');
    var line = settings.get('line', 'auto');
    if (line === 'auto' && defaults.line === -1) {
      // set numeric line number for Safari
      line = -1;
    }
    cue.line = line;
    cue.lineAlign = settings.get('lineAlign', 'start');
    cue.snapToLines = settings.get('snapToLines', true);
    cue.size = settings.get('size', 100);
    cue.align = settings.get('align', center);
    var position = settings.get('position', 'auto');
    if (position === 'auto' && defaults.position === 50) {
      // set numeric position for Safari
      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;
    }
    cue.position = position;
  }

  function skipWhitespace() {
    input = input.replace(/^\s+/, '');
  }

  // 4.1 WebVTT cue timings.
  skipWhitespace();
  cue.startTime = consumeTimeStamp(); // (1) collect cue start time
  skipWhitespace();
  if (input.substr(0, 3) !== '-->') {
    // (3) next characters must match '-->'
    throw new Error('Malformed time stamp (time stamps must be separated by \'-->\'): ' + oInput);
  }
  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp(); // (5) collect cue end time

  // 4.1 WebVTT cue settings list.
  skipWhitespace();
  consumeCueSettings(input, cue);
}

function fixLineBreaks(input) {
  return input.replace(/<br(?: \/)?>/gi, '\n');
}

VTTParser.prototype = {
  parse: function parse(data) {
    var self = this;

    // If there is no data then we won't decode it, but will just try to parse
    // whatever is in buffer already. This may occur in circumstances, for
    // example when flush() is called.
    if (data) {
      // Try to decode the data that we received.
      self.buffer += self.decoder.decode(data, { stream: true });
    }

    function collectNextLine() {
      var buffer = self.buffer;
      var pos = 0;

      buffer = fixLineBreaks(buffer);

      while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
        ++pos;
      }

      var line = buffer.substr(0, pos);
      // Advance the buffer early in case we fail below.
      if (buffer[pos] === '\r') {
        ++pos;
      }

      if (buffer[pos] === '\n') {
        ++pos;
      }

      self.buffer = buffer.substr(pos);
      return line;
    }

    // 3.2 WebVTT metadata header syntax
    function parseHeader(input) {
      parseOptions(input, function (k, v) {
        switch (k) {
          case 'Region':
            // 3.3 WebVTT region metadata header syntax
            // console.log('parse region', v);
            // parseRegion(v);
            break;
        }
      }, /:/);
    }

    // 5.1 WebVTT file parsing.
    try {
      var line = void 0;
      if (self.state === 'INITIAL') {
        // We can't start parsing until we have the first line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        line = collectNextLine();
        // strip of UTF-8 BOM if any
        // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8
        var m = line.match(/^()?WEBVTT([ \t].*)?$/);
        if (!m || !m[0]) {
          throw new Error('Malformed WebVTT signature.');
        }

        self.state = 'HEADER';
      }

      var alreadyCollectedLine = false;
      while (self.buffer) {
        // We can't parse a line until we have the full line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }

        switch (self.state) {
          case 'HEADER':
            // 13-18 - Allow a header (metadata) under the WEBVTT line.
            if (/:/.test(line)) {
              parseHeader(line);
            } else if (!line) {
              // An empty line terminates the header and starts the body (cues).
              self.state = 'ID';
            }
            continue;
          case 'NOTE':
            // Ignore NOTE blocks.
            if (!line) {
              self.state = 'ID';
            }

            continue;
          case 'ID':
            // Check for the start of NOTE blocks.
            if (/^NOTE($|[ \t])/.test(line)) {
              self.state = 'NOTE';
              break;
            }
            // 19-29 - Allow any number of line terminators, then initialize new cue values.
            if (!line) {
              continue;
            }

            self.cue = new _vttcue2.default(0, 0, '');
            self.state = 'CUE';
            // 30-39 - Check if self line contains an optional identifier or timing data.
            if (line.indexOf('-->') === -1) {
              self.cue.id = line;
              continue;
            }
          // Process line as start of a cue.
          /* falls through */
          case 'CUE':
            // 40 - Collect cue timings and settings.
            try {
              parseCue(line, self.cue, self.regionList);
            } catch (e) {
              // In case of an error ignore rest of the cue.
              self.cue = null;
              self.state = 'BADCUE';
              continue;
            }
            self.state = 'CUETEXT';
            continue;
          case 'CUETEXT':
            var hasSubstring = line.indexOf('-->') !== -1;
            // 34 - If we have an empty line then report the cue.
            // 35 - If we have the special substring '-->' then report the cue,
            // but do not collect the line as we need to process the current
            // one as a new cue.
            if (!line || hasSubstring && (alreadyCollectedLine = true)) {
              // We are done parsing self cue.
              if (self.oncue) {
                self.oncue(self.cue);
              }

              self.cue = null;
              self.state = 'ID';
              continue;
            }
            if (self.cue.text) {
              self.cue.text += '\n';
            }

            self.cue.text += line;
            continue;
          case 'BADCUE':
            // BADCUE
            // 54-62 - Collect and discard the remaining cue.
            if (!line) {
              self.state = 'ID';
            }

            continue;
        }
      }
    } catch (e) {
      // If we are currently parsing a cue, report what we have.
      if (self.state === 'CUETEXT' && self.cue && self.oncue) {
        self.oncue(self.cue);
      }

      self.cue = null;
      // Enter BADWEBVTT state if header was not parsed correctly otherwise
      // another exception occurred so enter BADCUE state.
      self.state = self.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';
    }
    return this;
  },
  flush: function flush() {
    var self = this;
    try {
      // Finish decoding the stream.
      self.buffer += self.decoder.decode();
      // Synthesize the end of the current cue or region.
      if (self.cue || self.state === 'HEADER') {
        self.buffer += '\n\n';
        self.parse();
      }
      // If we've flushed, parsed, and we're still on the INITIAL state then
      // that means we don't have enough of the stream to parse the first
      // line.
      if (self.state === 'INITIAL') {
        throw new Error('Malformed WebVTT signature.');
      }
    } catch (e) {
      throw e;
    }
    if (self.onflush) {
      self.onflush();
    }

    return this;
  }
};

exports.fixLineBreaks = fixLineBreaks;
exports.default = VTTParser;

/***/ }),

/***/ "./src/hls.js/utils/webvtt-parser.js":
/*!*******************************************!*\
  !*** ./src/hls.js/utils/webvtt-parser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vttparser = __webpack_require__(/*! ./vttparser */ "./src/hls.js/utils/vttparser.js");

var _vttparser2 = _interopRequireDefault(_vttparser);

var _id = __webpack_require__(/*! ../demux/id3 */ "./src/hls.js/demux/id3.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// String.prototype.startsWith is not supported in IE11
var startsWith = function startsWith(inputString, searchString, position) {
  return inputString.substr(position || 0, searchString.length) === searchString;
};

var cueString2millis = function cueString2millis(timeString) {
  var ts = parseInt(timeString.substr(-3));
  var secs = parseInt(timeString.substr(-6, 2));
  var mins = parseInt(timeString.substr(-9, 2));
  var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0;

  if (!Number.isFinite(ts) || !Number.isFinite(secs) || !Number.isFinite(mins) || !Number.isFinite(hours)) {
    return -1;
  }

  ts += 1000 * secs;
  ts += 60 * 1000 * mins;
  ts += 60 * 60 * 1000 * hours;

  return ts;
};

// From https://github.com/darkskyapp/string-hash
var hash = function hash(text) {
  var hash = 5381;
  var i = text.length;
  while (i) {
    hash = hash * 33 ^ text.charCodeAt(--i);
  }

  return (hash >>> 0).toString();
};

var calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {
  var currCC = vttCCs[cc];
  var prevCC = vttCCs[currCC.prevCC];

  // This is the first discontinuity or cues have been processed since the last discontinuity
  // Offset = current discontinuity time
  if (!prevCC || !prevCC.new && currCC.new) {
    vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
    currCC.new = false;
    return;
  }

  // There have been discontinuities since cues were last parsed.
  // Offset = time elapsed
  while (prevCC && prevCC.new) {
    vttCCs.ccOffset += currCC.start - prevCC.start;
    currCC.new = false;
    currCC = prevCC;
    prevCC = vttCCs[currCC.prevCC];
  }

  vttCCs.presentationOffset = presentationTime;
};

var WebVTTParser = {
  parse: function parse(vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) {
    // Convert byteArray into string, replacing any somewhat exotic linefeeds with "\n", then split on that character.
    var re = /\r\n|\n\r|\n|\r/g;
    // Uint8Array.prototype.reduce is not implemented in IE11
    var vttLines = (0, _id.utf8ArrayToStr)(new Uint8Array(vttByteArray)).trim().replace(re, '\n').split('\n');

    var cueTime = '00:00.000';
    var mpegTs = 0;
    var localTime = 0;
    var presentationTime = 0;
    var cues = [];
    var parsingError = void 0;
    var inHeader = true;
    // let VTTCue = VTTCue || window.TextTrackCue;

    // Create parser object using VTTCue with TextTrackCue fallback on certain browsers.
    var parser = new _vttparser2.default();

    parser.oncue = function (cue) {
      // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.
      var currCC = vttCCs[cc];
      var cueOffset = vttCCs.ccOffset;

      // Update offsets for new discontinuities
      if (currCC && currCC.new) {
        if (localTime !== undefined) {
          // When local time is provided, offset = discontinuity start time - local time
          cueOffset = vttCCs.ccOffset = currCC.start;
        } else {
          calculateOffset(vttCCs, cc, presentationTime);
        }
      }

      if (presentationTime) {
        // If we have MPEGTS, offset = presentation time + discontinuity offset
        cueOffset = presentationTime - vttCCs.presentationOffset;
      }

      cue.startTime += cueOffset - localTime;
      cue.endTime += cueOffset - localTime;

      // Create a unique hash id for a cue based on start/end times and text.
      // This helps timeline-controller to avoid showing repeated captions.
      cue.id = hash(cue.startTime.toString()) + hash(cue.endTime.toString()) + hash(cue.text);

      // Fix encoding of special characters. TODO: Test with all sorts of weird characters.
      cue.text = decodeURIComponent(encodeURIComponent(cue.text));
      if (cue.endTime > 0) {
        cues.push(cue);
      }
    };

    parser.onparsingerror = function (e) {
      parsingError = e;
    };

    parser.onflush = function () {
      if (parsingError && errorCallBack) {
        errorCallBack(parsingError);
        return;
      }
      callBack(cues);
    };

    // Go through contents line by line.
    vttLines.forEach(function (line) {
      if (inHeader) {
        // Look for X-TIMESTAMP-MAP in header.
        if (startsWith(line, 'X-TIMESTAMP-MAP=')) {
          // Once found, no more are allowed anyway, so stop searching.
          inHeader = false;
          // Extract LOCAL and MPEGTS.
          line.substr(16).split(',').forEach(function (timestamp) {
            if (startsWith(timestamp, 'LOCAL:')) {
              cueTime = timestamp.substr(6);
            } else if (startsWith(timestamp, 'MPEGTS:')) {
              mpegTs = parseInt(timestamp.substr(7));
            }
          });
          try {
            // Calculate subtitle offset in milliseconds.
            if (syncPTS + (vttCCs[cc].start * 90000 || 0) < 0) {
              syncPTS += 8589934592;
            }
            // Adjust MPEGTS by sync PTS.
            mpegTs -= syncPTS;
            // Convert cue time to seconds
            localTime = cueString2millis(cueTime) / 1000;
            // Convert MPEGTS to seconds from 90kHz.
            presentationTime = mpegTs / 90000;

            if (localTime === -1) {
              parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
            }
          } catch (e) {
            parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
          }
          // Return without parsing X-TIMESTAMP-MAP line.
          return;
        } else if (line === '') {
          inHeader = false;
        }
      }
      // Parse line by default.
      parser.parse(line + '\n');
    });

    parser.flush();
  }
};

exports.default = WebVTTParser;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/xhr-loader.js":
/*!****************************************!*\
  !*** ./src/hls.js/utils/xhr-loader.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * XHR based logger
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _window = window,
    performance = _window.performance,
    XMLHttpRequest = _window.XMLHttpRequest;

var XhrLoader = function () {
  function XhrLoader(config) {
    _classCallCheck(this, XhrLoader);

    if (config && config.xhrSetup) {
      this.xhrSetup = config.xhrSetup;
    }
  }

  _createClass(XhrLoader, [{
    key: 'destroy',
    value: function destroy() {
      this.abort();
      this.loader = null;
    }
  }, {
    key: 'abort',
    value: function abort() {
      var loader = this.loader;
      if (loader && loader.readyState !== 4) {
        this.stats.aborted = true;
        loader.abort();
      }

      window.clearTimeout(this.requestTimeout);
      this.requestTimeout = null;
      window.clearTimeout(this.retryTimeout);
      this.retryTimeout = null;
    }
  }, {
    key: 'load',
    value: function load(context, config, callbacks) {
      this.context = context;
      this.config = config;
      this.callbacks = callbacks;
      this.stats = { trequest: performance.now(), retry: 0 };
      this.retryDelay = config.retryDelay;
      this.loadInternal();
    }
  }, {
    key: 'loadInternal',
    value: function loadInternal() {
      var xhr = void 0,
          context = this.context;
      xhr = this.loader = new XMLHttpRequest();

      var stats = this.stats;
      stats.tfirst = 0;
      stats.loaded = 0;
      var xhrSetup = this.xhrSetup;

      try {
        if (xhrSetup) {
          try {
            xhrSetup(xhr, context.url);
          } catch (e) {
            // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader("Content-Language", "test");}
            // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN
            xhr.open('GET', context.url, true);
            xhrSetup(xhr, context.url);
          }
        }
        if (!xhr.readyState) {
          xhr.open('GET', context.url, true);
        }
      } catch (e) {
        // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
        this.callbacks.onError({ code: xhr.status, text: e.message }, context, xhr);
        return;
      }

      if (context.rangeEnd) {
        xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
      }

      xhr.onreadystatechange = this.readystatechange.bind(this);
      xhr.onprogress = this.loadprogress.bind(this);
      xhr.responseType = context.responseType;

      // setup timeout before we perform request
      this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
      xhr.send();
    }
  }, {
    key: 'readystatechange',
    value: function readystatechange(event) {
      var xhr = event.currentTarget,
          readyState = xhr.readyState,
          stats = this.stats,
          context = this.context,
          config = this.config;

      // don't proceed if xhr has been aborted
      if (stats.aborted) {
        return;
      }

      // >= HEADERS_RECEIVED
      if (readyState >= 2) {
        // clear xhr timeout and rearm it if readyState less than 4
        window.clearTimeout(this.requestTimeout);
        if (stats.tfirst === 0) {
          stats.tfirst = Math.max(performance.now(), stats.trequest);
        }

        if (readyState === 4) {
          var status = xhr.status;
          // http status between 200 to 299 are all successful
          if (status >= 200 && status < 300) {
            stats.tload = Math.max(stats.tfirst, performance.now());
            var data = void 0,
                len = void 0;
            if (context.responseType === 'arraybuffer') {
              data = xhr.response;
              len = data.byteLength;
            } else {
              data = xhr.responseText;
              len = data.length;
            }
            stats.loaded = stats.total = len;
            var response = { url: xhr.responseURL, data: data };
            this.callbacks.onSuccess(response, stats, context, xhr);
          } else {
            // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
            if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
              _logger.logger.error(status + ' while loading ' + context.url);
              this.callbacks.onError({ code: status, text: xhr.statusText }, context, xhr);
            } else {
              // retry
              _logger.logger.warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...');
              // aborts and resets internal state
              this.destroy();
              // schedule retry
              this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
              // set exponential backoff
              this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
              stats.retry++;
            }
          }
        } else {
          // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
          this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout);
        }
      }
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout() {
      _logger.logger.warn('timeout while loading ' + this.context.url);
      this.callbacks.onTimeout(this.stats, this.context, null);
    }
  }, {
    key: 'loadprogress',
    value: function loadprogress(event) {
      var xhr = event.currentTarget,
          stats = this.stats;

      stats.loaded = event.loaded;
      if (event.lengthComputable) {
        stats.total = event.total;
      }

      var onProgress = this.callbacks.onProgress;
      if (onProgress) {
        // third arg is to provide on progress data
        onProgress(stats, this.context, null, xhr);
      }
    }
  }]);

  return XhrLoader;
}();

exports.default = XhrLoader;
module.exports = exports['default'];

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _xgplayer = __webpack_require__(/*! xgplayer */ "xgplayer");

var _xgplayer2 = _interopRequireDefault(_xgplayer);

var _hls = __webpack_require__(/*! ./hls.js/hls */ "./src/hls.js/hls.js");

var _hls2 = _interopRequireDefault(_hls);

var _utils = __webpack_require__(/*! ./utils */ "./src/utils/index.js");

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HlsJsPlayer = function (_Player) {
  _inherits(HlsJsPlayer, _Player);

  function HlsJsPlayer(options) {
    _classCallCheck(this, HlsJsPlayer);

    var _this = _possibleConstructorReturn(this, (HlsJsPlayer.__proto__ || Object.getPrototypeOf(HlsJsPlayer)).call(this, options));

    _this.hlsOpts = options.hlsOpts || {};
    var util = _xgplayer2.default.util;
    var player = _this;
    _this.browser = _utils2.default.getBrowserVersion();
    if (player.config.useHls === undefined) {
      if (_xgplayer2.default.sniffer.device === 'mobile' && navigator.platform !== 'MacIntel' && navigator.platform !== 'Win32' || _this.browser.indexOf('Safari') > -1) {
        return _possibleConstructorReturn(_this);
      }
    } else if (!player.config.useHls) {
      return _possibleConstructorReturn(_this);
    }
    Number.isFinite = Number.isFinite || function (value) {
      return typeof value === "number" && isFinite(value);
    };

    var hls = void 0;
    hls = new _hls2.default(_this.hlsOpts);
    _this.hls = hls;

    Object.defineProperty(player, 'src', {
      get: function get() {
        return player.currentSrc;
      },
      set: function set(url) {
        util.removeClass(player.root, 'xgplayer-is-live');
        var liveDom = document.querySelector('.xgplayer-live');
        if (liveDom) {
          liveDom.parentNode.removeChild(liveDom);
        }
        // player.config.url = url
        var paused = player.paused;
        player.hls.stopLoad();
        player.hls.detachMedia();
        player.hls.destroy();
        player.hls = new _hls2.default(player.hlsOpts);
        player.register(url);
        if (!paused) {
          player.pause();
          player.once('pause', function () {
            player.hls.loadSource(url);
          });
          player.once('canplay', function () {
            player.play().catch(function (err) {});
          });
        } else {
          player.hls.loadSource(url);
        }
        player.hls.attachMedia(player.video);
        player.once('canplay', function () {
          player.currentTime = 0;
        });
      },

      configurable: true
    });
    _this.register(_this.config.url);
    _this.once('complete', function () {
      hls.attachMedia(player.video);
      player.once('canplay', function () {
        if (player.config.autoplay) {
          player.play().catch(function (err) {});
        }
      });
      if (player.config.isLive) {
        util.addClass(player.root, 'xgplayer-is-live');
        if (!util.findDom(player.root, '.xgplayer-live')) {
          var live = util.createDom('xg-live', '', {}, 'xgplayer-live');
          player.controls.appendChild(live);
        }
      }
    });
    _this.once('destroy', function () {
      hls.stopLoad();
    });
    return _this;
  }

  _createClass(HlsJsPlayer, [{
    key: 'register',
    value: function register(url) {
      var hls = this.hls;
      var util = _xgplayer2.default.util;
      var player = this;
      hls.on(_hls2.default.Events.MEDIA_ATTACHED, function () {
        hls.loadSource(url);
      });

      hls.on(_hls2.default.Events.LEVEL_LOADED, function (name, e) {
        if (!hls.inited) {
          hls.inited = true;
          if (e && e.details && e.details.live) {
            util.addClass(player.root, 'xgplayer-is-live');
            if (!util.findDom(player.root, '.xgplayer-live')) {
              var live = util.createDom('xg-live', '', {}, 'xgplayer-live');
              player.controls.appendChild(live);
            }
          }
        }
      });
      hls.on(_hls2.default.Events.ERROR, function (event, data) {
        player.emit('HLS_ERROR', {
          errorType: data.type,
          errorDetails: data.details,
          errorFatal: data.fatal
        });
        if (data.fatal) {
          switch (data.type) {
            case _hls2.default.ErrorTypes.NETWORK_ERROR:
              hls.startLoad();
              break;
            case _hls2.default.ErrorTypes.MEDIA_ERROR:
              hls.recoverMediaError();
              break;
            default:
              player.emit('error', data);
          }
        }
      });
      this._statistics();
    }
  }, {
    key: '_statistics',
    value: function _statistics() {
      var statsInfo = {
        speed: 0,
        playerType: "HlsPlayer"
      };

      var mediainfo = {
        videoDataRate: 0,
        audioDataRate: 0
      };
      var hls = this.hls;
      var player = this;

      hls.on(_hls2.default.Events.FRAG_LOAD_PROGRESS, function (flag, payload) {
        statsInfo.speed = payload.stats.loaded / 1000;
      });
      hls.on(_hls2.default.Events.FRAG_PARSING_DATA, function (flag, payload) {
        if (payload.type === 'video') {
          mediainfo.fps = parseInt(payload.nb / (payload.endPTS - payload.startPTS));
        }
      });

      hls.on(_hls2.default.Events.FRAG_PARSING_INIT_SEGMENT, function (flag, payload) {
        mediainfo.hasAudio = payload.tracks && payload.tracks.audio ? true : false;
        mediainfo.hasVideo = payload.tracks && payload.tracks.audio ? true : false;

        if (mediainfo.hasAudio) {
          var track = payload.tracks.audio;
          mediainfo.audioChannelCount = track.metadata && track.metadata.channelCount ? track.metadata.channelCount : 0;
          mediainfo.audioCodec = track.codec;
        }

        if (mediainfo.hasVideo) {
          var _track = payload.tracks.video;
          mediainfo.videoCodec = _track.codec;
          mediainfo.width = _track.metadata && _track.metadata.width ? _track.metadata.width : 0;
          mediainfo.height = _track.metadata && _track.metadata.height ? _track.metadata.height : 0;
        }
        mediainfo.duration = payload.frag && payload.frag.duration ? payload.frag.duration : 0;
        mediainfo.level = payload.frag && payload.frag.levels ? payload.frag.levels : 0;
        if (mediainfo.videoCodec || mediainfo.audioCodec) {
          mediainfo.mimeType = 'video/hls; codecs="' + mediainfo.videoCodec + ';' + mediainfo.audioCodec + '"';
        }

        player.mediainfo = mediainfo;
        player.emit("media_info", mediainfo);
      });

      this._statisticsTimmer = setInterval(function () {
        player.emit("statistics_info", statsInfo);
        statsInfo.speed = 0;
      }, 1000);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _get(HlsJsPlayer.prototype.__proto__ || Object.getPrototypeOf(HlsJsPlayer.prototype), 'destroy', this).call(this);
      clearInterval(this._statisticsTimmer);
    }
  }]);

  return HlsJsPlayer;
}(_xgplayer2.default);

HlsJsPlayer.isSupported = _hls2.default.isSupported;

exports.default = HlsJsPlayer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/utils/index.js":
/*!****************************!*\
  !*** ./src/utils/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var util = {};

util.getBrowserVersion = function () {
  var userAgent = navigator.userAgent; //userAgent
  if (userAgent.toLowerCase().indexOf("mobile") > -1) {
    return "Unknown";
  }
  if (userAgent.indexOf("Firefox") > -1) {
    var version = userAgent.match(/firefox\/[\d.]+/gi)[0].match(/[\d]+/)[0];
    return "Firefox " + version;
  } else if (userAgent.indexOf("Edge") > -1) {
    var _version = userAgent.match(/edge\/[\d.]+/gi)[0].match(/[\d]+/)[0];
    return "Edge " + _version;
  } else if (userAgent.indexOf("rv:11") > -1) {
    return "IE 11";
  } else if (userAgent.indexOf("Opera") > -1 || userAgent.indexOf("OPR") > -1) {
    if (userAgent.indexOf("Opera") > -1) {
      var _version2 = userAgent.match(/opera\/[\d.]+/gi)[0].match(/[\d]+/)[0];
      return "Opera " + _version2;
    }
    if (userAgent.indexOf("OPR") > -1) {
      var _version3 = userAgent.match(/opr\/[\d.]+/gi)[0].match(/[\d]+/)[0];
      return "Opera " + _version3;
    }
  } else if (userAgent.indexOf("Chrome") > -1) {
    var _version4 = userAgent.match(/chrome\/[\d.]+/gi)[0].match(/[\d]+/)[0];
    return "Chrome " + _version4;
  } else if (userAgent.indexOf("Safari") > -1) {
    var _version5 = userAgent.match(/safari\/[\d.]+/gi)[0].match(/[\d]+/)[0];
    return "Safari " + _version5;
  } else if (userAgent.indexOf("MSIE") > -1 || userAgent.indexOf("Trident") > -1) {
    if (userAgent.indexOf("MSIE") > -1) {
      var _version6 = userAgent.match(/msie [\d.]+/gi)[0].match(/[\d]+/)[0];
      return "IE " + _version6;
    }
    if (userAgent.indexOf("Trident") > -1) {
      var versionTrident = userAgent.match(/trident\/[\d.]+/gi)[0].match(/[\d]+/)[0];
      var _version7 = parseInt(versionTrident) + 4;
      return "IE " + _version7;
    }
  } else {
    return "Unknown";
  }
};

exports.default = util;
module.exports = exports["default"];

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./src/index.js */"./src/index.js");


/***/ }),

/***/ "xgplayer":
/*!***************************!*\
  !*** external "xgplayer" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_xgplayer__;

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvL1VzZXJzL2xlb25hcmRvL0RvY3VtZW50cy9mcm9udC1lbmQvcGxheWVyL3hncGxheWVyL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy9Vc2Vycy9sZW9uYXJkby9Eb2N1bWVudHMvZnJvbnQtZW5kL3BsYXllci94Z3BsYXllci9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8vVXNlcnMvbGVvbmFyZG8vRG9jdW1lbnRzL2Zyb250LWVuZC9wbGF5ZXIveGdwbGF5ZXIvbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8vVXNlcnMvbGVvbmFyZG8vRG9jdW1lbnRzL2Zyb250LWVuZC9wbGF5ZXIveGdwbGF5ZXIvbm9kZV9tb2R1bGVzL3dlYndvcmtpZnktd2VicGFjay9pbmRleC5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvY29uZmlnLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2Fici1jb250cm9sbGVyLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2F1ZGlvLXN0cmVhbS1jb250cm9sbGVyLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvYmFzZS1zdHJlYW0tY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvY29udHJvbGxlci9idWZmZXItY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvY29udHJvbGxlci9jYXAtbGV2ZWwtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvY29udHJvbGxlci9lbWUtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvY29udHJvbGxlci9mcHMtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvY29udHJvbGxlci9mcmFnbWVudC1maW5kZXJzLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2ZyYWdtZW50LXRyYWNrZXIuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvZ2FwLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvaWQzLXRyYWNrLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvbGV2ZWwtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvY29udHJvbGxlci9sZXZlbC1oZWxwZXIuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy9jcnlwdC9hZXMtY3J5cHRvLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy9jcnlwdC9hZXMtZGVjcnlwdG9yLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy9jcnlwdC9kZWNyeXB0ZXIuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2NyeXB0L2Zhc3QtYWVzLWtleS5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvZGVtdXgvYWFjZGVtdXhlci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvZGVtdXgvYWR0cy5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvZGVtdXgvZGVtdXhlci1pbmxpbmUuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2RlbXV4L2RlbXV4ZXItd29ya2VyLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy9kZW11eC9kZW11eGVyLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy9kZW11eC9leHAtZ29sb21iLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy9kZW11eC9pZDMuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2RlbXV4L21wM2RlbXV4ZXIuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2RlbXV4L21wNGRlbXV4ZXIuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2RlbXV4L21wZWdhdWRpby5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvZGVtdXgvc2FtcGxlLWFlcy5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvZGVtdXgvdHNkZW11eGVyLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2V2ZW50LWhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvaGxzLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy9pcy1zdXBwb3J0ZWQuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2xvYWRlci9mcmFnbWVudC1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2xvYWRlci9mcmFnbWVudC5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvbG9hZGVyL2tleS1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2xvYWRlci9sZXZlbC1rZXkuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL2xvYWRlci9sZXZlbC5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvbG9hZGVyL20zdTgtcGFyc2VyLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy9sb2FkZXIvcGxheWxpc3QtbG9hZGVyLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy9vYnNlcnZlci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvcmVtdXgvYWFjLWhlbHBlci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvcmVtdXgvbXA0LWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvcmVtdXgvbXA0LXJlbXV4ZXIuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL3JlbXV4L3Bhc3N0aHJvdWdoLXJlbXV4ZXIuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL3Rhc2stbG9vcC5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvdXRpbHMvYXR0ci1saXN0LmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy91dGlscy9iaW5hcnktc2VhcmNoLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy91dGlscy9idWZmZXItaGVscGVyLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy91dGlscy9jZWEtNjA4LXBhcnNlci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvdXRpbHMvY29kZWNzLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy91dGlscy9jdWVzLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy91dGlscy9kaXNjb250aW51aXRpZXMuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL3V0aWxzL2V3bWEtYmFuZHdpZHRoLWVzdGltYXRvci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvdXRpbHMvZXdtYS5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvdXRpbHMvZ2V0LXNlbGYtc2NvcGUuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL3V0aWxzL2xvZ2dlci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvdXRpbHMvbWVkaWFrZXlzLWhlbHBlci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy91dGlscy9vdXRwdXQtZmlsdGVyLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy91dGlscy90ZXh0dHJhY2stdXRpbHMuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL3V0aWxzL3RpbWUtcmFuZ2VzLmpzIiwid2VicGFjazovL3hncGxheWVyLWhsc2pzLmpzLy4vc3JjL2hscy5qcy91dGlscy92dHRjdWUuanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItaGxzanMuanMvLi9zcmMvaGxzLmpzL3V0aWxzL3Z0dHBhcnNlci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvdXRpbHMvd2VidnR0LXBhcnNlci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9obHMuanMvdXRpbHMveGhyLWxvYWRlci5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy8uL3NyYy91dGlscy9pbmRleC5qcyIsIndlYnBhY2s6Ly94Z3BsYXllci1obHNqcy5qcy9leHRlcm5hbCBcInhncGxheWVyXCIiXSwibmFtZXMiOlsiQ3VlcyIsImhsc0RlZmF1bHRDb25maWciLCJhdXRvU3RhcnRMb2FkIiwic3RhcnRQb3NpdGlvbiIsImRlZmF1bHRBdWRpb0NvZGVjIiwidW5kZWZpbmVkIiwiZGVidWciLCJjYXBMZXZlbE9uRlBTRHJvcCIsImNhcExldmVsVG9QbGF5ZXJTaXplIiwiaW5pdGlhbExpdmVNYW5pZmVzdFNpemUiLCJtYXhCdWZmZXJMZW5ndGgiLCJtYXhCdWZmZXJTaXplIiwibWF4QnVmZmVySG9sZSIsImxvd0J1ZmZlcldhdGNoZG9nUGVyaW9kIiwiaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kIiwibnVkZ2VPZmZzZXQiLCJudWRnZU1heFJldHJ5IiwibWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSIsImxpdmVTeW5jRHVyYXRpb25Db3VudCIsImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCIsIkluZmluaXR5IiwibGl2ZVN5bmNEdXJhdGlvbiIsImxpdmVNYXhMYXRlbmN5RHVyYXRpb24iLCJsaXZlRHVyYXRpb25JbmZpbml0eSIsImxpdmVCYWNrQnVmZmVyTGVuZ3RoIiwibWF4TWF4QnVmZmVyTGVuZ3RoIiwiZW5hYmxlV29ya2VyIiwiZW5hYmxlU29mdHdhcmVBRVMiLCJtYW5pZmVzdExvYWRpbmdUaW1lT3V0IiwibWFuaWZlc3RMb2FkaW5nTWF4UmV0cnkiLCJtYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5IiwibWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0Iiwic3RhcnRMZXZlbCIsImxldmVsTG9hZGluZ1RpbWVPdXQiLCJsZXZlbExvYWRpbmdNYXhSZXRyeSIsImxldmVsTG9hZGluZ1JldHJ5RGVsYXkiLCJsZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQiLCJmcmFnTG9hZGluZ1RpbWVPdXQiLCJmcmFnTG9hZGluZ01heFJldHJ5IiwiZnJhZ0xvYWRpbmdSZXRyeURlbGF5IiwiZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQiLCJzdGFydEZyYWdQcmVmZXRjaCIsImZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kIiwiZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQiLCJhcHBlbmRFcnJvck1heFJldHJ5IiwibG9hZGVyIiwiWGhyTG9hZGVyIiwiZkxvYWRlciIsInBMb2FkZXIiLCJ4aHJTZXR1cCIsImxpY2Vuc2VYaHJTZXR1cCIsImFickNvbnRyb2xsZXIiLCJBYnJDb250cm9sbGVyIiwiYnVmZmVyQ29udHJvbGxlciIsIkJ1ZmZlckNvbnRyb2xsZXIiLCJjYXBMZXZlbENvbnRyb2xsZXIiLCJDYXBMZXZlbENvbnRyb2xsZXIiLCJmcHNDb250cm9sbGVyIiwiRlBTQ29udHJvbGxlciIsInN0cmV0Y2hTaG9ydFZpZGVvVHJhY2siLCJtYXhBdWRpb0ZyYW1lc0RyaWZ0IiwiZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eSIsImFickV3bWFGYXN0TGl2ZSIsImFickV3bWFTbG93TGl2ZSIsImFickV3bWFGYXN0Vm9EIiwiYWJyRXdtYVNsb3dWb0QiLCJhYnJFd21hRGVmYXVsdEVzdGltYXRlIiwiYWJyQmFuZFdpZHRoRmFjdG9yIiwiYWJyQmFuZFdpZHRoVXBGYWN0b3IiLCJhYnJNYXhXaXRoUmVhbEJpdHJhdGUiLCJtYXhTdGFydmF0aW9uRGVsYXkiLCJtYXhMb2FkaW5nRGVsYXkiLCJtaW5BdXRvQml0cmF0ZSIsImVtZUVuYWJsZWQiLCJ3aWRldmluZUxpY2Vuc2VVcmwiLCJyZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jIiwicmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIiwic3VidGl0bGVTdHJlYW1Db250cm9sbGVyIiwiU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIiwic3VidGl0bGVUcmFja0NvbnRyb2xsZXIiLCJTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciIsInRpbWVsaW5lQ29udHJvbGxlciIsIlRpbWVsaW5lQ29udHJvbGxlciIsImN1ZUhhbmRsZXIiLCJlbmFibGVDRUE3MDhDYXB0aW9ucyIsImVuYWJsZVdlYlZUVCIsImNhcHRpb25zVGV4dFRyYWNrMUxhYmVsIiwiY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlIiwiY2FwdGlvbnNUZXh0VHJhY2syTGFiZWwiLCJjYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGUiLCJhdWRpb1N0cmVhbUNvbnRyb2xsZXIiLCJBdWRpb1N0cmVhbUNvbnRyb2xsZXIiLCJhdWRpb1RyYWNrQ29udHJvbGxlciIsIkF1ZGlvVHJhY2tDb250cm9sbGVyIiwiZW1lQ29udHJvbGxlciIsIkVNRUNvbnRyb2xsZXIiLCJ3aW5kb3ciLCJwZXJmb3JtYW5jZSIsImhscyIsIkV2ZW50IiwiRlJBR19MT0FESU5HIiwiRlJBR19MT0FERUQiLCJGUkFHX0JVRkZFUkVEIiwiRVJST1IiLCJsYXN0TG9hZGVkRnJhZ0xldmVsIiwiX25leHRBdXRvTGV2ZWwiLCJ0aW1lciIsIl9id0VzdGltYXRvciIsIm9uQ2hlY2siLCJfYWJhbmRvblJ1bGVzQ2hlY2siLCJiaW5kIiwiY2xlYXJUaW1lciIsIkV2ZW50SGFuZGxlciIsInByb3RvdHlwZSIsImRlc3Ryb3kiLCJjYWxsIiwiZGF0YSIsImZyYWciLCJ0eXBlIiwiZnJhZ0N1cnJlbnQiLCJzZXRJbnRlcnZhbCIsImNvbmZpZyIsImxldmVsIiwibGV2ZWxzIiwiaXNMaXZlIiwiZGV0YWlscyIsImxpdmUiLCJld21hRmFzdCIsImV3bWFTbG93IiwiRXdtYUJhbmRXaWR0aEVzdGltYXRvciIsInZpZGVvIiwibWVkaWEiLCJtaW5BdXRvTGV2ZWwiLCJzdGF0cyIsImFib3J0ZWQiLCJsb2dnZXIiLCJ3YXJuIiwicGF1c2VkIiwicGxheWJhY2tSYXRlIiwicmVhZHlTdGF0ZSIsImF1dG9MZXZlbCIsInJlcXVlc3REZWxheSIsIm5vdyIsInRyZXF1ZXN0IiwiTWF0aCIsImFicyIsImR1cmF0aW9uIiwibG9hZFJhdGUiLCJtYXgiLCJidyIsImxvYWRlZCIsImxldmVsQml0cmF0ZSIsInJlYWxCaXRyYXRlIiwiYml0cmF0ZSIsImV4cGVjdGVkTGVuIiwidG90YWwiLCJyb3VuZCIsInBvcyIsImN1cnJlbnRUaW1lIiwiZnJhZ0xvYWRlZERlbGF5IiwiYnVmZmVyU3RhcnZhdGlvbkRlbGF5IiwiQnVmZmVySGVscGVyIiwiYnVmZmVySW5mbyIsImVuZCIsImZyYWdMZXZlbE5leHRMb2FkZWREZWxheSIsIm5leHRMb2FkTGV2ZWwiLCJsZXZlbE5leHRCaXRyYXRlIiwidG9GaXhlZCIsInNhbXBsZSIsImFib3J0IiwidHJpZ2dlciIsIkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCIsIk51bWJlciIsImlzRmluaXRlIiwic24iLCJsb2FkZWRCeXRlcyIsImJ5dGVzIiwibG9hZGVkRHVyYXRpb24iLCJiaXRyYXRlVGVzdCIsInRwYXJzZWQiLCJ0YnVmZmVyZWQiLCJ0bG9hZCIsIm9uRnJhZ0J1ZmZlcmVkIiwiZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMiLCJsb2ciLCJ0Zmlyc3QiLCJid0VzdGltYXRlIiwiZ2V0RXN0aW1hdGUiLCJiaXRyYXRlVGVzdERlbGF5IiwiRXJyb3JEZXRhaWxzIiwiRlJBR19MT0FEX0VSUk9SIiwiRlJBR19MT0FEX1RJTUVPVVQiLCJjbGVhckludGVydmFsIiwiY3VycmVudExldmVsIiwiY3VycmVudEZyYWdEdXJhdGlvbiIsImN1cnJlbnRCdyIsIm1heEF1dG9MZXZlbCIsIm1heEZldGNoRHVyYXRpb24iLCJid0ZhY3RvciIsImJ3VXBGYWN0b3IiLCJpIiwibGV2ZWxJbmZvIiwibGV2ZWxEZXRhaWxzIiwiYXZnRHVyYXRpb24iLCJ0b3RhbGR1cmF0aW9uIiwiZnJhZ21lbnRzIiwibGVuZ3RoIiwiYWRqdXN0ZWRidyIsImZldGNoRHVyYXRpb24iLCJ0cmFjZSIsImZvcmNlZEF1dG9MZXZlbCIsImJ3RXN0aW1hdG9yIiwiY2FuRXN0aW1hdGUiLCJuZXh0QUJSQXV0b0xldmVsIiwiX25leHRBQlJBdXRvTGV2ZWwiLCJtaW4iLCJuZXh0TGV2ZWwiLCJhdmdidyIsImJlc3RMZXZlbCIsIl9maW5kQmVzdExldmVsIiwiTGV2ZWxIZWxwZXIiLCJUSUNLX0lOVEVSVkFMIiwiZnJhZ21lbnRUcmFja2VyIiwiTUVESUFfQVRUQUNIRUQiLCJNRURJQV9ERVRBQ0hJTkciLCJBVURJT19UUkFDS1NfVVBEQVRFRCIsIkFVRElPX1RSQUNLX1NXSVRDSElORyIsIkFVRElPX1RSQUNLX0xPQURFRCIsIktFWV9MT0FERUQiLCJGUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UIiwiRlJBR19QQVJTSU5HX0RBVEEiLCJGUkFHX1BBUlNFRCIsIkJVRkZFUl9SRVNFVCIsIkJVRkZFUl9DUkVBVEVEIiwiQlVGRkVSX0FQUEVOREVEIiwiQlVGRkVSX0ZMVVNIRUQiLCJJTklUX1BUU19GT1VORCIsImF1ZGlvQ29kZWNTd2FwIiwiX3N0YXRlIiwiU3RhdGUiLCJTVE9QUEVEIiwiaW5pdFBUUyIsIndhaXRpbmdGcmFnbWVudCIsInZpZGVvVHJhY2tDQyIsImRlbXV4ZXJJZCIsImlkIiwiY2MiLCJzdGF0ZSIsIldBSVRJTkdfSU5JVF9QVFMiLCJ0aWNrIiwidHJhY2tzIiwibGFzdEN1cnJlbnRUaW1lIiwic3RvcExvYWQiLCJmcmFnTG9hZEVycm9yIiwiSURMRSIsIlNUQVJUSU5HIiwibmV4dExvYWRQb3NpdGlvbiIsInRyYWNrIiwidHJhY2tEZXRhaWxzIiwiUEFVU0VEIiwiQlVGRkVSX0ZMVVNISU5HIiwiV0FJVElOR19UUkFDSyIsImxvYWRlZG1ldGFkYXRhIiwic3RhcnRGcmFnUmVxdWVzdGVkIiwibWVkaWFCdWZmZXIiLCJ2aWRlb0J1ZmZlciIsIm1haW5CdWZmZXJJbmZvIiwiYnVmZmVyTGVuIiwibGVuIiwiYnVmZmVyRW5kIiwiZnJhZ1ByZXZpb3VzIiwibWF4Q29uZmlnQnVmZmVyIiwibWF4QnVmTGVuIiwiYXVkaW9Td2l0Y2giLCJ0cmFja0lkIiwiX3N0cmVhbUVuZGVkIiwiQlVGRkVSX0VPUyIsIkVOREVEIiwiZnJhZ0xlbiIsInN0YXJ0IiwiUFRTS25vd24iLCJuZXh0U3RhcnQiLCJpbml0U2VnbWVudCIsImxvYWRJZHgiLCJmcmFnTG9hZElkeCIsIm5leHRCdWZmZXJlZCIsImZvdW5kRnJhZyIsImZyYWdOZXh0IiwiZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0IiwiY2FuZGlkYXRlIiwiY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlIiwiQmluYXJ5U2VhcmNoIiwic2VhcmNoIiwiZW5kU04iLCJzdGFydFNOIiwiZW5jcnlwdGVkIiwiS0VZX0xPQURJTkciLCJnZXRTdGF0ZSIsIkZyYWdtZW50U3RhdGUiLCJOT1RfTE9BREVEIiwiRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkiLCJyZXRyeURhdGUiLCJpc1NlZWtpbmciLCJzZWVraW5nIiwid2FpdGluZ0ZyYWciLCJ3YWl0aW5nRnJhZ0NDIiwib25GcmFnTG9hZGVkIiwiUEFSU0lORyIsIlBBUlNFRCIsIm9udnNlZWtpbmciLCJvbk1lZGlhU2Vla2luZyIsIm9udmVuZGVkIiwib25NZWRpYUVuZGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsInN0YXJ0TG9hZCIsImVuZGVkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9udnNlZWtlZCIsImF1ZGlvVHJhY2tzIiwiYWx0QXVkaW8iLCJ1cmwiLCJkZW11eGVyIiwibmV3RGV0YWlscyIsInNsaWRpbmciLCJjdXJEZXRhaWxzIiwibWVyZ2VEZXRhaWxzIiwic3RhcnRUaW1lT2Zmc2V0IiwiZnJhZ0xvYWRlZCIsImF1ZGlvQ29kZWMiLCJwYXlsb2FkIiwiYXBwZW5kZWQiLCJEZW11eGVyIiwiaW5pdFNlZ21lbnREYXRhIiwicGVuZGluZ0J1ZmZlcmluZyIsImFjY3VyYXRlVGltZU9mZnNldCIsInB1c2giLCJmcmFnTmV3IiwiYXVkaW8iLCJsZXZlbENvZGVjIiwiY29kZWMiLCJCVUZGRVJfQ09ERUNTIiwiY29udGFpbmVyIiwiYXBwZW5kT2JqIiwicGFyZW50IiwiY29udGVudCIsInBlbmRpbmdEYXRhIiwiQlVGRkVSX0FQUEVORElORyIsImVuZFBUUyIsInN0YXJ0UFRTIiwiZW5kRFRTIiwic3RhcnREVFMiLCJhZGRFbGVtZW50YXJ5U3RyZWFtIiwiRnJhZ21lbnQiLCJFbGVtZW50YXJ5U3RyZWFtVHlwZXMiLCJBVURJTyIsIm5iIiwidXBkYXRlRnJhZ1BUU0RUUyIsImFwcGVuZE9uQnVmZmVyRmx1c2giLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsIlBPU0lUSVZFX0lORklOSVRZIiwiQVVESU9fVFJBQ0tfU1dJVENIRUQiLCJFcnJvclR5cGVzIiwiTUVESUFfRVJST1IiLCJmYXRhbCIsImRhdGExIiwiZGF0YTIiLCJmb3JFYWNoIiwiYnVmZmVyIiwiX2NoZWNrQXBwZW5kZWRQYXJzZWQiLCJhdWRpb1RyYWNrIiwicGVuZGluZyIsIlRpbWVSYW5nZXMiLCJ0b1N0cmluZyIsImJ1ZmZlcmVkIiwibG9hZEVycm9yIiwiZGVsYXkiLCJwb3ciLCJlcnJvciIsIkFVRElPX1RSQUNLX0xPQURfRVJST1IiLCJBVURJT19UUkFDS19MT0FEX1RJTUVPVVQiLCJLRVlfTE9BRF9FUlJPUiIsIktFWV9MT0FEX1RJTUVPVVQiLCJCVUZGRVJfRlVMTF9FUlJPUiIsIm1lZGlhQnVmZmVyZWQiLCJpc0J1ZmZlcmVkIiwibmV4dFN0YXRlIiwicHJldmlvdXNTdGF0ZSIsIkJhc2VTdHJlYW1Db250cm9sbGVyIiwiTUFOSUZFU1RfTE9BRElORyIsIk1BTklGRVNUX1BBUlNFRCIsIkxFVkVMX0xPQURFRCIsIl90cmFja0lkIiwiX3NlbGVjdERlZmF1bHRUcmFjayIsInRyYWNrSWRCbGFja2xpc3QiLCJPYmplY3QiLCJjcmVhdGUiLCJhdWRpb0dyb3VwSWQiLCJoYXNJbnRlcnZhbCIsInVwZGF0ZVBlcmlvZE1zIiwidGFyZ2V0ZHVyYXRpb24iLCJncm91cElkIiwiYXVkaW9Hcm91cElkcyIsInVybElkIiwiX3NlbGVjdEluaXRpYWxBdWRpb1RyYWNrIiwiTkVUV09SS19FUlJPUiIsImNvbnRleHQiLCJfaGFuZGxlTG9hZEVycm9yIiwibmV3SWQiLCJfbG9hZFRyYWNrRGV0YWlsc0lmTmVlZGVkIiwiX3VwZGF0ZVRyYWNrIiwiY3VycmVudEF1ZGlvVHJhY2siLCJuYW1lIiwiZGVmYXVsdFRyYWNrcyIsImZpbHRlciIsImRlZmF1bHQiLCJ0cmFja0ZvdW5kIiwidHJhdmVyc2VUcmFja3MiLCJfc2V0QXVkaW9UcmFjayIsIl9uZWVkc1RyYWNrTG9hZGluZyIsIkFVRElPX1RSQUNLX0xPQURJTkciLCJwcmV2aW91c0lkIiwibGFuZ3VhZ2UiLCJuZXdUcmFjayIsIlRhc2tMb29wIiwiV0FJVElOR19MRVZFTCIsInJlbW92ZUZyYWdtZW50IiwiY2xlYXJOZXh0VGljayIsImJhY2t0cmFja2VkIiwiZnJhZ1N0YXRlIiwiUEFSVElBTCIsIk9LIiwidG9sZXJhbmNlIiwiZnJhZ1N0YXJ0T2Zmc2V0IiwiZnJhZ0VuZE9mZnNldCIsIk1lZGlhU291cmNlIiwiTUVESUFfQVRUQUNISU5HIiwiTEVWRUxfUFRTX1VQREFURUQiLCJMRVZFTF9VUERBVEVEIiwiX21zRHVyYXRpb24iLCJfbGV2ZWxEdXJhdGlvbiIsIl9sZXZlbFRhcmdldER1cmF0aW9uIiwiX2xpdmUiLCJfb2JqZWN0VXJsIiwiYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCIsIm9uc2J1ZSIsIm9uU0JVcGRhdGVFbmQiLCJvbnNiZSIsIm9uU0JVcGRhdGVFcnJvciIsInBlbmRpbmdUcmFja3MiLCJhdWRpb0J1ZmZlciIsInNvdXJjZUJ1ZmZlciIsImRlbHRhIiwidGltZXN0YW1wT2Zmc2V0IiwidXBkYXRpbmciLCJlcnIiLCJhdWRpb1RpbWVzdGFtcE9mZnNldCIsIm1zIiwibWVkaWFTb3VyY2UiLCJvbm1zbyIsIm9uTWVkaWFTb3VyY2VPcGVuIiwib25tc2UiLCJvbk1lZGlhU291cmNlRW5kZWQiLCJvbm1zYyIsIm9uTWVkaWFTb3VyY2VDbG9zZSIsInNyYyIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImVuZE9mU3RyZWFtIiwibWVzc2FnZSIsInJldm9rZU9iamVjdFVSTCIsInJlbW92ZUF0dHJpYnV0ZSIsImxvYWQiLCJmbHVzaFJhbmdlIiwic2VnbWVudHMiLCJNRURJQV9ERVRBQ0hFRCIsImNoZWNrUGVuZGluZ1RyYWNrcyIsInBlbmRpbmdUcmFja3NDb3VudCIsImtleXMiLCJjcmVhdGVTb3VyY2VCdWZmZXJzIiwiZG9BcHBlbmRpbmciLCJfbmVlZHNGbHVzaCIsImRvRmx1c2giLCJfbmVlZHNFb3MiLCJjaGVja0VvcyIsImFwcGVuZGluZyIsInJlZHVjZSIsImNvdW50ZXIiLCJzZWdtZW50IiwidGltZVJhbmdlcyIsInN0cmVhbVR5cGUiLCJfcGF1c2VkIiwic3RhcnRUaW1lIiwicGxheSIsImVuZFRpbWUiLCJ1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbiIsImZsdXNoTGl2ZUJhY2tCdWZmZXIiLCJldmVudCIsIkJVRkZFUl9BUFBFTkRJTkdfRVJST1IiLCJzYiIsInJlbW92ZVNvdXJjZUJ1ZmZlciIsInRyYWNrTmFtZSIsIm1pbWVUeXBlIiwiYWRkU291cmNlQnVmZmVyIiwiY29kZSIsIkJVRkZFUl9BRERfQ09ERUNfRVJST1IiLCJkYXRhVHlwZSIsInNib2JqIiwiZSIsImZsdXNoQnVmZmVyQ291bnRlciIsImJ1ZmZlclR5cGVzIiwidGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uIiwiaW5kZXgiLCJidWZmZXJUeXBlIiwicmVtb3ZlQnVmZmVyUmFuZ2UiLCJhdmVyYWdldGFyZ2V0ZHVyYXRpb24iLCJyYW5nZSIsImZsdXNoQnVmZmVyIiwic2hpZnQiLCJjb25zb2xlIiwiYXBwZW5kQnVmZmVyIiwiYXBwZW5kRXJyb3IiLCJ1bnNoaWZ0IiwiQlVGRkVSX0FQUEVORF9FUlJPUiIsInR5cGVJbiIsImJ1ZlN0YXJ0IiwiYnVmRW5kIiwicmVtb3ZlU3RhcnQiLCJyZW1vdmVFbmQiLCJyZW1vdmUiLCJGUFNfRFJPUF9MRVZFTF9DQVBQSU5HIiwiYXV0b0xldmVsQ2FwcGluZyIsImZpcnN0TGV2ZWwiLCJyZXN0cmljdGVkTGV2ZWxzIiwiX3N0b3BDYXBwaW5nIiwiaXNMZXZlbEFsbG93ZWQiLCJkcm9wcGVkTGV2ZWwiLCJIVE1MVmlkZW9FbGVtZW50IiwiX3N0YXJ0Q2FwcGluZyIsImxldmVsc0xlbmd0aCIsImdldE1heExldmVsIiwic3RyZWFtQ29udHJvbGxlciIsIm5leHRMZXZlbFN3aXRjaCIsImNhcExldmVsSW5kZXgiLCJ2YWxpZExldmVscyIsImdldE1heExldmVsQnlNZWRpYVNpemUiLCJtZWRpYVdpZHRoIiwibWVkaWFIZWlnaHQiLCJkZXRlY3RQbGF5ZXJTaXplIiwid2lkdGgiLCJjbGllbnRXaWR0aCIsIm9mZnNldFdpZHRoIiwiY29udGVudFNjYWxlRmFjdG9yIiwiaGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwiaW5kZXhPZiIsImF0R3JlYXRlc3RCYW5kaXdkdGgiLCJjdXJMZXZlbCIsIm1heExldmVsSW5kZXgiLCJwaXhlbFJhdGlvIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIlhNTEh0dHBSZXF1ZXN0IiwiTUFYX0xJQ0VOU0VfUkVRVUVTVF9GQUlMVVJFUyIsIktleVN5c3RlbXMiLCJXSURFVklORSIsIlBMQVlSRUFEWSIsImNyZWF0ZVdpZGV2aW5lTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyIsImF1ZGlvQ29kZWNzIiwidmlkZW9Db2RlY3MiLCJkcm1TeXN0ZW1PcHRpb25zIiwiYmFzZUNvbmZpZyIsInZpZGVvQ2FwYWJpbGl0aWVzIiwiY29udGVudFR5cGUiLCJnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zIiwia2V5U3lzdGVtIiwiRXJyb3IiLCJfd2lkZXZpbmVMaWNlbnNlVXJsIiwiX2xpY2Vuc2VYaHJTZXR1cCIsIl9lbWVFbmFibGVkIiwiX3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyIsIl9tZWRpYUtleXNMaXN0IiwiX21lZGlhIiwiX2hhc1NldE1lZGlhS2V5cyIsIl9pc01lZGlhRW5jcnlwdGVkIiwiX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50IiwiS0VZX1NZU1RFTV9FUlJPUiIsIktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCIsIm1lZGlhS2V5U3lzdGVtQ29uZmlncyIsInRoZW4iLCJtZWRpYUtleVN5c3RlbUFjY2VzcyIsIl9vbk1lZGlhS2V5U3lzdGVtQWNjZXNzT2J0YWluZWQiLCJjYXRjaCIsIm1lZGlhS2V5c0xpc3RJdGVtIiwibWVkaWFLZXlzIiwibWVkaWFLZXlzU2Vzc2lvbiIsIm1lZGlhS2V5c1Nlc3Npb25Jbml0aWFsaXplZCIsIm1lZGlhS2V5U3lzdGVtRG9tYWluIiwiY3JlYXRlTWVkaWFLZXlzIiwiX29uTWVkaWFLZXlzQ3JlYXRlZCIsImNyZWF0ZVNlc3Npb24iLCJfb25OZXdNZWRpYUtleVNlc3Npb24iLCJrZXlTZXNzaW9uIiwic2Vzc2lvbklkIiwiX29uS2V5U2Vzc2lvbk1lc3NhZ2UiLCJfcmVxdWVzdExpY2Vuc2UiLCJ1cGRhdGUiLCJpbml0RGF0YVR5cGUiLCJpbml0RGF0YSIsIl9tZWRpYUVuY3J5cHRpb25Jbml0RGF0YVR5cGUiLCJfbWVkaWFFbmNyeXB0aW9uSW5pdERhdGEiLCJfYXR0ZW1wdFNldE1lZGlhS2V5cyIsIl9nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbiIsImtleXNMaXN0SXRlbSIsIktFWV9TWVNURU1fTk9fS0VZUyIsInNldE1lZGlhS2V5cyIsIktFWV9TWVNURU1fTk9fQUNDRVNTIiwiS0VZX1NZU1RFTV9OT19TRVNTSU9OIiwiZ2VuZXJhdGVSZXF1ZXN0Iiwia2V5TWVzc2FnZSIsImNhbGxiYWNrIiwieGhyIiwib3BlbiIsInJlc3BvbnNlVHlwZSIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsIl9vbkxpY2Vuc2VSZXF1ZXN0UmVhZHlTdGFnZUNoYW5nZSIsInN0YXR1cyIsInJlc3BvbnNlIiwic3RhdHVzVGV4dCIsImF0dGVtcHRzTGVmdCIsImNoYWxsZW5nZSIsImdldExpY2Vuc2VTZXJ2ZXJVcmwiLCJfY3JlYXRlTGljZW5zZVhociIsInNlbmQiLCJfZ2VuZXJhdGVMaWNlbnNlUmVxdWVzdENoYWxsZW5nZSIsIl9vbk1lZGlhRW5jcnlwdGVkIiwibWFwIiwidmlkZW9Db2RlYyIsIl9hdHRlbXB0S2V5U3lzdGVtQWNjZXNzIiwiaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSIsImdldFZpZGVvUGxheWJhY2tRdWFsaXR5IiwiY2hlY2tGUFNJbnRlcnZhbCIsImRlY29kZWRGcmFtZXMiLCJkcm9wcGVkRnJhbWVzIiwibGFzdFRpbWUiLCJjdXJyZW50UGVyaW9kIiwiY3VycmVudERyb3BwZWQiLCJsYXN0RHJvcHBlZEZyYW1lcyIsImN1cnJlbnREZWNvZGVkIiwibGFzdERlY29kZWRGcmFtZXMiLCJkcm9wcGVkRlBTIiwiRlBTX0RST1AiLCJ0b3RhbERyb3BwZWRGcmFtZXMiLCJ2aWRlb1BsYXliYWNrUXVhbGl0eSIsImNoZWNrRlBTIiwidG90YWxWaWRlb0ZyYW1lcyIsImRyb3BwZWRWaWRlb0ZyYW1lcyIsIndlYmtpdERlY29kZWRGcmFtZUNvdW50Iiwid2Via2l0RHJvcHBlZEZyYW1lQ291bnQiLCJmaW5kRnJhZ21lbnRCeVBEVCIsImZpbmRGcmFnbWVudEJ5UFRTIiwicGR0V2l0aGluVG9sZXJhbmNlVGVzdCIsIlBEVFZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwicHJvZ3JhbURhdGVUaW1lIiwiZW5kUHJvZ3JhbURhdGVUaW1lIiwic2VnIiwiZGVsdGFQVFMiLCJwZHRCdWZmZXJFbmQiLCJBUFBFTkRJTkciLCJGcmFnbWVudFRyYWNrZXIiLCJidWZmZXJQYWRkaW5nIiwicG9zaXRpb24iLCJsZXZlbFR5cGUiLCJidWZmZXJlZEZyYWdzIiwiZnJhZ21lbnRFbnRpdHkiLCJrZXkiLCJib2R5IiwiYnVmZmVyZWRGcmFnS2V5IiwicG9wIiwiZWxlbWVudGFyeVN0cmVhbSIsInRpbWVSYW5nZSIsImZyYWdtZW50VGltZXMiLCJ0aW1lIiwiZXNEYXRhIiwiaXNUaW1lQnVmZmVyZWQiLCJmcmFnbWVudCIsImZyYWdLZXkiLCJnZXRGcmFnbWVudEtleSIsImhhc0VsZW1lbnRhcnlTdHJlYW0iLCJnZXRCdWZmZXJlZFRpbWVzIiwiZnJhZ21lbnRQYXJ0aWFsIiwicGFydGlhbCIsInRpbWVQYWRkaW5nIiwiYmVzdEZyYWdtZW50IiwiYmVzdE92ZXJsYXAiLCJpc1BhcnRpYWwiLCJkZXRlY3RFdmljdGVkRnJhZ21lbnRzIiwiZGV0ZWN0UGFydGlhbEZyYWdtZW50cyIsInN0YWxsRGVib3VuY2VJbnRlcnZhbCIsImp1bXBUaHJlc2hvbGQiLCJHYXBDb250cm9sbGVyIiwic3RhbGxSZXBvcnRlZCIsInRub3ciLCJzdGFsbGVkIiwibnVkZ2VSZXRyeSIsInN0YWxsZWREdXJhdGlvbiIsIl9yZXBvcnRTdGFsbCIsIl90cnlGaXhCdWZmZXJTdGFsbCIsImdldFBhcnRpYWxGcmFnbWVudCIsIl90cnlTa2lwQnVmZmVySG9sZSIsIl90cnlOdWRnZUJ1ZmZlciIsIkJVRkZFUl9TVEFMTEVEX0VSUk9SIiwibGFzdEVuZFRpbWUiLCJCVUZGRVJfU0VFS19PVkVSX0hPTEUiLCJyZWFzb24iLCJ0YXJnZXRUaW1lIiwiQlVGRkVSX05VREdFX09OX1NUQUxMIiwiSUQzVHJhY2tDb250cm9sbGVyIiwiRlJBR19QQVJTSU5HX01FVEFEQVRBIiwiaWQzVHJhY2siLCJ0ZXh0VHJhY2tzIiwidGV4dFRyYWNrIiwia2luZCIsImxhYmVsIiwiYWRkVGV4dFRyYWNrIiwic2FtcGxlcyIsImdldElEM1RyYWNrIiwibW9kZSIsIkN1ZSIsIldlYktpdERhdGFDdWUiLCJWVFRDdWUiLCJUZXh0VHJhY2tDdWUiLCJmcmFtZXMiLCJJRDMiLCJnZXRJRDNGcmFtZXMiLCJwdHMiLCJqIiwiZnJhbWUiLCJpc1RpbWVTdGFtcEZyYW1lIiwiY3VlIiwidmFsdWUiLCJhZGRDdWUiLCJjaHJvbWVPckZpcmVmb3giLCJMZXZlbENvbnRyb2xsZXIiLCJNQU5JRkVTVF9MT0FERUQiLCJjYW5sb2FkIiwiY3VycmVudExldmVsSW5kZXgiLCJtYW51YWxMZXZlbEluZGV4IiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInRvTG93ZXJDYXNlIiwiY2xlYXJUaW1lb3V0IiwiX2xldmVscyIsImxldmVsUmV0cnlDb3VudCIsImxvYWRMZXZlbCIsImJpdHJhdGVTdGFydCIsImxldmVsU2V0IiwibGV2ZWxGcm9tU2V0IiwidmlkZW9Db2RlY0ZvdW5kIiwiYXVkaW9Db2RlY0ZvdW5kIiwiYXR0cmlidXRlcyIsImF0dHJzIiwiZnJhZ21lbnRFcnJvciIsIlNVQlRJVExFUyIsInNvcnQiLCJhIiwiYiIsIl9maXJzdExldmVsIiwic29tZSIsInQiLCJNQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SIiwibmV3TGV2ZWwiLCJsZXZlbFByb3BlcnRpZXMiLCJMRVZFTF9TV0lUQ0hJTkciLCJMRVZFTF9MT0FESU5HIiwiT1RIRVJfRVJST1IiLCJMRVZFTF9TV0lUQ0hfRVJST1IiLCJsZXZlbEVycm9yIiwibGV2ZWxJbmRleCIsIkxFVkVMX0xPQURfRVJST1IiLCJMRVZFTF9MT0FEX1RJTUVPVVQiLCJSRU1VWF9BTExPQ19FUlJPUiIsInJlY292ZXJMZXZlbCIsImVycm9yRXZlbnQiLCJlcnJvckRldGFpbHMiLCJyZWR1bmRhbnRMZXZlbHMiLCJzZXRUaW1lb3V0IiwibGV2ZWxSZXRyeSIsIm5leHRBdXRvTGV2ZWwiLCJyZWxvYWRJbnRlcnZhbCIsImxldmVsT2JqZWN0Iiwic2V0TGV2ZWxJbnRlcm5hbCIsIl9zdGFydExldmVsIiwiY29uZmlnU3RhcnRMZXZlbCIsImFkZEdyb3VwSWQiLCJ1cGRhdGVQVFMiLCJtZXJnZVN1YnRpdGxlUGxheWxpc3RzIiwibWFwRnJhZ21lbnRJbnRlcnNlY3Rpb24iLCJhZGp1c3RTbGlkaW5nIiwiY29tcHV0ZVJlbG9hZEludGVydmFsIiwidGV4dEdyb3VwSWRzIiwiZnJvbUlkeCIsInRvSWR4IiwiZnJhZ0Zyb20iLCJmcmFnVG8iLCJmcmFnVG9QVFMiLCJtYXhTdGFydFBUUyIsImRyaWZ0IiwiZnJhZ0lkeCIsIm9sZERldGFpbHMiLCJjY09mZnNldCIsIlBUU0ZyYWciLCJvbGRGcmFnIiwibmV3RnJhZyIsImRyb3BwZWQiLCJuZXdGcmFnbWVudHMiLCJvbGRQbGF5bGlzdCIsIm5ld1BsYXlsaXN0IiwicmVmZXJlbmNlU3RhcnQiLCJsYXN0SW5kZXgiLCJmcmFncyIsImludGVyc2VjdGlvbkZuIiwib2xkRnJhZ21lbnRzIiwiY3VycmVudFBsYXlsaXN0IiwibGFzdFJlcXVlc3RUaW1lIiwibWluUmVsb2FkSW50ZXJ2YWwiLCJTdHJlYW1Db250cm9sbGVyIiwiZ2FwQ29udHJvbGxlciIsImZvcmNlU3RhcnRMb2FkIiwiX2RvVGlja0lkbGUiLCJfY2hlY2tCdWZmZXIiLCJfY2hlY2tGcmFnbWVudENoYW5nZWQiLCJsZXZlbExhc3RMb2FkZWQiLCJfZmV0Y2hQYXlsb2FkT3JFb3MiLCJfZW5zdXJlRnJhZ21lbnRBdExpdmVQb2ludCIsIl9maW5kRnJhZ21lbnQiLCJfbG9hZEtleSIsIl9sb2FkRnJhZ21lbnQiLCJtYXhMYXRlbmN5IiwibGl2ZVN5bmNQb3NpdGlvbiIsImNvbXB1dGVMaXZlUG9zaXRpb24iLCJoYXNQcm9ncmFtRGF0ZVRpbWUiLCJ0YXJnZXRTTiIsImxvb2t1cFRvbGVyYW5jZSIsImN1clNOSWR4Iiwic2FtZUxldmVsIiwicHJldkZyYWciLCJuZXh0RnJhZyIsImF1dG9MZXZlbEVuYWJsZWQiLCJfcmVkdWNlTWF4QnVmZmVyTGVuZ3RoIiwiZ2V0QnVmZmVyZWRGcmFnIiwiUGxheWxpc3RMb2FkZXIiLCJMZXZlbFR5cGUiLCJNQUlOIiwiZnJhZ1BsYXlpbmdDdXJyZW50IiwiZnJhZ1BsYXlpbmciLCJGUkFHX0NIQU5HRUQiLCJmcmFnUGxheWluZ0xldmVsIiwiTEVWRUxfU1dJVENIRUQiLCJpbW1lZGlhdGVTd2l0Y2giLCJwcmV2aW91c2x5UGF1c2VkIiwicGF1c2UiLCJmbHVzaE1haW5CdWZmZXIiLCJmZXRjaGRlbGF5IiwibmV4dEJ1ZmZlcmVkRnJhZyIsIm5leHRMZXZlbElkIiwiZnJhZ0xhc3RLYnBzIiwiZm9sbG93aW5nQnVmZmVyZWRGcmFnIiwiZmx1c2hTY29wZSIsIm9uTWVkaWFTZWVrZWQiLCJyZW1vdmVBbGxGcmFnbWVudHMiLCJhYWMiLCJoZWFhYyIsImF1ZGlvQ29kZWNTd2l0Y2giLCJuZXdMZXZlbElkIiwibGFzdExldmVsIiwiX2dldEF1ZGlvQ29kZWMiLCJ1YSIsIm1ldGFkYXRhIiwiY2hhbm5lbENvdW50IiwiaGFzQXVkaW8iLCJoYXNWaWRlbyIsIlZJREVPIiwibWVkaWFUcmFjayIsImFsdGVybmF0ZSIsIm1pbkxlbmd0aCIsIl9zZWVrVG9TdGFydFBvcyIsImltbWVkaWF0ZUxldmVsU3dpdGNoRW5kIiwicG9sbCIsInRhcmdldExhdGVuY3kiLCJTVFJFQU1fU1RBVEVfVFJBTlNJVElPTiIsIl9saXZlU3luY1Bvc2l0aW9uIiwiU1VCVElUTEVfVFJBQ0tTX1VQREFURUQiLCJTVUJUSVRMRV9UUkFDS19TV0lUQ0giLCJTVUJUSVRMRV9UUkFDS19MT0FERUQiLCJTVUJUSVRMRV9GUkFHX1BST0NFU1NFRCIsInRyYWNrc0J1ZmZlcmVkIiwiY3VycmVudFRyYWNrSWQiLCJkZWNyeXB0ZXIiLCJEZWNyeXB0ZXIiLCJsYXN0QVZTdGFydCIsIl9vbk1lZGlhU2Vla2luZyIsInN1Y2Nlc3MiLCJmcmFnU3RhcnQiLCJmcmFnRW5kIiwic3VidGl0bGVUcmFja3MiLCJjdXJyZW50VHJhY2siLCJkZWNyeXB0RGF0YSIsImRlY3J5cHRkYXRhIiwiYnl0ZUxlbmd0aCIsIm1ldGhvZCIsImRlY3J5cHQiLCJpdiIsImRlY3J5cHRlZERhdGEiLCJGUkFHX0RFQ1JZUFRFRCIsInRzdGFydCIsInRkZWNyeXB0IiwiYnVmZmVyZWRJbmZvIiwiX2dldEJ1ZmZlcmVkIiwic3RvcHBlZCIsInN1YnRpdGxlRGlzcGxheSIsInF1ZXVlZERlZmF1bHRUcmFjayIsInN1YnRpdGxlVHJhY2siLCJ0cmFja0NoYW5nZUxpc3RlbmVyIiwiX29uVGV4dFRyYWNrc0NoYW5nZWQiLCJ1c2VUZXh0VHJhY2tQb2xsaW5nIiwic3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwiLCJzdWJ0aXRsZXMiLCJfY2xlYXJSZWxvYWRUaW1lciIsIl9sb2FkQ3VycmVudFRyYWNrIiwiU1VCVElUTEVfVFJBQ0tfTE9BRElORyIsImZpbHRlclN1YnRpdGxlVHJhY2tzIiwic2xpY2UiLCJvbGRUcmFjayIsIm5leHRUcmFjayIsInN1YnRpdGxlVHJhY2tJZCIsIl90b2dnbGVUcmFja01vZGVzIiwiX3NldFN1YnRpdGxlVHJhY2tJbnRlcm5hbCIsInRleHRUcmFja0xpc3QiLCJjYW5SZXVzZVZ0dFRleHRUcmFjayIsImluVXNlVHJhY2siLCJtYW5pZmVzdFRyYWNrIiwidGV4dFRyYWNrMSIsInRleHRUcmFjazIiLCJpbnRlcnNlY3Rpb24iLCJ4MSIsIngyIiwieTEiLCJ5MiIsIkZSQUdfUEFSU0lOR19VU0VSREFUQSIsImVuYWJsZWQiLCJ1bnBhcnNlZFZ0dEZyYWdzIiwiY3VlUmFuZ2VzIiwiY2FwdGlvbnNUcmFja3MiLCJjYXB0aW9uc1Byb3BlcnRpZXMiLCJsYW5ndWFnZUNvZGUiLCJjaGFubmVsMSIsIk91dHB1dEZpbHRlciIsImNoYW5uZWwyIiwiY2VhNjA4UGFyc2VyIiwiQ2VhNjA4UGFyc2VyIiwic2NyZWVuIiwicmFuZ2VzIiwibWVyZ2VkIiwiY3VlUmFuZ2UiLCJvdmVybGFwIiwibmV3Q3VlIiwiZXhpc3RpbmdUcmFjayIsImdldEV4aXN0aW5nVHJhY2siLCJjcmVhdGVUZXh0VHJhY2siLCJsYW5nIiwiX2NsZWFuVHJhY2tzIiwibGFzdFNuIiwicHJldkNDIiwidnR0Q0NzIiwicHJlc2VudGF0aW9uT2Zmc2V0IiwibmV3IiwiaW5Vc2VUcmFja3MiLCJjbG9zZWRDYXB0aW9ucyIsInJlc2V0IiwiX3BhcnNlVlRUcyIsIldlYlZUVFBhcnNlciIsInBhcnNlIiwiY3VlcyIsImdldEN1ZUJ5SWQiLCJ0ZXh0VHJhY2tDdWUiLCJ0ZXh0IiwiY2NkYXRhcyIsImV4dHJhY3RDZWE2MDhEYXRhIiwiYWRkRGF0YSIsImJ5dGVBcnJheSIsImNvdW50IiwidG1wQnl0ZSIsImNjYnl0ZTEiLCJjY2J5dGUyIiwiY2NWYWxpZCIsImNjVHlwZSIsImFjdHVhbENDQnl0ZXMiLCJBRVNDcnlwdG8iLCJzdWJ0bGUiLCJhZXNJViIsInJlbW92ZVBhZGRpbmciLCJvdXRwdXRCeXRlcyIsInBhZGRpbmdCeXRlcyIsIkRhdGFWaWV3IiwiZ2V0VWludDgiLCJBRVNEZWNyeXB0b3IiLCJyY29uIiwic3ViTWl4IiwiVWludDMyQXJyYXkiLCJpbnZTdWJNaXgiLCJzQm94IiwiaW52U0JveCIsImluaXRUYWJsZSIsImFycmF5QnVmZmVyIiwidmlldyIsIm5ld0FycmF5IiwiZ2V0VWludDMyIiwic3ViTWl4MCIsInN1Yk1peDEiLCJzdWJNaXgyIiwic3ViTWl4MyIsImludlN1Yk1peDAiLCJpbnZTdWJNaXgxIiwiaW52U3ViTWl4MiIsImludlN1Yk1peDMiLCJkIiwieCIsInhpIiwic3giLCJ4NCIsIng4Iiwia2V5QnVmZmVyIiwidWludDhBcnJheVRvVWludDMyQXJyYXlfIiwic2FtZUtleSIsIm9mZnNldCIsImtleVNpemUiLCJrc1Jvd3MiLCJrc1JvdyIsImludktzUm93Iiwia2V5U2NoZWR1bGUiLCJpbnZLZXlTY2hlZHVsZSIsInNib3giLCJwcmV2Iiwid29yZCIsImlucHV0QXJyYXlCdWZmZXIiLCJyZW1vdmVQS0NTN1BhZGRpbmciLCJuUm91bmRzIiwiaW52U0JPWCIsImluaXRWZWN0b3IiLCJpbml0VmVjdG9yMCIsImluaXRWZWN0b3IxIiwiaW5pdFZlY3RvcjIiLCJpbml0VmVjdG9yMyIsImlucHV0SW50MzIiLCJJbnQzMkFycmF5Iiwib3V0cHV0SW50MzIiLCJ0MCIsInQxIiwidDIiLCJ0MyIsInMwIiwiczEiLCJzMiIsInMzIiwiaW5wdXRXb3JkczAiLCJpbnB1dFdvcmRzMSIsImlucHV0V29yZHMyIiwiaW5wdXRXb3JkczMiLCJzd2FwV29yZCIsIm5ldHdvcmtUb0hvc3RPcmRlclN3YXAiLCJnbG9iYWwiLCJvYnNlcnZlciIsImxvZ0VuYWJsZWQiLCJicm93c2VyQ3J5cHRvIiwiY3J5cHRvIiwid2Via2l0U3VidGxlIiwiZGlzYWJsZVdlYkNyeXB0byIsImRlY3J5cHRvciIsImV4cGFuZEtleSIsImZhc3RBZXNLZXkiLCJGYXN0QUVTS2V5IiwiYWVzS2V5Iiwib25XZWJDcnlwdG9FcnJvciIsInJlc3VsdCIsIkZSQUdfREVDUllQVF9FUlJPUiIsImltcG9ydEtleSIsIkFEVFMiLCJBQUNEZW11eGVyIiwicmVtdXhlciIsIl9hdWRpb1RyYWNrIiwic2VxdWVuY2VOdW1iZXIiLCJpc0FBQyIsIm1hbmlmZXN0Q29kZWMiLCJpbnB1dFRpbWVTY2FsZSIsInRpbWVPZmZzZXQiLCJjb250aWd1b3VzIiwiaWQzRGF0YSIsImdldElEM0RhdGEiLCJ0aW1lc3RhbXAiLCJnZXRUaW1lU3RhbXAiLCJmcmFtZUluZGV4Iiwic3RhbXAiLCJpZDNTYW1wbGVzIiwiZHRzIiwiaXNIZWFkZXIiLCJpbml0VHJhY2tDb25maWciLCJhcHBlbmRGcmFtZSIsInJlbXV4IiwicHJvYmUiLCJnZXRBdWRpb0NvbmZpZyIsImlzSGVhZGVyUGF0dGVybiIsImdldEhlYWRlckxlbmd0aCIsImdldEZ1bGxGcmFtZUxlbmd0aCIsImdldEZyYW1lRHVyYXRpb24iLCJwYXJzZUZyYW1lSGVhZGVyIiwiYWR0c09iamVjdFR5cGUiLCJhZHRzU2FtcGxlaW5nSW5kZXgiLCJhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXgiLCJhZHRzQ2hhbmVsQ29uZmlnIiwiYWR0c1NhbXBsZWluZ1JhdGVzIiwiRlJBR19QQVJTSU5HX0VSUk9SIiwic2FtcGxlcmF0ZSIsImhlYWRlckxlbmd0aCIsImZyYW1lTGVuZ3RoIiwibmV3T2Zmc2V0IiwiZnJhbWVEdXJhdGlvbiIsImhlYWRlciIsImFhY1NhbXBsZSIsInVuaXQiLCJzdWJhcnJheSIsIkRhdGUiLCJEZW11eGVySW5saW5lIiwidHlwZVN1cHBvcnRlZCIsInZlbmRvciIsImRpc2NvbnRpbnVpdHkiLCJ0cmFja1N3aXRjaCIsImRlZmF1bHRJbml0UFRTIiwicHVzaERlY3J5cHRlZCIsIlVpbnQ4QXJyYXkiLCJtdXhDb25maWciLCJkZW11eCIsIlRTRGVtdXhlciIsIk1QNFJlbXV4ZXIiLCJNUDREZW11eGVyIiwiUGFzc1Rocm91Z2hSZW11eGVyIiwiTVAzRGVtdXhlciIsIm11eCIsInJlc2V0SW5pdFNlZ21lbnQiLCJyZXNldFRpbWVTdGFtcCIsInNldERlY3J5cHREYXRhIiwiYXBwZW5kIiwiRGVtdXhlcldvcmtlciIsInNlbGYiLCJFdmVudEVtaXR0ZXIiLCJlbWl0Iiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJmb3J3YXJkTWVzc2FnZSIsImV2IiwicG9zdE1lc3NhZ2UiLCJjbWQiLCJKU09OIiwib24iLCJ0cmFuc2ZlcmFibGUiLCJ3b3JrIiwiT2JzZXJ2ZXIiLCJtcDQiLCJpc1R5cGVTdXBwb3J0ZWQiLCJtcGVnIiwibXAzIiwiV29ya2VyIiwidyIsInJlcXVpcmUiLCJvbndtc2ciLCJvbldvcmtlck1lc3NhZ2UiLCJvbmVycm9yIiwiSU5URVJOQUxfRVhDRVBUSU9OIiwiZmlsZW5hbWUiLCJsaW5lbm8iLCJzdHJpbmdpZnkiLCJvYmplY3RVUkwiLCJ0ZXJtaW5hdGUiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJsYXN0RnJhZyIsIm5leHRTTiIsIkFycmF5QnVmZmVyIiwiRXhwR29sb21iIiwiYnl0ZXNBdmFpbGFibGUiLCJiaXRzQXZhaWxhYmxlIiwid29ya2luZ0J5dGVzIiwiYXZhaWxhYmxlQnl0ZXMiLCJzZXQiLCJza2lwQnl0ZXMiLCJsb2FkV29yZCIsInNpemUiLCJiaXRzIiwidmFsdSIsInJlYWRCaXRzIiwibGVhZGluZ1plcm9Db3VudCIsInNraXBMWiIsInNraXBCaXRzIiwiY2x6IiwicmVhZFVFRyIsImxhc3RTY2FsZSIsIm5leHRTY2FsZSIsImRlbHRhU2NhbGUiLCJyZWFkRUciLCJmcmFtZUNyb3BMZWZ0T2Zmc2V0IiwiZnJhbWVDcm9wUmlnaHRPZmZzZXQiLCJmcmFtZUNyb3BUb3BPZmZzZXQiLCJmcmFtZUNyb3BCb3R0b21PZmZzZXQiLCJwcm9maWxlSWRjIiwicHJvZmlsZUNvbXBhdCIsImxldmVsSWRjIiwibnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlIiwicGljV2lkdGhJbk1ic01pbnVzMSIsInBpY0hlaWdodEluTWFwVW5pdHNNaW51czEiLCJmcmFtZU1ic09ubHlGbGFnIiwic2NhbGluZ0xpc3RDb3VudCIsInJlYWRVQnl0ZSIsInJlYWRCb29sZWFuIiwic2tpcEVHIiwic2tpcFVFRyIsInNraXBTY2FsaW5nTGlzdCIsImNocm9tYUZvcm1hdElkYyIsInBpY09yZGVyQ250VHlwZSIsImFzcGVjdFJhdGlvSWRjIiwiY2VpbCIsImZyb250IiwiX3JlYWRTaXplIiwiaXNGb290ZXIiLCJfcmVhZFRpbWVTdGFtcCIsImluZm8iLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJmcmFtZURhdGEiLCJfZ2V0RnJhbWVEYXRhIiwiX2RlY29kZUZyYW1lIiwiX2RlY29kZVByaXZGcmFtZSIsIl9kZWNvZGVUZXh0RnJhbWUiLCJfZGVjb2RlVVJMRnJhbWUiLCJ0aW1lU3RhbXBGcmFtZSIsInB0czMzQml0Iiwib3duZXIiLCJfdXRmOEFycmF5VG9TdHIiLCJwcml2YXRlRGF0YSIsImRlc2NyaXB0aW9uIiwiYXJyYXkiLCJleGl0T25OdWxsIiwiYyIsImNoYXIyIiwiY2hhcjMiLCJvdXQiLCJ1dGY4QXJyYXlUb1N0ciIsIk1wZWdBdWRpbyIsIlVJTlQzMl9NQVgiLCJwYXJzZUluaXRTZWdtZW50IiwiYXVkaW92aWRlbyIsImdldFN0YXJ0RFRTIiwib2Zmc2V0U3RhcnREVFMiLCJmaW5kQm94IiwiYXBwbHkiLCJ2YWwiLCJwYXRoIiwicmVzdWx0cyIsInN1YnJlc3VsdHMiLCJlbmRib3giLCJyZWFkVWludDMyIiwiYmluMnN0ciIsImNvbmNhdCIsIm1vb3YiLCJtb292RW5kT2Zmc2V0Iiwic2lkeCIsInJlZmVyZW5jZXMiLCJ2ZXJzaW9uIiwidGltZXNjYWxlIiwiZWFybGllc3RQcmVzZW50YXRpb25UaW1lIiwiZmlyc3RPZmZzZXQiLCJzdGFydEJ5dGUiLCJyZWZlcmVuY2VzQ291bnQiLCJyZWFkVWludDE2IiwicmVmZXJlbmNlSW5kZXgiLCJyZWZlcmVuY2VJbmZvIiwicmVmZXJlbmNlU2l6ZSIsInJlZmVyZW5jZVR5cGUiLCJzdWJzZWdtZW50RHVyYXRpb24iLCJ0cmFrcyIsInRraGQiLCJ0cmFrIiwibWRoZCIsImhkbHIiLCJoZGxyVHlwZSIsImNvZGVjQm94IiwiY29kZWNUeXBlIiwidHJhZnMiLCJiYXNlVGltZXMiLCJ0cmFmIiwidGZoZCIsInNjYWxlIiwiYmFzZVRpbWUiLCJ0ZmR0IiwiYmFzZU1lZGlhRGVjb2RlVGltZSIsIndyaXRlVWludDMyIiwidXBwZXIiLCJmbG9vciIsImxvd2VyIiwiQml0cmF0ZXNNYXAiLCJTYW1wbGluZ1JhdGVNYXAiLCJTYW1wbGVzQ29lZmZpY2llbnRzIiwiQnl0ZXNJblNsb3QiLCJwYXJzZUhlYWRlciIsInNhbXBsZXNQZXJGcmFtZSIsInNhbXBsZVJhdGUiLCJoZWFkZXJCIiwiaGVhZGVyQyIsImhlYWRlckUiLCJoZWFkZXJGIiwiaGVhZGVyRyIsImNvbHVtbkluQml0cmF0ZXMiLCJiaXRSYXRlIiwiY29sdW1uSW5TYW1wbGVSYXRlcyIsInNhbXBsZUNvZWZmaWNpZW50IiwiYnl0ZXNJblNsb3QiLCJwYXJzZUludCIsIlNhbXBsZUFlc0RlY3J5cHRlciIsImRpc2NhcmRFUEIiLCJlbmNyeXB0ZWREYXRhIiwic2FtcGxlSW5kZXgiLCJzeW5jIiwiY3VyVW5pdCIsImVuY3J5cHRlZEJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJsb2NhbHRoaXMiLCJkZWNyeXB0QnVmZmVyIiwiZGVjcnlwdEFhY1NhbXBsZXMiLCJpc1N5bmMiLCJkZWNyeXB0QWFjU2FtcGxlIiwiZGVjb2RlZERhdGEiLCJlbmNyeXB0ZWREYXRhTGVuIiwiSW50OEFycmF5Iiwib3V0cHV0UG9zIiwiaW5wdXRQb3MiLCJ1bml0SW5kZXgiLCJnZXRBdmNFbmNyeXB0ZWREYXRhIiwiZ2V0QXZjRGVjcnlwdGVkVW5pdCIsImRlY3J5cHRBdmNTYW1wbGVzIiwiY3VyVW5pdHMiLCJ1bml0cyIsImRlY3J5cHRBdmNTYW1wbGUiLCJSZW11eGVyVHJhY2tJZENvbmZpZyIsImlkMyIsInNhbXBsZUFlcyIsInBtdFBhcnNlZCIsIl9wbXRJZCIsIl9hdmNUcmFjayIsImNyZWF0ZVRyYWNrIiwiX2lkM1RyYWNrIiwiX3R4dFRyYWNrIiwiYWFjT3ZlckZsb3ciLCJhYWNMYXN0UFRTIiwiYXZjU2FtcGxlIiwiX2R1cmF0aW9uIiwic3R0IiwicGlkIiwiYXRmIiwicGVzIiwidW5rbm93blBJRHMiLCJhdmNUcmFjayIsImF2Y0lkIiwiYXVkaW9JZCIsImlkM0lkIiwicG10SWQiLCJhdmNEYXRhIiwicGVzRGF0YSIsImF1ZGlvRGF0YSIsInBhcnNlUEFUIiwiX3BhcnNlUEFUIiwicGFyc2VQTVQiLCJfcGFyc2VQTVQiLCJwYXJzZVBFUyIsIl9wYXJzZVBFUyIsInBhcnNlQVZDUEVTIiwiX3BhcnNlQVZDUEVTIiwicGFyc2VBQUNQRVMiLCJfcGFyc2VBQUNQRVMiLCJwYXJzZU1QRUdQRVMiLCJfcGFyc2VNUEVHUEVTIiwicGFyc2VJRDNQRVMiLCJfcGFyc2VJRDNQRVMiLCJzeW5jT2Zmc2V0IiwiX3N5bmNPZmZzZXQiLCJwYXJzZWRQSURzIiwiYXZjIiwiZGVjcnlwdEFuZFJlbXV4IiwidmlkZW9UcmFjayIsImRlY3J5cHRBbmRSZW11eEF2YyIsIl9pbml0UFRTIiwiX2luaXREVFMiLCJtcGVnU3VwcG9ydGVkIiwiaXNTYW1wbGVBZXMiLCJzZWN0aW9uTGVuZ3RoIiwidGFibGVFbmQiLCJwcm9ncmFtSW5mb0xlbmd0aCIsInN0cmVhbSIsInBlc0ZsYWdzIiwicGVzUHJlZml4IiwicGVzTGVuIiwicGVzSGRyTGVuIiwicGVzUHRzIiwicGVzRHRzIiwicGF5bG9hZFN0YXJ0T2Zmc2V0IiwibmV3RGF0YSIsInNwbGljZSIsImRhdGFMZW4iLCJuYlNhbXBsZXMiLCJzcHMiLCJsYXN0IiwiX3BhcnNlQVZDTkFMdSIsImV4cEdvbG9tYkRlY29kZXIiLCJzcHNmb3VuZCIsInB1c2hBY2Nlc1VuaXQiLCJjcmVhdGVBVkNTYW1wbGUiLCJhdWRGb3VuZCIsInNsaWNlVHlwZSIsInJlYWRTbGljZVR5cGUiLCJwYXlsb2FkVHlwZSIsInBheWxvYWRTaXplIiwiZW5kT2ZDYXB0aW9ucyIsImNvdW50cnlDb2RlIiwicHJvdmlkZXJDb2RlIiwicmVhZFVTaG9ydCIsInVzZXJTdHJ1Y3R1cmUiLCJyZWFkVUludCIsInVzZXJEYXRhVHlwZSIsImZpcnN0Qnl0ZSIsInNlY29uZEJ5dGUiLCJ0b3RhbENDcyIsIl9pbnNlcnRTYW1wbGVJbk9yZGVyIiwicmVhZFNQUyIsImNvZGVjYXJyYXkiLCJjb2RlY3N0cmluZyIsImgiLCJwcHMiLCJhcnIiLCJsYXN0VW5pdCIsIm92ZXJmbG93IiwibmFsdVN0YXRlIiwibGFzdFN0YXRlIiwidW5pdFR5cGUiLCJsYXN0VW5pdFN0YXJ0IiwibGFzdFVuaXRUeXBlIiwiX2dldExhc3ROYWxVbml0IiwidG1wIiwiRVBCUG9zaXRpb25zIiwibmV3TGVuZ3RoIiwic291cmNlSW5kZXgiLCJuZXdQVFMiLCJzY2Fud2luZG93IiwiTVVYX0VSUk9SIiwiTUFOSUZFU1RfTE9BRF9FUlJPUiIsIk1BTklGRVNUX0xPQURfVElNRU9VVCIsIk1BTklGRVNUX1BBUlNJTkdfRVJST1IiLCJGT1JCSURERU5fRVZFTlRfTkFNRVMiLCJvbkV2ZW50IiwiZXZlbnRzIiwiaGFuZGxlZEV2ZW50cyIsInVzZUdlbmVyaWNIYW5kbGVyIiwicmVnaXN0ZXJMaXN0ZW5lcnMiLCJvbkhhbmRsZXJEZXN0cm95aW5nIiwidW5yZWdpc3Rlckxpc3RlbmVycyIsIm9uSGFuZGxlckRlc3Ryb3llZCIsImlzRXZlbnRIYW5kbGVyIiwib25FdmVudEdlbmVyaWMiLCJldmVudFRvRnVuY3Rpb24iLCJmdW5jTmFtZSIsInJlcGxhY2UiLCJjb25zdHJ1Y3RvciIsIkhsc0V2ZW50cyIsIkZSQUdfTE9BRF9QUk9HUkVTUyIsIkRFU1RST1lJTkciLCJVUkxUb29sa2l0IiwiSGxzIiwiX19WRVJTSU9OX18iLCJkZWZhdWx0Q29uZmlnIiwiRGVmYXVsdENvbmZpZyIsInByb3AiLCJfYXV0b0xldmVsQ2FwcGluZyIsInBsYXlMaXN0TG9hZGVyIiwiZnJhZ21lbnRMb2FkZXIiLCJGcmFnbWVudExvYWRlciIsImtleUxvYWRlciIsIktleUxvYWRlciIsImlkM1RyYWNrQ29udHJvbGxlciIsImxldmVsQ29udHJvbGxlciIsIm5ldHdvcmtDb250cm9sbGVycyIsIkNvbnRyb2xsZXIiLCJjb3JlQ29tcG9uZW50cyIsImRldGFjaE1lZGlhIiwiY29tcG9uZW50IiwiYnVpbGRBYnNvbHV0ZVVSTCIsImxvY2F0aW9uIiwiaHJlZiIsImFsd2F5c05vcm1hbGl6ZSIsImNvbnRyb2xsZXIiLCJzd2FwQXVkaW9Db2RlYyIsImF0dGFjaE1lZGlhIiwiaW1tZWRpYXRlTGV2ZWxTd2l0Y2giLCJtYW51YWxMZXZlbCIsImF1ZGlvVHJhY2tJZCIsImlzU3VwcG9ydGVkIiwiU291cmNlQnVmZmVyIiwiV2ViS2l0U291cmNlQnVmZmVyIiwic291cmNlQnVmZmVyVmFsaWRBUEkiLCJsb2FkZXJzIiwibG9hZGVyTmFtZSIsIkZyYWdtZW50SUxvYWRlciIsIkRlZmF1bHRJTG9hZGVyIiwibG9hZGVyQ29udGV4dCIsImxvYWRlckNvbmZpZyIsImxvYWRlckNhbGxiYWNrcyIsInByb2dyZXNzRGF0YSIsImJ5dGVSYW5nZVN0YXJ0T2Zmc2V0IiwiYnl0ZVJhbmdlRW5kT2Zmc2V0IiwicmFuZ2VTdGFydCIsInJhbmdlRW5kIiwidGltZW91dCIsIm1heFJldHJ5IiwicmV0cnlEZWxheSIsIm1heFJldHJ5RGVsYXkiLCJvblN1Y2Nlc3MiLCJsb2Fkc3VjY2VzcyIsIm9uRXJyb3IiLCJsb2FkZXJyb3IiLCJvblRpbWVvdXQiLCJsb2FkdGltZW91dCIsIm9uUHJvZ3Jlc3MiLCJsb2FkcHJvZ3Jlc3MiLCJuZXR3b3JrRGV0YWlscyIsIl91cmwiLCJfYnl0ZVJhbmdlIiwiX2RlY3J5cHRkYXRhIiwidGFnTGlzdCIsInJhd1Byb2dyYW1EYXRlVGltZSIsIl9lbGVtZW50YXJ5U3RyZWFtcyIsInNlZ21lbnROdW1iZXIiLCJ1aW50OFZpZXciLCJsZXZlbGtleSIsInVyaSIsIkxldmVsS2V5IiwiYmFzZXVyaSIsInJlbHVyaSIsImNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yIiwicmVsdXJsIiwiYmFzZXVybCIsInJhd0J5dGVSYW5nZSIsImJ5dGVSYW5nZSIsInBhcmFtcyIsInNwbGl0IiwibGFzdEJ5dGVSYW5nZUVuZE9mZnNldCIsImZyYWdtZW50RGVjcnlwdGRhdGFGcm9tTGV2ZWxrZXkiLCJkZWNyeXB0a2V5IiwiZGVjcnlwdHVybCIsIl91cmkiLCJMZXZlbCIsImJhc2VVcmwiLCJlbmRDQyIsIm5lZWRTaWR4UmFuZ2VzIiwic3RhcnRDQyIsIk1BU1RFUl9QTEFZTElTVF9SRUdFWCIsIk1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCIsIkxFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QiLCJSZWdFeHAiLCJzb3VyY2UiLCJqb2luIiwiTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyIsIk1QNF9SRUdFWF9TVUZGSVgiLCJNM1U4UGFyc2VyIiwiZ3JvdXBzIiwibWVkaWFHcm91cElkIiwibWF0Y2hpbmdHcm91cCIsImdyb3VwIiwiYXZjZGF0YSIsInN1YnN0ciIsInN0cmluZyIsInNldENvZGVjcyIsImNvZGVjcyIsImZpbHRlcmVkIiwicHJlZmVycmVkIiwibGFzdEluZGV4T2YiLCJ1bmtub3duQ29kZWNzIiwiZXhlYyIsIkF0dHJMaXN0IiwicmVzb2x2ZSIsInJlc29sdXRpb24iLCJkZWNpbWFsUmVzb2x1dGlvbiIsImRlY2ltYWxJbnRlZ2VyIiwiTkFNRSIsIkNPREVDUyIsImNvbnZlcnRBVkMxVG9BVkNPVEkiLCJhdWRpb0dyb3VwcyIsIm1lZGlhcyIsIlRZUEUiLCJERUZBVUxUIiwiYXV0b3NlbGVjdCIsIkFVVE9TRUxFQ1QiLCJmb3JjZWQiLCJGT1JDRUQiLCJVUkkiLCJMQU5HVUFHRSIsImdyb3VwQ29kZWMiLCJmaW5kR3JvdXAiLCJsZXZlbFVybElkIiwiY3VycmVudFNOIiwiZmlyc3RQZHRJbmRleCIsInBhcnNlRmxvYXQiLCJ0aXRsZSIsImFzc2lnblByb2dyYW1EYXRlVGltZSIsIm1hdGNoIiwidmFsdWUxIiwidmFsdWUyIiwidG9VcHBlckNhc2UiLCJkZWNyeXB0cGFyYW1zIiwia2V5QXR0cnMiLCJkZWNyeXB0bWV0aG9kIiwiZW51bWVyYXRlZFN0cmluZyIsImRlY3J5cHR1cmkiLCJkZWNyeXB0aXYiLCJoZXhhZGVjaW1hbEludGVnZXIiLCJzdGFydFBhcmFtcyIsInN0YXJ0QXR0cnMiLCJkZWNpbWFsRmxvYXRpbmdQb2ludCIsIm1hcEF0dHJzIiwiQllURVJBTkdFIiwiZXZlcnkiLCJiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMiLCJzdGFydEluZGV4IiwiZnJhZ1ByZXYiLCJDb250ZXh0VHlwZSIsIk1BTklGRVNUIiwiTEVWRUwiLCJBVURJT19UUkFDSyIsIlNVQlRJVExFX1RSQUNLIiwiU1VCVElUTEUiLCJQTG9hZGVyIiwiTG9hZGVyIiwiSW50ZXJuYWxMb2FkZXIiLCJjb250ZXh0VHlwZSIsInJlc2V0SW50ZXJuYWxMb2FkZXIiLCJkZXN0cm95SW50ZXJuYWxMb2FkZXJzIiwiZ2V0SW50ZXJuYWxMb2FkZXIiLCJjcmVhdGVJbnRlcm5hbExvYWRlciIsImlzU2lkeFJlcXVlc3QiLCJfaGFuZGxlU2lkeFJlcXVlc3QiLCJfaGFuZGxlUGxheWxpc3RMb2FkZWQiLCJfaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IiLCJfaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QiLCJfaGFuZGxlTWFzdGVyUGxheWxpc3QiLCJfaGFuZGxlTmV0d29ya0Vycm9yIiwiZ2V0UmVzcG9uc2VVcmwiLCJwYXJzZU1hc3RlclBsYXlsaXN0IiwicGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhIiwiZW1iZWRkZWRBdWRpb0ZvdW5kIiwibGV2ZWxJZCIsIm1hcENvbnRleHRUb0xldmVsVHlwZSIsInBhcnNlTGV2ZWxQbGF5bGlzdCIsInNpbmdsZUxldmVsIiwic2lkeFVybCIsInNpZHhJbmZvIiwicGFyc2VTZWdtZW50SW5kZXgiLCJzaWR4UmVmZXJlbmNlcyIsInNlZ21lbnRSZWYiLCJzZWdSZWZJbmZvIiwiZXJyb3JEYXRhIiwiY2FuSGF2ZUxldmVscyIsImNhbkhhdmVRdWFsaXR5TGV2ZWxzIiwiQUFDIiwiTVA0IiwidHlwZXMiLCJhdmMxIiwiYXZjQyIsImJ0cnQiLCJkaW5mIiwiZHJlZiIsImVzZHMiLCJmdHlwIiwibWRhdCIsIm1kaWEiLCJtZmhkIiwibWluZiIsIm1vb2YiLCJtcDRhIiwibXZleCIsIm12aGQiLCJwYXNwIiwic2R0cCIsInN0YmwiLCJzdGNvIiwic3RzYyIsInN0c2QiLCJzdHN6Iiwic3R0cyIsInRydW4iLCJ0cmV4Iiwidm1oZCIsInNtaGQiLCJoYXNPd25Qcm9wZXJ0eSIsImNoYXJDb2RlQXQiLCJ2aWRlb0hkbHIiLCJhdWRpb0hkbHIiLCJIRExSX1RZUEVTIiwiU1RUUyIsIlNUU0MiLCJTVENPIiwiU1RTWiIsIlZNSEQiLCJTTUhEIiwiU1RTRCIsIm1ham9yQnJhbmQiLCJhdmMxQnJhbmQiLCJtaW5vclZlcnNpb24iLCJGVFlQIiwiYm94IiwiRElORiIsImFyZ3VtZW50cyIsInVwcGVyV29yZER1cmF0aW9uIiwibG93ZXJXb3JkRHVyYXRpb24iLCJib3hlcyIsImZsYWdzIiwiZGVwZW5kc09uIiwiaXNEZXBlbmRlZE9uIiwiaGFzUmVkdW5kYW5jeSIsImF2Y2MiLCJoU3BhY2luZyIsInZTcGFjaW5nIiwiY29uZmlnbGVuIiwic2FtcGxlRGVwZW5kZW5jeVRhYmxlIiwidXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSIsImxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUiLCJhcnJheWxlbiIsImN0cyIsImlzTGVhZGluZyIsInBhZGRpbmdWYWx1ZSIsImlzTm9uU3luYyIsImRlZ3JhZFByaW8iLCJpbml0IiwibW92aWUiLCJNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OIiwiaXNTYWZhcmkiLCJJU0dlbmVyYXRlZCIsImRlZmF1bHRUaW1lU3RhbXAiLCJnZW5lcmF0ZUlTIiwibmJBdWRpb1NhbXBsZXMiLCJuYlZpZGVvU2FtcGxlcyIsImF1ZGlvVGltZU9mZnNldCIsInZpZGVvVGltZU9mZnNldCIsImF1ZGlvdmlkZW9EZWx0YUR0cyIsInJlbXV4QXVkaW8iLCJhdWRpb1RyYWNrTGVuZ3RoIiwicmVtdXhWaWRlbyIsInZpZGVvRGF0YSIsInJlbXV4RW1wdHlBdWRpbyIsInJlbXV4SUQzIiwicmVtdXhUZXh0IiwiYXVkaW9TYW1wbGVzIiwidmlkZW9TYW1wbGVzIiwiY29tcHV0ZVBUU0RUUyIsImluaXREVFMiLCJtcDRTYW1wbGVEdXJhdGlvbiIsImZpcnN0UFRTIiwiZmlyc3REVFMiLCJsYXN0UFRTIiwibGFzdERUUyIsInRpbWVTY2FsZSIsImlucHV0U2FtcGxlcyIsIm91dHB1dFNhbXBsZXMiLCJwdHNOb3JtYWxpemUiLCJfUFRTTm9ybWFsaXplIiwibmV4dEF2Y0R0cyIsImRlbHRhZHRzIiwiZGVsdGFwdHMiLCJQVFNEVFNzaGlmdCIsImN1cnIiLCJuYk5hbHUiLCJuYWx1TGVuIiwibmJVbml0cyIsInNhbXBsZUxlbiIsIm1kYXRTaXplIiwic2V0VWludDMyIiwiYXZjU2FtcGxlVW5pdHMiLCJtcDRTYW1wbGVMZW5ndGgiLCJjb21wb3NpdGlvblRpbWVPZmZzZXQiLCJ1bml0RGF0YSIsInVuaXREYXRhTGVuIiwibGFzdEZyYW1lRHVyYXRpb24iLCJnYXBUb2xlcmFuY2UiLCJkZWx0YVRvRnJhbWVFbmQiLCJuZXh0QXVkaW9QdHMiLCJtcDR0aW1lU2NhbGUiLCJzY2FsZUZhY3RvciIsImlucHV0U2FtcGxlRHVyYXRpb24iLCJyYXdNUEVHIiwibXA0U2FtcGxlIiwiZmlsbEZyYW1lIiwibmV4dFB0cyIsIm1pc3NpbmciLCJuZXdTdGFtcCIsImdldFNpbGVudEZyYW1lIiwiYXVkaW9TYW1wbGUiLCJudW1NaXNzaW5nRnJhbWVzIiwidW5pdExlbiIsImxhc3RTYW1wbGVEdXJhdGlvbiIsInNhbXBsZUR1cmF0aW9uIiwic2lsZW50RnJhbWUiLCJyZWZlcmVuY2UiLCJyYXdEYXRhIiwiX3RpY2tJbnRlcnZhbCIsIl90aWNrVGltZXIiLCJfdGlja0NhbGxDb3VudCIsIl9ib3VuZFRpY2siLCJtaWxsaXMiLCJkb1RpY2siLCJERUNJTUFMX1JFU09MVVRJT05fUkVHRVgiLCJBVFRSX0xJU1RfUkVHRVgiLCJwYXJzZUF0dHJMaXN0IiwiYXR0ciIsImF0dHJOYW1lIiwiaW50VmFsdWUiLCJNQVhfU0FGRV9JTlRFR0VSIiwic3RyaW5nVmFsdWUiLCJyZXMiLCJpbnB1dCIsInF1b3RlIiwibGlzdCIsImNvbXBhcmlzb25GdW5jdGlvbiIsIm1pbkluZGV4IiwibWF4SW5kZXgiLCJjdXJyZW50SW5kZXgiLCJjdXJyZW50RWxlbWVudCIsImNvbXBhcmlzb25SZXN1bHQiLCJtYXhIb2xlRHVyYXRpb24iLCJ2YnVmZmVyZWQiLCJidWZmZXJlZDIiLCJidWZmZXJTdGFydCIsImJ1ZmZlclN0YXJ0TmV4dCIsImRpZmYiLCJidWYybGVuIiwiYnVmMmVuZCIsInNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzIiwiZ2V0Q2hhckZvckJ5dGUiLCJieXRlIiwiY2hhckNvZGUiLCJOUl9ST1dTIiwiTlJfQ09MUyIsInJvd3NMb3dDaDEiLCJyb3dzSGlnaENoMSIsInJvd3NMb3dDaDIiLCJyb3dzSGlnaENoMiIsImJhY2tncm91bmRDb2xvcnMiLCJ2ZXJib3NlRmlsdGVyIiwidmVyYm9zZUxldmVsIiwic2V0VGltZSIsIm5ld1RpbWUiLCJzZXZlcml0eSIsIm1zZyIsIm1pbkxldmVsIiwibnVtQXJyYXlUb0hleEFycmF5IiwibnVtQXJyYXkiLCJoZXhBcnJheSIsIlBlblN0YXRlIiwiZm9yZWdyb3VuZCIsInVuZGVybGluZSIsIml0YWxpY3MiLCJiYWNrZ3JvdW5kIiwiZmxhc2giLCJzdHlsZXMiLCJhdHRyaWJzIiwic3R5bGUiLCJvdGhlciIsIm5ld1BlblN0YXRlIiwiU3R5bGVkVW5pY29kZUNoYXIiLCJ1Y2hhciIsInBlblN0YXRlIiwiY29weSIsImVxdWFscyIsIm5ld0NoYXIiLCJpc0RlZmF1bHQiLCJSb3ciLCJjaGFycyIsImN1cnJQZW5TdGF0ZSIsImVxdWFsIiwiZW1wdHkiLCJpc0VtcHR5IiwiYWJzUG9zIiwicmVsUG9zIiwibmV3UG9zIiwic2V0UGVuU3RhdGUiLCJzZXRDdXJzb3IiLCJtb3ZlQ3Vyc29yIiwic2V0Q2hhciIsImJhY2tTcGFjZSIsImNoYXIiLCJzdGFydFBvcyIsImNsZWFyRnJvbVBvcyIsInNldFN0eWxlcyIsImN1cnJDaGFyIiwiQ2FwdGlvblNjcmVlbiIsInJvd3MiLCJjdXJyUm93IiwibnJSb2xsVXBSb3dzIiwiY2xlYXIiLCJyb3ciLCJjbGVhclRvRW5kT2ZSb3ciLCJpbnNlcnRDaGFyIiwic2V0UGVuU3R5bGVzIiwicGFjRGF0YSIsIm5ld1JvdyIsInRvcFJvd0luZGV4IiwibGFzdE91dHB1dFNjcmVlbiIsInByZXZMaW5lVGltZSIsImN1ZVN0YXJ0VGltZSIsImluZGVudCIsInByZXZQb3MiLCJjb2xvciIsInNldFBlbiIsImJrZ0RhdGEiLCJuclJvd3MiLCJnZXREaXNwbGF5VGV4dCIsInRvcFJvdyIsImFzT25lUm93IiwiZGlzcGxheVRleHQiLCJyb3dOciIsInJvd1RleHQiLCJnZXRUZXh0U3RyaW5nIiwidHJpbSIsIkNlYTYwOENoYW5uZWwiLCJjaGFubmVsTnVtYmVyIiwib3V0cHV0RmlsdGVyIiwiY2hOciIsInZlcmJvc2UiLCJkaXNwbGF5ZWRNZW1vcnkiLCJub25EaXNwbGF5ZWRNZW1vcnkiLCJjdXJyUm9sbFVwUm93Iiwid3JpdGVTY3JlZW4iLCJsYXN0Q3VlRW5kVGltZSIsIm5ld0hhbmRsZXIiLCJzZXRQQUMiLCJzZXRCa2dEYXRhIiwibmV3TW9kZSIsIm91dHB1dERhdGFVcGRhdGUiLCJzZXRNb2RlIiwic2V0Um9sbFVwUm93cyIsInJvbGxVcCIsIm5yQ29scyIsImNvbG9ySW5kZXgiLCJjb2xvcnMiLCJkaXNwYXRjaCIsImRpc3BhdGNoQ3VlIiwiZmllbGQiLCJvdXQxIiwib3V0MiIsIm91dHB1dHMiLCJjaGFubmVscyIsImN1cnJDaE5yIiwibGFzdENtZEEiLCJsYXN0Q21kQiIsImJ1ZmZlcmVkRGF0YSIsImRhdGFDb3VudGVycyIsImdldEhhbmRsZXIiLCJzZXRIYW5kbGVyIiwiYnl0ZUxpc3QiLCJjbWRGb3VuZCIsImNoYXJzRm91bmQiLCJwYWRkaW5nIiwicGFyc2VDbWQiLCJwYXJzZU1pZHJvdyIsInBhcnNlUEFDIiwicGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyIsInBhcnNlQ2hhcnMiLCJjaGFubmVsIiwiaW5zZXJ0Q2hhcnMiLCJjb25kMSIsImNvbmQyIiwiY2NSQ0wiLCJjY0JTIiwiY2NBT0YiLCJjY0FPTiIsImNjREVSIiwiY2NSVSIsImNjRk9OIiwiY2NSREMiLCJjY1RSIiwiY2NSVEQiLCJjY0VETSIsImNjQ1IiLCJjY0VOTSIsImNjRU9DIiwiY2NUTyIsImNjTUlEUk9XIiwiY2FzZTEiLCJjYXNlMiIsImludGVycHJldFBBQyIsInBhY0luZGV4IiwiY2hhbm5lbE5yIiwiY2hhckNvZGVzIiwiY2hhckNvZGUxIiwib25lQ29kZSIsImhleENvZGVzIiwiY3VlU3BsaXRBdFRpbWUiLCJzYW1wbGVFbnRyeUNvZGVzSVNPIiwiaXNDb2RlY1R5cGUiLCJ0eXBlQ29kZXMiLCJpc0NvZGVjU3VwcG9ydGVkSW5NcDQiLCJjYXB0aW9uU2NyZWVuIiwiaW5kZW50aW5nIiwiciIsImxpbmUiLCJhbGlnbiIsImZpbmRGaXJzdEZyYWdXaXRoQ0MiLCJmaW5kRnJhZ1dpdGhDQyIsInNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMiLCJmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWciLCJhZGp1c3RQdHMiLCJhbGlnblN0cmVhbSIsImFsaWduRGlzY29udGludWl0aWVzIiwiYWxpZ25QRFQiLCJmaXJzdEZyYWciLCJjdXJyZW50RnJhZyIsIkNDIiwic2hvdWxkQWxpZ24iLCJwcmV2RGV0YWlscyIsInByZXZGcmFncyIsImN1ckZyYWdzIiwicHJldlN0YXJ0RnJhZyIsInJlZmVyZW5jZUZyYWciLCJsYXN0RGV0YWlscyIsImxhc3RQRFQiLCJuZXdQRFQiLCJzbG93IiwiZmFzdCIsImRlZmF1bHRFc3RpbWF0ZSIsImRlZmF1bHRFc3RpbWF0ZV8iLCJtaW5XZWlnaHRfIiwibWluRGVsYXlNc18iLCJzbG93XyIsIkVXTUEiLCJmYXN0XyIsImR1cmF0aW9uTXMiLCJudW1CeXRlcyIsImJhbmR3aWR0aCIsIndlaWdodCIsImdldFRvdGFsV2VpZ2h0IiwiaGFsZkxpZmUiLCJhbHBoYV8iLCJleHAiLCJlc3RpbWF0ZV8iLCJ0b3RhbFdlaWdodF8iLCJhZGpBbHBoYSIsInplcm9GYWN0b3IiLCJnZXRTZWxmU2NvcGUiLCJub29wIiwiZmFrZUxvZ2dlciIsImV4cG9ydGVkTG9nZ2VyIiwiZm9ybWF0TXNnIiwiY29uc29sZVByaW50Rm4iLCJmdW5jIiwiYXJncyIsImV4cG9ydExvZ2dlckZ1bmN0aW9ucyIsImRlYnVnQ29uZmlnIiwiZnVuY3Rpb25zIiwiZW5hYmxlTG9ncyIsImdldE1lZGlhU291cmNlIiwiV2ViS2l0TWVkaWFTb3VyY2UiLCJhZGRDdWVzIiwiY3JlYXRlQ2FwdGlvbnNUcmFjayIsInNlbmRBZGRUcmFja0V2ZW50IiwiY2xlYXJDdXJyZW50Q3VlcyIsInZpZGVvRWwiLCJkb2N1bWVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsInJlbW92ZUN1ZSIsImF1dG9LZXl3b3JkIiwiZGlyZWN0aW9uU2V0dGluZyIsImxyIiwicmwiLCJhbGlnblNldHRpbmciLCJtaWRkbGUiLCJsZWZ0IiwicmlnaHQiLCJmaW5kRGlyZWN0aW9uU2V0dGluZyIsImRpciIsImZpbmRBbGlnblNldHRpbmciLCJleHRlbmQiLCJvYmoiLCJjb2JqIiwicCIsImlzSUU4IiwiYmFzZU9iaiIsImNyZWF0ZUVsZW1lbnQiLCJlbnVtZXJhYmxlIiwiaGFzQmVlblJlc2V0IiwiX2lkIiwiX3BhdXNlT25FeGl0IiwiX3N0YXJ0VGltZSIsIl9lbmRUaW1lIiwiX3RleHQiLCJfcmVnaW9uIiwiX3ZlcnRpY2FsIiwiX3NuYXBUb0xpbmVzIiwiX2xpbmUiLCJfbGluZUFsaWduIiwiX3Bvc2l0aW9uIiwiX3Bvc2l0aW9uQWxpZ24iLCJfc2l6ZSIsIl9hbGlnbiIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiVHlwZUVycm9yIiwic2V0dGluZyIsIlN5bnRheEVycm9yIiwiZGlzcGxheVN0YXRlIiwiZ2V0Q3VlQXNIVE1MIiwiV2ViVlRUIiwiY29udmVydEN1ZVRvRE9NVHJlZSIsIlN0cmluZ0RlY29kZXIiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJWVFRQYXJzZXIiLCJkZWNvZGVyIiwicmVnaW9uTGlzdCIsInBhcnNlVGltZVN0YW1wIiwiY29tcHV0ZVNlY29uZHMiLCJtIiwicyIsImYiLCJTZXR0aW5ncyIsInZhbHVlcyIsImsiLCJ2IiwiZGZsdCIsImRlZmF1bHRLZXkiLCJoYXMiLCJhbHQiLCJuIiwiaW50ZWdlciIsInBlcmNlbnQiLCJwYXJzZU9wdGlvbnMiLCJrZXlWYWx1ZURlbGltIiwiZ3JvdXBEZWxpbSIsImt2IiwiZGVmYXVsdHMiLCJjZW50ZXIiLCJwYXJzZUN1ZSIsIm9JbnB1dCIsImNvbnN1bWVUaW1lU3RhbXAiLCJ0cyIsImNvbnN1bWVDdWVTZXR0aW5ncyIsInNldHRpbmdzIiwicmVnaW9uIiwidmFscyIsInZhbHMwIiwidmVydGljYWwiLCJsaW5lQWxpZ24iLCJzbmFwVG9MaW5lcyIsInNraXBXaGl0ZXNwYWNlIiwiZml4TGluZUJyZWFrcyIsImNvbGxlY3ROZXh0TGluZSIsImFscmVhZHlDb2xsZWN0ZWRMaW5lIiwiaGFzU3Vic3RyaW5nIiwib25jdWUiLCJmbHVzaCIsIm9uZmx1c2giLCJzdGFydHNXaXRoIiwiaW5wdXRTdHJpbmciLCJzZWFyY2hTdHJpbmciLCJjdWVTdHJpbmcybWlsbGlzIiwidGltZVN0cmluZyIsInNlY3MiLCJtaW5zIiwiaG91cnMiLCJoYXNoIiwiY2FsY3VsYXRlT2Zmc2V0IiwicHJlc2VudGF0aW9uVGltZSIsImN1cnJDQyIsInZ0dEJ5dGVBcnJheSIsInN5bmNQVFMiLCJjYWxsQmFjayIsImVycm9yQ2FsbEJhY2siLCJyZSIsInZ0dExpbmVzIiwiY3VlVGltZSIsIm1wZWdUcyIsImxvY2FsVGltZSIsInBhcnNpbmdFcnJvciIsImluSGVhZGVyIiwicGFyc2VyIiwiY3VlT2Zmc2V0Iiwib25wYXJzaW5nZXJyb3IiLCJyZXF1ZXN0VGltZW91dCIsInJldHJ5VGltZW91dCIsImNhbGxiYWNrcyIsInJldHJ5IiwibG9hZEludGVybmFsIiwic2V0UmVxdWVzdEhlYWRlciIsInJlYWR5c3RhdGVjaGFuZ2UiLCJvbnByb2dyZXNzIiwiY3VycmVudFRhcmdldCIsInJlc3BvbnNlVGV4dCIsInJlc3BvbnNlVVJMIiwibGVuZ3RoQ29tcHV0YWJsZSIsIkhsc0pzUGxheWVyIiwib3B0aW9ucyIsImhsc09wdHMiLCJ1dGlsIiwiUGxheWVyIiwicGxheWVyIiwiYnJvd3NlciIsInV0aWxzIiwiZ2V0QnJvd3NlclZlcnNpb24iLCJ1c2VIbHMiLCJzbmlmZmVyIiwiZGV2aWNlIiwicGxhdGZvcm0iLCJjdXJyZW50U3JjIiwicmVtb3ZlQ2xhc3MiLCJyb290IiwibGl2ZURvbSIsInF1ZXJ5U2VsZWN0b3IiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJyZWdpc3RlciIsIm9uY2UiLCJsb2FkU291cmNlIiwiY29uZmlndXJhYmxlIiwiYXV0b3BsYXkiLCJhZGRDbGFzcyIsImZpbmREb20iLCJjcmVhdGVEb20iLCJjb250cm9scyIsImFwcGVuZENoaWxkIiwiRXZlbnRzIiwiaW5pdGVkIiwiZXJyb3JUeXBlIiwiZXJyb3JGYXRhbCIsInJlY292ZXJNZWRpYUVycm9yIiwiX3N0YXRpc3RpY3MiLCJzdGF0c0luZm8iLCJzcGVlZCIsInBsYXllclR5cGUiLCJtZWRpYWluZm8iLCJ2aWRlb0RhdGFSYXRlIiwiYXVkaW9EYXRhUmF0ZSIsImZsYWciLCJmcHMiLCJhdWRpb0NoYW5uZWxDb3VudCIsIl9zdGF0aXN0aWNzVGltbWVyIiwidmVyc2lv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QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7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WUFBVTlnQixVQUFVcTJCLEtBQVYsQ0FBZ0Isa0JBQWhCLEVBQW9DLENBQXBDLEVBQXVDQSxLQUF2QyxDQUE2QyxPQUE3QyxFQUFzRCxDQUF0RCxDQUFkO0FBQ0EsV0FBTyxZQUFVdlYsU0FBakI7QUFDRCxHQUhNLE1BR0EsSUFBSTlnQixVQUFVcE0sT0FBVixDQUFrQixNQUFsQixJQUE0QixDQUFDLENBQTdCLElBQWtDb00sVUFBVXBNLE9BQVYsQ0FBa0IsU0FBbEIsSUFBK0IsQ0FBQyxDQUF0RSxFQUF5RTtBQUM5RSxRQUFJb00sVUFBVXBNLE9BQVYsQ0FBa0IsTUFBbEIsSUFBNEIsQ0FBQyxDQUFqQyxFQUFvQztBQUNsQyxVQUFJa3RCLFlBQVU5Z0IsVUFBVXEyQixLQUFWLENBQWdCLGVBQWhCLEVBQWlDLENBQWpDLEVBQW9DQSxLQUFwQyxDQUEwQyxPQUExQyxFQUFtRCxDQUFuRCxDQUFkO0FBQ0EsYUFBTyxRQUFNdlYsU0FBYjtBQUNEO0FBQ0QsUUFBSTlnQixVQUFVcE0sT0FBVixDQUFrQixTQUFsQixJQUErQixDQUFDLENBQXBDLEVBQXVDO0FBQ3JDLFVBQUkwcUQsaUJBQWlCdCtDLFVBQVVxMkIsS0FBVixDQUFnQixtQkFBaEIsRUFBcUMsQ0FBckMsRUFBd0NBLEtBQXhDLENBQThDLE9BQTlDLEVBQXVELENBQXZELENBQXJCO0FBQ0EsVUFBSXZWLFlBQVVpRCxTQUFTdTZCLGNBQVQsSUFBMkIsQ0FBekM7QUFDQSxhQUFPLFFBQU14OUIsU0FBYjtBQUNEO0FBQ0YsR0FWTSxNQVVBO0FBQ0wsV0FBTyxTQUFQO0FBQ0Q7QUFDRixDQXpDRDs7a0JBMkNlNjZCLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdDZixzRCIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInhncGxheWVyXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInhncGxheWVyXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInhncGxheWVyLWhsc2pzLmpzXCJdID0gZmFjdG9yeShyZXF1aXJlKFwieGdwbGF5ZXJcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInhncGxheWVyLWhsc2pzLmpzXCJdID0gZmFjdG9yeShyb290W1wieGdwbGF5ZXJcIl0pO1xufSkod2luZG93LCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3hncGxheWVyX18pIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBSZWZsZWN0QXBwbHkodGhpcy5saXN0ZW5lciwgdGhpcy50YXJnZXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiIsIi8vIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTgwOFxuXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4oZnVuY3Rpb24ocm9vdCkgeyBcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbiAgdmFyIFVSTF9SRUdFWCA9IC9eKCg/OlthLXpBLVowLTkrXFwtLl0rOik/KShcXC9cXC9bXlxcLz8jXSopPygoPzpbXlxcL1xcPyNdKlxcLykqLio/KT8/KDsuKj8pPyhcXD8uKj8pPygjLio/KT8kLztcbiAgdmFyIEZJUlNUX1NFR01FTlRfUkVHRVggPSAvXihbXlxcLz8jXSopKC4qKSQvO1xuICB2YXIgU0xBU0hfRE9UX1JFR0VYID0gLyg/OlxcL3xeKVxcLig/PVxcLykvZztcbiAgdmFyIFNMQVNIX0RPVF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuXFwuXFwvKD8hXFwuXFwuXFwvKS4qPyg/PVxcLykvZztcblxuICB2YXIgVVJMVG9vbGtpdCA9IHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgLy8gSWYgb3B0cy5hbHdheXNOb3JtYWxpemUgaXMgdHJ1ZSB0aGVuIHRoZSBwYXRoIHdpbGwgYWx3YXlzIGJlIG5vcm1hbGl6ZWQgZXZlbiB3aGVuIGl0IHN0YXJ0cyB3aXRoIC8gb3IgLy9cbiAgICAvLyBFLmdcbiAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gZmFsc2UgKGRlZmF1bHQsIHNwZWMgY29tcGxpYW50KVxuICAgIC8vIGh0dHA6Ly9hLmNvbS9iL2NkICsgL2UvZi8uLi9nID0+IGh0dHA6Ly9hLmNvbS9lL2YvLi4vZ1xuICAgIC8vIFdpdGggb3B0cy5hbHdheXNOb3JtYWxpemUgPSB0cnVlIChub3Qgc3BlYyBjb21wbGlhbnQpXG4gICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZ1xuICAgIGJ1aWxkQWJzb2x1dGVVUkw6IGZ1bmN0aW9uKGJhc2VVUkwsIHJlbGF0aXZlVVJMLCBvcHRzKSB7XG4gICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgIC8vIHJlbW92ZSBhbnkgcmVtYWluaW5nIHNwYWNlIGFuZCBDUkxGXG4gICAgICBiYXNlVVJMID0gYmFzZVVSTC50cmltKCk7XG4gICAgICByZWxhdGl2ZVVSTCA9IHJlbGF0aXZlVVJMLnRyaW0oKTtcbiAgICAgIGlmICghcmVsYXRpdmVVUkwpIHtcbiAgICAgICAgLy8gMmEpIElmIHRoZSBlbWJlZGRlZCBVUkwgaXMgZW50aXJlbHkgZW1wdHksIGl0IGluaGVyaXRzIHRoZVxuICAgICAgICAvLyBlbnRpcmUgYmFzZSBVUkwgKGkuZS4sIGlzIHNldCBlcXVhbCB0byB0aGUgYmFzZSBVUkwpXG4gICAgICAgIC8vIGFuZCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuICAgICAgICAgIHJldHVybiBiYXNlVVJMO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXNlUGFydHNGb3JOb3JtYWxpc2UgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xuICAgICAgICBpZiAoIWJhc2VQYXJ0c0Zvck5vcm1hbGlzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xuICAgICAgICB9XG4gICAgICAgIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZS5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKGJhc2VQYXJ0c0Zvck5vcm1hbGlzZS5wYXRoKTtcbiAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYmFzZVBhcnRzRm9yTm9ybWFsaXNlKTtcbiAgICAgIH1cbiAgICAgIHZhciByZWxhdGl2ZVBhcnRzID0gVVJMVG9vbGtpdC5wYXJzZVVSTChyZWxhdGl2ZVVSTCk7XG4gICAgICBpZiAoIXJlbGF0aXZlUGFydHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgcmVsYXRpdmUgVVJMLicpO1xuICAgICAgfVxuICAgICAgaWYgKHJlbGF0aXZlUGFydHMuc2NoZW1lKSB7XG4gICAgICAgIC8vIDJiKSBJZiB0aGUgZW1iZWRkZWQgVVJMIHN0YXJ0cyB3aXRoIGEgc2NoZW1lIG5hbWUsIGl0IGlzXG4gICAgICAgIC8vIGludGVycHJldGVkIGFzIGFuIGFic29sdXRlIFVSTCBhbmQgd2UgYXJlIGRvbmUuXG4gICAgICAgIGlmICghb3B0cy5hbHdheXNOb3JtYWxpemUpIHtcbiAgICAgICAgICByZXR1cm4gcmVsYXRpdmVVUkw7XG4gICAgICAgIH1cbiAgICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKHJlbGF0aXZlUGFydHMucGF0aCk7XG4gICAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKHJlbGF0aXZlUGFydHMpO1xuICAgICAgfVxuICAgICAgdmFyIGJhc2VQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwoYmFzZVVSTCk7XG4gICAgICBpZiAoIWJhc2VQYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC4nKTtcbiAgICAgIH1cbiAgICAgIGlmICghYmFzZVBhcnRzLm5ldExvYyAmJiBiYXNlUGFydHMucGF0aCAmJiBiYXNlUGFydHMucGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICAgIC8vIElmIG5ldExvYyBtaXNzaW5nIGFuZCBwYXRoIGRvZXNuJ3Qgc3RhcnQgd2l0aCAnLycsIGFzc3VtZSBldmVydGhpbmcgYmVmb3JlIHRoZSBmaXJzdCAnLycgaXMgdGhlIG5ldExvY1xuICAgICAgICAvLyBUaGlzIGNhdXNlcyAnZXhhbXBsZS5jb20vYScgdG8gYmUgaGFuZGxlZCBhcyAnLy9leGFtcGxlLmNvbS9hJyBpbnN0ZWFkIG9mICcvZXhhbXBsZS5jb20vYSdcbiAgICAgICAgdmFyIHBhdGhQYXJ0cyA9IEZJUlNUX1NFR01FTlRfUkVHRVguZXhlYyhiYXNlUGFydHMucGF0aCk7XG4gICAgICAgIGJhc2VQYXJ0cy5uZXRMb2MgPSBwYXRoUGFydHNbMV07XG4gICAgICAgIGJhc2VQYXJ0cy5wYXRoID0gcGF0aFBhcnRzWzJdO1xuICAgICAgfVxuICAgICAgaWYgKGJhc2VQYXJ0cy5uZXRMb2MgJiYgIWJhc2VQYXJ0cy5wYXRoKSB7XG4gICAgICAgIGJhc2VQYXJ0cy5wYXRoID0gJy8nO1xuICAgICAgfVxuICAgICAgdmFyIGJ1aWx0UGFydHMgPSB7XG4gICAgICAgIC8vIDJjKSBPdGhlcndpc2UsIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIHNjaGVtZSBvZlxuICAgICAgICAvLyB0aGUgYmFzZSBVUkwuXG4gICAgICAgIHNjaGVtZTogYmFzZVBhcnRzLnNjaGVtZSxcbiAgICAgICAgbmV0TG9jOiByZWxhdGl2ZVBhcnRzLm5ldExvYyxcbiAgICAgICAgcGF0aDogbnVsbCxcbiAgICAgICAgcGFyYW1zOiByZWxhdGl2ZVBhcnRzLnBhcmFtcyxcbiAgICAgICAgcXVlcnk6IHJlbGF0aXZlUGFydHMucXVlcnksXG4gICAgICAgIGZyYWdtZW50OiByZWxhdGl2ZVBhcnRzLmZyYWdtZW50XG4gICAgICB9O1xuICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLm5ldExvYykge1xuICAgICAgICAvLyAzKSBJZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPG5ldF9sb2M+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuICAgICAgICAvLyBTdGVwIDcuICBPdGhlcndpc2UsIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIDxuZXRfbG9jPlxuICAgICAgICAvLyAoaWYgYW55KSBvZiB0aGUgYmFzZSBVUkwuXG4gICAgICAgIGJ1aWx0UGFydHMubmV0TG9jID0gYmFzZVBhcnRzLm5ldExvYztcbiAgICAgICAgLy8gNCkgSWYgdGhlIGVtYmVkZGVkIFVSTCBwYXRoIGlzIHByZWNlZGVkIGJ5IGEgc2xhc2ggXCIvXCIsIHRoZVxuICAgICAgICAvLyBwYXRoIGlzIG5vdCByZWxhdGl2ZSBhbmQgd2Ugc2tpcCB0byBTdGVwIDcuXG4gICAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xuICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5wYXRoKSB7XG4gICAgICAgICAgICAvLyA1KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgZW1wdHkgKGFuZCBub3QgcHJlY2VkZWQgYnkgYVxuICAgICAgICAgICAgLy8gc2xhc2gpLCB0aGVuIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIGJhc2UgVVJMIHBhdGhcbiAgICAgICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgLy8gNWEpIGlmIHRoZSBlbWJlZGRlZCBVUkwncyA8cGFyYW1zPiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHBhcmFtcz4gb2YgdGhlIGJhc2VcbiAgICAgICAgICAgIC8vIFVSTCAoaWYgYW55KSBhbmRcbiAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXJhbXMgPSBiYXNlUGFydHMucGFyYW1zO1xuICAgICAgICAgICAgICAvLyA1YikgaWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxxdWVyeT4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG4gICAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHF1ZXJ5PiBvZiB0aGUgYmFzZVxuICAgICAgICAgICAgICAvLyBVUkwgKGlmIGFueSkgYW5kIHdlIHNraXAgdG8gc3RlcCA3LlxuICAgICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucXVlcnkpIHtcbiAgICAgICAgICAgICAgICBidWlsdFBhcnRzLnF1ZXJ5ID0gYmFzZVBhcnRzLnF1ZXJ5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIDYpIFRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGJhc2UgVVJMJ3MgcGF0aCAoYW55dGhpbmdcbiAgICAgICAgICAgIC8vIGZvbGxvd2luZyB0aGUgcmlnaHRtb3N0IHNsYXNoIFwiL1wiLCBvciB0aGUgZW50aXJlIHBhdGggaWYgbm9cbiAgICAgICAgICAgIC8vIHNsYXNoIGlzIHByZXNlbnQpIGlzIHJlbW92ZWQgYW5kIHRoZSBlbWJlZGRlZCBVUkwncyBwYXRoIGlzXG4gICAgICAgICAgICAvLyBhcHBlbmRlZCBpbiBpdHMgcGxhY2UuXG4gICAgICAgICAgICB2YXIgYmFzZVVSTFBhdGggPSBiYXNlUGFydHMucGF0aDtcbiAgICAgICAgICAgIHZhciBuZXdQYXRoID0gYmFzZVVSTFBhdGguc3Vic3RyaW5nKDAsIGJhc2VVUkxQYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKSArIHJlbGF0aXZlUGFydHMucGF0aDtcbiAgICAgICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChuZXdQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChidWlsdFBhcnRzLnBhdGggPT09IG51bGwpIHtcbiAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gb3B0cy5hbHdheXNOb3JtYWxpemUgPyBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgocmVsYXRpdmVQYXJ0cy5wYXRoKSA6IHJlbGF0aXZlUGFydHMucGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKGJ1aWx0UGFydHMpO1xuICAgIH0sXG4gICAgcGFyc2VVUkw6IGZ1bmN0aW9uKHVybCkge1xuICAgICAgdmFyIHBhcnRzID0gVVJMX1JFR0VYLmV4ZWModXJsKTtcbiAgICAgIGlmICghcGFydHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWU6IHBhcnRzWzFdIHx8ICcnLFxuICAgICAgICBuZXRMb2M6IHBhcnRzWzJdIHx8ICcnLFxuICAgICAgICBwYXRoOiBwYXJ0c1szXSB8fCAnJyxcbiAgICAgICAgcGFyYW1zOiBwYXJ0c1s0XSB8fCAnJyxcbiAgICAgICAgcXVlcnk6IHBhcnRzWzVdIHx8ICcnLFxuICAgICAgICBmcmFnbWVudDogcGFydHNbNl0gfHwgJydcbiAgICAgIH07XG4gICAgfSxcbiAgICBub3JtYWxpemVQYXRoOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG9wZXJhdGlvbnMgYXJlXG4gICAgICAvLyB0aGVuIGFwcGxpZWQsIGluIG9yZGVyLCB0byB0aGUgbmV3IHBhdGg6XG4gICAgICAvLyA2YSkgQWxsIG9jY3VycmVuY2VzIG9mIFwiLi9cIiwgd2hlcmUgXCIuXCIgaXMgYSBjb21wbGV0ZSBwYXRoXG4gICAgICAvLyBzZWdtZW50LCBhcmUgcmVtb3ZlZC5cbiAgICAgIC8vIDZiKSBJZiB0aGUgcGF0aCBlbmRzIHdpdGggXCIuXCIgYXMgYSBjb21wbGV0ZSBwYXRoIHNlZ21lbnQsXG4gICAgICAvLyB0aGF0IFwiLlwiIGlzIHJlbW92ZWQuXG4gICAgICBwYXRoID0gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpLnJlcGxhY2UoU0xBU0hfRE9UX1JFR0VYLCAnJyk7XG4gICAgICAvLyA2YykgQWxsIG9jY3VycmVuY2VzIG9mIFwiPHNlZ21lbnQ+Ly4uL1wiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuICAgICAgLy8gY29tcGxldGUgcGF0aCBzZWdtZW50IG5vdCBlcXVhbCB0byBcIi4uXCIsIGFyZSByZW1vdmVkLlxuICAgICAgLy8gUmVtb3ZhbCBvZiB0aGVzZSBwYXRoIHNlZ21lbnRzIGlzIHBlcmZvcm1lZCBpdGVyYXRpdmVseSxcbiAgICAgIC8vIHJlbW92aW5nIHRoZSBsZWZ0bW9zdCBtYXRjaGluZyBwYXR0ZXJuIG9uIGVhY2ggaXRlcmF0aW9uLFxuICAgICAgLy8gdW50aWwgbm8gbWF0Y2hpbmcgcGF0dGVybiByZW1haW5zLlxuICAgICAgLy8gNmQpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIjxzZWdtZW50Pi8uLlwiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuICAgICAgLy8gY29tcGxldGUgcGF0aCBzZWdtZW50IG5vdCBlcXVhbCB0byBcIi4uXCIsIHRoYXRcbiAgICAgIC8vIFwiPHNlZ21lbnQ+Ly4uXCIgaXMgcmVtb3ZlZC5cbiAgICAgIHdoaWxlIChwYXRoLmxlbmd0aCAhPT0gKHBhdGggPSBwYXRoLnJlcGxhY2UoU0xBU0hfRE9UX0RPVF9SRUdFWCwgJycpKS5sZW5ndGgpIHt9IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgcmV0dXJuIHBhdGguc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbiAgICB9LFxuICAgIGJ1aWxkVVJMRnJvbVBhcnRzOiBmdW5jdGlvbihwYXJ0cykge1xuICAgICAgcmV0dXJuIHBhcnRzLnNjaGVtZSArIHBhcnRzLm5ldExvYyArIHBhcnRzLnBhdGggKyBwYXJ0cy5wYXJhbXMgKyBwYXJ0cy5xdWVyeSArIHBhcnRzLmZyYWdtZW50O1xuICAgIH1cbiAgfTtcblxuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBVUkxUb29sa2l0O1xuICBlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gVVJMVG9vbGtpdDsgfSk7XG4gIGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuICAgIGV4cG9ydHNbXCJVUkxUb29sa2l0XCJdID0gVVJMVG9vbGtpdDtcbiAgZWxzZVxuICAgIHJvb3RbXCJVUkxUb29sa2l0XCJdID0gVVJMVG9vbGtpdDtcbn0pKHRoaXMpO1xuLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiIsImZ1bmN0aW9uIHdlYnBhY2tCb290c3RyYXBGdW5jIChtb2R1bGVzKSB7XG4vKioqKioqLyAgLy8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gIHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovICAvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gIGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gICAgLy8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyAgICBpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovICAgICAgcmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovICAgIC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyAgICB2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyAgICAgIGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gICAgICBsOiBmYWxzZSxcbi8qKioqKiovICAgICAgZXhwb3J0czoge31cbi8qKioqKiovICAgIH07XG5cbi8qKioqKiovICAgIC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gICAgbW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovICAgIC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovICAgIG1vZHVsZS5sID0gdHJ1ZTtcblxuLyoqKioqKi8gICAgLy8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovICB9XG5cbi8qKioqKiovICAvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovICAvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovICAvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4vKioqKioqLyAgLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyAgICBpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gICAgICAgIGdldDogZ2V0dGVyXG4vKioqKioqLyAgICAgIH0pO1xuLyoqKioqKi8gICAgfVxuLyoqKioqKi8gIH07XG5cbi8qKioqKiovICAvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovICB9O1xuXG4vKioqKioqLyAgLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovICAgIHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gICAgICBmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gICAgICBmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gICAgcmV0dXJuIGdldHRlcjtcbi8qKioqKiovICB9O1xuXG4vKioqKioqLyAgLy8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4vKioqKioqLyAgLy8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuLyoqKioqKi8gIC8vIG9uIGVycm9yIGZ1bmN0aW9uIGZvciBhc3luYyBsb2FkaW5nXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5vZSA9IGZ1bmN0aW9uKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IHRocm93IGVycjsgfTtcblxuICB2YXIgZiA9IF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gRU5UUllfTU9EVUxFKVxuICByZXR1cm4gZi5kZWZhdWx0IHx8IGYgLy8gdHJ5IHRvIGNhbGwgZGVmYXVsdCBpZiBkZWZpbmVkIHRvIGFsc28gc3VwcG9ydCBiYWJlbCBlc21vZHVsZSBleHBvcnRzXG59XG5cbnZhciBtb2R1bGVOYW1lUmVxRXhwID0gJ1tcXFxcLnxcXFxcLXxcXFxcK3xcXFxcd3xcXC98QF0rJ1xudmFyIGRlcGVuZGVuY3lSZWdFeHAgPSAnXFxcXChcXFxccyooXFwvXFxcXCouKj9cXFxcKlxcLyk/XFxcXHMqLio/KCcgKyBtb2R1bGVOYW1lUmVxRXhwICsgJykuKj9cXFxcKScgLy8gYWRkaXRpb25hbCBjaGFycyB3aGVuIG91dHB1dC5wYXRoaW5mbyBpcyB0cnVlXG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI1OTM2NjEvMTMwNDQyXG5mdW5jdGlvbiBxdW90ZVJlZ0V4cCAoc3RyKSB7XG4gIHJldHVybiAoc3RyICsgJycpLnJlcGxhY2UoL1suPyorXiRbXFxdXFxcXCgpe318LV0vZywgJ1xcXFwkJicpXG59XG5cbmZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gIHJldHVybiAhaXNOYU4oMSAqIG4pOyAvLyAxICogbiBjb252ZXJ0cyBpbnRlZ2VycywgaW50ZWdlcnMgYXMgc3RyaW5nIChcIjEyM1wiKSwgMWUzIGFuZCBcIjFlM1wiIHRvIGludGVnZXJzIGFuZCBzdHJpbmdzIHRvIE5hTlxufVxuXG5mdW5jdGlvbiBnZXRNb2R1bGVEZXBlbmRlbmNpZXMgKHNvdXJjZXMsIG1vZHVsZSwgcXVldWVOYW1lKSB7XG4gIHZhciByZXR2YWwgPSB7fVxuICByZXR2YWxbcXVldWVOYW1lXSA9IFtdXG5cbiAgdmFyIGZuU3RyaW5nID0gbW9kdWxlLnRvU3RyaW5nKClcbiAgdmFyIHdyYXBwZXJTaWduYXR1cmUgPSBmblN0cmluZy5tYXRjaCgvXmZ1bmN0aW9uXFxzP1xcdypcXChcXHcrLFxccypcXHcrLFxccyooXFx3KylcXCkvKVxuICBpZiAoIXdyYXBwZXJTaWduYXR1cmUpIHJldHVybiByZXR2YWxcbiAgdmFyIHdlYnBhY2tSZXF1aXJlTmFtZSA9IHdyYXBwZXJTaWduYXR1cmVbMV1cblxuICAvLyBtYWluIGJ1bmRsZSBkZXBzXG4gIHZhciByZSA9IG5ldyBSZWdFeHAoJyhcXFxcXFxcXG58XFxcXFcpJyArIHF1b3RlUmVnRXhwKHdlYnBhY2tSZXF1aXJlTmFtZSkgKyBkZXBlbmRlbmN5UmVnRXhwLCAnZycpXG4gIHZhciBtYXRjaFxuICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhmblN0cmluZykpKSB7XG4gICAgaWYgKG1hdGNoWzNdID09PSAnZGxsLXJlZmVyZW5jZScpIGNvbnRpbnVlXG4gICAgcmV0dmFsW3F1ZXVlTmFtZV0ucHVzaChtYXRjaFszXSlcbiAgfVxuXG4gIC8vIGRsbCBkZXBzXG4gIHJlID0gbmV3IFJlZ0V4cCgnXFxcXCgnICsgcXVvdGVSZWdFeHAod2VicGFja1JlcXVpcmVOYW1lKSArICdcXFxcKFwiKGRsbC1yZWZlcmVuY2VcXFxccygnICsgbW9kdWxlTmFtZVJlcUV4cCArICcpKVwiXFxcXClcXFxcKScgKyBkZXBlbmRlbmN5UmVnRXhwLCAnZycpXG4gIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKGZuU3RyaW5nKSkpIHtcbiAgICBpZiAoIXNvdXJjZXNbbWF0Y2hbMl1dKSB7XG4gICAgICByZXR2YWxbcXVldWVOYW1lXS5wdXNoKG1hdGNoWzFdKVxuICAgICAgc291cmNlc1ttYXRjaFsyXV0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKG1hdGNoWzFdKS5tXG4gICAgfVxuICAgIHJldHZhbFttYXRjaFsyXV0gPSByZXR2YWxbbWF0Y2hbMl1dIHx8IFtdXG4gICAgcmV0dmFsW21hdGNoWzJdXS5wdXNoKG1hdGNoWzRdKVxuICB9XG5cbiAgLy8gY29udmVydCAxZTMgYmFjayB0byAxMDAwIC0gdGhpcyBjYW4gYmUgaW1wb3J0YW50IGFmdGVyIHVnbGlmeS1qcyBjb252ZXJ0ZWQgMTAwMCB0byAxZTNcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZXR2YWwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJldHZhbFtrZXlzW2ldXS5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGlzTnVtZXJpYyhyZXR2YWxba2V5c1tpXV1bal0pKSB7XG4gICAgICAgIHJldHZhbFtrZXlzW2ldXVtqXSA9IDEgKiByZXR2YWxba2V5c1tpXV1bal07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHZhbFxufVxuXG5mdW5jdGlvbiBoYXNWYWx1ZXNJblF1ZXVlcyAocXVldWVzKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocXVldWVzKVxuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc1ZhbHVlcywga2V5KSB7XG4gICAgcmV0dXJuIGhhc1ZhbHVlcyB8fCBxdWV1ZXNba2V5XS5sZW5ndGggPiAwXG4gIH0sIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBnZXRSZXF1aXJlZE1vZHVsZXMgKHNvdXJjZXMsIG1vZHVsZUlkKSB7XG4gIHZhciBtb2R1bGVzUXVldWUgPSB7XG4gICAgbWFpbjogW21vZHVsZUlkXVxuICB9XG4gIHZhciByZXF1aXJlZE1vZHVsZXMgPSB7XG4gICAgbWFpbjogW11cbiAgfVxuICB2YXIgc2Vlbk1vZHVsZXMgPSB7XG4gICAgbWFpbjoge31cbiAgfVxuXG4gIHdoaWxlIChoYXNWYWx1ZXNJblF1ZXVlcyhtb2R1bGVzUXVldWUpKSB7XG4gICAgdmFyIHF1ZXVlcyA9IE9iamVjdC5rZXlzKG1vZHVsZXNRdWV1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHF1ZXVlTmFtZSA9IHF1ZXVlc1tpXVxuICAgICAgdmFyIHF1ZXVlID0gbW9kdWxlc1F1ZXVlW3F1ZXVlTmFtZV1cbiAgICAgIHZhciBtb2R1bGVUb0NoZWNrID0gcXVldWUucG9wKClcbiAgICAgIHNlZW5Nb2R1bGVzW3F1ZXVlTmFtZV0gPSBzZWVuTW9kdWxlc1txdWV1ZU5hbWVdIHx8IHt9XG4gICAgICBpZiAoc2Vlbk1vZHVsZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSB8fCAhc291cmNlc1txdWV1ZU5hbWVdW21vZHVsZVRvQ2hlY2tdKSBjb250aW51ZVxuICAgICAgc2Vlbk1vZHVsZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSA9IHRydWVcbiAgICAgIHJlcXVpcmVkTW9kdWxlc1txdWV1ZU5hbWVdID0gcmVxdWlyZWRNb2R1bGVzW3F1ZXVlTmFtZV0gfHwgW11cbiAgICAgIHJlcXVpcmVkTW9kdWxlc1txdWV1ZU5hbWVdLnB1c2gobW9kdWxlVG9DaGVjaylcbiAgICAgIHZhciBuZXdNb2R1bGVzID0gZ2V0TW9kdWxlRGVwZW5kZW5jaWVzKHNvdXJjZXMsIHNvdXJjZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSwgcXVldWVOYW1lKVxuICAgICAgdmFyIG5ld01vZHVsZXNLZXlzID0gT2JqZWN0LmtleXMobmV3TW9kdWxlcylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3TW9kdWxlc0tleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXSA9IG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0gfHwgW11cbiAgICAgICAgbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXSA9IG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0uY29uY2F0KG5ld01vZHVsZXNbbmV3TW9kdWxlc0tleXNbal1dKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXF1aXJlZE1vZHVsZXNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobW9kdWxlSWQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIHNvdXJjZXMgPSB7XG4gICAgbWFpbjogX193ZWJwYWNrX21vZHVsZXNfX1xuICB9XG5cbiAgdmFyIHJlcXVpcmVkTW9kdWxlcyA9IG9wdGlvbnMuYWxsID8geyBtYWluOiBPYmplY3Qua2V5cyhzb3VyY2VzLm1haW4pIH0gOiBnZXRSZXF1aXJlZE1vZHVsZXMoc291cmNlcywgbW9kdWxlSWQpXG5cbiAgdmFyIHNyYyA9ICcnXG5cbiAgT2JqZWN0LmtleXMocmVxdWlyZWRNb2R1bGVzKS5maWx0ZXIoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0gIT09ICdtYWluJyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICB2YXIgZW50cnlNb2R1bGUgPSAwXG4gICAgd2hpbGUgKHJlcXVpcmVkTW9kdWxlc1ttb2R1bGVdW2VudHJ5TW9kdWxlXSkge1xuICAgICAgZW50cnlNb2R1bGUrK1xuICAgIH1cbiAgICByZXF1aXJlZE1vZHVsZXNbbW9kdWxlXS5wdXNoKGVudHJ5TW9kdWxlKVxuICAgIHNvdXJjZXNbbW9kdWxlXVtlbnRyeU1vZHVsZV0gPSAnKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgeyBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX187IH0pJ1xuICAgIHNyYyA9IHNyYyArICd2YXIgJyArIG1vZHVsZSArICcgPSAoJyArIHdlYnBhY2tCb290c3RyYXBGdW5jLnRvU3RyaW5nKCkucmVwbGFjZSgnRU5UUllfTU9EVUxFJywgSlNPTi5zdHJpbmdpZnkoZW50cnlNb2R1bGUpKSArICcpKHsnICsgcmVxdWlyZWRNb2R1bGVzW21vZHVsZV0ubWFwKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gJycgKyBKU09OLnN0cmluZ2lmeShpZCkgKyAnOiAnICsgc291cmNlc1ttb2R1bGVdW2lkXS50b1N0cmluZygpIH0pLmpvaW4oJywnKSArICd9KTtcXG4nXG4gIH0pXG5cbiAgc3JjID0gc3JjICsgJ25ldyAoKCcgKyB3ZWJwYWNrQm9vdHN0cmFwRnVuYy50b1N0cmluZygpLnJlcGxhY2UoJ0VOVFJZX01PRFVMRScsIEpTT04uc3RyaW5naWZ5KG1vZHVsZUlkKSkgKyAnKSh7JyArIHJlcXVpcmVkTW9kdWxlcy5tYWluLm1hcChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuICcnICsgSlNPTi5zdHJpbmdpZnkoaWQpICsgJzogJyArIHNvdXJjZXMubWFpbltpZF0udG9TdHJpbmcoKSB9KS5qb2luKCcsJykgKyAnfSkpKHNlbGYpOydcblxuICB2YXIgYmxvYiA9IG5ldyB3aW5kb3cuQmxvYihbc3JjXSwgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KVxuICBpZiAob3B0aW9ucy5iYXJlKSB7IHJldHVybiBibG9iIH1cblxuICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMXG5cbiAgdmFyIHdvcmtlclVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgdmFyIHdvcmtlciA9IG5ldyB3aW5kb3cuV29ya2VyKHdvcmtlclVybClcbiAgd29ya2VyLm9iamVjdFVSTCA9IHdvcmtlclVybFxuXG4gIHJldHVybiB3b3JrZXJcbn1cbiIsIi8qKlxuICogSExTIGNvbmZpZ1xuICovXG5cbmltcG9ydCBBYnJDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9hYnItY29udHJvbGxlcic7XG5pbXBvcnQgQnVmZmVyQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXInO1xuaW1wb3J0IENhcExldmVsQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvY2FwLWxldmVsLWNvbnRyb2xsZXInO1xuaW1wb3J0IEZQU0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyJztcbmltcG9ydCBYaHJMb2FkZXIgZnJvbSAnLi91dGlscy94aHItbG9hZGVyJztcbi8vIGltcG9ydCBGZXRjaExvYWRlciBmcm9tICcuL3V0aWxzL2ZldGNoLWxvYWRlcic7XG5cbmltcG9ydCBBdWRpb1RyYWNrQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlcic7XG5pbXBvcnQgQXVkaW9TdHJlYW1Db250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlcic7XG5cbmltcG9ydCAqIGFzIEN1ZXMgZnJvbSAnLi91dGlscy9jdWVzJztcbmltcG9ydCBUaW1lbGluZUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXInO1xuaW1wb3J0IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9zdWJ0aXRsZS10cmFjay1jb250cm9sbGVyJztcbmltcG9ydCB7IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciB9IGZyb20gJy4vY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgRU1FQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvZW1lLWNvbnRyb2xsZXInO1xuXG5pbXBvcnQgeyByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgfSBmcm9tICcuL3V0aWxzL21lZGlha2V5cy1oZWxwZXInO1xuXG5leHBvcnQgdmFyIGhsc0RlZmF1bHRDb25maWcgPSB7XG4gIGF1dG9TdGFydExvYWQ6IHRydWUsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgc3RhcnRQb3NpdGlvbjogLTEsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZGVmYXVsdEF1ZGlvQ29kZWM6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBkZWJ1ZzogZmFsc2UsIC8vIHVzZWQgYnkgbG9nZ2VyXG4gIGNhcExldmVsT25GUFNEcm9wOiBmYWxzZSwgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBjYXBMZXZlbFRvUGxheWVyU2l6ZTogZmFsc2UsIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgaW5pdGlhbExpdmVNYW5pZmVzdFNpemU6IDEsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4QnVmZmVyTGVuZ3RoOiAzMCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhCdWZmZXJTaXplOiA2MCAqIDEwMDAgKiAxMDAwLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEJ1ZmZlckhvbGU6IDAuNSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuXG4gIGxvd0J1ZmZlcldhdGNoZG9nUGVyaW9kOiAwLjUsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kOiAzLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG51ZGdlT2Zmc2V0OiAwLjEsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbnVkZ2VNYXhSZXRyeTogMywgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlOiAwLjI1LCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGxpdmVTeW5jRHVyYXRpb25Db3VudDogMywgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQ6IEluZmluaXR5LCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGxpdmVTeW5jRHVyYXRpb246IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbGl2ZUR1cmF0aW9uSW5maW5pdHk6IGZhbHNlLCAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIGxpdmVCYWNrQnVmZmVyTGVuZ3RoOiBJbmZpbml0eSwgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICBtYXhNYXhCdWZmZXJMZW5ndGg6IDYwMCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBlbmFibGVXb3JrZXI6IHRydWUsIC8vIHVzZWQgYnkgZGVtdXhlclxuICBlbmFibGVTb2Z0d2FyZUFFUzogdHJ1ZSwgLy8gdXNlZCBieSBkZWNyeXB0ZXJcbiAgbWFuaWZlc3RMb2FkaW5nVGltZU91dDogMTAwMDAsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5OiAxLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBtYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBzdGFydExldmVsOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgbGV2ZWwtY29udHJvbGxlclxuICBsZXZlbExvYWRpbmdUaW1lT3V0OiAxMDAwMCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgbGV2ZWxMb2FkaW5nTWF4UmV0cnk6IDQsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIGxldmVsTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIGxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIGZyYWdMb2FkaW5nVGltZU91dDogMjAwMDAsIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gIGZyYWdMb2FkaW5nTWF4UmV0cnk6IDYsIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gIGZyYWdMb2FkaW5nUmV0cnlEZWxheTogMTAwMCwgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLCAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBzdGFydEZyYWdQcmVmZXRjaDogZmFsc2UsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2Q6IDUwMDAsIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQ6IDAuMiwgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBhcHBlbmRFcnJvck1heFJldHJ5OiAzLCAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIGxvYWRlcjogWGhyTG9hZGVyLFxuICAvLyBsb2FkZXI6IEZldGNoTG9hZGVyLFxuICBmTG9hZGVyOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gIHBMb2FkZXI6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgeGhyU2V0dXA6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSB4aHItbG9hZGVyXG4gIGxpY2Vuc2VYaHJTZXR1cDogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIC8vIGZldGNoU2V0dXA6IHVuZGVmaW5lZCxcbiAgYWJyQ29udHJvbGxlcjogQWJyQ29udHJvbGxlcixcbiAgYnVmZmVyQ29udHJvbGxlcjogQnVmZmVyQ29udHJvbGxlcixcbiAgY2FwTGV2ZWxDb250cm9sbGVyOiBDYXBMZXZlbENvbnRyb2xsZXIsXG4gIGZwc0NvbnRyb2xsZXI6IEZQU0NvbnRyb2xsZXIsXG4gIHN0cmV0Y2hTaG9ydFZpZGVvVHJhY2s6IGZhbHNlLCAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXG4gIG1heEF1ZGlvRnJhbWVzRHJpZnQ6IDEsIC8vIHVzZWQgYnkgbXA0LXJlbXV4ZXJcbiAgZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eTogdHJ1ZSwgLy8gdXNlZCBieSB0cy1kZW11eGVyXG4gIGFickV3bWFGYXN0TGl2ZTogMywgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hU2xvd0xpdmU6IDksIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYUZhc3RWb0Q6IDMsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYVNsb3dWb0Q6IDksIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTogNWU1LCAvLyA1MDAga2JwcyAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJCYW5kV2lkdGhGYWN0b3I6IDAuOTUsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyQmFuZFdpZHRoVXBGYWN0b3I6IDAuNywgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJNYXhXaXRoUmVhbEJpdHJhdGU6IGZhbHNlLCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1heFN0YXJ2YXRpb25EZWxheTogNCwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtYXhMb2FkaW5nRGVsYXk6IDQsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWluQXV0b0JpdHJhdGU6IDAsIC8vIHVzZWQgYnkgaGxzXG4gIGVtZUVuYWJsZWQ6IGZhbHNlLCAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHdpZGV2aW5lTGljZW5zZVVybDogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmM6XG4gICAgICAgICAgICByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxufTtcblxuXG4gIGhsc0RlZmF1bHRDb25maWcuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyID0gU3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xuICBobHNEZWZhdWx0Q29uZmlnLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gU3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gIGhsc0RlZmF1bHRDb25maWcudGltZWxpbmVDb250cm9sbGVyID0gVGltZWxpbmVDb250cm9sbGVyO1xuICBobHNEZWZhdWx0Q29uZmlnLmN1ZUhhbmRsZXIgPSBDdWVzOyAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgaGxzRGVmYXVsdENvbmZpZy5lbmFibGVDRUE3MDhDYXB0aW9ucyA9IHRydWU7IC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICBobHNEZWZhdWx0Q29uZmlnLmVuYWJsZVdlYlZUVCA9IHRydWU7IC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICBobHNEZWZhdWx0Q29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhYmVsID0gJ0VuZ2xpc2gnOyAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgaGxzRGVmYXVsdENvbmZpZy5jYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGUgPSAnZW4nOyAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgaGxzRGVmYXVsdENvbmZpZy5jYXB0aW9uc1RleHRUcmFjazJMYWJlbCA9ICdTcGFuaXNoJzsgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gIGhsc0RlZmF1bHRDb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlID0gJ2VzJzsgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG5cblxuICBobHNEZWZhdWx0Q29uZmlnLmF1ZGlvU3RyZWFtQ29udHJvbGxlciA9IEF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcbiAgaGxzRGVmYXVsdENvbmZpZy5hdWRpb1RyYWNrQ29udHJvbGxlciA9IEF1ZGlvVHJhY2tDb250cm9sbGVyO1xuXG5cbiAgaGxzRGVmYXVsdENvbmZpZy5lbWVDb250cm9sbGVyID0gRU1FQ29udHJvbGxlcjtcblxuIiwiLypcbiAqIHNpbXBsZSBBQlIgQ29udHJvbGxlclxuICogIC0gY29tcHV0ZSBuZXh0IGxldmVsIGJhc2VkIG9uIGxhc3QgZnJhZ21lbnQgYncgaGV1cmlzdGljc1xuICogIC0gaW1wbGVtZW50IGFuIGFiYW5kb24gcnVsZXMgdHJpZ2dlcmVkIGlmIHdlIGhhdmUgbGVzcyB0aGFuIDIgZnJhZyBidWZmZXJlZCBhbmQgaWYgY29tcHV0ZWQgYncgc2hvd3MgdGhhdCB3ZSByaXNrIGJ1ZmZlciBzdGFsbGluZ1xuICovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7IEJ1ZmZlckhlbHBlciB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IHsgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgRXdtYUJhbmRXaWR0aEVzdGltYXRvciBmcm9tICcuLi91dGlscy9ld21hLWJhbmR3aWR0aC1lc3RpbWF0b3InO1xuXG5jb25zdCB7IHBlcmZvcm1hbmNlIH0gPSB3aW5kb3c7XG5cbmNsYXNzIEFickNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCBFdmVudC5GUkFHX0xPQURJTkcsXG4gICAgICBFdmVudC5GUkFHX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfQlVGRkVSRUQsXG4gICAgICBFdmVudC5FUlJPUik7XG4gICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gMDtcbiAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgdGhpcy5fYndFc3RpbWF0b3IgPSBudWxsO1xuICAgIHRoaXMub25DaGVjayA9IHRoaXMuX2FiYW5kb25SdWxlc0NoZWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIG9uRnJhZ0xvYWRpbmcgKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIGlmIChmcmFnLnR5cGUgPT09ICdtYWluJykge1xuICAgICAgaWYgKCF0aGlzLnRpbWVyKSB7XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbkNoZWNrLCAxMDApO1xuICAgICAgfVxuXG4gICAgICAvLyBsYXp5IGluaXQgb2YgQndFc3RpbWF0b3IsIHJhdGlvbmFsZSBpcyB0aGF0IHdlIHVzZSBkaWZmZXJlbnQgcGFyYW1zIGZvciBMaXZlL1ZvRFxuICAgICAgLy8gc28gd2UgbmVlZCB0byB3YWl0IGZvciBzdHJlYW0gbWFuaWZlc3QgLyBwbGF5bGlzdCB0eXBlIHRvIGluc3RhbnRpYXRlIGl0LlxuICAgICAgaWYgKCF0aGlzLl9id0VzdGltYXRvcikge1xuICAgICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAgICAgY29uc3QgY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBmcmFnLmxldmVscztcbiAgICAgICAgY29uc3QgaXNMaXZlID0gaGxzLmxldmVsc1tsZXZlbF0uZGV0YWlscy5saXZlO1xuXG4gICAgICAgIGxldCBld21hRmFzdCwgZXdtYVNsb3c7XG4gICAgICAgIGlmIChpc0xpdmUpIHtcbiAgICAgICAgICBld21hRmFzdCA9IGNvbmZpZy5hYnJFd21hRmFzdExpdmU7XG4gICAgICAgICAgZXdtYVNsb3cgPSBjb25maWcuYWJyRXdtYVNsb3dMaXZlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV3bWFGYXN0ID0gY29uZmlnLmFickV3bWFGYXN0Vm9EO1xuICAgICAgICAgIGV3bWFTbG93ID0gY29uZmlnLmFickV3bWFTbG93Vm9EO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J3RXN0aW1hdG9yID0gbmV3IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IoaGxzLCBld21hU2xvdywgZXdtYUZhc3QsIGNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfYWJhbmRvblJ1bGVzQ2hlY2sgKCkge1xuICAgIC8qXG4gICAgICBtb25pdG9yIGZyYWdtZW50IHJldHJpZXZhbCB0aW1lLi4uXG4gICAgICB3ZSBjb21wdXRlIGV4cGVjdGVkIHRpbWUgb2YgYXJyaXZhbCBvZiB0aGUgY29tcGxldGUgZnJhZ21lbnQuXG4gICAgICB3ZSBjb21wYXJlIGl0IHRvIGV4cGVjdGVkIHRpbWUgb2YgYnVmZmVyIHN0YXJ2YXRpb25cbiAgICAqL1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IHZpZGVvID0gaGxzLm1lZGlhO1xuICAgIGNvbnN0IGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuXG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgY29uc3QgbWluQXV0b0xldmVsID0gaGxzLm1pbkF1dG9MZXZlbDtcblxuICAgIC8vIGlmIGxvYWRlciBoYXMgYmVlbiBkZXN0cm95ZWQgb3IgbG9hZGluZyBoYXMgYmVlbiBhYm9ydGVkLCBzdG9wIHRpbWVyIGFuZCByZXR1cm5cbiAgICBpZiAoIWxvYWRlciB8fCAobG9hZGVyLnN0YXRzICYmIGxvYWRlci5zdGF0cy5hYm9ydGVkKSkge1xuICAgICAgbG9nZ2VyLndhcm4oJ2ZyYWcgbG9hZGVyIGRlc3Ryb3kgb3IgYWJvcnRlZCwgZGlzYXJtIGFiYW5kb25SdWxlcycpO1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAvLyByZXNldCBmb3JjZWQgYXV0byBsZXZlbCB2YWx1ZSBzbyB0aGF0IG5leHQgbGV2ZWwgd2lsbCBiZSBzZWxlY3RlZFxuICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc3RhdHMgPSBsb2FkZXIuc3RhdHM7XG4gICAgLyogb25seSBtb25pdG9yIGZyYWcgcmV0cmlldmFsIHRpbWUgaWZcbiAgICAodmlkZW8gbm90IHBhdXNlZCBPUiBmaXJzdCBmcmFnbWVudCBiZWluZyBsb2FkZWQocmVhZHkgc3RhdGUgPT09IEhBVkVfTk9USElORyA9IDApKSBBTkQgYXV0b3N3aXRjaGluZyBlbmFibGVkIEFORCBub3QgbG93ZXN0IGxldmVsICg9PiBtZWFucyB0aGF0IHdlIGhhdmUgc2V2ZXJhbCBsZXZlbHMpICovXG4gICAgaWYgKHZpZGVvICYmIHN0YXRzICYmICgoIXZpZGVvLnBhdXNlZCAmJiAodmlkZW8ucGxheWJhY2tSYXRlICE9PSAwKSkgfHwgIXZpZGVvLnJlYWR5U3RhdGUpICYmIGZyYWcuYXV0b0xldmVsICYmIGZyYWcubGV2ZWxzKSB7XG4gICAgICBsZXQgcmVxdWVzdERlbGF5ID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGF0cy50cmVxdWVzdCxcbiAgICAgICAgcGxheWJhY2tSYXRlID0gTWF0aC5hYnModmlkZW8ucGxheWJhY2tSYXRlKTtcbiAgICAgIC8vIG1vbml0b3IgZnJhZ21lbnQgbG9hZCBwcm9ncmVzcyBhZnRlciBoYWxmIG9mIGV4cGVjdGVkIGZyYWdtZW50IGR1cmF0aW9uLHRvIHN0YWJpbGl6ZSBiaXRyYXRlXG4gICAgICBpZiAocmVxdWVzdERlbGF5ID4gKDUwMCAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpKSB7XG4gICAgICAgIGxldCBsZXZlbHMgPSBobHMubGV2ZWxzLFxuICAgICAgICAgIGxvYWRSYXRlID0gTWF0aC5tYXgoMSwgc3RhdHMuYncgPyBzdGF0cy5idyAvIDggOiBzdGF0cy5sb2FkZWQgKiAxMDAwIC8gcmVxdWVzdERlbGF5KSwgLy8gYnl0ZS9zOyBhdCBsZWFzdCAxIGJ5dGUvcyB0byBhdm9pZCBkaXZpc2lvbiBieSB6ZXJvXG4gICAgICAgICAgLy8gY29tcHV0ZSBleHBlY3RlZCBmcmFnbWVudCBsZW5ndGggdXNpbmcgZnJhZyBkdXJhdGlvbiBhbmQgbGV2ZWwgYml0cmF0ZS4gYWxzbyBlbnN1cmUgdGhhdCBleHBlY3RlZCBsZW4gaXMgZ3RlIHRoYW4gYWxyZWFkeSBsb2FkZWQgc2l6ZVxuICAgICAgICAgIGxldmVsID0gbGV2ZWxzW2ZyYWcubGV2ZWxzXSxcbiAgICAgICAgICBsZXZlbEJpdHJhdGUgPSBsZXZlbC5yZWFsQml0cmF0ZSA/IE1hdGgubWF4KGxldmVsLnJlYWxCaXRyYXRlLCBsZXZlbC5iaXRyYXRlKSA6IGxldmVsLmJpdHJhdGUsXG4gICAgICAgICAgZXhwZWN0ZWRMZW4gPSBzdGF0cy50b3RhbCA/IHN0YXRzLnRvdGFsIDogTWF0aC5tYXgoc3RhdHMubG9hZGVkLCBNYXRoLnJvdW5kKGZyYWcuZHVyYXRpb24gKiBsZXZlbEJpdHJhdGUgLyA4KSksXG4gICAgICAgICAgcG9zID0gdmlkZW8uY3VycmVudFRpbWUsXG4gICAgICAgICAgZnJhZ0xvYWRlZERlbGF5ID0gKGV4cGVjdGVkTGVuIC0gc3RhdHMubG9hZGVkKSAvIGxvYWRSYXRlLFxuICAgICAgICAgIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9IChCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh2aWRlbywgcG9zLCBobHMuY29uZmlnLm1heEJ1ZmZlckhvbGUpLmVuZCAtIHBvcykgLyBwbGF5YmFja1JhdGU7XG4gICAgICAgIC8vIGNvbnNpZGVyIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBvbmx5IGlmIHdlIGhhdmUgbGVzcyB0aGFuIDIgZnJhZyBidWZmZXJlZCBBTkRcbiAgICAgICAgLy8gdGltZSB0byBmaW5pc2ggbG9hZGluZyBjdXJyZW50IGZyYWdtZW50IGlzIGJpZ2dlciB0aGFuIGJ1ZmZlciBzdGFydmF0aW9uIGRlbGF5XG4gICAgICAgIC8vIGllIGlmIHdlIHJpc2sgYnVmZmVyIHN0YXJ2YXRpb24gaWYgYncgZG9lcyBub3QgaW5jcmVhc2UgcXVpY2tseVxuICAgICAgICBpZiAoKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA8ICgyICogZnJhZy5kdXJhdGlvbiAvIHBsYXliYWNrUmF0ZSkpICYmIChmcmFnTG9hZGVkRGVsYXkgPiBidWZmZXJTdGFydmF0aW9uRGVsYXkpKSB7XG4gICAgICAgICAgbGV0IGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSwgbmV4dExvYWRMZXZlbDtcbiAgICAgICAgICAvLyBsZXRzIGl0ZXJhdGUgdGhyb3VnaCBsb3dlciBsZXZlbCBhbmQgdHJ5IHRvIGZpbmQgdGhlIGJpZ2dlc3Qgb25lIHRoYXQgY291bGQgYXZvaWQgcmVidWZmZXJpbmdcbiAgICAgICAgICAvLyB3ZSBzdGFydCBmcm9tIGN1cnJlbnQgbGV2ZWwgLSAxIGFuZCB3ZSBzdGVwIGRvd24gLCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2hpbmcgbGV2ZWxcbiAgICAgICAgICBmb3IgKG5leHRMb2FkTGV2ZWwgPSBmcmFnLmxldmVscyAtIDE7IG5leHRMb2FkTGV2ZWwgPiBtaW5BdXRvTGV2ZWw7IG5leHRMb2FkTGV2ZWwtLSkge1xuICAgICAgICAgICAgLy8gY29tcHV0ZSB0aW1lIHRvIGxvYWQgbmV4dCBmcmFnbWVudCBhdCBsb3dlciBsZXZlbFxuICAgICAgICAgICAgLy8gMC44IDogY29uc2lkZXIgb25seSA4MCUgb2YgY3VycmVudCBidyB0byBiZSBjb25zZXJ2YXRpdmVcbiAgICAgICAgICAgIC8vIDggPSBiaXRzIHBlciBieXRlIChicHMvQnBzKVxuICAgICAgICAgICAgbGV0IGxldmVsTmV4dEJpdHJhdGUgPSBsZXZlbHNbbmV4dExvYWRMZXZlbF0ucmVhbEJpdHJhdGUgPyBNYXRoLm1heChsZXZlbHNbbmV4dExvYWRMZXZlbF0ucmVhbEJpdHJhdGUsIGxldmVsc1tuZXh0TG9hZExldmVsXS5iaXRyYXRlKSA6IGxldmVsc1tuZXh0TG9hZExldmVsXS5iaXRyYXRlO1xuICAgICAgICAgICAgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gZnJhZy5kdXJhdGlvbiAqIGxldmVsTmV4dEJpdHJhdGUgLyAoOCAqIDAuOCAqIGxvYWRSYXRlKTtcbiAgICAgICAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPCBidWZmZXJTdGFydmF0aW9uRGVsYXkpIHtcbiAgICAgICAgICAgICAgLy8gd2UgZm91bmQgYSBsb3dlciBsZXZlbCB0aGF0IGJlIHJlYnVmZmVyaW5nIGZyZWUgd2l0aCBjdXJyZW50IGVzdGltYXRlZCBidyAhXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBvbmx5IGVtZXJnZW5jeSBzd2l0Y2ggZG93biBpZiBpdCB0YWtlcyBsZXNzIHRpbWUgdG8gbG9hZCBuZXcgZnJhZ21lbnQgYXQgbG93ZXN0IGxldmVsIGluc3RlYWRcbiAgICAgICAgICAvLyBvZiBmaW5pc2hpbmcgbG9hZGluZyBjdXJyZW50IG9uZSAuLi5cbiAgICAgICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5IDwgZnJhZ0xvYWRlZERlbGF5KSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgbG9hZGluZyB0b28gc2xvdywgYWJvcnQgZnJhZ21lbnQgbG9hZGluZyBhbmQgc3dpdGNoIHRvIGxldmVsICR7bmV4dExvYWRMZXZlbH06ZnJhZ0xvYWRlZERlbGF5WyR7bmV4dExvYWRMZXZlbH1dPGZyYWdMb2FkZWREZWxheVske2ZyYWcubGV2ZWxzIC0gMX1dO2J1ZmZlclN0YXJ2YXRpb25EZWxheToke2ZyYWdMZXZlbE5leHRMb2FkZWREZWxheS50b0ZpeGVkKDEpfTwke2ZyYWdMb2FkZWREZWxheS50b0ZpeGVkKDEpfToke2J1ZmZlclN0YXJ2YXRpb25EZWxheS50b0ZpeGVkKDEpfWApO1xuICAgICAgICAgICAgLy8gZm9yY2UgbmV4dCBsb2FkIGxldmVsIGluIGF1dG8gbW9kZVxuICAgICAgICAgICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBuZXh0TG9hZExldmVsO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGJ3IGVzdGltYXRlIGZvciB0aGlzIGZyYWdtZW50IGJlZm9yZSBjYW5jZWxsaW5nIGxvYWQgKHRoaXMgd2lsbCBoZWxwIHJlZHVjaW5nIHRoZSBidylcbiAgICAgICAgICAgIHRoaXMuX2J3RXN0aW1hdG9yLnNhbXBsZShyZXF1ZXN0RGVsYXksIHN0YXRzLmxvYWRlZCk7XG4gICAgICAgICAgICAvLyBhYm9ydCBmcmFnbWVudCBsb2FkaW5nXG4gICAgICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIC8vIHN0b3AgYWJhbmRvbiBydWxlcyB0aW1lclxuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHsgZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0xvYWRlZCAoZGF0YSkge1xuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gJ21haW4nICYmIE51bWJlci5pc0Zpbml0ZShmcmFnLnNuKSkge1xuICAgICAgLy8gc3RvcCBtb25pdG9yaW5nIGJ3IG9uY2UgZnJhZyBsb2FkZWRcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgLy8gc3RvcmUgbGV2ZWwgaWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBmcmFnbWVudCBsb2FkXG4gICAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSBmcmFnLmxldmVscztcbiAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXG4gICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG5cbiAgICAgIC8vIGNvbXB1dGUgbGV2ZWwgYXZlcmFnZSBiaXRyYXRlXG4gICAgICBpZiAodGhpcy5obHMuY29uZmlnLmFick1heFdpdGhSZWFsQml0cmF0ZSkge1xuICAgICAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tmcmFnLmxldmVsc107XG4gICAgICAgIGxldCBsb2FkZWRCeXRlcyA9IChsZXZlbC5sb2FkZWQgPyBsZXZlbC5sb2FkZWQuYnl0ZXMgOiAwKSArIGRhdGEuc3RhdHMubG9hZGVkO1xuICAgICAgICBsZXQgbG9hZGVkRHVyYXRpb24gPSAobGV2ZWwubG9hZGVkID8gbGV2ZWwubG9hZGVkLmR1cmF0aW9uIDogMCkgKyBkYXRhLmZyYWcuZHVyYXRpb247XG4gICAgICAgIGxldmVsLmxvYWRlZCA9IHsgYnl0ZXM6IGxvYWRlZEJ5dGVzLCBkdXJhdGlvbjogbG9hZGVkRHVyYXRpb24gfTtcbiAgICAgICAgbGV2ZWwucmVhbEJpdHJhdGUgPSBNYXRoLnJvdW5kKDggKiBsb2FkZWRCeXRlcyAvIGxvYWRlZER1cmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIGZyYWdtZW50IGhhcyBiZWVuIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0LFxuICAgICAgaWYgKGRhdGEuZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgICBsZXQgc3RhdHMgPSBkYXRhLnN0YXRzO1xuICAgICAgICBzdGF0cy50cGFyc2VkID0gc3RhdHMudGJ1ZmZlcmVkID0gc3RhdHMudGxvYWQ7XG4gICAgICAgIHRoaXMub25GcmFnQnVmZmVyZWQoZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25GcmFnQnVmZmVyZWQgKGRhdGEpIHtcbiAgICBjb25zdCBzdGF0cyA9IGRhdGEuc3RhdHM7XG4gICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAvLyBvbmx5IHVwZGF0ZSBzdGF0cyBvbiBmaXJzdCBmcmFnIGJ1ZmZlcmluZ1xuICAgIC8vIGlmIHNhbWUgZnJhZyBpcyBsb2FkZWQgbXVsdGlwbGUgdGltZXMsIGl0IG1pZ2h0IGJlIGluIGJyb3dzZXIgY2FjaGUsIGFuZCBsb2FkZWQgcXVpY2tseVxuICAgIC8vIGFuZCBsZWFkaW5nIHRvIHdyb25nIGJ3IGVzdGltYXRpb25cbiAgICAvLyBvbiBiaXRyYXRlIHRlc3QsIGFsc28gb25seSB1cGRhdGUgc3RhdHMgb25jZSAoaWYgdGxvYWQgPSB0YnVmZmVyZWQgPT0gb24gRlJBR19MT0FERUQpXG4gICAgaWYgKHN0YXRzLmFib3J0ZWQgIT09IHRydWUgJiYgZnJhZy50eXBlID09PSAnbWFpbicgJiYgTnVtYmVyLmlzRmluaXRlKGZyYWcuc24pICYmICgoIWZyYWcuYml0cmF0ZVRlc3QgfHwgc3RhdHMudGxvYWQgPT09IHN0YXRzLnRidWZmZXJlZCkpKSB7XG4gICAgICAvLyB1c2UgdHBhcnNlZC10cmVxdWVzdCBpbnN0ZWFkIG9mIHRidWZmZXJlZC10cmVxdWVzdCB0byBjb21wdXRlIGZyYWdMb2FkaW5nUHJvY2Vzc2luZzsgcmF0aW9uYWxlIGlzIHRoYXQgIGJ1ZmZlciBhcHBlbmRpbmcgb25seSBoYXBwZW5zIG9uY2UgbWVkaWEgaXMgYXR0YWNoZWRcbiAgICAgIC8vIGluIGNhc2Ugd2UgdXNlIGNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCB3aGlsZSBtZWRpYSBpcyBub3QgYXR0YWNoZWQgeWV0LCBmcmFnbWVudCBtaWdodCBiZSBwYXJzZWQgd2hpbGUgbWVkaWEgbm90IGF0dGFjaGVkIHlldCwgYnV0IGl0IHdpbGwgb25seSBiZSBidWZmZXJlZCBvbiBtZWRpYSBhdHRhY2hlZFxuICAgICAgLy8gYXMgYSBjb25zZXF1ZW5jZSBpdCBjb3VsZCBoYXBwZW4gcmVhbGx5IGxhdGUgaW4gdGhlIHByb2Nlc3MuIG1lYW5pbmcgdGhhdCBhcHBlbmRpbmcgZHVyYXRpb24gbWlnaHQgYXBwZWFycyBodWdlIC4uLiBsZWFkaW5nIHRvIHVuZGVyZXN0aW1hdGVkIHRocm91Z2hwdXQgZXN0aW1hdGlvblxuICAgICAgbGV0IGZyYWdMb2FkaW5nUHJvY2Vzc2luZ01zID0gc3RhdHMudHBhcnNlZCAtIHN0YXRzLnRyZXF1ZXN0O1xuICAgICAgbG9nZ2VyLmxvZyhgbGF0ZW5jeS9sb2FkaW5nL3BhcnNpbmcvYXBwZW5kL2ticHM6JHtNYXRoLnJvdW5kKHN0YXRzLnRmaXJzdCAtIHN0YXRzLnRyZXF1ZXN0KX0vJHtNYXRoLnJvdW5kKHN0YXRzLnRsb2FkIC0gc3RhdHMudGZpcnN0KX0vJHtNYXRoLnJvdW5kKHN0YXRzLnRwYXJzZWQgLSBzdGF0cy50bG9hZCl9LyR7TWF0aC5yb3VuZChzdGF0cy50YnVmZmVyZWQgLSBzdGF0cy50cGFyc2VkKX0vJHtNYXRoLnJvdW5kKDggKiBzdGF0cy5sb2FkZWQgLyAoc3RhdHMudGJ1ZmZlcmVkIC0gc3RhdHMudHJlcXVlc3QpKX1gKTtcbiAgICAgIHRoaXMuX2J3RXN0aW1hdG9yLnNhbXBsZShmcmFnTG9hZGluZ1Byb2Nlc3NpbmdNcywgc3RhdHMubG9hZGVkKTtcbiAgICAgIHN0YXRzLmJ3RXN0aW1hdGUgPSB0aGlzLl9id0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpO1xuICAgICAgLy8gaWYgZnJhZ21lbnQgaGFzIGJlZW4gbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3QsIChobHMuc3RhcnRMZXZlbCA9IC0xKSwgc3RvcmUgYml0cmF0ZSB0ZXN0IGRlbGF5IGR1cmF0aW9uXG4gICAgICBpZiAoZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSBmcmFnTG9hZGluZ1Byb2Nlc3NpbmdNcyAvIDEwMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IgKGRhdGEpIHtcbiAgICAvLyBzdG9wIHRpbWVyIGluIGNhc2Ugb2YgZnJhZyBsb2FkaW5nIGVycm9yXG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjbGVhclRpbWVyICgpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgIHRoaXMudGltZXIgPSBudWxsO1xuICB9XG5cbiAgLy8gcmV0dXJuIG5leHQgYXV0byBsZXZlbFxuICBnZXQgbmV4dEF1dG9MZXZlbCAoKSB7XG4gICAgY29uc3QgZm9yY2VkQXV0b0xldmVsID0gdGhpcy5fbmV4dEF1dG9MZXZlbDtcbiAgICBjb25zdCBid0VzdGltYXRvciA9IHRoaXMuX2J3RXN0aW1hdG9yO1xuICAgIC8vIGluIGNhc2UgbmV4dCBhdXRvIGxldmVsIGhhcyBiZWVuIGZvcmNlZCwgYW5kIGJ3IG5vdCBhdmFpbGFibGUgb3Igbm90IHJlbGlhYmxlLCByZXR1cm4gZm9yY2VkIHZhbHVlXG4gICAgaWYgKGZvcmNlZEF1dG9MZXZlbCAhPT0gLTEgJiYgKCFid0VzdGltYXRvciB8fCAhYndFc3RpbWF0b3IuY2FuRXN0aW1hdGUoKSkpIHtcbiAgICAgIHJldHVybiBmb3JjZWRBdXRvTGV2ZWw7XG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSBuZXh0IGxldmVsIHVzaW5nIEFCUiBsb2dpY1xuICAgIGxldCBuZXh0QUJSQXV0b0xldmVsID0gdGhpcy5fbmV4dEFCUkF1dG9MZXZlbDtcbiAgICAvLyBpZiBmb3JjZWQgYXV0byBsZXZlbCBoYXMgYmVlbiBkZWZpbmVkLCB1c2UgaXQgdG8gY2FwIEFCUiBjb21wdXRlZCBxdWFsaXR5IGxldmVsXG4gICAgaWYgKGZvcmNlZEF1dG9MZXZlbCAhPT0gLTEpIHtcbiAgICAgIG5leHRBQlJBdXRvTGV2ZWwgPSBNYXRoLm1pbihmb3JjZWRBdXRvTGV2ZWwsIG5leHRBQlJBdXRvTGV2ZWwpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0QUJSQXV0b0xldmVsO1xuICB9XG4gIGdldCBfbmV4dEFCUkF1dG9MZXZlbCAoKSB7XG4gICAgbGV0IGhscyA9IHRoaXMuaGxzLCBtYXhBdXRvTGV2ZWwgPSBobHMubWF4QXV0b0xldmVsLCBsZXZlbHMgPSBobHMubGV2ZWxzLCBjb25maWcgPSBobHMuY29uZmlnLCBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsO1xuICAgIGNvbnN0IHZpZGVvID0gaGxzLm1lZGlhLFxuICAgICAgY3VycmVudExldmVsID0gdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsLFxuICAgICAgY3VycmVudEZyYWdEdXJhdGlvbiA9IHRoaXMuZnJhZ0N1cnJlbnQgPyB0aGlzLmZyYWdDdXJyZW50LmR1cmF0aW9uIDogMCxcbiAgICAgIHBvcyA9ICh2aWRlbyA/IHZpZGVvLmN1cnJlbnRUaW1lIDogMCksXG4gICAgICAvLyBwbGF5YmFja1JhdGUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBwbGF5YmFjayByYXRlOyBpZiB2aWRlby5wbGF5YmFja1JhdGUgaXMgMCwgd2UgdXNlIDEgdG8gbG9hZCBhc1xuICAgICAgLy8gaWYgd2UncmUgcGxheWluZyBiYWNrIGF0IHRoZSBub3JtYWwgcmF0ZS5cbiAgICAgIHBsYXliYWNrUmF0ZSA9ICgodmlkZW8gJiYgKHZpZGVvLnBsYXliYWNrUmF0ZSAhPT0gMCkpID8gTWF0aC5hYnModmlkZW8ucGxheWJhY2tSYXRlKSA6IDEuMCksXG4gICAgICBhdmdidyA9IHRoaXMuX2J3RXN0aW1hdG9yID8gdGhpcy5fYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKSA6IGNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlLFxuICAgICAgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIHRoZSB3YWxsLWNsb2NrIHRpbWUgbGVmdCB1bnRpbCB0aGUgcGxheWJhY2sgYnVmZmVyIGlzIGV4aGF1c3RlZC5cbiAgICAgIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9IChCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh2aWRlbywgcG9zLCBjb25maWcubWF4QnVmZmVySG9sZSkuZW5kIC0gcG9zKSAvIHBsYXliYWNrUmF0ZTtcblxuICAgIC8vIEZpcnN0LCBsb29rIHRvIHNlZSBpZiB3ZSBjYW4gZmluZCBhIGxldmVsIG1hdGNoaW5nIHdpdGggb3VyIGF2ZyBiYW5kd2lkdGggQU5EIHRoYXQgY291bGQgYWxzbyBndWFyYW50ZWUgbm8gcmVidWZmZXJpbmcgYXQgYWxsXG4gICAgbGV0IGJlc3RMZXZlbCA9IHRoaXMuX2ZpbmRCZXN0TGV2ZWwoY3VycmVudExldmVsLCBjdXJyZW50RnJhZ0R1cmF0aW9uLCBhdmdidywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSwgY29uZmlnLmFickJhbmRXaWR0aEZhY3RvciwgY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yLCBsZXZlbHMpO1xuICAgIGlmIChiZXN0TGV2ZWwgPj0gMCkge1xuICAgICAgcmV0dXJuIGJlc3RMZXZlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLnRyYWNlKCdyZWJ1ZmZlcmluZyBleHBlY3RlZCB0byBoYXBwZW4sIGxldHMgdHJ5IHRvIGZpbmQgYSBxdWFsaXR5IGxldmVsIG1pbmltaXppbmcgdGhlIHJlYnVmZmVyaW5nJyk7XG4gICAgICAvLyBub3QgcG9zc2libGUgdG8gZ2V0IHJpZCBvZiByZWJ1ZmZlcmluZyAuLi4gbGV0J3MgdHJ5IHRvIGZpbmQgbGV2ZWwgdGhhdCB3aWxsIGd1YXJhbnRlZSBsZXNzIHRoYW4gbWF4U3RhcnZhdGlvbkRlbGF5IG9mIHJlYnVmZmVyaW5nXG4gICAgICAvLyBpZiBubyBtYXRjaGluZyBsZXZlbCBmb3VuZCwgbG9naWMgd2lsbCByZXR1cm4gMFxuICAgICAgbGV0IG1heFN0YXJ2YXRpb25EZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLCBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5KSA6IGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXksXG4gICAgICAgIGJ3RmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aEZhY3RvcixcbiAgICAgICAgYndVcEZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvcjtcbiAgICAgIGlmIChidWZmZXJTdGFydmF0aW9uRGVsYXkgPT09IDApIHtcbiAgICAgICAgLy8gaW4gY2FzZSBidWZmZXIgaXMgZW1wdHksIGxldCdzIGNoZWNrIGlmIHByZXZpb3VzIGZyYWdtZW50IHdhcyBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdFxuICAgICAgICBsZXQgYml0cmF0ZVRlc3REZWxheSA9IHRoaXMuYml0cmF0ZVRlc3REZWxheTtcbiAgICAgICAgaWYgKGJpdHJhdGVUZXN0RGVsYXkpIHtcbiAgICAgICAgICAvLyBpZiBpdCBpcyB0aGUgY2FzZSwgdGhlbiB3ZSBuZWVkIHRvIGFkanVzdCBvdXIgbWF4IHN0YXJ2YXRpb24gZGVsYXkgdXNpbmcgbWF4TG9hZGluZ0RlbGF5IGNvbmZpZyB2YWx1ZVxuICAgICAgICAgIC8vIG1heCB2aWRlbyBsb2FkaW5nIGRlbGF5IHVzZWQgaW4gIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24gOlxuICAgICAgICAgIC8vIGluIHRoYXQgbW9kZSBBQlIgY29udHJvbGxlciB3aWxsIGVuc3VyZSB0aGF0IHZpZGVvIGxvYWRpbmcgdGltZSAoaWUgdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZpcnN0IGZyYWdtZW50IGF0IGxvd2VzdCBxdWFsaXR5IGxldmVsICtcbiAgICAgICAgICAvLyB0aGUgdGltZSB0byBmZXRjaCB0aGUgZnJhZ21lbnQgYXQgdGhlIGFwcHJvcHJpYXRlIHF1YWxpdHkgbGV2ZWwgaXMgbGVzcyB0aGFuIGBgYG1heExvYWRpbmdEZWxheWBgYCApXG4gICAgICAgICAgLy8gY2FwIG1heExvYWRpbmdEZWxheSBhbmQgZW5zdXJlIGl0IGlzIG5vdCBiaWdnZXIgJ3RoYW4gYml0cmF0ZSB0ZXN0JyBmcmFnIGR1cmF0aW9uXG4gICAgICAgICAgY29uc3QgbWF4TG9hZGluZ0RlbGF5ID0gY3VycmVudEZyYWdEdXJhdGlvbiA/IE1hdGgubWluKGN1cnJlbnRGcmFnRHVyYXRpb24sIGNvbmZpZy5tYXhMb2FkaW5nRGVsYXkpIDogY29uZmlnLm1heExvYWRpbmdEZWxheTtcbiAgICAgICAgICBtYXhTdGFydmF0aW9uRGVsYXkgPSBtYXhMb2FkaW5nRGVsYXkgLSBiaXRyYXRlVGVzdERlbGF5O1xuICAgICAgICAgIGxvZ2dlci50cmFjZShgYml0cmF0ZSB0ZXN0IHRvb2sgJHtNYXRoLnJvdW5kKDEwMDAgKiBiaXRyYXRlVGVzdERlbGF5KX1tcywgc2V0IGZpcnN0IGZyYWdtZW50IG1heCBmZXRjaER1cmF0aW9uIHRvICR7TWF0aC5yb3VuZCgxMDAwICogbWF4U3RhcnZhdGlvbkRlbGF5KX0gbXNgKTtcbiAgICAgICAgICAvLyBkb24ndCB1c2UgY29uc2VydmF0aXZlIGZhY3RvciBvbiBiaXRyYXRlIHRlc3RcbiAgICAgICAgICBid0ZhY3RvciA9IGJ3VXBGYWN0b3IgPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBiZXN0TGV2ZWwgPSB0aGlzLl9maW5kQmVzdExldmVsKGN1cnJlbnRMZXZlbCwgY3VycmVudEZyYWdEdXJhdGlvbiwgYXZnYncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBidWZmZXJTdGFydmF0aW9uRGVsYXkgKyBtYXhTdGFydmF0aW9uRGVsYXksIGJ3RmFjdG9yLCBid1VwRmFjdG9yLCBsZXZlbHMpO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGJlc3RMZXZlbCwgMCk7XG4gICAgfVxuICB9XG5cbiAgX2ZpbmRCZXN0TGV2ZWwgKGN1cnJlbnRMZXZlbCwgY3VycmVudEZyYWdEdXJhdGlvbiwgY3VycmVudEJ3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgbWF4RmV0Y2hEdXJhdGlvbiwgYndGYWN0b3IsIGJ3VXBGYWN0b3IsIGxldmVscykge1xuICAgIGZvciAobGV0IGkgPSBtYXhBdXRvTGV2ZWw7IGkgPj0gbWluQXV0b0xldmVsOyBpLS0pIHtcbiAgICAgIGxldCBsZXZlbEluZm8gPSBsZXZlbHNbaV07XG5cbiAgICAgIGlmICghbGV2ZWxJbmZvKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHMsXG4gICAgICAgIGF2Z0R1cmF0aW9uID0gbGV2ZWxEZXRhaWxzID8gbGV2ZWxEZXRhaWxzLnRvdGFsZHVyYXRpb24gLyBsZXZlbERldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA6IGN1cnJlbnRGcmFnRHVyYXRpb24sXG4gICAgICAgIGxpdmUgPSBsZXZlbERldGFpbHMgPyBsZXZlbERldGFpbHMubGl2ZSA6IGZhbHNlLFxuICAgICAgICBhZGp1c3RlZGJ3O1xuICAgICAgLy8gZm9sbG93IGFsZ29yaXRobSBjYXB0dXJlZCBmcm9tIHN0YWdlZnJpZ2h0IDpcbiAgICAgIC8vIGh0dHBzOi8vYW5kcm9pZC5nb29nbGVzb3VyY2UuY29tL3BsYXRmb3JtL2ZyYW1ld29ya3MvYXYvKy9tYXN0ZXIvbWVkaWEvbGlic3RhZ2VmcmlnaHQvaHR0cGxpdmUvTGl2ZVNlc3Npb24uY3BwXG4gICAgICAvLyBQaWNrIHRoZSBoaWdoZXN0IGJhbmR3aWR0aCBzdHJlYW0gYmVsb3cgb3IgZXF1YWwgdG8gZXN0aW1hdGVkIGJhbmR3aWR0aC5cbiAgICAgIC8vIGNvbnNpZGVyIG9ubHkgODAlIG9mIHRoZSBhdmFpbGFibGUgYmFuZHdpZHRoLCBidXQgaWYgd2UgYXJlIHN3aXRjaGluZyB1cCxcbiAgICAgIC8vIGJlIGV2ZW4gbW9yZSBjb25zZXJ2YXRpdmUgKDcwJSkgdG8gYXZvaWQgb3ZlcmVzdGltYXRpbmcgYW5kIGltbWVkaWF0ZWx5XG4gICAgICAvLyBzd2l0Y2hpbmcgYmFjay5cbiAgICAgIGlmIChpIDw9IGN1cnJlbnRMZXZlbCkge1xuICAgICAgICBhZGp1c3RlZGJ3ID0gYndGYWN0b3IgKiBjdXJyZW50Qnc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGp1c3RlZGJ3ID0gYndVcEZhY3RvciAqIGN1cnJlbnRCdztcbiAgICAgIH1cblxuICAgICAgY29uc3QgYml0cmF0ZSA9IGxldmVsc1tpXS5yZWFsQml0cmF0ZSA/IE1hdGgubWF4KGxldmVsc1tpXS5yZWFsQml0cmF0ZSwgbGV2ZWxzW2ldLmJpdHJhdGUpIDogbGV2ZWxzW2ldLmJpdHJhdGUsXG4gICAgICAgIGZldGNoRHVyYXRpb24gPSBiaXRyYXRlICogYXZnRHVyYXRpb24gLyBhZGp1c3RlZGJ3O1xuXG4gICAgICBsb2dnZXIudHJhY2UoYGxldmVsL2FkanVzdGVkYncvYml0cmF0ZS9hdmdEdXJhdGlvbi9tYXhGZXRjaER1cmF0aW9uL2ZldGNoRHVyYXRpb246ICR7aX0vJHtNYXRoLnJvdW5kKGFkanVzdGVkYncpfS8ke2JpdHJhdGV9LyR7YXZnRHVyYXRpb259LyR7bWF4RmV0Y2hEdXJhdGlvbn0vJHtmZXRjaER1cmF0aW9ufWApO1xuICAgICAgLy8gaWYgYWRqdXN0ZWQgYncgaXMgZ3JlYXRlciB0aGFuIGxldmVsIGJpdHJhdGUgQU5EXG4gICAgICBpZiAoYWRqdXN0ZWRidyA+IGJpdHJhdGUgJiZcbiAgICAgIC8vIGZyYWdtZW50IGZldGNoRHVyYXRpb24gdW5rbm93biBPUiBsaXZlIHN0cmVhbSBPUiBmcmFnbWVudCBmZXRjaER1cmF0aW9uIGxlc3MgdGhhbiBtYXggYWxsb3dlZCBmZXRjaCBkdXJhdGlvbiwgdGhlbiB0aGlzIGxldmVsIG1hdGNoZXNcbiAgICAgIC8vIHdlIGRvbid0IGFjY291bnQgZm9yIG1heCBGZXRjaCBEdXJhdGlvbiBmb3IgbGl2ZSBzdHJlYW1zLCB0aGlzIGlzIHRvIGF2b2lkIHN3aXRjaGluZyBkb3duIHdoZW4gbmVhciB0aGUgZWRnZSBvZiBsaXZlIHNsaWRpbmcgd2luZG93IC4uLlxuICAgICAgLy8gc3BlY2lhbCBjYXNlIHRvIHN1cHBvcnQgc3RhcnRMZXZlbCA9IC0xIChiaXRyYXRlVGVzdCkgb24gbGl2ZSBzdHJlYW1zIDogaW4gdGhhdCBjYXNlIHdlIHNob3VsZCBub3QgZXhpdCBsb29wIHNvIHRoYXQgX2ZpbmRCZXN0TGV2ZWwgd2lsbCByZXR1cm4gLTFcbiAgICAgICAgKCFmZXRjaER1cmF0aW9uIHx8wqAobGl2ZSAmJiAhdGhpcy5iaXRyYXRlVGVzdERlbGF5KSB8fCBmZXRjaER1cmF0aW9uIDwgbWF4RmV0Y2hEdXJhdGlvbikpIHtcbiAgICAgICAgLy8gYXMgd2UgYXJlIGxvb3BpbmcgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCwgdGhpcyB3aWxsIHJldHVybiB0aGUgYmVzdCBhY2hpZXZhYmxlIHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5vdCBlbm91Z2ggdGltZSBidWRnZXQgZXZlbiB3aXRoIHF1YWxpdHkgbGV2ZWwgMCAuLi4gcmVidWZmZXJpbmcgbWlnaHQgaGFwcGVuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgc2V0IG5leHRBdXRvTGV2ZWwgKG5leHRMZXZlbCkge1xuICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWJyQ29udHJvbGxlcjtcbiIsIi8qXG4gKiBBdWRpbyBTdHJlYW0gQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEJpbmFyeVNlYXJjaCBmcm9tICcuLi91dGlscy9iaW5hcnktc2VhcmNoJztcbmltcG9ydCB7IEJ1ZmZlckhlbHBlciB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IERlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvZGVtdXhlcic7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCAqIGFzIExldmVsSGVscGVyIGZyb20gJy4vbGV2ZWwtaGVscGVyJztcbmltcG9ydCBUaW1lUmFuZ2VzIGZyb20gJy4uL3V0aWxzL3RpbWUtcmFuZ2VzJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgZmluZEZyYWdXaXRoQ0MgfSBmcm9tICcuLi91dGlscy9kaXNjb250aW51aXRpZXMnO1xuaW1wb3J0IHsgRnJhZ21lbnRTdGF0ZSB9IGZyb20gJy4vZnJhZ21lbnQtdHJhY2tlcic7XG5pbXBvcnQgRnJhZ21lbnQgZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCBCYXNlU3RyZWFtQ29udHJvbGxlciwgeyBTdGF0ZSB9IGZyb20gJy4vYmFzZS1zdHJlYW0tY29udHJvbGxlcic7XG5jb25zdCB7IHBlcmZvcm1hbmNlIH0gPSB3aW5kb3c7XG5cbmNvbnN0IFRJQ0tfSU5URVJWQUwgPSAxMDA7IC8vIGhvdyBvZnRlbiB0byB0aWNrIGluIG1zXG5cbmNsYXNzIEF1ZGlvU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIEJhc2VTdHJlYW1Db250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscywgZnJhZ21lbnRUcmFja2VyKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNIRUQsXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXG4gICAgICBFdmVudC5BVURJT19UUkFDS1NfVVBEQVRFRCxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSElORyxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX0xPQURFRCxcbiAgICAgIEV2ZW50LktFWV9MT0FERUQsXG4gICAgICBFdmVudC5GUkFHX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfREFUQSxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0VELFxuICAgICAgRXZlbnQuRVJST1IsXG4gICAgICBFdmVudC5CVUZGRVJfUkVTRVQsXG4gICAgICBFdmVudC5CVUZGRVJfQ1JFQVRFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9BUFBFTkRFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9GTFVTSEVELFxuICAgICAgRXZlbnQuSU5JVF9QVFNfRk9VTkQpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5fc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICAgIHRoaXMud2FpdGluZ0ZyYWdtZW50ID0gbnVsbDtcbiAgICB0aGlzLnZpZGVvVHJhY2tDQyA9IG51bGw7XG4gIH1cblxuICAvLyBTaWduYWwgdGhhdCB2aWRlbyBQVFMgd2FzIGZvdW5kXG4gIG9uSW5pdFB0c0ZvdW5kIChkYXRhKSB7XG4gICAgbGV0IGRlbXV4ZXJJZCA9IGRhdGEuaWQsIGNjID0gZGF0YS5mcmFnLmNjLCBpbml0UFRTID0gZGF0YS5pbml0UFRTO1xuICAgIGlmIChkZW11eGVySWQgPT09ICdtYWluJykge1xuICAgICAgLy8gQWx3YXlzIHVwZGF0ZSB0aGUgbmV3IElOSVQgUFRTXG4gICAgICAvLyBDYW4gY2hhbmdlIGR1ZSBsZXZlbCBzd2l0Y2hcbiAgICAgIHRoaXMuaW5pdFBUU1tjY10gPSBpbml0UFRTO1xuICAgICAgdGhpcy52aWRlb1RyYWNrQ0MgPSBjYztcbiAgICAgIGxvZ2dlci5sb2coYEluaXRQVFMgZm9yIGNjOiAke2NjfSBmb3VuZCBmcm9tIHZpZGVvIHRyYWNrOiAke2luaXRQVFN9YCk7XG5cbiAgICAgIC8vIElmIHdlIGFyZSB3YWl0aW5nIHdlIG5lZWQgdG8gZGVtdXgvcmVtdXggdGhlIHdhaXRpbmcgZnJhZ1xuICAgICAgLy8gV2l0aCB0aGUgbmV3IGluaXRQVFNcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTKSB7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0YXJ0TG9hZCAoc3RhcnRQb3NpdGlvbikge1xuICAgIGlmICh0aGlzLnRyYWNrcykge1xuICAgICAgbGV0IGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICBsb2dnZXIubG9nKGBhdWRpbzpvdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke2xhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5zdGFydFBvc2l0aW9uID8gdGhpcy5zdGFydFBvc2l0aW9uIDogc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUQVJUSU5HO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIH1cbiAgfVxuXG4gIHNldCBzdGF0ZSAobmV4dFN0YXRlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IG5leHRTdGF0ZSkge1xuICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICB0aGlzLl9zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIGxvZ2dlci5sb2coYGF1ZGlvIHN0cmVhbToke3ByZXZpb3VzU3RhdGV9LT4ke25leHRTdGF0ZX1gKTtcbiAgICB9XG4gIH1cblxuICBnZXQgc3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIGRvVGljayAoKSB7XG4gICAgbGV0IHBvcywgdHJhY2ssIHRyYWNrRGV0YWlscywgaGxzID0gdGhpcy5obHMsIGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgLy8gbG9nZ2VyLmxvZygnYXVkaW9TdHJlYW06JyArIHRoaXMuc3RhdGUpO1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgIGNhc2UgU3RhdGUuRVJST1I6XG4gICAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpbiBlcnJvciBzdGF0ZSB0byBhdm9pZCBicmVha2luZyBmdXJ0aGVyIC4uLlxuICAgIGNhc2UgU3RhdGUuUEFVU0VEOlxuICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaW4gcGF1c2VkIHN0YXRlIGVpdGhlciAuLi5cbiAgICBjYXNlIFN0YXRlLkJVRkZFUl9GTFVTSElORzpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU3RhdGUuU1RBUlRJTkc6XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU3RhdGUuSURMRTpcbiAgICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMudHJhY2tzO1xuICAgICAgLy8gYXVkaW8gdHJhY2tzIG5vdCByZWNlaXZlZCA9PiBleGl0IGxvb3BcbiAgICAgIGlmICghdHJhY2tzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EXG4gICAgICAvLyBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIGRpc2FibGVcbiAgICAgIC8vIGV4aXQgbG9vcFxuICAgICAgLy8gPT4gaWYgbWVkaWEgbm90IGF0dGFjaGVkIGJ1dCBzdGFydCBmcmFnIHByZWZldGNoIGlzIGVuYWJsZWQgYW5kIHN0YXJ0IGZyYWcgbm90IHJlcXVlc3RlZCB5ZXQsIHdlIHdpbGwgbm90IGV4aXQgbG9vcFxuICAgICAgaWYgKCF0aGlzLm1lZGlhICYmXG4gICAgICAgICAgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBkZXRlcm1pbmUgbmV4dCBjYW5kaWRhdGUgZnJhZ21lbnQgdG8gYmUgbG9hZGVkLCBiYXNlZCBvbiBjdXJyZW50IHBvc2l0aW9uIGFuZFxuICAgICAgLy8gIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cbiAgICAgIGlmICh0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICAgIHBvcyA9IHRoaXMubWVkaWEuY3VycmVudFRpbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSB0aGlzLm5leHRMb2FkUG9zaXRpb247XG4gICAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWEsXG4gICAgICAgIHZpZGVvQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlciA/IHRoaXMudmlkZW9CdWZmZXIgOiB0aGlzLm1lZGlhLFxuICAgICAgICBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLFxuICAgICAgICBtYWluQnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHZpZGVvQnVmZmVyLCBwb3MsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKSxcbiAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW4sXG4gICAgICAgIGJ1ZmZlckVuZCA9IGJ1ZmZlckluZm8uZW5kLFxuICAgICAgICBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cyxcbiAgICAgICAgLy8gZW5zdXJlIHdlIGJ1ZmZlciBhdCBsZWFzdCBjb25maWcubWF4QnVmZmVyTGVuZ3RoIChkZWZhdWx0IDMwcykgb3IgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCAoZGVmYXVsdDogNjAwcylcbiAgICAgICAgLy8gd2hpY2hldmVyIGlzIHNtYWxsZXIuXG4gICAgICAgIC8vIG9uY2Ugd2UgcmVhY2ggdGhhdCB0aHJlc2hvbGQsIGRvbid0IGJ1ZmZlciBtb3JlIHRoYW4gdmlkZW8gKG1haW5CdWZmZXJJbmZvLmxlbilcbiAgICAgICAgbWF4Q29uZmlnQnVmZmVyID0gTWF0aC5taW4oY29uZmlnLm1heEJ1ZmZlckxlbmd0aCwgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCksXG4gICAgICAgIG1heEJ1ZkxlbiA9IE1hdGgubWF4KG1heENvbmZpZ0J1ZmZlciwgbWFpbkJ1ZmZlckluZm8ubGVuKSxcbiAgICAgICAgYXVkaW9Td2l0Y2ggPSB0aGlzLmF1ZGlvU3dpdGNoLFxuICAgICAgICB0cmFja0lkID0gdGhpcy50cmFja0lkO1xuXG4gICAgICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudFxuICAgICAgaWYgKChidWZmZXJMZW4gPCBtYXhCdWZMZW4gfHwgYXVkaW9Td2l0Y2gpICYmIHRyYWNrSWQgPCB0cmFja3MubGVuZ3RoKSB7XG4gICAgICAgIHRyYWNrRGV0YWlscyA9IHRyYWNrc1t0cmFja0lkXS5kZXRhaWxzO1xuICAgICAgICAvLyBpZiB0cmFjayBpbmZvIG5vdCByZXRyaWV2ZWQgeWV0LCBzd2l0Y2ggc3RhdGUgYW5kIHdhaXQgZm9yIHRyYWNrIHJldHJpZXZhbFxuICAgICAgICBpZiAodHlwZW9mIHRyYWNrRGV0YWlscyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYXVkaW9Td2l0Y2ggJiYgdGhpcy5fc3RyZWFtRW5kZWQoYnVmZmVySW5mbywgdHJhY2tEZXRhaWxzKSkge1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0VPUywgeyB0eXBlOiAnYXVkaW8nIH0pO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIGZyYWdtZW50IGluZGV4LCBjb250aWd1b3VzIHdpdGggZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgICAgICBsZXQgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cyxcbiAgICAgICAgICBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aCxcbiAgICAgICAgICBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydCxcbiAgICAgICAgICBlbmQgPSBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdLnN0YXJ0ICsgZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXS5kdXJhdGlvbixcbiAgICAgICAgICBmcmFnO1xuXG4gICAgICAgICAgLy8gV2hlbiBzd2l0Y2hpbmcgYXVkaW8gdHJhY2ssIHJlbG9hZCBhdWRpbyBhcyBjbG9zZSBhcyBwb3NzaWJsZSB0byBjdXJyZW50VGltZVxuICAgICAgICBpZiAoYXVkaW9Td2l0Y2gpIHtcbiAgICAgICAgICBpZiAodHJhY2tEZXRhaWxzLmxpdmUgJiYgIXRyYWNrRGV0YWlscy5QVFNLbm93bikge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnc3dpdGNoaW5nIGF1ZGlvdHJhY2ssIGxpdmUgc3RyZWFtLCB1bmtub3duIFBUUyxsb2FkIGZpcnN0IGZyYWdtZW50Jyk7XG4gICAgICAgICAgICBidWZmZXJFbmQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXJFbmQgPSBwb3M7XG4gICAgICAgICAgICAvLyBpZiBjdXJyZW50VGltZSAocG9zKSBpcyBsZXNzIHRoYW4gYWx0IGF1ZGlvIHBsYXlsaXN0IHN0YXJ0IHRpbWUsIGl0IG1lYW5zIHRoYXQgYWx0IGF1ZGlvIGlzIGFoZWFkIG9mIGN1cnJlbnRUaW1lXG4gICAgICAgICAgICBpZiAodHJhY2tEZXRhaWxzLlBUU0tub3duICYmIHBvcyA8IHN0YXJ0KSB7XG4gICAgICAgICAgICAgIC8vIGlmIGV2ZXJ5dGhpbmcgaXMgYnVmZmVyZWQgZnJvbSBwb3MgdG8gc3RhcnQgb3IgaWYgYXVkaW8gYnVmZmVyIHVwZnJvbnQsIGxldCdzIHNlZWsgdG8gc3RhcnRcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlckluZm8uZW5kID4gc3RhcnQgfHwgYnVmZmVySW5mby5uZXh0U3RhcnQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdhbHQgYXVkaW8gdHJhY2sgYWhlYWQgb2YgbWFpbiB0cmFjaywgc2VlayB0byBzdGFydCBvZiBhbHQgYXVkaW8gdHJhY2snKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnQgKyAwLjA1O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2tEZXRhaWxzLmluaXRTZWdtZW50ICYmICF0cmFja0RldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSkge1xuICAgICAgICAgIGZyYWcgPSB0cmFja0RldGFpbHMuaW5pdFNlZ21lbnQ7XG4gICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBicmFjZS1zdHlsZVxuICAgICAgICAvLyBpZiBidWZmZXJFbmQgYmVmb3JlIHN0YXJ0IG9mIHBsYXlsaXN0LCBsb2FkIGZpcnN0IGZyYWdtZW50XG4gICAgICAgIGVsc2UgaWYgKGJ1ZmZlckVuZCA8PSBzdGFydCkge1xuICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgICAgaWYgKHRoaXMudmlkZW9UcmFja0NDICE9PSBudWxsICYmIGZyYWcuY2MgIT09IHRoaXMudmlkZW9UcmFja0NDKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgd2UgZmluZCBhIGZyYWdtZW50IHdoaWNoIG1hdGNoZXMgdGhlIGNvbnRpbnVpdHkgb2YgdGhlIHZpZGVvIHRyYWNrXG4gICAgICAgICAgICBmcmFnID0gZmluZEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCB0aGlzLnZpZGVvVHJhY2tDQyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0cmFja0RldGFpbHMubGl2ZSAmJiBmcmFnLmxvYWRJZHggJiYgZnJhZy5sb2FkSWR4ID09PSB0aGlzLmZyYWdMb2FkSWR4KSB7XG4gICAgICAgICAgICAvLyB3ZSBqdXN0IGxvYWRlZCB0aGlzIGZpcnN0IGZyYWdtZW50LCBhbmQgd2UgYXJlIHN0aWxsIGxhZ2dpbmcgYmVoaW5kIHRoZSBzdGFydCBvZiB0aGUgbGl2ZSBwbGF5bGlzdFxuICAgICAgICAgICAgLy8gbGV0J3MgZm9yY2Ugc2VlayB0byBzdGFydFxuICAgICAgICAgICAgY29uc3QgbmV4dEJ1ZmZlcmVkID0gYnVmZmVySW5mby5uZXh0U3RhcnQgPyBidWZmZXJJbmZvLm5leHRTdGFydCA6IHN0YXJ0O1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgbm8gYWx0IGF1ZGlvIGF2YWlsYWJsZSBAY3VycmVudFRpbWU6JHt0aGlzLm1lZGlhLmN1cnJlbnRUaW1lfSwgc2Vla2luZyBAJHtuZXh0QnVmZmVyZWQgKyAwLjA1fWApO1xuICAgICAgICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IG5leHRCdWZmZXJlZCArIDAuMDU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBmb3VuZEZyYWc7XG4gICAgICAgICAgbGV0IG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgICAgICBjb25zdCBmcmFnTmV4dCA9IGZyYWdQcmV2aW91cyA/IGZyYWdtZW50c1tmcmFnUHJldmlvdXMuc24gLSBmcmFnbWVudHNbMF0uc24gKyAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBsZXQgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0ID0gKGNhbmRpZGF0ZSkgPT4ge1xuICAgICAgICAgICAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBjb3BlIHdpdGggc2l0dWF0aW9ucyBsaWtlXG4gICAgICAgICAgICAvLyBidWZmZXJFbmQgPSA5Ljk5MVxuICAgICAgICAgICAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cbiAgICAgICAgICAgIC8vIGZyYWdbMV0gOiBbMTAsMjBdXG4gICAgICAgICAgICAvLyBidWZmZXJFbmQgaXMgd2l0aGluIGZyYWdbMF0gcmFuZ2UgLi4uIGFsdGhvdWdoIHdoYXQgd2UgYXJlIGV4cGVjdGluZyBpcyB0byByZXR1cm4gZnJhZ1sxXSBoZXJlXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgZnJhZyBzdGFydCAgICAgICAgICAgICAgIGZyYWcgc3RhcnQrZHVyYXRpb25cbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIDwtLS0+ICAgICAgICAgICAgICAgICAgICAgICAgIDwtLS0+XG4gICAgICAgICAgICAvLyAgLi4uLS0tLS0tLS0+PC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPjwtLS0tLS0tLS0uLi4uXG4gICAgICAgICAgICAvLyBwcmV2aW91cyBmcmFnICAgICAgICAgbWF0Y2hpbmcgZnJhZ21lbnQgICAgICAgICBuZXh0IGZyYWdcbiAgICAgICAgICAgIC8vICByZXR1cm4gLTEgICAgICAgICAgICAgcmV0dXJuIDAgICAgICAgICAgICAgICAgIHJldHVybiAxXG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKGBsZXZlbC9zbi9zdGFydC9lbmQvYnVmRW5kOiR7bGV2ZWx9LyR7Y2FuZGlkYXRlLnNufS8ke2NhbmRpZGF0ZS5zdGFydH0vJHsoY2FuZGlkYXRlLnN0YXJ0K2NhbmRpZGF0ZS5kdXJhdGlvbil9LyR7YnVmZmVyRW5kfWApO1xuICAgICAgICAgICAgLy8gU2V0IHRoZSBsb29rdXAgdG9sZXJhbmNlIHRvIGJlIHNtYWxsIGVub3VnaCB0byBkZXRlY3QgdGhlIGN1cnJlbnQgc2VnbWVudCAtIGVuc3VyZXMgd2UgZG9uJ3Qgc2tpcCBvdmVyIHZlcnkgc21hbGwgc2VnbWVudHNcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24pO1xuICAgICAgICAgICAgaWYgKChjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UpIDw9IGJ1ZmZlckVuZCkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FuZGlkYXRlLnN0YXJ0IC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gYnVmZmVyRW5kICYmIGNhbmRpZGF0ZS5zdGFydCkge1xuICAgICAgICAgICAgICAvLyBpZiBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHdpbGwgaGF2ZSBuZWdhdGl2ZSB2YWx1ZSB0aGVuIGRvbid0IHJldHVybiAtMSBmb3IgZmlyc3QgZWxlbWVudFxuICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XG4gICAgICAgICAgICBpZiAoYnVmZmVyRW5kID4gZW5kIC0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJlZmVyIHRoZSBuZXh0IGZyYWdtZW50IGlmIGl0J3Mgd2l0aGluIHRvbGVyYW5jZVxuICAgICAgICAgICAgaWYgKGZyYWdOZXh0ICYmICFmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoZnJhZ05leHQpKSB7XG4gICAgICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdOZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm91bmRGcmFnID0gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlYWNoIGVuZCBvZiBwbGF5bGlzdFxuICAgICAgICAgICAgZm91bmRGcmFnID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvdW5kRnJhZykge1xuICAgICAgICAgICAgZnJhZyA9IGZvdW5kRnJhZztcbiAgICAgICAgICAgIHN0YXJ0ID0gZm91bmRGcmFnLnN0YXJ0O1xuICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmluZCBTTiBtYXRjaGluZyB3aXRoIHBvczonICsgIGJ1ZmZlckVuZCArICc6JyArIGZyYWcuc24pO1xuICAgICAgICAgICAgaWYgKGZyYWdQcmV2aW91cyAmJiBmcmFnLmxldmVscyA9PT0gZnJhZ1ByZXZpb3VzLmxldmVscyAmJiBmcmFnLnNuID09PSBmcmFnUHJldmlvdXMuc24pIHtcbiAgICAgICAgICAgICAgaWYgKGZyYWcuc24gPCB0cmFja0RldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWcuc24gKyAxIC0gdHJhY2tEZXRhaWxzLnN0YXJ0U05dO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFNOIGp1c3QgbG9hZGVkLCBsb2FkIG5leHQgb25lOiAke2ZyYWcuc259YCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhZyA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCcgICAgICBsb2FkaW5nIGZyYWcgJyArIGkgKycscG9zL2J1ZkVuZDonICsgcG9zLnRvRml4ZWQoMykgKyAnLycgKyBidWZmZXJFbmQudG9GaXhlZCgzKSk7XG4gICAgICAgICAgaWYgKGZyYWcuZW5jcnlwdGVkKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBMb2FkaW5nIGtleSBmb3IgJHtmcmFnLnNufSBvZiBbJHt0cmFja0RldGFpbHMuc3RhcnRTTn0gLCR7dHJhY2tEZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfWApO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLktFWV9MT0FESU5HO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuS0VZX0xPQURJTkcsIHsgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyAke2ZyYWcuc259LCBjYzogJHtmcmFnLmNjfSBvZiBbJHt0cmFja0RldGFpbHMuc3RhcnRTTn0gLCR7dHJhY2tEZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfSwgY3VycmVudFRpbWU6JHtwb3N9LGJ1ZmZlckVuZDoke2J1ZmZlckVuZC50b0ZpeGVkKDMpfWApO1xuICAgICAgICAgICAgLy8gb25seSBsb2FkIGlmIGZyYWdtZW50IGlzIG5vdCBsb2FkZWQgb3IgaWYgaW4gYXVkaW8gc3dpdGNoXG4gICAgICAgICAgICAvLyB3ZSBmb3JjZSBhIGZyYWcgbG9hZGluZyBpbiBhdWRpbyBzd2l0Y2ggYXMgZnJhZ21lbnQgdHJhY2tlciBtaWdodCBub3QgaGF2ZSBldmljdGVkIHByZXZpb3VzIGZyYWdzIGluIGNhc2Ugb2YgcXVpY2sgYXVkaW8gc3dpdGNoXG4gICAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICAgICAgICAgIGlmIChhdWRpb1N3aXRjaCB8fCB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnLnNuKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FESU5HLCB7IGZyYWcgfSk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFN0YXRlLldBSVRJTkdfVFJBQ0s6XG4gICAgICB0cmFjayA9IHRoaXMudHJhY2tzW3RoaXMudHJhY2tJZF07XG4gICAgICAvLyBjaGVjayBpZiBwbGF5bGlzdCBpcyBhbHJlYWR5IGxvYWRlZFxuICAgICAgaWYgKHRyYWNrICYmIHRyYWNrLmRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB2YXIgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XG4gICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICB2YXIgaXNTZWVraW5nID0gbWVkaWEgJiYgbWVkaWEuc2Vla2luZztcbiAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXG4gICAgICBpZiAoIXJldHJ5RGF0ZSB8fCAobm93ID49IHJldHJ5RGF0ZSkgfHwgaXNTZWVraW5nKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ2F1ZGlvU3RyZWFtQ29udHJvbGxlcjogcmV0cnlEYXRlIHJlYWNoZWQsIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUnKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFN0YXRlLldBSVRJTkdfSU5JVF9QVFM6XG4gICAgICBjb25zdCB2aWRlb1RyYWNrQ0MgPSB0aGlzLnZpZGVvVHJhY2tDQztcbiAgICAgIGlmICh0aGlzLmluaXRQVFNbdmlkZW9UcmFja0NDXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBFbnN1cmUgd2UgZG9uJ3QgZ2V0IHN0dWNrIGluIHRoZSBXQUlUSU5HX0lOSVRfUFRTIHN0YXRlIGlmIHRoZSB3YWl0aW5nIGZyYWcgQ0MgZG9lc24ndCBtYXRjaCBhbnkgaW5pdFBUU1xuICAgICAgY29uc3Qgd2FpdGluZ0ZyYWcgPSB0aGlzLndhaXRpbmdGcmFnbWVudDtcbiAgICAgIGlmICh3YWl0aW5nRnJhZykge1xuICAgICAgICBjb25zdCB3YWl0aW5nRnJhZ0NDID0gd2FpdGluZ0ZyYWcuZnJhZy5jYztcbiAgICAgICAgaWYgKHZpZGVvVHJhY2tDQyAhPT0gd2FpdGluZ0ZyYWdDQykge1xuICAgICAgICAgIHRyYWNrID0gdGhpcy50cmFja3NbdGhpcy50cmFja0lkXTtcbiAgICAgICAgICBpZiAodHJhY2suZGV0YWlscyAmJiB0cmFjay5kZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBXYWl0aW5nIGZyYWdtZW50IENDICgke3dhaXRpbmdGcmFnQ0N9KSBkb2VzIG5vdCBtYXRjaCB2aWRlbyB0cmFjayBDQyAoJHt2aWRlb1RyYWNrQ0N9KWApO1xuICAgICAgICAgICAgdGhpcy53YWl0aW5nRnJhZ21lbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgdGhpcy5vbkZyYWdMb2FkZWQodGhpcy53YWl0aW5nRnJhZ21lbnQpO1xuICAgICAgICAgIHRoaXMud2FpdGluZ0ZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU3RhdGUuU1RPUFBFRDpcbiAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElORzpcbiAgICBjYXNlIFN0YXRlLlBBUlNJTkc6XG4gICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgY2FzZSBTdGF0ZS5FTkRFRDpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoZWQgKGRhdGEpIHtcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbk1lZGlhU2Vla2luZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub252ZW5kZWQgPSB0aGlzLm9uTWVkaWFFbmRlZC5iaW5kKHRoaXMpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmICh0aGlzLnRyYWNrcyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCkge1xuICAgICAgdGhpcy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcgKCkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhICYmIG1lZGlhLmVuZGVkKSB7XG4gICAgICBsb2dnZXIubG9nKCdNU0UgZGV0YWNoaW5nIGFuZCB2aWRlbyBlbmRlZCwgcmVzZXQgc3RhcnRQb3NpdGlvbicpO1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252c2Vla2VkID0gdGhpcy5vbnZlbmRlZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgfVxuXG4gIG9uQXVkaW9UcmFja3NVcGRhdGVkIChkYXRhKSB7XG4gICAgbG9nZ2VyLmxvZygnYXVkaW8gdHJhY2tzIHVwZGF0ZWQnKTtcbiAgICB0aGlzLnRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3M7XG4gIH1cblxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcgKGRhdGEpIHtcbiAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgbGV0IGFsdEF1ZGlvID0gISFkYXRhLnVybDtcbiAgICB0aGlzLnRyYWNrSWQgPSBkYXRhLmlkO1xuXG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBVVNFRDtcbiAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XG4gICAgLy8gZGVzdHJveSB1c2VsZXNzIGRlbXV4ZXIgd2hlbiBzd2l0Y2hpbmcgYXVkaW8gdG8gbWFpblxuICAgIGlmICghYWx0QXVkaW8pIHtcbiAgICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3dpdGNoaW5nIHRvIGF1ZGlvIHRyYWNrLCBzdGFydCB0aW1lciBpZiBub3QgYWxyZWFkeSBzdGFydGVkXG4gICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xuICAgIH1cblxuICAgIC8vIHNob3VsZCB3ZSBzd2l0Y2ggdHJhY2tzID9cbiAgICBpZiAoYWx0QXVkaW8pIHtcbiAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSB0cnVlO1xuICAgICAgLy8gbWFpbiBhdWRpbyB0cmFjayBhcmUgaGFuZGxlZCBieSBzdHJlYW0tY29udHJvbGxlciwganVzdCBkbyBzb21ldGhpbmcgaWYgc3dpdGNoaW5nIHRvIGFsdCBhdWRpbyB0cmFja1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25BdWRpb1RyYWNrTG9hZGVkIChkYXRhKSB7XG4gICAgbGV0IG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHMsXG4gICAgICB0cmFja0lkID0gZGF0YS5pZCxcbiAgICAgIHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tJZF0sXG4gICAgICBkdXJhdGlvbiA9IG5ld0RldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgIHNsaWRpbmcgPSAwO1xuXG4gICAgbG9nZ2VyLmxvZyhgdHJhY2sgJHt0cmFja0lkfSBsb2FkZWQgWyR7bmV3RGV0YWlscy5zdGFydFNOfSwke25ld0RldGFpbHMuZW5kU059XSxkdXJhdGlvbjoke2R1cmF0aW9ufWApO1xuXG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgbGV0IGN1ckRldGFpbHMgPSB0cmFjay5kZXRhaWxzO1xuICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyB3ZSBhbHJlYWR5IGhhdmUgZGV0YWlscyBmb3IgdGhhdCBsZXZlbCwgbWVyZ2UgdGhlbVxuICAgICAgICBMZXZlbEhlbHBlci5tZXJnZURldGFpbHMoY3VyRGV0YWlscywgbmV3RGV0YWlscyk7XG4gICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyB0aGlzLmxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgY3VyRGV0YWlscyk7XG4gICAgICAgIGlmIChuZXdEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBhdWRpbyBwbGF5bGlzdCBzbGlkaW5nOiR7c2xpZGluZy50b0ZpeGVkKDMpfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgYXVkaW8gcGxheWxpc3QgLSBvdXRkYXRlZCBQVFMsIHVua25vd24gc2xpZGluZycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgYXVkaW8gcGxheWxpc3QgLSBmaXJzdCBsb2FkLCB1bmtub3duIHNsaWRpbmcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgIH1cbiAgICB0cmFjay5kZXRhaWxzID0gbmV3RGV0YWlscztcblxuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb25cbiAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICAgIGlmICh0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcbiAgICAgICAgbGV0IHN0YXJ0VGltZU9mZnNldCA9IG5ld0RldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBzdGFydCB0aW1lIG9mZnNldCBmb3VuZCBpbiBwbGF5bGlzdCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gdG8gJHtzdGFydFRpbWVPZmZzZXR9YCk7XG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICB9XG4gICAgLy8gb25seSBzd2l0Y2ggYmF0Y2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIHRyYWNrIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfVFJBQ0spIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uS2V5TG9hZGVkICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuS0VZX0xPQURJTkcpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnTG9hZGVkIChkYXRhKSB7XG4gICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgIGZyYWdMb2FkZWQgPSBkYXRhLmZyYWc7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyAmJlxuICAgICAgICBmcmFnQ3VycmVudCAmJlxuICAgICAgICBmcmFnTG9hZGVkLnR5cGUgPT09ICdhdWRpbycgJiZcbiAgICAgICAgZnJhZ0xvYWRlZC5sZXZlbHMgPT09IGZyYWdDdXJyZW50LmxldmVscyAmJlxuICAgICAgICBmcmFnTG9hZGVkLnNuID09PSBmcmFnQ3VycmVudC5zbikge1xuICAgICAgbGV0IHRyYWNrID0gdGhpcy50cmFja3NbdGhpcy50cmFja0lkXSxcbiAgICAgICAgZGV0YWlscyA9IHRyYWNrLmRldGFpbHMsXG4gICAgICAgIGR1cmF0aW9uID0gZGV0YWlscy50b3RhbGR1cmF0aW9uLFxuICAgICAgICB0cmFja0lkID0gZnJhZ0N1cnJlbnQubGV2ZWxzLFxuICAgICAgICBzbiA9IGZyYWdDdXJyZW50LnNuLFxuICAgICAgICBjYyA9IGZyYWdDdXJyZW50LmNjLFxuICAgICAgICBhdWRpb0NvZGVjID0gdGhpcy5jb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgdHJhY2suYXVkaW9Db2RlYyB8fCAnbXA0YS40MC4yJyxcbiAgICAgICAgc3RhdHMgPSB0aGlzLnN0YXRzID0gZGF0YS5zdGF0cztcbiAgICAgIGlmIChzbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcblxuICAgICAgICBzdGF0cy50cGFyc2VkID0gc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGRldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSA9IGRhdGEucGF5bG9hZDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7IHN0YXRzOiBzdGF0cywgZnJhZzogZnJhZ0N1cnJlbnQsIGlkOiAnYXVkaW8nIH0pO1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTSU5HO1xuICAgICAgICAvLyB0cmFuc211eCB0aGUgTVBFRy1UUyBkYXRhIHRvIElTTy1CTUZGIHNlZ21lbnRzXG4gICAgICAgIHRoaXMuYXBwZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcih0aGlzLmhscywgJ2F1ZGlvJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHZpZGVvIGluaXRQVFNcbiAgICAgICAgLy8gSWYgbm90IHdlIG5lZWQgdG8gd2FpdCBmb3IgaXRcbiAgICAgICAgbGV0IGluaXRQVFMgPSB0aGlzLmluaXRQVFNbY2NdO1xuICAgICAgICBsZXQgaW5pdFNlZ21lbnREYXRhID0gZGV0YWlscy5pbml0U2VnbWVudCA/IGRldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSA6IFtdO1xuICAgICAgICBpZiAoZGV0YWlscy5pbml0U2VnbWVudCB8fCBpbml0UFRTICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgIGxvZ2dlci5sb2coYERlbXV4aW5nICR7c259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLHRyYWNrICR7dHJhY2tJZH1gKTtcbiAgICAgICAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcbiAgICAgICAgICBsZXQgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gZmFsc2U7IC8vIGRldGFpbHMuUFRTS25vd24gfHwgIWRldGFpbHMubGl2ZTtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIucHVzaChkYXRhLnBheWxvYWQsIGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgbnVsbCwgZnJhZ0N1cnJlbnQsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGluaXRQVFMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coYHVua25vd24gdmlkZW8gUFRTIGZvciBjb250aW51aXR5IGNvdW50ZXIgJHtjY30sIHdhaXRpbmcgZm9yIHZpZGVvIFBUUyBiZWZvcmUgZGVtdXhpbmcgYXVkaW8gZnJhZyAke3NufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICAgICAgdGhpcy53YWl0aW5nRnJhZ21lbnQgPSBkYXRhO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nSW5pdFNlZ21lbnQgKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgY29uc3QgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ2F1ZGlvJyAmJlxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBmcmFnTmV3LmxldmVscyA9PT0gZnJhZ0N1cnJlbnQubGV2ZWxzICYmXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIGxldCB0cmFja3MgPSBkYXRhLnRyYWNrcywgdHJhY2s7XG5cbiAgICAgIC8vIGRlbGV0ZSBhbnkgdmlkZW8gdHJhY2sgZm91bmQgb24gYXVkaW8gZGVtdXhlclxuICAgICAgaWYgKHRyYWNrcy52aWRlbykge1xuICAgICAgICBkZWxldGUgdHJhY2tzLnZpZGVvO1xuICAgICAgfVxuXG4gICAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgICAgdHJhY2sgPSB0cmFja3MuYXVkaW87XG4gICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgdHJhY2subGV2ZWxDb2RlYyA9IHRyYWNrLmNvZGVjO1xuICAgICAgICB0cmFjay5pZCA9IGRhdGEuaWQ7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0NPREVDUywgdHJhY2tzKTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgYXVkaW8gdHJhY2s6YXVkaW8sY29udGFpbmVyOiR7dHJhY2suY29udGFpbmVyfSxjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJHt0cmFjay5sZXZlbENvZGVjfS8ke3RyYWNrLmNvZGVjfV1gKTtcbiAgICAgICAgbGV0IGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG4gICAgICAgIGlmIChpbml0U2VnbWVudCkge1xuICAgICAgICAgIGxldCBhcHBlbmRPYmogPSB7IHR5cGU6ICdhdWRpbycsIGRhdGE6IGluaXRTZWdtZW50LCBwYXJlbnQ6ICdhdWRpbycsIGNvbnRlbnQ6ICdpbml0U2VnbWVudCcgfTtcbiAgICAgICAgICBpZiAodGhpcy5hdWRpb1N3aXRjaCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGF0YSA9IFthcHBlbmRPYmpdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGFybSBwZW5kaW5nIEJ1ZmZlcmluZyBmbGFnIGJlZm9yZSBhcHBlbmRpbmcgYSBzZWdtZW50XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCBhcHBlbmRPYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdEYXRhIChkYXRhKSB7XG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcbiAgICAgICAgZGF0YS50eXBlID09PSAnYXVkaW8nICYmXG4gICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgIGZyYWdOZXcubGV2ZWxzID09PSBmcmFnQ3VycmVudC5sZXZlbHMgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgbGV0IHRyYWNrSWQgPSB0aGlzLnRyYWNrSWQsXG4gICAgICAgIHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tJZF0sXG4gICAgICAgIGhscyA9IHRoaXMuaGxzO1xuXG4gICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShkYXRhLmVuZFBUUykpIHtcbiAgICAgICAgZGF0YS5lbmRQVFMgPSBkYXRhLnN0YXJ0UFRTICsgZnJhZ0N1cnJlbnQuZHVyYXRpb247XG4gICAgICAgIGRhdGEuZW5kRFRTID0gZGF0YS5zdGFydERUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICBmcmFnQ3VycmVudC5hZGRFbGVtZW50YXJ5U3RyZWFtKEZyYWdtZW50LkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyk7XG5cbiAgICAgIGxvZ2dlci5sb2coYHBhcnNlZCAke2RhdGEudHlwZX0sUFRTOlske2RhdGEuc3RhcnRQVFMudG9GaXhlZCgzKX0sJHtkYXRhLmVuZFBUUy50b0ZpeGVkKDMpfV0sRFRTOlske2RhdGEuc3RhcnREVFMudG9GaXhlZCgzKX0vJHtkYXRhLmVuZERUUy50b0ZpeGVkKDMpfV0sbmI6JHtkYXRhLm5ifWApO1xuICAgICAgTGV2ZWxIZWxwZXIudXBkYXRlRnJhZ1BUU0RUUyh0cmFjay5kZXRhaWxzLCBmcmFnQ3VycmVudCwgZGF0YS5zdGFydFBUUywgZGF0YS5lbmRQVFMpO1xuXG4gICAgICBsZXQgYXVkaW9Td2l0Y2ggPSB0aGlzLmF1ZGlvU3dpdGNoLCBtZWRpYSA9IHRoaXMubWVkaWEsIGFwcGVuZE9uQnVmZmVyRmx1c2ggPSBmYWxzZTtcbiAgICAgIC8vIE9ubHkgZmx1c2ggYXVkaW8gZnJvbSBvbGQgYXVkaW8gdHJhY2tzIHdoZW4gUFRTIGlzIGtub3duIG9uIG5ldyBhdWRpbyB0cmFja1xuICAgICAgaWYgKGF1ZGlvU3dpdGNoICYmIG1lZGlhKSB7XG4gICAgICAgIGlmIChtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgbGV0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnc3dpdGNoaW5nIGF1ZGlvIHRyYWNrIDogY3VycmVudFRpbWU6JyArIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICBpZiAoY3VycmVudFRpbWUgPj0gZGF0YS5zdGFydFBUUykge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnc3dpdGNoaW5nIGF1ZGlvIHRyYWNrIDogZmx1c2hpbmcgYWxsIGF1ZGlvJyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQlVGRkVSX0ZMVVNISU5HO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNISU5HLCB7IHN0YXJ0T2Zmc2V0OiAwLCBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgdHlwZTogJ2F1ZGlvJyB9KTtcbiAgICAgICAgICAgIGFwcGVuZE9uQnVmZmVyRmx1c2ggPSB0cnVlO1xuICAgICAgICAgICAgLy8gTGV0cyBhbm5vdW5jZSB0aGF0IHRoZSBpbml0aWFsIGF1ZGlvIHRyYWNrIHN3aXRjaCBmbHVzaCBvY2N1clxuICAgICAgICAgICAgdGhpcy5hdWRpb1N3aXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHsgaWQ6IHRyYWNrSWQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExldHMgYW5ub3VuY2UgdGhhdCB0aGUgaW5pdGlhbCBhdWRpbyB0cmFjayBzd2l0Y2ggZmx1c2ggb2NjdXJcbiAgICAgICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHsgaWQ6IHRyYWNrSWQgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IHBlbmRpbmdEYXRhID0gdGhpcy5wZW5kaW5nRGF0YTtcblxuICAgICAgaWYgKCFwZW5kaW5nRGF0YSkge1xuICAgICAgICBsb2dnZXIud2FybignQXBwYXJlbnRseSBhdHRlbXB0IHRvIGVucXVldWUgbWVkaWEgcGF5bG9hZCB3aXRob3V0IGNvZGVjIGluaXRpYWxpemF0aW9uIGRhdGEgdXBmcm9udCcpO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBudWxsLCBmYXRhbDogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuYXVkaW9Td2l0Y2gpIHtcbiAgICAgICAgW2RhdGEuZGF0YTEsIGRhdGEuZGF0YTJdLmZvckVhY2goYnVmZmVyID0+IHtcbiAgICAgICAgICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBlbmRpbmdEYXRhLnB1c2goeyB0eXBlOiBkYXRhLnR5cGUsIGRhdGE6IGJ1ZmZlciwgcGFyZW50OiAnYXVkaW8nLCBjb250ZW50OiAnZGF0YScgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFhcHBlbmRPbkJ1ZmZlckZsdXNoICYmIHBlbmRpbmdEYXRhLmxlbmd0aCkge1xuICAgICAgICAgIHBlbmRpbmdEYXRhLmZvckVhY2goYXBwZW5kT2JqID0+IHtcbiAgICAgICAgICAgIC8vIG9ubHkgYXBwZW5kIGluIFBBUlNJTkcgc3RhdGUgKHJhdGlvbmFsZSBpcyB0aGF0IGFuIGFwcGVuZGluZyBlcnJvciBjb3VsZCBoYXBwZW4gc3luY2hyb25vdXNseSBvbiBmaXJzdCBzZWdtZW50IGFwcGVuZGluZylcbiAgICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSBpdCBpcyB1c2VsZXNzIHRvIGFwcGVuZCBmb2xsb3dpbmcgc2VnbWVudHNcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICAgICAgICAgIC8vIGFybSBwZW5kaW5nIEJ1ZmZlcmluZyBmbGFnIGJlZm9yZSBhcHBlbmRpbmcgYSBzZWdtZW50XG4gICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywgYXBwZW5kT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdEYXRhID0gW107XG4gICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ1BhcnNlZCAoZGF0YSkge1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBjb25zdCBmcmFnTmV3ID0gZGF0YS5mcmFnO1xuICAgIGlmIChmcmFnQ3VycmVudCAmJlxuICAgICAgICBkYXRhLmlkID09PSAnYXVkaW8nICYmXG4gICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgIGZyYWdOZXcubGV2ZWxzID09PSBmcmFnQ3VycmVudC5sZXZlbHMgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgdGhpcy5zdGF0cy50cGFyc2VkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0VEO1xuICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgIH1cbiAgfVxuXG4gIG9uQnVmZmVyUmVzZXQgKCkge1xuICAgIC8vIHJlc2V0IHJlZmVyZW5jZSB0byBzb3VyY2VidWZmZXJzXG4gICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgfVxuXG4gIG9uQnVmZmVyQ3JlYXRlZCAoZGF0YSkge1xuICAgIGxldCBhdWRpb1RyYWNrID0gZGF0YS50cmFja3MuYXVkaW87XG4gICAgaWYgKGF1ZGlvVHJhY2spIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBhdWRpb1RyYWNrLmJ1ZmZlcjtcbiAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZGF0YS50cmFja3MudmlkZW8pIHtcbiAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSBkYXRhLnRyYWNrcy52aWRlby5idWZmZXI7XG4gICAgfVxuICB9XG5cbiAgb25CdWZmZXJBcHBlbmRlZCAoZGF0YSkge1xuICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ2F1ZGlvJykge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgaWYgKHN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8IHN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIGFwcGVuZGVkXG4gICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IChkYXRhLnBlbmRpbmcgPiAwKTtcbiAgICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jaGVja0FwcGVuZGVkUGFyc2VkICgpIHtcbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCAmJiAoIXRoaXMuYXBwZW5kZWQgfHwgIXRoaXMucGVuZGluZ0J1ZmZlcmluZykpIHtcbiAgICAgIGxldCBmcmFnID0gdGhpcy5mcmFnQ3VycmVudCwgc3RhdHMgPSB0aGlzLnN0YXRzLCBobHMgPSB0aGlzLmhscztcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgICAgc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZSQUdfQlVGRkVSRUQsIHsgc3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnLCBpZDogJ2F1ZGlvJyB9KTtcbiAgICAgICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgICAgICBsb2dnZXIubG9nKGBhdWRpbyBidWZmZXJlZCA6ICR7VGltZVJhbmdlcy50b1N0cmluZyhtZWRpYS5idWZmZXJlZCl9YCk7XG4gICAgICAgIGlmICh0aGlzLmF1ZGlvU3dpdGNoICYmIHRoaXMuYXBwZW5kZWQpIHtcbiAgICAgICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHsgaWQ6IHRoaXMudHJhY2tJZCB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IgKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBhdWRpbyBmcmFnbWVudFxuICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gJ2F1ZGlvJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgIC8vIGRvbid0IGhhbmRsZSBmcmFnIGVycm9yIG5vdCByZWxhdGVkIHRvIGF1ZGlvIGZyYWdtZW50XG4gICAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09ICdhdWRpbycpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGF0YS5mYXRhbCkge1xuICAgICAgICBsZXQgbG9hZEVycm9yID0gdGhpcy5mcmFnTG9hZEVycm9yO1xuICAgICAgICBpZiAobG9hZEVycm9yKSB7XG4gICAgICAgICAgbG9hZEVycm9yKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9hZEVycm9yID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICBpZiAobG9hZEVycm9yIDw9IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5KSB7XG4gICAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gbG9hZEVycm9yO1xuICAgICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dFxuICAgICAgICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5taW4oTWF0aC5wb3coMiwgbG9hZEVycm9yIC0gMSkgKiBjb25maWcuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LCBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQpO1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBBdWRpb1N0cmVhbUNvbnRyb2xsZXI6IGZyYWcgbG9hZGluZyBmYWlsZWQsIHJldHJ5IGluICR7ZGVsYXl9IG1zYCk7XG4gICAgICAgICAgdGhpcy5yZXRyeURhdGUgPSBwZXJmb3JtYW5jZS5ub3coKSArIGRlbGF5O1xuICAgICAgICAgIC8vIHJldHJ5IGxvYWRpbmcgc3RhdGVcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGBBdWRpb1N0cmVhbUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSByZWFjaGVzIG1heCByZXRyeSwgcmVkaXNwYXRjaCBhcyBmYXRhbCAuLi5gKTtcbiAgICAgICAgICAvLyBzd2l0Y2ggZXJyb3IgdG8gZmF0YWxcbiAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAvLyAgd2hlbiBpbiBFUlJPUiBzdGF0ZSwgZG9uJ3Qgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpbiBjYXNlIGEgbm9uLWZhdGFsIGVycm9yIGlzIHJlY2VpdmVkXG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgLy8gaWYgZmF0YWwgZXJyb3IsIHN0b3AgcHJvY2Vzc2luZywgb3RoZXJ3aXNlIG1vdmUgdG8gSURMRSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgIHRoaXMuc3RhdGUgPSBkYXRhLmZhdGFsID8gU3RhdGUuRVJST1IgOiBTdGF0ZS5JRExFO1xuICAgICAgICBsb2dnZXIud2FybihgQXVkaW9TdHJlYW1Db250cm9sbGVyOiAke2RhdGEuZGV0YWlsc30gd2hpbGUgbG9hZGluZyBmcmFnLCBub3cgc3dpdGNoaW5nIHRvICR7dGhpcy5zdGF0ZX0gc3RhdGUgLi4uYCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgIC8vIGlmIGluIGFwcGVuZGluZyBzdGF0ZVxuICAgICAgaWYgKGRhdGEucGFyZW50ID09PSAnYXVkaW8nICYmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8wqB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQpKSB7XG4gICAgICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlcixcbiAgICAgICAgICBjdXJyZW50VGltZSA9IHRoaXMubWVkaWEuY3VycmVudFRpbWUsXG4gICAgICAgICAgbWVkaWFCdWZmZXJlZCA9IG1lZGlhICYmIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLCBjdXJyZW50VGltZSkgJiYgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsIGN1cnJlbnRUaW1lICsgMC41KTtcbiAgICAgICAgICAvLyByZWR1Y2UgbWF4IGJ1ZiBsZW4gaWYgY3VycmVudCBwb3NpdGlvbiBpcyBidWZmZXJlZFxuICAgICAgICBpZiAobWVkaWFCdWZmZXJlZCkge1xuICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgIGlmIChjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoID49IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCBhcyBpdCBtaWdodCBiZSB0b28gaGlnaC4gd2UgZG8gdGhpcyB0byBhdm9pZCBsb29wIGZsdXNoaW5nIC4uLlxuICAgICAgICAgICAgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCAvPSAyO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYEF1ZGlvU3RyZWFtQ29udHJvbGxlcjogcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIHRvICR7Y29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aH1zYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLCBidXQgYnJvd3NlciBpcyBzdGlsbCBjb21wbGFpbmluZyBhYm91dCBidWZmZXIgZnVsbCBlcnJvclxuICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBvbiBJRS9FZGdlLCByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9wdWxsLzcwOFxuICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSBmbHVzaCB0aGUgd2hvbGUgYXVkaW8gYnVmZmVyIHRvIHJlY292ZXJcbiAgICAgICAgICBsb2dnZXIud2FybignQXVkaW9TdHJlYW1Db250cm9sbGVyOiBidWZmZXIgZnVsbCBlcnJvciBhbHNvIG1lZGlhLmN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgZmx1c2ggYXVkaW8gYnVmZmVyJyk7XG4gICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgLy8gZmx1c2ggZXZlcnl0aGluZ1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hJTkcsIHsgc3RhcnRPZmZzZXQ6IDAsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0eXBlOiAnYXVkaW8nIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgb25CdWZmZXJGbHVzaGVkICgpIHtcbiAgICBsZXQgcGVuZGluZ0RhdGEgPSB0aGlzLnBlbmRpbmdEYXRhO1xuICAgIGlmIChwZW5kaW5nRGF0YSAmJiBwZW5kaW5nRGF0YS5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci5sb2coJ0F1ZGlvU3RyZWFtQ29udHJvbGxlcjogYXBwZW5kaW5nIHBlbmRpbmcgYXVkaW8gZGF0YSBhZnRlciBidWZmZXIgZmx1c2hlZCcpO1xuICAgICAgcGVuZGluZ0RhdGEuZm9yRWFjaChhcHBlbmRPYmogPT4ge1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsIGFwcGVuZE9iaik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xuICAgICAgdGhpcy5wZW5kaW5nRGF0YSA9IFtdO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbW92ZSB0byBJRExFIG9uY2UgZmx1c2ggY29tcGxldGUuIHRoaXMgc2hvdWxkIHRyaWdnZXIgbmV3IGZyYWdtZW50IGxvYWRpbmdcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIGZyYWdcbiAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgQXVkaW9TdHJlYW1Db250cm9sbGVyO1xuIiwiaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgVGFza0xvb3AgZnJvbSAnLi4vdGFzay1sb29wJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuXG4vKipcbiAqIEBjbGFzcyBBdWRpb1RyYWNrQ29udHJvbGxlclxuICogQGltcGxlbWVudHMge0V2ZW50SGFuZGxlcn1cbiAqXG4gKiBIYW5kbGVzIG1haW4gbWFuaWZlc3QgYW5kIGF1ZGlvLXRyYWNrIG1ldGFkYXRhIGxvYWRlZCxcbiAqIG93bnMgYW5kIGV4cG9zZXMgdGhlIHNlbGVjdGFibGUgYXVkaW8tdHJhY2tzIGRhdGEtbW9kZWxzLlxuICpcbiAqIEV4cG9zZXMgaW50ZXJuYWwgaW50ZXJmYWNlIHRvIHNlbGVjdCBhdmFpbGFibGUgYXVkaW8tdHJhY2tzLlxuICpcbiAqIEhhbmRsZXMgZXJyb3JzIG9uIGxvYWRpbmcgYXVkaW8tdHJhY2sgcGxheWxpc3RzLiBNYW5hZ2VzIGZhbGxiYWNrIG1lY2hhbmlzbVxuICogd2l0aCByZWR1bmRhbnRzIHRyYWNrcyAoZ3JvdXAtSURzKS5cbiAqXG4gKiBIYW5kbGVzIGxldmVsLWxvYWRpbmcgYW5kIGdyb3VwLUlEIHN3aXRjaGVzIGZvciB2aWRlbyAoZmFsbGJhY2sgb24gdmlkZW8gbGV2ZWxzKSxcbiAqIGFuZCBldmVudHVhbGx5IGFkYXB0cyB0aGUgYXVkaW8tdHJhY2sgZ3JvdXAtSUQgdG8gbWF0Y2guXG4gKlxuICogQGZpcmVzIEFVRElPX1RSQUNLX0xPQURJTkdcbiAqIEBmaXJlcyBBVURJT19UUkFDS19TV0lUQ0hJTkdcbiAqIEBmaXJlcyBBVURJT19UUkFDS1NfVVBEQVRFRFxuICogQGZpcmVzIEVSUk9SXG4gKlxuICovXG5jbGFzcyBBdWRpb1RyYWNrQ29udHJvbGxlciBleHRlbmRzIFRhc2tMb29wIHtcbiAgY29uc3RydWN0b3IgKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURJTkcsXG4gICAgICBFdmVudC5NQU5JRkVTVF9QQVJTRUQsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19MT0FERUQsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCxcbiAgICAgIEV2ZW50LkxFVkVMX0xPQURFRCxcbiAgICAgIEV2ZW50LkVSUk9SXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQ3VycmVudGx5IHNlbGVjdGVkIGluZGV4IGluIGB0cmFja3NgXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSB0cmFja0lkXG4gICAgICovXG4gICAgdGhpcy5fdHJhY2tJZCA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBJZiBzaG91bGQgc2VsZWN0IHRyYWNrcyBhY2NvcmRpbmcgdG8gZGVmYXVsdCB0cmFjayBhdHRyaWJ1dGVcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufSBfc2VsZWN0RGVmYXVsdFRyYWNrXG4gICAgICovXG4gICAgdGhpcy5fc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBBbGwgdHJhY2tzIGF2YWlsYWJsZVxuICAgICAqIEBtZW1iZXIge0F1ZGlvVHJhY2tbXX1cbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIExpc3Qgb2YgYmxhY2tsaXN0ZWQgYXVkaW8gdHJhY2sgSURzICh0aGF0IGhhdmUgY2F1c2VkIGZhaWx1cmUpXG4gICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICovXG4gICAgdGhpcy50cmFja0lkQmxhY2tsaXN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBUaGUgY3VycmVudGx5IHJ1bm5pbmcgZ3JvdXAgSUQgZm9yIGF1ZGlvXG4gICAgICogKHdlIGdyYWIgdGhpcyBvbiBtYW5pZmVzdC1wYXJzZWQgYW5kIG5ldyBsZXZlbC1sb2FkZWQpXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuYXVkaW9Hcm91cElkID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBhdWRpbyB0cmFja3Mgb24gbmV3IG1hbmlmZXN0IGxvYWRpbmcuXG4gICAqL1xuICBvbk1hbmlmZXN0TG9hZGluZyAoKSB7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLl90cmFja0lkID0gLTE7XG4gICAgdGhpcy5fc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZSB0cmFja3MgZGF0YSBmcm9tIG1hbmlmZXN0IHBhcnNlZCBkYXRhLlxuICAgKlxuICAgKiBUcmlnZ2VyIEFVRElPX1RSQUNLU19VUERBVEVEIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICovXG4gIG9uTWFuaWZlc3RQYXJzZWQgKGRhdGEpIHtcbiAgICBjb25zdCB0cmFja3MgPSB0aGlzLnRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MgfHwgW107XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS1NfVVBEQVRFRCwgeyBhdWRpb1RyYWNrczogdHJhY2tzIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlIHRyYWNrIGRldGFpbHMgb2YgbG9hZGVkIHRyYWNrIGluIG91ciBkYXRhLW1vZGVsLlxuICAgKlxuICAgKiBTZXQtdXAgbWV0YWRhdGEgdXBkYXRlIGludGVydmFsIHRhc2sgZm9yIGxpdmUtbW9kZSBzdHJlYW1zLlxuICAgKlxuICAgKiBAcGFyYW0ge30gZGF0YVxuICAgKi9cbiAgb25BdWRpb1RyYWNrTG9hZGVkIChkYXRhKSB7XG4gICAgaWYgKGRhdGEuaWQgPj0gdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIud2FybignSW52YWxpZCBhdWRpbyB0cmFjayBpZDonLCBkYXRhLmlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2dnZXIubG9nKGBhdWRpb1RyYWNrICR7ZGF0YS5pZH0gbG9hZGVkYCk7XG5cbiAgICB0aGlzLnRyYWNrc1tkYXRhLmlkXS5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuXG4gICAgLy8gY2hlY2sgaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3RcbiAgICAvLyBhbmQgaWYgd2UgaGF2ZSBhbHJlYWR5IG91ciByZWxvYWQgaW50ZXJ2YWwgc2V0dXBcbiAgICBpZiAoZGF0YS5kZXRhaWxzLmxpdmUgJiYgIXRoaXMuaGFzSW50ZXJ2YWwoKSkge1xuICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCB3ZSB3aWxsIGhhdmUgdG8gcmVsb2FkIGl0IHBlcmlvZGljYWxseVxuICAgICAgLy8gc2V0IHJlbG9hZCBwZXJpb2QgdG8gcGxheWxpc3QgdGFyZ2V0IGR1cmF0aW9uXG4gICAgICBjb25zdCB1cGRhdGVQZXJpb2RNcyA9IGRhdGEuZGV0YWlscy50YXJnZXRkdXJhdGlvbiAqIDEwMDA7XG4gICAgICB0aGlzLnNldEludGVydmFsKHVwZGF0ZVBlcmlvZE1zKTtcbiAgICB9XG5cbiAgICBpZiAoIWRhdGEuZGV0YWlscy5saXZlICYmIHRoaXMuaGFzSW50ZXJ2YWwoKSkge1xuICAgICAgLy8gcGxheWxpc3QgaXMgbm90IGxpdmUgYW5kIHRpbWVyIGlzIHNjaGVkdWxlZDogY2FuY2VsIGl0XG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBpbnRlcm5hbCBncm91cCBJRCB0byBhbnkgYXVkaW8tdHJhY2sgd2UgbWF5IGhhdmUgc2V0IG1hbnVhbGx5XG4gICAqIG9yIGJlY2F1c2Ugb2YgYSBmYWlsdXJlLWhhbmRsaW5nIGZhbGxiYWNrLlxuICAgKlxuICAgKiBRdWFsaXR5LWxldmVscyBzaG91bGQgdXBkYXRlIHRvIHRoYXQgZ3JvdXAgSUQgaW4gdGhpcyBjYXNlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICovXG4gIG9uQXVkaW9UcmFja1N3aXRjaGVkIChkYXRhKSB7XG4gICAgY29uc3QgYXVkaW9Hcm91cElkID0gdGhpcy50cmFja3NbZGF0YS5pZF0uZ3JvdXBJZDtcbiAgICBpZiAoYXVkaW9Hcm91cElkICYmICh0aGlzLmF1ZGlvR3JvdXBJZCAhPT0gYXVkaW9Hcm91cElkKSkge1xuICAgICAgdGhpcy5hdWRpb0dyb3VwSWQgPSBhdWRpb0dyb3VwSWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBsZXZlbCBnZXRzIGxvYWRlZCwgaWYgaXQgaGFzIHJlZHVuZGFudCBhdWRpb0dyb3VwSWRzIChpbiB0aGUgc2FtZSBvcmRpbmFsaXR5IGFzIGl0J3MgcmVkdW5kYW50IFVSTHMpXG4gICAqIHdlIGFyZSBzZXR0aW5nIG91ciBhdWRpby1ncm91cCBJRCBpbnRlcm5hbGx5IHRvIHRoZSBvbmUgc2V0LCBpZiBpdCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZ3JvdXAgSUQgY3VycmVudGx5IHNldC5cbiAgICpcbiAgICogSWYgZ3JvdXAtSUQgZ290IHVwZGF0ZSwgd2UgcmUtc2VsZWN0IHRoZSBhcHByb3ByaWF0ZSBhdWRpby10cmFjayB3aXRoIHRoaXMgZ3JvdXAtSUQgbWF0Y2hpbmcgdGhlIGN1cnJlbnRseVxuICAgKiBzZWxlY3RlZCBvbmUgKGJhc2VkIG9uIE5BTUUgcHJvcGVydHkpLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICovXG4gIG9uTGV2ZWxMb2FkZWQgKGRhdGEpIHtcbiAgICAvLyBGSVhNRTogY3Jhc2hlcyBiZWNhdXNlIGN1cnJlbnRMZXZlbCBpcyB1bmRlZmluZWRcbiAgICAvLyBjb25zdCBsZXZlbEluZm8gPSB0aGlzLmhscy5sZXZlbHNbdGhpcy5obHMuY3VycmVudExldmVsXTtcblxuICAgIGNvbnN0IGxldmVsSW5mbyA9IHRoaXMuaGxzLmxldmVsc1tkYXRhLmxldmVsc107XG5cbiAgICBpZiAoIWxldmVsSW5mby5hdWRpb0dyb3VwSWRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXVkaW9Hcm91cElkID0gbGV2ZWxJbmZvLmF1ZGlvR3JvdXBJZHNbbGV2ZWxJbmZvLnVybElkXTtcbiAgICBpZiAodGhpcy5hdWRpb0dyb3VwSWQgIT09IGF1ZGlvR3JvdXBJZCkge1xuICAgICAgdGhpcy5hdWRpb0dyb3VwSWQgPSBhdWRpb0dyb3VwSWQ7XG4gICAgICB0aGlzLl9zZWxlY3RJbml0aWFsQXVkaW9UcmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgbmV0d29yayBlcnJvcnMgbG9hZGluZyBhdWRpbyB0cmFjayBtYW5pZmVzdHNcbiAgICogYW5kIGFsc28gcGF1c2luZyBvbiBhbnkgbmV0d29rIGVycm9ycy5cbiAgICpcbiAgICogQHBhcmFtIHtFcnJvckV2ZW50RGF0YX0gZGF0YVxuICAgKi9cbiAgb25FcnJvciAoZGF0YSkge1xuICAgIC8vIE9ubHkgaGFuZGxlIG5ldHdvcmsgZXJyb3JzXG4gICAgaWYgKGRhdGEudHlwZSAhPT0gRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgZmF0YWwgbmV0d29yayBlcnJvciwgY2FuY2VsIHVwZGF0ZSB0YXNrXG4gICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgIH1cblxuICAgIC8vIElmIG5vdCBhbiBhdWRpby10cmFjayBsb2FkaW5nIGVycm9yIGRvbid0IGhhbmRsZSBmdXJ0aGVyXG4gICAgaWYgKGRhdGEuZGV0YWlscyAhPT0gRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2dnZXIud2FybignTmV0d29yayBmYWlsdXJlIG9uIGF1ZGlvLXRyYWNrIGlkOicsIGRhdGEuY29udGV4dC5pZCk7XG4gICAgdGhpcy5faGFuZGxlTG9hZEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0F1ZGlvVHJhY2tbXX0gQXVkaW8tdHJhY2sgbGlzdCB3ZSBvd25cbiAgICovXG4gIGdldCBhdWRpb1RyYWNrcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9IEluZGV4IGludG8gYXVkaW8tdHJhY2tzIGxpc3Qgb2YgY3VycmVudGx5IHNlbGVjdGVkIHRyYWNrLlxuICAgKi9cbiAgZ2V0IGF1ZGlvVHJhY2sgKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFja0lkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBjdXJyZW50IHRyYWNrIGJ5IGluZGV4XG4gICAqL1xuICBzZXQgYXVkaW9UcmFjayAobmV3SWQpIHtcbiAgICB0aGlzLl9zZXRBdWRpb1RyYWNrKG5ld0lkKTtcbiAgICAvLyBJZiBhdWRpbyB0cmFjayBpcyBzZWxlY3RlZCBmcm9tIEFQSSB0aGVuIGRvbid0IGNob29zZSBmcm9tIHRoZSBtYW5pZmVzdCBkZWZhdWx0IHRyYWNrXG4gICAgdGhpcy5fc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5ld0lkXG4gICAqL1xuICBfc2V0QXVkaW9UcmFjayAobmV3SWQpIHtcbiAgICAvLyBub29wIG9uIHNhbWUgYXVkaW8gdHJhY2sgaWQgYXMgYWxyZWFkeSBzZXRcbiAgICBpZiAodGhpcy5fdHJhY2tJZCA9PT0gbmV3SWQgJiYgdGhpcy50cmFja3NbdGhpcy5fdHJhY2tJZF0uZGV0YWlscykge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdTYW1lIGlkIGFzIGN1cnJlbnQgYXVkaW8tdHJhY2sgcGFzc2VkLCBhbmQgdHJhY2sgZGV0YWlscyBhdmFpbGFibGUgLT4gbm8tb3AnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICBpZiAobmV3SWQgPCAwIHx8IG5ld0lkID49IHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLndhcm4oJ0ludmFsaWQgaWQgcGFzc2VkIHRvIGF1ZGlvLXRyYWNrIGNvbnRyb2xsZXInKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhdWRpb1RyYWNrID0gdGhpcy50cmFja3NbbmV3SWRdO1xuXG4gICAgbG9nZ2VyLmxvZyhgTm93IHN3aXRjaGluZyB0byBhdWRpby10cmFjayBpbmRleCAke25ld0lkfWApO1xuXG4gICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgdGhpcy5fdHJhY2tJZCA9IG5ld0lkO1xuXG4gICAgY29uc3QgeyB1cmwsIHR5cGUsIGlkIH0gPSBhdWRpb1RyYWNrO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB7IGlkLCB0eXBlLCB1cmwgfSk7XG4gICAgdGhpcy5fbG9hZFRyYWNrRGV0YWlsc0lmTmVlZGVkKGF1ZGlvVHJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZG9UaWNrICgpIHtcbiAgICB0aGlzLl91cGRhdGVUcmFjayh0aGlzLl90cmFja0lkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgaW5pdGlhbCB0cmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlbGVjdEluaXRpYWxBdWRpb1RyYWNrICgpIHtcbiAgICBsZXQgdHJhY2tzID0gdGhpcy50cmFja3M7XG4gICAgaWYgKCF0cmFja3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudEF1ZGlvVHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLl90cmFja0lkXTtcblxuICAgIGxldCBuYW1lID0gbnVsbDtcbiAgICBpZiAoY3VycmVudEF1ZGlvVHJhY2spIHtcbiAgICAgIG5hbWUgPSBjdXJyZW50QXVkaW9UcmFjay5uYW1lO1xuICAgIH1cblxuICAgIC8vIFByZS1zZWxlY3QgZGVmYXVsdCB0cmFja3MgaWYgdGhlcmUgYXJlIGFueVxuICAgIGlmICh0aGlzLl9zZWxlY3REZWZhdWx0VHJhY2spIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRUcmFja3MgPSB0cmFja3MuZmlsdGVyKCh0cmFjaykgPT4gdHJhY2suZGVmYXVsdCk7XG4gICAgICBpZiAoZGVmYXVsdFRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgdHJhY2tzID0gZGVmYXVsdFRyYWNrcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdObyBkZWZhdWx0IGF1ZGlvIHRyYWNrcyBkZWZpbmVkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHRyYWNrRm91bmQgPSBmYWxzZTtcblxuICAgIGNvbnN0IHRyYXZlcnNlVHJhY2tzID0gKCkgPT4ge1xuICAgICAgLy8gU2VsZWN0IHRyYWNrIHdpdGggcmlnaHQgZ3JvdXAgSURcbiAgICAgIHRyYWNrcy5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICBpZiAodHJhY2tGb3VuZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBuZWVkIHRvIG1hdGNoIHRoZSAocHJlLSlzZWxlY3RlZCBncm91cCBJRFxuICAgICAgICAvLyBhbmQgdGhlIE5BTUUgb2YgdGhlIGN1cnJlbnQgdHJhY2suXG4gICAgICAgIGlmICgoIXRoaXMuYXVkaW9Hcm91cElkIHx8IHRyYWNrLmdyb3VwSWQgPT09IHRoaXMuYXVkaW9Hcm91cElkKSAmJlxuICAgICAgICAgICghbmFtZSB8fCBuYW1lID09PSB0cmFjay5uYW1lKSkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHByZXZpb3VzIHRyYWNrIHRyeSB0byBzdGF5IHdpdGggdGhlIHNhbWUgYE5BTUVgLlxuICAgICAgICAgIC8vIEl0IHNob3VsZCBiZSB1bmlxdWUgYWNyb3NzIHRyYWNrcyBvZiBzYW1lIGdyb3VwLCBhbmQgY29uc2lzdGVudCB0aHJvdWdoIHJlZHVuZGFudCB0cmFjayBncm91cHMuXG4gICAgICAgICAgdGhpcy5fc2V0QXVkaW9UcmFjayh0cmFjay5pZCk7XG4gICAgICAgICAgdHJhY2tGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0cmF2ZXJzZVRyYWNrcygpO1xuXG4gICAgaWYgKCF0cmFja0ZvdW5kKSB7XG4gICAgICBuYW1lID0gbnVsbDtcbiAgICAgIHRyYXZlcnNlVHJhY2tzKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0cmFja0ZvdW5kKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoYE5vIHRyYWNrIGZvdW5kIGZvciBydW5uaW5nIGF1ZGlvIGdyb3VwLUlEOiAke3RoaXMuYXVkaW9Hcm91cElkfWApO1xuXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXVkaW9UcmFja30gYXVkaW9UcmFja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIF9uZWVkc1RyYWNrTG9hZGluZyAoYXVkaW9UcmFjaykge1xuICAgIGNvbnN0IHsgZGV0YWlscywgdXJsIH0gPSBhdWRpb1RyYWNrO1xuXG4gICAgaWYgKCFkZXRhaWxzIHx8IGRldGFpbHMubGl2ZSkge1xuICAgICAgLy8gY2hlY2sgaWYgd2UgZmFjZSBhbiBhdWRpbyB0cmFjayBlbWJlZGRlZCBpbiBtYWluIHBsYXlsaXN0IChhdWRpbyB0cmFjayB3aXRob3V0IFVSSSBhdHRyaWJ1dGUpXG4gICAgICByZXR1cm4gISF1cmw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXVkaW9UcmFja30gYXVkaW9UcmFja1xuICAgKi9cbiAgX2xvYWRUcmFja0RldGFpbHNJZk5lZWRlZCAoYXVkaW9UcmFjaykge1xuICAgIGlmICh0aGlzLl9uZWVkc1RyYWNrTG9hZGluZyhhdWRpb1RyYWNrKSkge1xuICAgICAgY29uc3QgeyB1cmwsIGlkIH0gPSBhdWRpb1RyYWNrO1xuICAgICAgLy8gdHJhY2sgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgbG9nZ2VyLmxvZyhgbG9hZGluZyBhdWRpby10cmFjayBwbGF5bGlzdCBmb3IgaWQ6ICR7aWR9YCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX0xPQURJTkcsIHsgdXJsLCBpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5ld0lkXG4gICAqL1xuICBfdXBkYXRlVHJhY2sgKG5ld0lkKSB7XG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgaWYgKG5ld0lkIDwgMCB8fCBuZXdJZCA+PSB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICB0aGlzLl90cmFja0lkID0gbmV3SWQ7XG4gICAgbG9nZ2VyLmxvZyhgdHJ5aW5nIHRvIHVwZGF0ZSBhdWRpby10cmFjayAke25ld0lkfWApO1xuICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSB0aGlzLnRyYWNrc1tuZXdJZF07XG4gICAgdGhpcy5fbG9hZFRyYWNrRGV0YWlsc0lmTmVlZGVkKGF1ZGlvVHJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFuZGxlTG9hZEVycm9yICgpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgYmxhY2sgbGlzdCBjdXJyZW50IHRyYWNrIGlkXG4gICAgdGhpcy50cmFja0lkQmxhY2tsaXN0W3RoaXMuX3RyYWNrSWRdID0gdHJ1ZTtcblxuICAgIC8vIExldCdzIHRyeSB0byBmYWxsIGJhY2sgb24gYSBmdW5jdGlvbmFsIGF1ZGlvLXRyYWNrIHdpdGggdGhlIHNhbWUgZ3JvdXAgSURcbiAgICBjb25zdCBwcmV2aW91c0lkID0gdGhpcy5fdHJhY2tJZDtcbiAgICBjb25zdCB7IG5hbWUsIGxhbmd1YWdlLCBncm91cElkIH0gPSB0aGlzLnRyYWNrc1twcmV2aW91c0lkXTtcblxuICAgIGxvZ2dlci53YXJuKGBMb2FkaW5nIGZhaWxlZCBvbiBhdWRpbyB0cmFjayBpZDogJHtwcmV2aW91c0lkfSwgZ3JvdXAtaWQ6ICR7Z3JvdXBJZH0sIG5hbWUvbGFuZ3VhZ2U6IFwiJHtuYW1lfVwiIC8gXCIke2xhbmd1YWdlfVwiYCk7XG5cbiAgICAvLyBGaW5kIGEgbm9uLWJsYWNrbGlzdGVkIHRyYWNrIElEIHdpdGggdGhlIHNhbWUgTkFNRVxuICAgIC8vIEF0IGxlYXN0IGEgdHJhY2sgdGhhdCBpcyBub3QgYmxhY2tsaXN0ZWQsIHRodXMgb24gYW5vdGhlciBncm91cC1JRC5cbiAgICBsZXQgbmV3SWQgPSBwcmV2aW91c0lkO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLnRyYWNrSWRCbGFja2xpc3RbaV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdUcmFjayA9IHRoaXMudHJhY2tzW2ldO1xuICAgICAgaWYgKG5ld1RyYWNrLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbmV3SWQgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmV3SWQgPT09IHByZXZpb3VzSWQpIHtcbiAgICAgIGxvZ2dlci53YXJuKGBObyBmYWxsYmFjayBhdWRpby10cmFjayBmb3VuZCBmb3IgbmFtZS9sYW5ndWFnZTogXCIke25hbWV9XCIgLyBcIiR7bGFuZ3VhZ2V9XCJgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2dnZXIubG9nKCdBdHRlbXB0aW5nIGF1ZGlvLXRyYWNrIGZhbGxiYWNrIGlkOicsIG5ld0lkLCAnZ3JvdXAtaWQ6JywgdGhpcy50cmFja3NbbmV3SWRdLmdyb3VwSWQpO1xuXG4gICAgdGhpcy5fc2V0QXVkaW9UcmFjayhuZXdJZCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXVkaW9UcmFja0NvbnRyb2xsZXI7XG4iLCJpbXBvcnQgVGFza0xvb3AgZnJvbSAnLi4vdGFzay1sb29wJztcbmltcG9ydCB7IEZyYWdtZW50U3RhdGUgfSBmcm9tICcuL2ZyYWdtZW50LXRyYWNrZXInO1xuaW1wb3J0IHsgQnVmZmVySGVscGVyIH0gZnJvbSAnLi4vdXRpbHMvYnVmZmVyLWhlbHBlcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5leHBvcnQgY29uc3QgU3RhdGUgPSB7XG4gIFNUT1BQRUQ6ICdTVE9QUEVEJyxcbiAgU1RBUlRJTkc6ICdTVEFSVElORycsXG4gIElETEU6ICdJRExFJyxcbiAgUEFVU0VEOiAnUEFVU0VEJyxcbiAgS0VZX0xPQURJTkc6ICdLRVlfTE9BRElORycsXG4gIEZSQUdfTE9BRElORzogJ0ZSQUdfTE9BRElORycsXG4gIEZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxuICBXQUlUSU5HX1RSQUNLOiAnV0FJVElOR19UUkFDSycsXG4gIFBBUlNJTkc6ICdQQVJTSU5HJyxcbiAgUEFSU0VEOiAnUEFSU0VEJyxcbiAgQlVGRkVSX0ZMVVNISU5HOiAnQlVGRkVSX0ZMVVNISU5HJyxcbiAgRU5ERUQ6ICdFTkRFRCcsXG4gIEVSUk9SOiAnRVJST1InLFxuICBXQUlUSU5HX0lOSVRfUFRTOiAnV0FJVElOR19JTklUX1BUUycsXG4gIFdBSVRJTkdfTEVWRUw6ICdXQUlUSU5HX0xFVkVMJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZVN0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBUYXNrTG9vcCB7XG4gIGRvVGljayAoKSB7fVxuXG4gIHN0YXJ0TG9hZCAoKSB7fVxuXG4gIHN0b3BMb2FkICgpIHtcbiAgICBsZXQgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIGlmIChmcmFnLmxvYWRlcikge1xuICAgICAgICBmcmFnLmxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gIH1cblxuICBfc3RyZWFtRW5kZWQgKGJ1ZmZlckluZm8sIGxldmVsRGV0YWlscykge1xuICAgIGNvbnN0IHsgZnJhZ0N1cnJlbnQsIGZyYWdtZW50VHJhY2tlciB9ID0gdGhpcztcbiAgICAvLyB3ZSBqdXN0IGdvdCBkb25lIGxvYWRpbmcgdGhlIGZpbmFsIGZyYWdtZW50IGFuZCB0aGVyZSBpcyBubyBvdGhlciBidWZmZXJlZCByYW5nZSBhZnRlciAuLi5cbiAgICAvLyByYXRpb25hbGUgaXMgdGhhdCBpbiBjYXNlIHRoZXJlIGFyZSBhbnkgYnVmZmVyZWQgcmFuZ2VzIGFmdGVyLCBpdCBtZWFucyB0aGF0IHRoZXJlIGFyZSB1bmJ1ZmZlcmVkIHBvcnRpb24gaW4gYmV0d2VlblxuICAgIC8vIHNvIHdlIHNob3VsZCBub3Qgc3dpdGNoIHRvIEVOREVEIGluIHRoYXQgY2FzZSwgdG8gYmUgYWJsZSB0byBidWZmZXIgdGhlbVxuICAgIC8vIGRvbnQgc3dpdGNoIHRvIEVOREVEIGlmIHdlIG5lZWQgdG8gYmFja3RyYWNrIGxhc3QgZnJhZ21lbnRcbiAgICBpZiAoIWxldmVsRGV0YWlscy5saXZlICYmIGZyYWdDdXJyZW50ICYmICFmcmFnQ3VycmVudC5iYWNrdHJhY2tlZCAmJiBmcmFnQ3VycmVudC5zbiA9PT0gbGV2ZWxEZXRhaWxzLmVuZFNOICYmICFidWZmZXJJbmZvLm5leHRTdGFydCkge1xuICAgICAgY29uc3QgZnJhZ1N0YXRlID0gZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWdDdXJyZW50KTtcbiAgICAgIHJldHVybiBmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuUEFSVElBTCB8fCBmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuT0s7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG9uTWVkaWFTZWVraW5nICgpIHtcbiAgICBjb25zdCB7IGNvbmZpZywgbWVkaWEsIG1lZGlhQnVmZmVyLCBzdGF0ZSB9ID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiBudWxsO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYUJ1ZmZlciB8fCBtZWRpYSwgY3VycmVudFRpbWUsIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShjdXJyZW50VGltZSkpIHtcbiAgICAgIGxvZ2dlci5sb2coYG1lZGlhIHNlZWtpbmcgdG8gJHtjdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HKSB7XG4gICAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIHNlZWtpbmcgdG8gYSB1bmJ1ZmZlcmVkIGFyZWEgQU5EIGlmIGZyYWcgbG9hZGluZyBpcyBpbiBwcm9ncmVzc1xuICAgICAgaWYgKGJ1ZmZlckluZm8ubGVuID09PSAwICYmIGZyYWdDdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgICBjb25zdCBmcmFnU3RhcnRPZmZzZXQgPSBmcmFnQ3VycmVudC5zdGFydCAtIHRvbGVyYW5jZTtcbiAgICAgICAgY29uc3QgZnJhZ0VuZE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0ICsgZnJhZ0N1cnJlbnQuZHVyYXRpb24gKyB0b2xlcmFuY2U7XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIHNlZWsgcG9zaXRpb24gd2lsbCBiZSBvdXQgb2YgY3VycmVudGx5IGxvYWRlZCBmcmFnIHJhbmdlIDogaWYgb3V0IGNhbmNlbCBmcmFnIGxvYWQsIGlmIGluLCBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICBpZiAoY3VycmVudFRpbWUgPCBmcmFnU3RhcnRPZmZzZXQgfHwgY3VycmVudFRpbWUgPiBmcmFnRW5kT2Zmc2V0KSB7XG4gICAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnc2Vla2luZyBvdXRzaWRlIG9mIGJ1ZmZlciB3aGlsZSBmcmFnbWVudCBsb2FkIGluIHByb2dyZXNzLCBjYW5jZWwgZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3NlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgYnV0IHdpdGhpbiBjdXJyZW50bHkgbG9hZGVkIGZyYWdtZW50IHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xuICAgICAgLy8gaWYgc2Vla2luZyB0byB1bmJ1ZmZlcmVkIGFyZWEsIGNsZWFuIHVwIGZyYWdQcmV2aW91c1xuICAgICAgaWYgKGJ1ZmZlckluZm8ubGVuID09PSAwKSB7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGNoZWNrIGZvciBwb3RlbnRpYWwgbmV3IGZyYWdtZW50XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIH1cblxuICAgIC8vIGluIGNhc2Ugc2Vla2luZyBvY2N1cnMgYWx0aG91Z2ggbm8gbWVkaWEgYnVmZmVyZWQsIGFkanVzdCBzdGFydFBvc2l0aW9uIGFuZCBuZXh0TG9hZFBvc2l0aW9uIHRvIHNlZWsgdGFyZ2V0XG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSBjdXJyZW50VGltZTtcbiAgICB9XG5cbiAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIHByb2Nlc3NpbmdcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uTWVkaWFFbmRlZCAoKSB7XG4gICAgLy8gcmVzZXQgc3RhcnRQb3NpdGlvbiBhbmQgbGFzdEN1cnJlbnRUaW1lIHRvIHJlc3RhcnQgcGxheWJhY2sgQCBzdHJlYW0gYmVnaW5uaW5nXG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICB9XG5cbiAgb25IYW5kbGVyRGVzdHJveWluZyAoKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIHN1cGVyLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcbiAgfVxuXG4gIG9uSGFuZGxlckRlc3Ryb3llZCAoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBudWxsO1xuICB9XG59XG4iLCIvKlxuICogQnVmZmVyIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgZ2V0TWVkaWFTb3VyY2UgfSBmcm9tICcuLi91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXInO1xuXG5jb25zdCBNZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKCk7XG5cbmNsYXNzIEJ1ZmZlckNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNISU5HLFxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfUEFSU0VELFxuICAgICAgRXZlbnQuQlVGRkVSX1JFU0VULFxuICAgICAgRXZlbnQuQlVGRkVSX0FQUEVORElORyxcbiAgICAgIEV2ZW50LkJVRkZFUl9DT0RFQ1MsXG4gICAgICBFdmVudC5CVUZGRVJfRU9TLFxuICAgICAgRXZlbnQuQlVGRkVSX0ZMVVNISU5HLFxuICAgICAgRXZlbnQuTEVWRUxfUFRTX1VQREFURUQsXG4gICAgICBFdmVudC5MRVZFTF9VUERBVEVEKTtcblxuICAgIC8vIHRoZSB2YWx1ZSB0aGF0IHdlIGhhdmUgc2V0IG1lZGlhc291cmNlLmR1cmF0aW9uIHRvXG4gICAgLy8gKHRoZSBhY3R1YWwgZHVyYXRpb24gbWF5IGJlIHR3ZWFrZWQgc2xpZ2hseSBieSB0aGUgYnJvd3NlcilcbiAgICB0aGlzLl9tc0R1cmF0aW9uID0gbnVsbDtcbiAgICAvLyB0aGUgdmFsdWUgdGhhdCB3ZSB3YW50IHRvIHNldCBtZWRpYVNvdXJjZS5kdXJhdGlvbiB0b1xuICAgIHRoaXMuX2xldmVsRHVyYXRpb24gPSBudWxsO1xuICAgIC8vIHRoZSB0YXJnZXQgZHVyYXRpb24gb2YgdGhlIGN1cnJlbnQgbWVkaWEgcGxheWxpc3RcbiAgICB0aGlzLl9sZXZlbFRhcmdldER1cmF0aW9uID0gMTA7XG4gICAgLy8gY3VycmVudCBzdHJlYW0gc3RhdGU6IHRydWUgLSBmb3IgbGl2ZSBicm9hZGNhc3QsIGZhbHNlIC0gZm9yIFZvRCBjb250ZW50XG4gICAgdGhpcy5fbGl2ZSA9IG51bGw7XG4gICAgLy8gY2FjaGUgdGhlIHNlbGYgZ2VuZXJhdGVkIG9iamVjdCB1cmwgdG8gZGV0ZWN0IGhpamFjayBvZiB2aWRlbyB0YWdcbiAgICB0aGlzLl9vYmplY3RVcmwgPSBudWxsO1xuICAgIC8vIFRoZSBudW1iZXIgb2YgQlVGRkVSX0NPREVDIGV2ZW50cyByZWNlaXZlZCBiZWZvcmUgYW55IHNvdXJjZUJ1ZmZlcnMgYXJlIGNyZWF0ZWRcbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSAwO1xuXG4gICAgLy8gU291cmNlIEJ1ZmZlciBsaXN0ZW5lcnNcbiAgICB0aGlzLm9uc2J1ZSA9IHRoaXMub25TQlVwZGF0ZUVuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25zYmUgPSB0aGlzLm9uU0JVcGRhdGVFcnJvci5iaW5kKHRoaXMpO1xuICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgIHRoaXMudHJhY2tzID0ge307XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIG9uTGV2ZWxQdHNVcGRhdGVkIChkYXRhKSB7XG4gICAgbGV0IHR5cGUgPSBkYXRhLnR5cGU7XG4gICAgbGV0IGF1ZGlvVHJhY2sgPSB0aGlzLnRyYWNrcy5hdWRpbztcblxuICAgIC8vIEFkanVzdGluZyBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGAgKGRlc2lyZWQgcG9pbnQgaW4gdGhlIHRpbWVsaW5lIHdoZXJlIHRoZSBuZXh0IGZyYW1lcyBzaG91bGQgYmUgYXBwZW5kZWQpXG4gICAgLy8gaW4gQ2hyb21lIGJyb3dzZXIgd2hlbiB3ZSBkZXRlY3QgTVBFRyBhdWRpbyBjb250YWluZXIgYW5kIHRpbWUgZGVsdGEgYmV0d2VlbiBsZXZlbCBQVFMgYW5kIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YFxuICAgIC8vIGlzIGdyZWF0ZXIgdGhhbiAxMDBtcyAodGhpcyBpcyBlbm91Z2ggdG8gaGFuZGxlIHNlZWsgZm9yIFZPRCBvciBsZXZlbCBjaGFuZ2UgZm9yIExJVkUgdmlkZW9zKS4gQXQgdGhlIHRpbWUgb2YgY2hhbmdlIHdlIGlzc3VlXG4gICAgLy8gYFNvdXJjZUJ1ZmZlci5hYm9ydCgpYCBhbmQgYWRqdXN0aW5nIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YCBpZiBgU291cmNlQnVmZmVyLnVwZGF0aW5nYCBpcyBmYWxzZSBvciBhd2FpdGluZyBgdXBkYXRlZW5kYFxuICAgIC8vIGV2ZW50IGlmIFNCIGlzIGluIHVwZGF0aW5nIHN0YXRlLlxuICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMzMyI2lzc3VlY29tbWVudC0yNTc5ODY0ODZcblxuICAgIGlmICh0eXBlID09PSAnYXVkaW8nICYmIGF1ZGlvVHJhY2sgJiYgYXVkaW9UcmFjay5jb250YWluZXIgPT09ICdhdWRpby9tcGVnJykgeyAvLyBDaHJvbWUgYXVkaW8gbXAzIHRyYWNrXG4gICAgICBsZXQgYXVkaW9CdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlci5hdWRpbztcbiAgICAgIGxldCBkZWx0YSA9IE1hdGguYWJzKGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCAtIGRhdGEuc3RhcnQpO1xuXG4gICAgICAvLyBhZGp1c3QgdGltZXN0YW1wIG9mZnNldCBpZiB0aW1lIGRlbHRhIGlzIGdyZWF0ZXIgdGhhbiAxMDBtc1xuICAgICAgaWYgKGRlbHRhID4gMC4xKSB7XG4gICAgICAgIGxldCB1cGRhdGluZyA9IGF1ZGlvQnVmZmVyLnVwZGF0aW5nO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXVkaW9CdWZmZXIuYWJvcnQoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ2NhbiBub3QgYWJvcnQgYXVkaW8gYnVmZmVyOiAnICsgZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXBkYXRpbmcpIHtcbiAgICAgICAgICBsb2dnZXIud2FybignY2hhbmdlIG1wZWcgYXVkaW8gdGltZXN0YW1wIG9mZnNldCBmcm9tICcgKyBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgKyAnIHRvICcgKyBkYXRhLnN0YXJ0KTtcbiAgICAgICAgICBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgPSBkYXRhLnN0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQgPSBkYXRhLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25NYW5pZmVzdFBhcnNlZCAoZGF0YSkge1xuICAgIC8vIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIDIgQlVGRkVSX0NPREVDUyBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQsIG9uZSBwZXIgc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAvLyBzb3VyY2VidWZmZXJzIHdpbGwgYmUgY3JlYXRlZCBhbGwgYXQgb25jZSB3aGVuIHRoZSBleHBlY3RlZCBuYiBvZiB0cmFja3Mgd2lsbCBiZSByZWFjaGVkXG4gICAgLy8gaW4gY2FzZSBhbHQgYXVkaW8gaXMgbm90IHVzZWQsIG9ubHkgb25lIEJVRkZFUl9DT0RFQyBldmVudCB3aWxsIGJlIGZpcmVkIGZyb20gbWFpbiBzdHJlYW0gY29udHJvbGxlclxuICAgIC8vIGl0IHdpbGwgY29udGFpbiB0aGUgZXhwZWN0ZWQgbmIgb2Ygc291cmNlIGJ1ZmZlcnMsIG5vIG5lZWQgdG8gY29tcHV0ZSBpdFxuICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IGRhdGEuYWx0QXVkaW8gPyAyIDogMTtcbiAgICBsb2dnZXIubG9nKGAke3RoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZH0gYnVmZmVyQ29kZWMgZXZlbnQocykgZXhwZWN0ZWRgKTtcbiAgfVxuXG4gIG9uTWVkaWFBdHRhY2hpbmcgKGRhdGEpIHtcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIC8vIHNldHVwIHRoZSBtZWRpYSBzb3VyY2VcbiAgICAgIGxldCBtcyA9IHRoaXMubWVkaWFTb3VyY2UgPSBuZXcgTWVkaWFTb3VyY2UoKTtcbiAgICAgIC8vIE1lZGlhIFNvdXJjZSBsaXN0ZW5lcnNcbiAgICAgIHRoaXMub25tc28gPSB0aGlzLm9uTWVkaWFTb3VyY2VPcGVuLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLm9ubXNlID0gdGhpcy5vbk1lZGlhU291cmNlRW5kZWQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMub25tc2MgPSB0aGlzLm9uTWVkaWFTb3VyY2VDbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25tc28pO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLm9ubXNlKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5vbm1zYyk7XG4gICAgICAvLyBsaW5rIHZpZGVvIGFuZCBtZWRpYSBTb3VyY2VcbiAgICAgIG1lZGlhLnNyYyA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG1zKTtcbiAgICAgIC8vIGNhY2hlIHRoZSBsb2NhbGx5IGdlbmVyYXRlZCBvYmplY3QgdXJsXG4gICAgICB0aGlzLl9vYmplY3RVcmwgPSBtZWRpYS5zcmM7XG4gICAgfVxuICB9XG5cbiAgb25NZWRpYURldGFjaGluZyAoKSB7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGRldGFjaGluZycpO1xuICAgIGxldCBtcyA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgaWYgKG1zKSB7XG4gICAgICBpZiAobXMucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gZW5kT2ZTdHJlYW0gY291bGQgdHJpZ2dlciBleGNlcHRpb24gaWYgYW55IHNvdXJjZWJ1ZmZlciBpcyBpbiB1cGRhdGluZyBzdGF0ZVxuICAgICAgICAgIC8vIHdlIGRvbid0IHJlYWxseSBjYXJlIGFib3V0IGNoZWNraW5nIHNvdXJjZWJ1ZmZlciBzdGF0ZSBoZXJlLFxuICAgICAgICAgIC8vIGFzIHdlIGFyZSBhbnl3YXkgZGV0YWNoaW5nIHRoZSBNZWRpYVNvdXJjZVxuICAgICAgICAgIC8vIGxldCdzIGp1c3QgYXZvaWQgdGhpcyBleGNlcHRpb24gdG8gcHJvcGFnYXRlXG4gICAgICAgICAgbXMuZW5kT2ZTdHJlYW0oKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYG9uTWVkaWFEZXRhY2hpbmc6JHtlcnIubWVzc2FnZX0gd2hpbGUgY2FsbGluZyBlbmRPZlN0cmVhbWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vbm1zbyk7XG4gICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMub25tc2UpO1xuICAgICAgbXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLm9ubXNjKTtcblxuICAgICAgLy8gRGV0YWNoIHByb3Blcmx5IHRoZSBNZWRpYVNvdXJjZSBmcm9tIHRoZSBIVE1MTWVkaWFFbGVtZW50IGFzXG4gICAgICAvLyBzdWdnZXN0ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3czYy9tZWRpYS1zb3VyY2UvaXNzdWVzLzUzLlxuICAgICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5fb2JqZWN0VXJsKTtcblxuICAgICAgICAvLyBjbGVhbiB1cCB2aWRlbyB0YWcgc3JjIG9ubHkgaWYgaXQncyBvdXIgb3duIHVybC4gc29tZSBleHRlcm5hbCBsaWJyYXJpZXMgbWlnaHRcbiAgICAgICAgLy8gaGlqYWNrIHRoZSB2aWRlbyB0YWcgYW5kIGNoYW5nZSBpdHMgJ3NyYycgd2l0aG91dCBkZXN0cm95aW5nIHRoZSBIbHMgaW5zdGFuY2UgZmlyc3RcbiAgICAgICAgaWYgKHRoaXMubWVkaWEuc3JjID09PSB0aGlzLl9vYmplY3RVcmwpIHtcbiAgICAgICAgICB0aGlzLm1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgdGhpcy5tZWRpYS5sb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ21lZGlhLnNyYyB3YXMgY2hhbmdlZCBieSBhIHRoaXJkIHBhcnR5IC0gc2tpcCBjbGVhbnVwJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5tZWRpYVNvdXJjZSA9IG51bGw7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMuX29iamVjdFVybCA9IG51bGw7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICAgIHRoaXMudHJhY2tzID0ge307XG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xuICAgICAgdGhpcy5mbHVzaFJhbmdlID0gW107XG4gICAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgICB0aGlzLmFwcGVuZGVkID0gMDtcbiAgICB9XG4gICAgdGhpcy5vbm1zbyA9IHRoaXMub25tc2UgPSB0aGlzLm9ubXNjID0gbnVsbDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50Lk1FRElBX0RFVEFDSEVEKTtcbiAgfVxuXG4gIG9uTWVkaWFTb3VyY2VPcGVuICgpIHtcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzb3VyY2Ugb3BlbmVkJyk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5NRURJQV9BVFRBQ0hFRCwgeyBtZWRpYTogdGhpcy5tZWRpYSB9KTtcbiAgICBsZXQgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIGlmIChtZWRpYVNvdXJjZSkge1xuICAgICAgLy8gb25jZSByZWNlaXZlZCwgZG9uJ3QgbGlzdGVuIGFueW1vcmUgdG8gc291cmNlb3BlbiBldmVudFxuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25tc28pO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICB9XG5cbiAgY2hlY2tQZW5kaW5nVHJhY2tzICgpIHtcbiAgICBsZXQgeyBidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkLCBwZW5kaW5nVHJhY2tzIH0gPSB0aGlzO1xuICAgIC8vIENoZWNrIGlmIHdlJ3ZlIHJlY2VpdmVkIGFsbCBvZiB0aGUgZXhwZWN0ZWQgYnVmZmVyQ29kZWMgZXZlbnRzLiBXaGVuIG5vbmUgcmVtYWluLCBjcmVhdGUgYWxsIHRoZSBzb3VyY2VCdWZmZXJzIGF0IG9uY2UuXG4gICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgTVNFIHNwZWMgYWxsb3dzIGltcGxlbWVudGF0aW9ucyB0byB0aHJvdyBRdW90YUV4Y2VlZGVkRXJyb3JzIGlmIGNyZWF0aW5nIG5ldyBzb3VyY2VCdWZmZXJzIGFmdGVyXG4gICAgLy8gZGF0YSBoYXMgYmVlbiBhcHBlbmRlZCB0byBleGlzdGluZyBvbmVzLlxuICAgIC8vIDIgdHJhY2tzIGlzIHRoZSBtYXggKG9uZSBmb3IgYXVkaW8sIG9uZSBmb3IgdmlkZW8pLiBJZiB3ZSd2ZSByZWFjaCB0aGlzIG1heCBnbyBhaGVhZCBhbmQgY3JlYXRlIHRoZSBidWZmZXJzLlxuXG4gICAgY29uc3QgcGVuZGluZ1RyYWNrc0NvdW50ID0gT2JqZWN0LmtleXMocGVuZGluZ1RyYWNrcykubGVuZ3RoO1xuICAgIGlmICgocGVuZGluZ1RyYWNrc0NvdW50ICYmICFidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkKSB8fCBwZW5kaW5nVHJhY2tzQ291bnQgPT09IDIpIHtcbiAgICAgIC8vIG9rLCBsZXQncyBjcmVhdGUgdGhlbSBub3cgIVxuICAgICAgdGhpcy5jcmVhdGVTb3VyY2VCdWZmZXJzKHBlbmRpbmdUcmFja3MpO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICAvLyBhcHBlbmQgYW55IHBlbmRpbmcgc2VnbWVudHMgbm93ICFcbiAgICAgIHRoaXMuZG9BcHBlbmRpbmcoKTtcbiAgICB9XG4gIH1cblxuICBvbk1lZGlhU291cmNlQ2xvc2UgKCkge1xuICAgIGxvZ2dlci5sb2coJ21lZGlhIHNvdXJjZSBjbG9zZWQnKTtcbiAgfVxuXG4gIG9uTWVkaWFTb3VyY2VFbmRlZCAoKSB7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGVuZGVkJyk7XG4gIH1cblxuICBvblNCVXBkYXRlRW5kICgpIHtcbiAgICAvLyB1cGRhdGUgdGltZXN0YW1wT2Zmc2V0XG4gICAgaWYgKHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQpIHtcbiAgICAgIGxldCBhdWRpb0J1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLmF1ZGlvO1xuICAgICAgbG9nZ2VyLndhcm4oYGNoYW5nZSBtcGVnIGF1ZGlvIHRpbWVzdGFtcCBvZmZzZXQgZnJvbSAke2F1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldH0gdG8gJHt0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0fWApO1xuICAgICAgYXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0ID0gdGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldDtcbiAgICAgIGRlbGV0ZSB0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9uZWVkc0ZsdXNoKSB7XG4gICAgICB0aGlzLmRvRmx1c2goKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbmVlZHNFb3MpIHtcbiAgICAgIHRoaXMuY2hlY2tFb3MoKTtcbiAgICB9XG5cbiAgICB0aGlzLmFwcGVuZGluZyA9IGZhbHNlO1xuICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAvLyBjb3VudCBuYiBvZiBwZW5kaW5nIHNlZ21lbnRzIHdhaXRpbmcgZm9yIGFwcGVuZGluZyBvbiB0aGlzIHNvdXJjZWJ1ZmZlclxuICAgIGxldCBwZW5kaW5nID0gdGhpcy5zZWdtZW50cy5yZWR1Y2UoKGNvdW50ZXIsIHNlZ21lbnQpID0+IChzZWdtZW50LnBhcmVudCA9PT0gcGFyZW50KSA/IGNvdW50ZXIgKyAxIDogY291bnRlciwgMCk7XG5cbiAgICAvLyB0aGlzLnNvdXJjZUJ1ZmZlciBpcyBiZXR0ZXIgdG8gdXNlIHRoYW4gbWVkaWEuYnVmZmVyZWQgYXMgaXQgaXMgY2xvc2VyIHRvIHRoZSBQVFMgZGF0YSBmcm9tIHRoZSBmcmFnbWVudHNcbiAgICBsZXQgdGltZVJhbmdlcyA9IHt9O1xuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgIGZvciAobGV0IHN0cmVhbVR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICB0aW1lUmFuZ2VzW3N0cmVhbVR5cGVdID0gc291cmNlQnVmZmVyW3N0cmVhbVR5cGVdLmJ1ZmZlcmVkO1xuICAgIH1cblxuICAgIC8vIOWvu+aJvuWPr+aSreaUvueahOi1t+Wni+eCueOAguWmguaenOayoeacieiHquWKqOaSreaUvu+8jOmcgOimgeaJi+WKqFNlZWtcbiAgICBpZih0aGlzLl9wYXVzZWQgPT09IGZhbHNlXG4gICAgICAmJiB0aW1lUmFuZ2VzW1widmlkZW9cIl0gJiYgdGltZVJhbmdlc1tcInZpZGVvXCJdLmxlbmd0aCA+IDBcbiAgICAgICYmIHRpbWVSYW5nZXNbXCJhdWRpb1wiXSAmJiB0aW1lUmFuZ2VzW1wiYXVkaW9cIl0ubGVuZ3RoID4gMCkge1xuXG4gICAgICBpZih0aW1lUmFuZ2VzW1widmlkZW9cIl0uZW5kKDApIC0gdGltZVJhbmdlc1tcInZpZGVvXCJdLnN0YXJ0KDApID4gMVxuICAgICAgJiYgdGltZVJhbmdlc1tcImF1ZGlvXCJdLmVuZCgwKSAtIHRpbWVSYW5nZXNbXCJhdWRpb1wiXS5zdGFydCgwKSA+IDEpIHtcbiAgICAgICAgLy8gU2VlayB0byB0aGUgcG9pbnQgdGhhdCBjYW4gcGxheTtcbiAgICAgICAgbGV0IHN0YXJ0VGltZSA9IE1hdGgubWF4KHRpbWVSYW5nZXNbXCJ2aWRlb1wiXS5zdGFydCgwKSx0aW1lUmFuZ2VzW1wiYXVkaW9cIl0uc3RhcnQoMCkpXG4gICAgICAgIHRoaXMubWVkaWEuY3VycmVudFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgIHRoaXMubWVkaWEucGxheSgpO1xuICAgICAgICBkZWxldGUgdGhpc1tcIl9wYXVzZWRcIl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUcnkgdG8gc2VlayBtb3JlXG4gICAgICAgIGxldCBlbmRUaW1lID0gTWF0aC5tYXgodGltZVJhbmdlc1tcInZpZGVvXCJdLmVuZCgwKSx0aW1lUmFuZ2VzW1wiYXVkaW9cIl0uZW5kKDApKVxuICAgICAgICB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lID0gZW5kVGltZTtcbiAgICAgICAgdGhpcy5tZWRpYS5wbGF5KCk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRFRCwgeyBwYXJlbnQsIHBlbmRpbmcsIHRpbWVSYW5nZXMgfSk7XG4gICAgLy8gZG9uJ3QgYXBwZW5kIGluIGZsdXNoaW5nIG1vZGVcbiAgICBpZiAoIXRoaXMuX25lZWRzRmx1c2gpIHtcbiAgICAgIHRoaXMuZG9BcHBlbmRpbmcoKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCk7XG5cbiAgICAvLyBhcHBlbmRpbmcgZ29lcyBmaXJzdFxuICAgIGlmIChwZW5kaW5nID09PSAwKSB7XG4gICAgICB0aGlzLmZsdXNoTGl2ZUJhY2tCdWZmZXIoKTtcbiAgICB9XG4gIH1cblxuICBvblNCVXBkYXRlRXJyb3IgKGV2ZW50KSB7XG4gICAgbG9nZ2VyLmVycm9yKCdzb3VyY2VCdWZmZXIgZXJyb3I6JywgZXZlbnQpO1xuICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3NvdXJjZWJ1ZmZlci1hcHBlbmQtZXJyb3JcbiAgICAvLyB0aGlzIGVycm9yIG1pZ2h0IG5vdCBhbHdheXMgYmUgZmF0YWwgKGl0IGlzIGZhdGFsIGlmIGRlY29kZSBlcnJvciBpcyBzZXQsIGluIHRoYXQgY2FzZVxuICAgIC8vIGl0IHdpbGwgYmUgZm9sbG93ZWQgYnkgYSBtZWRpYUVsZW1lbnQgZXJyb3IgLi4uKVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSB9KTtcbiAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIGRvIG1vcmUgdGhhbiB0aGF0LCBhcyBhY2NvcmRpbiB0byB0aGUgc3BlYywgdXBkYXRlZW5kIHdpbGwgYmUgZmlyZWQganVzdCBhZnRlclxuICB9XG5cbiAgb25CdWZmZXJSZXNldCAoKSB7XG4gICAgbGV0IHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgIGZvciAobGV0IHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICBsZXQgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm1lZGlhU291cmNlLnJlbW92ZVNvdXJjZUJ1ZmZlcihzYik7XG4gICAgICAgIHNiLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIHRoaXMub25zYnVlKTtcbiAgICAgICAgc2IucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLm9uc2JlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xuICAgIHRoaXMuZmx1c2hSYW5nZSA9IFtdO1xuICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICB0aGlzLmFwcGVuZGVkID0gMDtcbiAgfVxuXG4gIG9uQnVmZmVyQ29kZWNzICh0cmFja3MpIHtcbiAgICAvLyBpZiBzb3VyY2UgYnVmZmVyKHMpIG5vdCBjcmVhdGVkIHlldCwgYXBwZW5kZWQgYnVmZmVyIHRyYWNrcyBpbiB0aGlzLnBlbmRpbmdUcmFja3NcbiAgICAvLyBpZiBzb3VyY2VidWZmZXJzIGFscmVhZHkgY3JlYXRlZCwgZG8gbm90aGluZyAuLi5cbiAgICAvKiog6ZyA6KaB5pS+6L+HdHJhY2tzLCDmnInmlrDnmoR0cmFja+mcgOimgemHjeaWsOWKoGJ1ZmZlciDkvb/lvpfnlLvpnaLliLDovr7ml7bvvIzlj6/ku6Xmkq3mlL7nlLvpnaJcbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXIpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0qL1xuXG4gICAgT2JqZWN0LmtleXModHJhY2tzKS5mb3JFYWNoKHRyYWNrTmFtZSA9PiB7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFja3NbdHJhY2tOYW1lXSA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgIH0pO1xuICAgIGNvbnN0IHsgbWVkaWFTb3VyY2UgfSA9IHRoaXM7XG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gTWF0aC5tYXgodGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkIC0gMSwgMCk7XG4gICAgaWYgKG1lZGlhU291cmNlICYmIG1lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgdGhpcy5jaGVja1BlbmRpbmdUcmFja3MoKTtcbiAgICB9XG4gIH1cblxuICBjcmVhdGVTb3VyY2VCdWZmZXJzICh0cmFja3MpIHtcbiAgICBsZXQgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICBmb3IgKGxldCB0cmFja05hbWUgaW4gdHJhY2tzKSB7XG4gICAgICBpZiAoIXNvdXJjZUJ1ZmZlclt0cmFja05hbWVdKSB7XG4gICAgICAgIGxldCB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICAvLyB1c2UgbGV2ZWxDb2RlYyBhcyBmaXJzdCBwcmlvcml0eVxuICAgICAgICBsZXQgY29kZWMgPSB0cmFjay5sZXZlbENvZGVjIHx8IHRyYWNrLmNvZGVjO1xuICAgICAgICBsZXQgbWltZVR5cGUgPSBgJHt0cmFjay5jb250YWluZXJ9O2NvZGVjcz0ke2NvZGVjfWA7XG4gICAgICAgIGxvZ2dlci5sb2coYGNyZWF0aW5nIHNvdXJjZUJ1ZmZlcigke21pbWVUeXBlfSlgKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgc2IgPSBzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSA9IG1lZGlhU291cmNlLmFkZFNvdXJjZUJ1ZmZlcihtaW1lVHlwZSk7XG4gICAgICAgICAgc2IuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgdGhpcy5vbnNidWUpO1xuICAgICAgICAgIHNiLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5vbnNiZSk7XG4gICAgICAgICAgdGhpcy50cmFja3NbdHJhY2tOYW1lXSA9IHsgY29kZWM6IGNvZGVjLCBjb250YWluZXI6IHRyYWNrLmNvbnRhaW5lciB9O1xuICAgICAgICAgIHRyYWNrLmJ1ZmZlciA9IHNiO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZihlcnIuY29kZSA9PSAyMikge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIkZvdW5kIG5ldyB0cmFjaywgdHJ5IHRvIHJlYnVpbGRcIik7XG4gICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHNldHVwIHRoZSBtZWRpYSBzb3VyY2VcbiAgICAgICAgICAgIGxldCBtcyA9IHRoaXMubWVkaWFTb3VyY2UgPSBuZXcgTWVkaWFTb3VyY2UoKTtcbiAgICAgICAgICAgIC8vIE1lZGlhIFNvdXJjZSBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMub25tc28gPSB0aGlzLm9uTWVkaWFTb3VyY2VPcGVuLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9ubXNlID0gdGhpcy5vbk1lZGlhU291cmNlRW5kZWQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub25tc2MgPSB0aGlzLm9uTWVkaWFTb3VyY2VDbG9zZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpPE9iamVjdC5rZXlzKHRoaXMudHJhY2tzKS5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgICAgIGxldCB0cmFjayA9IHRoaXMudHJhY2tzW09iamVjdC5rZXlzKHRoaXMudHJhY2tzKVtpXV07XG4gICAgICAgICAgICAgIHRoaXMucGVuZGluZ1RyYWNrc1tPYmplY3Qua2V5cyh0aGlzLnRyYWNrcylbaV1dID0gdHJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXIgPSB7fTtcbiAgICAgICAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLm9ubXNvKTtcbiAgICAgICAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5vbm1zZSk7XG4gICAgICAgICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMub25tc2MpO1xuICAgICAgICAgICAgLy8gbGluayB2aWRlbyBhbmQgbWVkaWEgU291cmNlXG4gICAgICAgICAgICB0aGlzLm1lZGlhLnNyYyA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG1zKTtcbiAgICAgICAgICAgIC8vIGNhY2hlIHRoZSBsb2NhbGx5IGdlbmVyYXRlZCBvYmplY3QgdXJsXG4gICAgICAgICAgICB0aGlzLl9vYmplY3RVcmwgPSBtZWRpYS5zcmM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgZXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGFkZCBzb3VyY2VCdWZmZXI6JHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BRERfQ09ERUNfRVJST1IsIGZhdGFsOiBmYWxzZSwgZXJyOiBlcnIsIG1pbWVUeXBlOiBtaW1lVHlwZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9DUkVBVEVELCB7IHRyYWNrczogdHJhY2tzIH0pO1xuICB9XG5cbiAgb25CdWZmZXJBcHBlbmRpbmcgKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuX25lZWRzRmx1c2gpIHtcbiAgICAgIGlmICghdGhpcy5zZWdtZW50cykge1xuICAgICAgICB0aGlzLnNlZ21lbnRzID0gWyBkYXRhIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZG9BcHBlbmRpbmcoKTtcbiAgICB9XG4gIH1cblxuICBvbkJ1ZmZlckFwcGVuZEZhaWwgKGRhdGEpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ3NvdXJjZUJ1ZmZlciBlcnJvcjonLCBkYXRhLmV2ZW50KTtcbiAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyNzb3VyY2VidWZmZXItYXBwZW5kLWVycm9yXG4gICAgLy8gdGhpcyBlcnJvciBtaWdodCBub3QgYWx3YXlzIGJlIGZhdGFsIChpdCBpcyBmYXRhbCBpZiBkZWNvZGUgZXJyb3IgaXMgc2V0LCBpbiB0aGF0IGNhc2VcbiAgICAvLyBpdCB3aWxsIGJlIGZvbGxvd2VkIGJ5IGEgbWVkaWFFbGVtZW50IGVycm9yIC4uLilcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SLCBmYXRhbDogZmFsc2UgfSk7XG4gIH1cblxuICAvLyBvbiBCVUZGRVJfRU9TIG1hcmsgbWF0Y2hpbmcgc291cmNlYnVmZmVyKHMpIGFzIGVuZGVkIGFuZCB0cmlnZ2VyIGNoZWNrRW9zKClcbiAgb25CdWZmZXJFb3MgKGRhdGEpIHtcbiAgICBsZXQgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICBsZXQgZGF0YVR5cGUgPSBkYXRhLnR5cGU7XG4gICAgZm9yIChsZXQgdHlwZSBpbiBzYikge1xuICAgICAgaWYgKCFkYXRhVHlwZSB8fCB0eXBlID09PSBkYXRhVHlwZSkge1xuICAgICAgICBpZiAoIXNiW3R5cGVdLmVuZGVkKSB7XG4gICAgICAgICAgc2JbdHlwZV0uZW5kZWQgPSB0cnVlO1xuICAgICAgICAgIGxvZ2dlci5sb2coYCR7dHlwZX0gc291cmNlQnVmZmVyIG5vdyBFT1NgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNoZWNrRW9zKCk7XG4gIH1cblxuICAvLyBpZiBhbGwgc291cmNlIGJ1ZmZlcnMgYXJlIG1hcmtlZCBhcyBlbmRlZCwgc2lnbmFsIGVuZE9mU3RyZWFtKCkgdG8gTWVkaWFTb3VyY2UuXG4gIGNoZWNrRW9zICgpIHtcbiAgICBsZXQgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlciwgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIGlmICghbWVkaWFTb3VyY2UgfHwgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICB0aGlzLl9uZWVkc0VvcyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCB0eXBlIGluIHNiKSB7XG4gICAgICBsZXQgc2JvYmogPSBzYlt0eXBlXTtcbiAgICAgIGlmICghc2JvYmouZW5kZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2JvYmoudXBkYXRpbmcpIHtcbiAgICAgICAgdGhpcy5fbmVlZHNFb3MgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGxvZ2dlci5sb2coJ2FsbCBtZWRpYSBkYXRhIGFyZSBhdmFpbGFibGUsIHNpZ25hbCBlbmRPZlN0cmVhbSgpIHRvIE1lZGlhU291cmNlIGFuZCBzdG9wIGxvYWRpbmcgZnJhZ21lbnQnKTtcbiAgICAvLyBOb3RpZnkgdGhlIG1lZGlhIGVsZW1lbnQgdGhhdCBpdCBub3cgaGFzIGFsbCBvZiB0aGUgbWVkaWEgZGF0YVxuICAgIHRyeSB7XG4gICAgICBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdleGNlcHRpb24gd2hpbGUgY2FsbGluZyBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpJyk7XG4gICAgfVxuICAgIHRoaXMuX25lZWRzRW9zID0gZmFsc2U7XG4gIH1cblxuICBvbkJ1ZmZlckZsdXNoaW5nIChkYXRhKSB7XG4gICAgdGhpcy5mbHVzaFJhbmdlLnB1c2goeyBzdGFydDogZGF0YS5zdGFydE9mZnNldCwgZW5kOiBkYXRhLmVuZE9mZnNldCwgdHlwZTogZGF0YS50eXBlIH0pO1xuICAgIC8vIGF0dGVtcHQgZmx1c2ggaW1tZWRpYXRlbHlcbiAgICB0aGlzLmZsdXNoQnVmZmVyQ291bnRlciA9IDA7XG4gICAgdGhpcy5kb0ZsdXNoKCk7XG4gIH1cblxuICBmbHVzaExpdmVCYWNrQnVmZmVyICgpIHtcbiAgICAvLyBjbGVhciBiYWNrIGJ1ZmZlciBmb3IgbGl2ZSBvbmx5XG4gICAgaWYgKCF0aGlzLl9saXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGl2ZUJhY2tCdWZmZXJMZW5ndGggPSB0aGlzLmhscy5jb25maWcubGl2ZUJhY2tCdWZmZXJMZW5ndGg7XG4gICAgaWYgKCFpc0Zpbml0ZShsaXZlQmFja0J1ZmZlckxlbmd0aCkgfHwgbGl2ZUJhY2tCdWZmZXJMZW5ndGggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgIGNvbnN0IGJ1ZmZlclR5cGVzID0gT2JqZWN0LmtleXMoc291cmNlQnVmZmVyKTtcbiAgICBjb25zdCB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24gPSBjdXJyZW50VGltZSAtIE1hdGgubWF4KGxpdmVCYWNrQnVmZmVyTGVuZ3RoLCB0aGlzLl9sZXZlbFRhcmdldER1cmF0aW9uKTtcblxuICAgIGZvciAobGV0IGluZGV4ID0gYnVmZmVyVHlwZXMubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgY29uc3QgYnVmZmVyVHlwZSA9IGJ1ZmZlclR5cGVzW2luZGV4XSwgYnVmZmVyZWQgPSBzb3VyY2VCdWZmZXJbYnVmZmVyVHlwZV0uYnVmZmVyZWQ7XG5cbiAgICAgIC8vIHdoZW4gdGFyZ2V0IGJ1ZmZlciBzdGFydCBleGNlZWRzIGFjdHVhbCBidWZmZXIgc3RhcnRcbiAgICAgIGlmIChidWZmZXJlZC5sZW5ndGggPiAwICYmIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbiA+IGJ1ZmZlcmVkLnN0YXJ0KDApKSB7XG4gICAgICAgIC8vIHJlbW92ZSBidWZmZXIgdXAgdW50aWwgY3VycmVudCB0aW1lIG1pbnVzIG1pbmltdW0gYmFjayBidWZmZXIgbGVuZ3RoIChyZW1vdmluZyBidWZmZXIgdG9vIGNsb3NlIHRvIGN1cnJlbnRcbiAgICAgICAgLy8gdGltZSB3aWxsIGxlYWQgdG8gcGxheWJhY2sgZnJlZXppbmcpXG4gICAgICAgIC8vIGNyZWRpdHMgZm9yIGxldmVsIHRhcmdldCBkdXJhdGlvbiAtIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL2h0dHAtc3RyZWFtaW5nL2Jsb2IvMzEzMjkzM2I2YWE5OWRkZWZhYjI5YzEwNDQ3NjI0ZWZkNmZkNmU1Mi9zcmMvc2VnbWVudC1sb2FkZXIuanMjTDkxXG4gICAgICAgIHRoaXMucmVtb3ZlQnVmZmVyUmFuZ2UoYnVmZmVyVHlwZSwgc291cmNlQnVmZmVyW2J1ZmZlclR5cGVdLCAwLCB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uTGV2ZWxVcGRhdGVkICh7IGRldGFpbHMgfSkge1xuICAgIGlmIChkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9sZXZlbER1cmF0aW9uID0gZGV0YWlscy50b3RhbGR1cmF0aW9uICsgZGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICB0aGlzLl9sZXZlbFRhcmdldER1cmF0aW9uID0gZGV0YWlscy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gfHwgZGV0YWlscy50YXJnZXRkdXJhdGlvbiB8fCAxMDtcbiAgICAgIHRoaXMuX2xpdmUgPSBkZXRhaWxzLmxpdmU7XG4gICAgICB0aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBNZWRpYSBTb3VyY2UgZHVyYXRpb24gdG8gY3VycmVudCBsZXZlbCBkdXJhdGlvbiBvciBvdmVycmlkZSB0byBJbmZpbml0eSBpZiBjb25maWd1cmF0aW9uIHBhcmFtZXRlclxuICAgKiAnbGl2ZUR1cmF0aW9uSW5maW5pdHlgIGlzIHNldCB0byBgdHJ1ZWBcbiAgICogTW9yZSBkZXRhaWxzOiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMzU1XG4gICAqL1xuICB1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbiAoKSB7XG4gICAgbGV0IHsgY29uZmlnIH0gPSB0aGlzLmhscztcbiAgICBsZXQgZHVyYXRpb247XG5cbiAgICBpZiAodGhpcy5fbGV2ZWxEdXJhdGlvbiA9PT0gbnVsbCB8fFxuICAgICAgIXRoaXMubWVkaWEgfHxcbiAgICAgICF0aGlzLm1lZGlhU291cmNlIHx8XG4gICAgICAhdGhpcy5zb3VyY2VCdWZmZXIgfHxcbiAgICAgIHRoaXMubWVkaWEucmVhZHlTdGF0ZSA9PT0gMCB8fFxuICAgICAgdGhpcy5tZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCB0eXBlIGluIHRoaXMuc291cmNlQnVmZmVyKSB7XG4gICAgICBpZiAodGhpcy5zb3VyY2VCdWZmZXJbdHlwZV0udXBkYXRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgLy8gY2FuJ3Qgc2V0IGR1cmF0aW9uIHdoaWxzdCBhIGJ1ZmZlciBpcyB1cGRhdGluZ1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZHVyYXRpb24gPSB0aGlzLm1lZGlhLmR1cmF0aW9uO1xuICAgIC8vIGluaXRpYWxpc2UgdG8gdGhlIHZhbHVlIHRoYXQgdGhlIG1lZGlhIHNvdXJjZSBpcyByZXBvcnRpbmdcbiAgICBpZiAodGhpcy5fbXNEdXJhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fbXNEdXJhdGlvbiA9IHRoaXMubWVkaWFTb3VyY2UuZHVyYXRpb247XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xpdmUgPT09IHRydWUgJiYgY29uZmlnLmxpdmVEdXJhdGlvbkluZmluaXR5ID09PSB0cnVlKSB7XG4gICAgICAvLyBPdmVycmlkZSBkdXJhdGlvbiB0byBJbmZpbml0eVxuICAgICAgbG9nZ2VyLmxvZygnTWVkaWEgU291cmNlIGR1cmF0aW9uIGlzIHNldCB0byBJbmZpbml0eScpO1xuICAgICAgdGhpcy5fbXNEdXJhdGlvbiA9IHRoaXMubWVkaWFTb3VyY2UuZHVyYXRpb24gPSBJbmZpbml0eTtcbiAgICB9IGVsc2UgaWYgKCh0aGlzLl9sZXZlbER1cmF0aW9uID4gdGhpcy5fbXNEdXJhdGlvbiAmJiB0aGlzLl9sZXZlbER1cmF0aW9uID4gZHVyYXRpb24pIHx8ICFOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb24pKSB7XG4gICAgICAvLyBsZXZlbER1cmF0aW9uIHdhcyB0aGUgbGFzdCB2YWx1ZSB3ZSBzZXQuXG4gICAgICAvLyBub3QgdXNpbmcgbWVkaWFTb3VyY2UuZHVyYXRpb24gYXMgdGhlIGJyb3dzZXIgbWF5IHR3ZWFrIHRoaXMgdmFsdWVcbiAgICAgIC8vIG9ubHkgdXBkYXRlIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiBpZiBpdHMgdmFsdWUgaW5jcmVhc2UsIHRoaXMgaXMgdG8gYXZvaWRcbiAgICAgIC8vIGZsdXNoaW5nIGFscmVhZHkgYnVmZmVyZWQgcG9ydGlvbiB3aGVuIHN3aXRjaGluZyBiZXR3ZWVuIHF1YWxpdHkgbGV2ZWxcbiAgICAgIGxvZ2dlci5sb2coYFVwZGF0aW5nIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiB0byAke3RoaXMuX2xldmVsRHVyYXRpb24udG9GaXhlZCgzKX1gKTtcbiAgICAgIHRoaXMuX21zRHVyYXRpb24gPSB0aGlzLm1lZGlhU291cmNlLmR1cmF0aW9uID0gdGhpcy5fbGV2ZWxEdXJhdGlvbjtcbiAgICB9XG4gIH1cblxuICBkb0ZsdXNoICgpIHtcbiAgICAvLyBsb29wIHRocm91Z2ggYWxsIGJ1ZmZlciByYW5nZXMgdG8gZmx1c2hcbiAgICB3aGlsZSAodGhpcy5mbHVzaFJhbmdlLmxlbmd0aCkge1xuICAgICAgbGV0IHJhbmdlID0gdGhpcy5mbHVzaFJhbmdlWzBdO1xuICAgICAgLy8gZmx1c2hCdWZmZXIgd2lsbCBhYm9ydCBhbnkgYnVmZmVyIGFwcGVuZCBpbiBwcm9ncmVzcyBhbmQgZmx1c2ggQXVkaW8vVmlkZW8gQnVmZmVyXG4gICAgICBpZiAodGhpcy5mbHVzaEJ1ZmZlcihyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCByYW5nZS50eXBlKSkge1xuICAgICAgICAvLyByYW5nZSBmbHVzaGVkLCByZW1vdmUgZnJvbSBmbHVzaCBhcnJheVxuICAgICAgICB0aGlzLmZsdXNoUmFuZ2Uuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbmVlZHNGbHVzaCA9IHRydWU7XG4gICAgICAgIC8vIGF2b2lkIGxvb3BpbmcsIHdhaXQgZm9yIFNCIHVwZGF0ZSBlbmQgdG8gcmV0cmlnZ2VyIGEgZmx1c2hcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5mbHVzaFJhbmdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gZXZlcnl0aGluZyBmbHVzaGVkXG4gICAgICB0aGlzLl9uZWVkc0ZsdXNoID0gZmFsc2U7XG5cbiAgICAgIC8vIGxldCdzIHJlY29tcHV0ZSB0aGlzLmFwcGVuZGVkLCB3aGljaCBpcyB1c2VkIHRvIGF2b2lkIGZsdXNoIGxvb3BpbmdcbiAgICAgIGxldCBhcHBlbmRlZCA9IDA7XG4gICAgICBsZXQgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKGxldCB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgIGFwcGVuZGVkICs9IHNvdXJjZUJ1ZmZlclt0eXBlXS5idWZmZXJlZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIGVycm9yIGNvdWxkIGJlIHRocm93biB3aGlsZSBhY2Nlc3NpbmcgYnVmZmVyZWQsIGluIGNhc2Ugc291cmNlYnVmZmVyIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBmcm9tIE1lZGlhU291cmNlXG4gICAgICAgIC8vIHRoaXMgaXMgaGFybWVzcyBhdCB0aGlzIHN0YWdlLCBjYXRjaCB0aGlzIHRvIGF2b2lkIHJlcG9ydGluZyBhbiBpbnRlcm5hbCBleGNlcHRpb25cbiAgICAgICAgbG9nZ2VyLmVycm9yKCdlcnJvciB3aGlsZSBhY2Nlc3Npbmcgc291cmNlQnVmZmVyLmJ1ZmZlcmVkJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmFwcGVuZGVkID0gYXBwZW5kZWQ7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9GTFVTSEVEKTtcbiAgICB9XG4gIH1cblxuICBkb0FwcGVuZGluZyAoKSB7XG5cbiAgICBsZXQgeyBobHMsIHNlZ21lbnRzLCBzb3VyY2VCdWZmZXIgfSA9IHRoaXM7XG4gICAgaWYgKE9iamVjdC5rZXlzKHNvdXJjZUJ1ZmZlcikubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYS5lcnJvcikge1xuICAgICAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgICAgIGxvZ2dlci5lcnJvcigndHJ5aW5nIHRvIGFwcGVuZCBhbHRob3VnaCBhIG1lZGlhIGVycm9yIG9jY3VyZWQsIGZsdXNoIHNlZ21lbnQgYW5kIGFib3J0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmFwcGVuZGluZykge1xuICAgICAgICAvLyBsb2dnZXIubG9nKGBzYiBhcHBlbmRpbmcgaW4gcHJvZ3Jlc3NgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICBsZXQgc2VnbWVudCA9IHNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHR5cGUgPSBzZWdtZW50LnR5cGUsIHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICAgIGlmIChzYikge1xuICAgICAgICAgICAgaWYgKCFzYi51cGRhdGluZykge1xuICAgICAgICAgICAgICAvLyByZXNldCBzb3VyY2VCdWZmZXIgZW5kZWQgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIHNlZ21lbnRcbiAgICAgICAgICAgICAgc2IuZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZyhgYXBwZW5kaW5nICR7c2VnbWVudC5jb250ZW50fSAke3R5cGV9IFNCLCBzaXplOiR7c2VnbWVudC5kYXRhLmxlbmd0aH0sICR7c2VnbWVudC5wYXJlbnR9YCk7XG4gICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gc2VnbWVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhcHBlbmQgYnVmZmVyICcsIHNlZ21lbnQpXG4gICAgICAgICAgICAgIHNiLmFwcGVuZEJ1ZmZlcihzZWdtZW50LmRhdGEpO1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yID0gMDtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRlZCsrO1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWdtZW50cy51bnNoaWZ0KHNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIHdlIGRvbid0IGhhdmUgYW55IHNvdXJjZSBidWZmZXIgbWF0Y2hpbmcgd2l0aCB0aGlzIHNlZ21lbnQgdHlwZSxcbiAgICAgICAgICAgIC8vIGl0IG1lYW5zIHRoYXQgTWVkaWFzb3VyY2UgZmFpbHMgdG8gY3JlYXRlIHNvdXJjZWJ1ZmZlclxuICAgICAgICAgICAgLy8gZGlzY2FyZCB0aGlzIHNlZ21lbnQsIGFuZCB0cmlnZ2VyIHVwZGF0ZSBlbmRcbiAgICAgICAgICAgIHRoaXMub25TQlVwZGF0ZUVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBhbnkgZXJyb3Igb2NjdXJlZCB3aGlsZSBhcHBlbmRpbmcsIHB1dCBiYWNrIHNlZ21lbnQgaW4gc2VnbWVudHMgdGFibGVcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoYGVycm9yIHdoaWxlIHRyeWluZyB0byBhcHBlbmQgYnVmZmVyOiR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgc2VnbWVudHMudW5zaGlmdChzZWdtZW50KTtcbiAgICAgICAgICBsZXQgZXZlbnQgPSB7IHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIHBhcmVudDogc2VnbWVudC5wYXJlbnQgfTtcbiAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09IDIyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRFcnJvcikge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXZlbnQuZGV0YWlscyA9IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SO1xuICAgICAgICAgICAgLyogd2l0aCBVSEQgY29udGVudCwgd2UgY291bGQgZ2V0IGxvb3Agb2YgcXVvdGEgZXhjZWVkZWQgZXJyb3IgdW50aWxcbiAgICAgICAgICAgICAgYnJvd3NlciBpcyBhYmxlIHRvIGV2aWN0IHNvbWUgZGF0YSBmcm9tIHNvdXJjZWJ1ZmZlci4gcmV0cnlpbmcgaGVscCByZWNvdmVyaW5nIHRoaXNcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRFcnJvciA+IGhscy5jb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeSkge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBmYWlsICR7aGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5fSB0aW1lcyB0byBhcHBlbmQgc2VnbWVudCBpbiBzb3VyY2VCdWZmZXJgKTtcbiAgICAgICAgICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgICBldmVudC5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCBldmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBldmVudC5mYXRhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBRdW90YUV4Y2VlZGVkRXJyb3I6IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjcXVvdGFleGNlZWRlZGVycm9yXG4gICAgICAgICAgICAvLyBsZXQncyBzdG9wIGFwcGVuZGluZyBhbnkgc2VnbWVudHMsIGFuZCByZXBvcnQgQlVGRkVSX0ZVTExfRVJST1IgZXJyb3JcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I7XG4gICAgICAgICAgICBldmVudC5mYXRhbCA9IGZhbHNlO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAgIGZsdXNoIHNwZWNpZmllZCBidWZmZXJlZCByYW5nZSxcbiAgICByZXR1cm4gdHJ1ZSBvbmNlIHJhbmdlIGhhcyBiZWVuIGZsdXNoZWQuXG4gICAgYXMgc291cmNlQnVmZmVyLnJlbW92ZSgpIGlzIGFzeW5jaHJvbm91cywgZmx1c2hCdWZmZXIgd2lsbCBiZSByZXRyaWdnZXJlZCBvbiBzb3VyY2VCdWZmZXIgdXBkYXRlIGVuZFxuICAqL1xuICBmbHVzaEJ1ZmZlciAoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdHlwZUluKSB7XG4gICAgbGV0IHNiO1xuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgIGlmIChPYmplY3Qua2V5cyhzb3VyY2VCdWZmZXIpLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLmxvZyhgZmx1c2hCdWZmZXIscG9zL3N0YXJ0L2VuZDogJHt0aGlzLm1lZGlhLmN1cnJlbnRUaW1lLnRvRml4ZWQoMyl9LyR7c3RhcnRPZmZzZXR9LyR7ZW5kT2Zmc2V0fWApO1xuICAgICAgLy8gc2FmZWd1YXJkIHRvIGF2b2lkIGluZmluaXRlIGxvb3BpbmcgOiBkb24ndCB0cnkgdG8gZmx1c2ggbW9yZSB0aGFuIHRoZSBuYiBvZiBhcHBlbmRlZCBzZWdtZW50c1xuICAgICAgaWYgKHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyIDwgdGhpcy5hcHBlbmRlZCkge1xuICAgICAgICBmb3IgKGxldCB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgIC8vIGNoZWNrIGlmIHNvdXJjZWJ1ZmZlciB0eXBlIGlzIGRlZmluZWQgKHR5cGVJbik6IGlmIHllcywgbGV0J3Mgb25seSBmbHVzaCB0aGlzIG9uZVxuICAgICAgICAgIC8vIGlmIG5vLCBsZXQncyBmbHVzaCBhbGwgc291cmNlYnVmZmVyc1xuICAgICAgICAgIGlmICh0eXBlSW4gJiYgdHlwZSAhPT0gdHlwZUluKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgICAvLyB3ZSBhcmUgZ29pbmcgdG8gZmx1c2ggYnVmZmVyLCBtYXJrIHNvdXJjZSBidWZmZXIgYXMgJ25vdCBlbmRlZCdcbiAgICAgICAgICBzYi5lbmRlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmICghc2IudXBkYXRpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbW92ZUJ1ZmZlclJhbmdlKHR5cGUsIHNiLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSkge1xuICAgICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyQ291bnRlcisrO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdjYW5ub3QgZmx1c2gsIHNiIHVwZGF0aW5nIGluIHByb2dyZXNzJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybignYWJvcnQgZmx1c2hpbmcgdG9vIG1hbnkgcmV0cmllcycpO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLmxvZygnYnVmZmVyIGZsdXNoZWQnKTtcbiAgICB9XG4gICAgLy8gZXZlcnl0aGluZyBmbHVzaGVkICFcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGZpcnN0IGJ1ZmZlcmVkIHJhbmdlIGZyb20gcHJvdmlkZWQgc291cmNlIGJ1ZmZlciB0aGF0IGxpZXMgd2l0aGluIGdpdmVuIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0cy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgVHlwZSBvZiB0aGUgc291cmNlIGJ1ZmZlciwgbG9nZ2luZyBwdXJwb3NlcyBvbmx5LlxuICAgKiBAcGFyYW0gc2IgVGFyZ2V0IFNvdXJjZUJ1ZmZlciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHN0YXJ0T2Zmc2V0XG4gICAqIEBwYXJhbSBlbmRPZmZzZXRcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgd2hlbiBzb3VyY2UgYnVmZmVyIHJlbW92ZSByZXF1ZXN0ZWQuXG4gICAqL1xuICByZW1vdmVCdWZmZXJSYW5nZSAodHlwZSwgc2IsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICB0cnkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYi5idWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYnVmU3RhcnQgPSBzYi5idWZmZXJlZC5zdGFydChpKTtcbiAgICAgICAgbGV0IGJ1ZkVuZCA9IHNiLmJ1ZmZlcmVkLmVuZChpKTtcbiAgICAgICAgbGV0IHJlbW92ZVN0YXJ0ID0gTWF0aC5tYXgoYnVmU3RhcnQsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgbGV0IHJlbW92ZUVuZCA9IE1hdGgubWluKGJ1ZkVuZCwgZW5kT2Zmc2V0KTtcblxuICAgICAgICAvKiBzb21ldGltZXMgc291cmNlYnVmZmVyLnJlbW92ZSgpIGRvZXMgbm90IGZsdXNoXG4gICAgICAgICAgdGhlIGV4YWN0IGV4cGVjdGVkIHRpbWUgcmFuZ2UuXG4gICAgICAgICAgdG8gYXZvaWQgcm91bmRpbmcgaXNzdWVzL2luZmluaXRlIGxvb3AsXG4gICAgICAgICAgb25seSBmbHVzaCBidWZmZXIgcmFuZ2Ugb2YgbGVuZ3RoIGdyZWF0ZXIgdGhhbiA1MDBtcy5cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKE1hdGgubWluKHJlbW92ZUVuZCwgYnVmRW5kKSAtIHJlbW92ZVN0YXJ0ID4gMC41KSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgc2IgcmVtb3ZlICR7dHlwZX0gWyR7cmVtb3ZlU3RhcnR9LCR7cmVtb3ZlRW5kfV0sIG9mIFske2J1ZlN0YXJ0fSwke2J1ZkVuZH1dLCBwb3M6JHt0aGlzLm1lZGlhLmN1cnJlbnRUaW1lfWApO1xuICAgICAgICAgIHNiLnJlbW92ZShyZW1vdmVTdGFydCwgcmVtb3ZlRW5kKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIud2FybigncmVtb3ZlQnVmZmVyUmFuZ2UgZmFpbGVkJywgZXJyb3IpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdWZmZXJDb250cm9sbGVyO1xuIiwiLypcbiAqIGNhcCBzdHJlYW0gbGV2ZWwgdG8gbWVkaWEgc2l6ZSBkaW1lbnNpb24gY29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuXG5jbGFzcyBDYXBMZXZlbENvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuRlBTX0RST1BfTEVWRUxfQ0FQUElORyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX1BBUlNFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9DT0RFQ1MsXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcpO1xuXG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IG51bGw7XG4gICAgdGhpcy5sZXZlbHMgPSBbXTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGlmICh0aGlzLmhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUpIHtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy5fc3RvcENhcHBpbmcoKTtcbiAgICB9XG4gIH1cblxuICBvbkZwc0Ryb3BMZXZlbENhcHBpbmcgKGRhdGEpIHtcbiAgICAvLyBEb24ndCBhZGQgYSByZXN0cmljdGVkIGxldmVsIG1vcmUgdGhhbiBvbmNlXG4gICAgaWYgKENhcExldmVsQ29udHJvbGxlci5pc0xldmVsQWxsb3dlZChkYXRhLmRyb3BwZWRMZXZlbCwgdGhpcy5yZXN0cmljdGVkTGV2ZWxzKSkge1xuICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLnB1c2goZGF0YS5kcm9wcGVkTGV2ZWwpO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFBdHRhY2hpbmcgKGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gIH1cblxuICBvbk1hbmlmZXN0UGFyc2VkIChkYXRhKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSBkYXRhLmZpcnN0TGV2ZWw7XG4gICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgZGF0YS52aWRlbykge1xuICAgICAgLy8gU3RhcnQgY2FwcGluZyBpbW1lZGlhdGVseSBpZiB0aGUgbWFuaWZlc3QgaGFzIHNpZ25hbGVkIHZpZGVvIGNvZGVjc1xuICAgICAgdGhpcy5fc3RhcnRDYXBwaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gT25seSBhY3RpdmF0ZSBjYXBwaW5nIHdoZW4gcGxheWluZyBhIHZpZGVvIHN0cmVhbTsgb3RoZXJ3aXNlLCBtdWx0aS1iaXRyYXRlIGF1ZGlvLW9ubHkgc3RyZWFtcyB3aWxsIGJlIHJlc3RyaWN0ZWRcbiAgLy8gdG8gdGhlIGZpcnN0IGxldmVsXG4gIG9uQnVmZmVyQ29kZWNzIChkYXRhKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgZGF0YS52aWRlbykge1xuICAgICAgLy8gSWYgdGhlIG1hbmlmZXN0IGRpZCBub3Qgc2lnbmFsIGEgdmlkZW8gY29kZWMgY2FwcGluZyBoYXMgYmVlbiBkZWZlcnJlZCB1bnRpbCB3ZSdyZSBjZXJ0YWluIHZpZGVvIGlzIHByZXNlbnRcbiAgICAgIHRoaXMuX3N0YXJ0Q2FwcGluZygpO1xuICAgIH1cbiAgfVxuXG4gIG9uTGV2ZWxzVXBkYXRlZCAoZGF0YSkge1xuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nICgpIHtcbiAgICB0aGlzLl9zdG9wQ2FwcGluZygpO1xuICB9XG5cbiAgZGV0ZWN0UGxheWVyU2l6ZSAoKSB7XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIGxldCBsZXZlbHNMZW5ndGggPSB0aGlzLmxldmVscyA/IHRoaXMubGV2ZWxzLmxlbmd0aCA6IDA7XG4gICAgICBpZiAobGV2ZWxzTGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IHRoaXMuZ2V0TWF4TGV2ZWwobGV2ZWxzTGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmIChobHMuYXV0b0xldmVsQ2FwcGluZyA+IHRoaXMuYXV0b0xldmVsQ2FwcGluZykge1xuICAgICAgICAgIC8vIGlmIGF1dG8gbGV2ZWwgY2FwcGluZyBoYXMgYSBoaWdoZXIgdmFsdWUgZm9yIHRoZSBwcmV2aW91cyBvbmUsIGZsdXNoIHRoZSBidWZmZXIgdXNpbmcgbmV4dExldmVsU3dpdGNoXG4gICAgICAgICAgLy8gdXN1YWxseSBoYXBwZW4gd2hlbiB0aGUgdXNlciBnbyB0byB0aGUgZnVsbHNjcmVlbiBtb2RlLlxuICAgICAgICAgIGhscy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IGhscy5hdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICogcmV0dXJucyBsZXZlbCBzaG91bGQgYmUgdGhlIG9uZSB3aXRoIHRoZSBkaW1lbnNpb25zIGVxdWFsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbWVkaWEgKHBsYXllcikgZGltZW5zaW9ucyAoc28gdGhlIHZpZGVvIHdpbGwgYmUgZG93bnNjYWxlZClcbiAgKi9cbiAgZ2V0TWF4TGV2ZWwgKGNhcExldmVsSW5kZXgpIHtcbiAgICBpZiAoIXRoaXMubGV2ZWxzKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsaWRMZXZlbHMgPSB0aGlzLmxldmVscy5maWx0ZXIoKGxldmVsLCBpbmRleCkgPT5cbiAgICAgIENhcExldmVsQ29udHJvbGxlci5pc0xldmVsQWxsb3dlZChpbmRleCwgdGhpcy5yZXN0cmljdGVkTGV2ZWxzKSAmJiBpbmRleCA8PSBjYXBMZXZlbEluZGV4XG4gICAgKTtcblxuICAgIHJldHVybiBDYXBMZXZlbENvbnRyb2xsZXIuZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZSh2YWxpZExldmVscywgdGhpcy5tZWRpYVdpZHRoLCB0aGlzLm1lZGlhSGVpZ2h0KTtcbiAgfVxuXG4gIF9zdGFydENhcHBpbmcgKCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAvLyBEb24ndCByZXNldCBjYXBwaW5nIGlmIHN0YXJ0ZWQgdHdpY2U7IHRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgbWFuaWZlc3Qgc2lnbmFscyBhIHZpZGVvIGNvZGVjXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB0aGlzLmhscy5maXJzdExldmVsID0gdGhpcy5nZXRNYXhMZXZlbCh0aGlzLmZpcnN0TGV2ZWwpO1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMuZGV0ZWN0UGxheWVyU2l6ZS5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICB0aGlzLmRldGVjdFBsYXllclNpemUoKTtcbiAgfVxuXG4gIF9zdG9wQ2FwcGluZyAoKSB7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgdGhpcy5maXJzdExldmVsID0gbnVsbDtcbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIHRoaXMudGltZXIgPSBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZ2V0IG1lZGlhV2lkdGggKCkge1xuICAgIGxldCB3aWR0aDtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICB3aWR0aCA9IG1lZGlhLndpZHRoIHx8IG1lZGlhLmNsaWVudFdpZHRoIHx8IG1lZGlhLm9mZnNldFdpZHRoO1xuICAgICAgd2lkdGggKj0gQ2FwTGV2ZWxDb250cm9sbGVyLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG5cbiAgZ2V0IG1lZGlhSGVpZ2h0ICgpIHtcbiAgICBsZXQgaGVpZ2h0O1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGhlaWdodCA9IG1lZGlhLmhlaWdodCB8fCBtZWRpYS5jbGllbnRIZWlnaHQgfHwgbWVkaWEub2Zmc2V0SGVpZ2h0O1xuICAgICAgaGVpZ2h0ICo9IENhcExldmVsQ29udHJvbGxlci5jb250ZW50U2NhbGVGYWN0b3I7XG4gICAgfVxuICAgIHJldHVybiBoZWlnaHQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGNvbnRlbnRTY2FsZUZhY3RvciAoKSB7XG4gICAgbGV0IHBpeGVsUmF0aW8gPSAxO1xuICAgIHRyeSB7XG4gICAgICBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gcGl4ZWxSYXRpbztcbiAgfVxuXG4gIHN0YXRpYyBpc0xldmVsQWxsb3dlZCAobGV2ZWwsIHJlc3RyaWN0ZWRMZXZlbHMgPSBbXSkge1xuICAgIHJldHVybiByZXN0cmljdGVkTGV2ZWxzLmluZGV4T2YobGV2ZWwpID09PSAtMTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRNYXhMZXZlbEJ5TWVkaWFTaXplIChsZXZlbHMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWxldmVscyB8fCAobGV2ZWxzICYmICFsZXZlbHMubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIExldmVscyBjYW4gaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zIGJ1dCBkaWZmZXJpbmcgYmFuZHdpZHRocyAtIHNpbmNlIGxldmVscyBhcmUgb3JkZXJlZCwgd2UgY2FuIGxvb2sgdG8gdGhlIG5leHRcbiAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSd2ZSBjaG9zZW4gdGhlIGdyZWF0ZXN0IGJhbmR3aWR0aCBmb3IgdGhlIG1lZGlhJ3MgZGltZW5zaW9uc1xuICAgIGNvbnN0IGF0R3JlYXRlc3RCYW5kaXdkdGggPSAoY3VyTGV2ZWwsIG5leHRMZXZlbCkgPT4ge1xuICAgICAgaWYgKCFuZXh0TGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJMZXZlbC53aWR0aCAhPT0gbmV4dExldmVsLndpZHRoIHx8IGN1ckxldmVsLmhlaWdodCAhPT0gbmV4dExldmVsLmhlaWdodDtcbiAgICB9O1xuXG4gICAgLy8gSWYgd2UgcnVuIHRocm91Z2ggdGhlIGxvb3Agd2l0aG91dCBicmVha2luZywgdGhlIG1lZGlhJ3MgZGltZW5zaW9ucyBhcmUgZ3JlYXRlciB0aGFuIGV2ZXJ5IGxldmVsLCBzbyBkZWZhdWx0IHRvXG4gICAgLy8gdGhlIG1heCBsZXZlbFxuICAgIGxldCBtYXhMZXZlbEluZGV4ID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICBpZiAoKGxldmVsLndpZHRoID49IHdpZHRoIHx8IGxldmVsLmhlaWdodCA+PSBoZWlnaHQpICYmIGF0R3JlYXRlc3RCYW5kaXdkdGgobGV2ZWwsIGxldmVsc1tpICsgMV0pKSB7XG4gICAgICAgIG1heExldmVsSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF4TGV2ZWxJbmRleDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXBMZXZlbENvbnRyb2xsZXI7XG4iLCIvKipcbiAqIEBhdXRob3IgU3RlcGhhbiBIZXNzZSA8ZGlzcGFyYXRAZ21haWwuY29tPiB8IDx0Y2hha2FiYW1AZ21haWwuY29tPlxuICpcbiAqIERSTSBzdXBwb3J0IGZvciBIbHMuanNcbiAqL1xuXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jb25zdCB7IFhNTEh0dHBSZXF1ZXN0IH0gPSB3aW5kb3c7XG5cbmNvbnN0IE1BWF9MSUNFTlNFX1JFUVVFU1RfRkFJTFVSRVMgPSAzO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05hdmlnYXRvci9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NcbiAqL1xuY29uc3QgS2V5U3lzdGVtcyA9IHtcbiAgV0lERVZJTkU6ICdjb20ud2lkZXZpbmUuYWxwaGEnLFxuICBQTEFZUkVBRFk6ICdjb20ubWljcm9zb2Z0LnBsYXlyZWFkeSdcbn07XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGF1ZGlvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgYXVkaW8gY29kZWNzIHRvIHN1cHBvcnRcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdmlkZW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCB2aWRlbyBjb2RlY3MgdG8gc3VwcG9ydFxuICogQHBhcmFtIHtvYmplY3R9IGRybVN5c3RlbU9wdGlvbnMgT3B0aW9uYWwgcGFyYW1ldGVycy9yZXF1aXJlbWVudHMgZm9yIHRoZSBrZXktc3lzdGVtXG4gKiBAcmV0dXJucyB7QXJyYXk8TWVkaWFTeXN0ZW1Db25maWd1cmF0aW9uPn0gQW4gYXJyYXkgb2Ygc3VwcG9ydGVkIGNvbmZpZ3VyYXRpb25zXG4gKi9cblxuY29uc3QgY3JlYXRlV2lkZXZpbmVNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zID0gZnVuY3Rpb24gKGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcywgZHJtU3lzdGVtT3B0aW9ucykgeyAvKiBqc2hpbnQgaWdub3JlOmxpbmUgKi9cbiAgY29uc3QgYmFzZUNvbmZpZyA9IHtcbiAgICAvLyBpbml0RGF0YVR5cGVzOiBbJ2tleWlkcycsICdtcDQnXSxcbiAgICAvLyBsYWJlbDogXCJcIixcbiAgICAvLyBwZXJzaXN0ZW50U3RhdGU6IFwibm90LWFsbG93ZWRcIiwgLy8gb3IgXCJyZXF1aXJlZFwiID9cbiAgICAvLyBkaXN0aW5jdGl2ZUlkZW50aWZpZXI6IFwibm90LWFsbG93ZWRcIiwgLy8gb3IgXCJyZXF1aXJlZFwiID9cbiAgICAvLyBzZXNzaW9uVHlwZXM6IFsndGVtcG9yYXJ5J10sXG4gICAgdmlkZW9DYXBhYmlsaXRpZXM6IFtcbiAgICAgIC8vIHsgY29udGVudFR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJFMDFFXCInIH1cbiAgICBdXG4gIH07XG5cbiAgdmlkZW9Db2RlY3MuZm9yRWFjaCgoY29kZWMpID0+IHtcbiAgICBiYXNlQ29uZmlnLnZpZGVvQ2FwYWJpbGl0aWVzLnB1c2goe1xuICAgICAgY29udGVudFR5cGU6IGB2aWRlby9tcDQ7IGNvZGVjcz1cIiR7Y29kZWN9XCJgXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBbXG4gICAgYmFzZUNvbmZpZ1xuICBdO1xufTtcblxuLyoqXG4gKiBUaGUgaWRlYSBoZXJlIGlzIHRvIGhhbmRsZSBrZXktc3lzdGVtIChhbmQgdGhlaXIgcmVzcGVjdGl2ZSBwbGF0Zm9ybXMpIHNwZWNpZmljIGNvbmZpZ3VyYXRpb24gZGlmZmVyZW5jZXNcbiAqIGluIG9yZGVyIHRvIHdvcmsgd2l0aCB0aGUgbG9jYWwgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIG1ldGhvZC5cbiAqXG4gKiBXZSBjYW4gYWxzbyBydWxlLW91dCBwbGF0Zm9ybS1yZWxhdGVkIGtleS1zeXN0ZW0gc3VwcG9ydCBhdCB0aGlzIHBvaW50IGJ5IHRocm93aW5nIGFuIGVycm9yIG9yIHJldHVybmluZyBudWxsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlTeXN0ZW0gSWRlbnRpZmllciBmb3IgdGhlIGtleS1zeXN0ZW0sIHNlZSBgS2V5U3lzdGVtc2AgZW51bVxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhdWRpb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIGF1ZGlvIGNvZGVjcyB0byBzdXBwb3J0XG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHZpZGVvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgdmlkZW8gY29kZWNzIHRvIHN1cHBvcnRcbiAqIEByZXR1cm5zIHtBcnJheTxNZWRpYVN5c3RlbUNvbmZpZ3VyYXRpb24+IHwgbnVsbH0gQSBub24tZW1wdHkgQXJyYXkgb2YgTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9uIG9iamVjdHMgb3IgYG51bGxgXG4gKi9cbmNvbnN0IGdldFN1cHBvcnRlZE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMgPSBmdW5jdGlvbiAoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpIHtcbiAgc3dpdGNoIChrZXlTeXN0ZW0pIHtcbiAgY2FzZSBLZXlTeXN0ZW1zLldJREVWSU5FOlxuICAgIHJldHVybiBjcmVhdGVXaWRldmluZU1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKTtcbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBFcnJvcignVW5rbm93biBrZXktc3lzdGVtOiAnICsga2V5U3lzdGVtKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGRlYWwgd2l0aCBlbmNyeXB0ZWQgbWVkaWEgZXh0ZW5zaW9ucyAoRU1FKVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRW5jcnlwdGVkX01lZGlhX0V4dGVuc2lvbnNfQVBJXG4gKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgRU1FQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RzXG4gICAgICogQHBhcmFtIHtIbHN9IGhscyBPdXIgSGxzLmpzIGluc3RhbmNlXG4gICAgICovXG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX1BBUlNFRFxuICAgICk7XG5cbiAgICB0aGlzLl93aWRldmluZUxpY2Vuc2VVcmwgPSBobHMuY29uZmlnLndpZGV2aW5lTGljZW5zZVVybDtcbiAgICB0aGlzLl9saWNlbnNlWGhyU2V0dXAgPSBobHMuY29uZmlnLmxpY2Vuc2VYaHJTZXR1cDtcbiAgICB0aGlzLl9lbWVFbmFibGVkID0gaGxzLmNvbmZpZy5lbWVFbmFibGVkO1xuXG4gICAgdGhpcy5fcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzID0gaGxzLmNvbmZpZy5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jO1xuXG4gICAgdGhpcy5fbWVkaWFLZXlzTGlzdCA9IFtdO1xuICAgIHRoaXMuX21lZGlhID0gbnVsbDtcblxuICAgIHRoaXMuX2hhc1NldE1lZGlhS2V5cyA9IGZhbHNlO1xuICAgIHRoaXMuX2lzTWVkaWFFbmNyeXB0ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVN5c3RlbSBJZGVudGlmaWVyIGZvciB0aGUga2V5LXN5c3RlbSwgc2VlIGBLZXlTeXN0ZW1zYCBlbnVtXG4gICAgICogQHJldHVybnMge3N0cmluZ30gTGljZW5zZSBzZXJ2ZXIgVVJMIGZvciBrZXktc3lzdGVtIChpZiBhbnkgY29uZmlndXJlZCwgb3RoZXJ3aXNlIGNhdXNlcyBlcnJvcilcbiAgICAgKi9cbiAgZ2V0TGljZW5zZVNlcnZlclVybCAoa2V5U3lzdGVtKSB7XG4gICAgbGV0IHVybDtcbiAgICBzd2l0Y2ggKGtleVN5c3RlbSkge1xuICAgIGNhc2UgS2V5U3lzdGVtcy5XSURFVklORTpcbiAgICAgIHVybCA9IHRoaXMuX3dpZGV2aW5lTGljZW5zZVVybDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB1cmwgPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihgTm8gbGljZW5zZSBzZXJ2ZXIgVVJMIGNvbmZpZ3VyZWQgZm9yIGtleS1zeXN0ZW0gXCIke2tleVN5c3RlbX1cImApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgLyoqXG4gICAgICogUmVxdWVzdHMgYWNjZXNzIG9iamVjdCBhbmQgYWRkcyBpdCB0byBvdXIgbGlzdCB1cG9uIHN1Y2Nlc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlTeXN0ZW0gU3lzdGVtIElEIChzZWUgYEtleVN5c3RlbXNgKVxuICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXVkaW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCBhdWRpbyBjb2RlY3MgdG8gc3VwcG9ydFxuICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdmlkZW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCB2aWRlbyBjb2RlY3MgdG8gc3VwcG9ydFxuICAgICAqL1xuICBfYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyAoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpIHtcbiAgICAvLyBUT0RPOiBhZGQgb3RoZXIgRFJNIFwib3B0aW9uc1wiXG5cbiAgICBjb25zdCBtZWRpYUtleVN5c3RlbUNvbmZpZ3MgPSBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKTtcblxuICAgIGlmICghbWVkaWFLZXlTeXN0ZW1Db25maWdzKSB7XG4gICAgICBsb2dnZXIud2FybignQ2FuIG5vdCBjcmVhdGUgY29uZmlnIGZvciBrZXktc3lzdGVtIChtYXliZSBiZWNhdXNlIHBsYXRmb3JtIGlzIG5vdCBzdXBwb3J0ZWQpOicsIGtleVN5c3RlbSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9nZ2VyLmxvZygnUmVxdWVzdGluZyBlbmNyeXB0ZWQgbWVkaWEga2V5LXN5c3RlbSBhY2Nlc3MnKTtcblxuICAgIC8vIGV4cGVjdGluZyBpbnRlcmZhY2UgbGlrZSB3aW5kb3cubmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1xuICAgIHRoaXMucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbSwgbWVkaWFLZXlTeXN0ZW1Db25maWdzKVxuICAgICAgLnRoZW4oKG1lZGlhS2V5U3lzdGVtQWNjZXNzKSA9PiB7XG4gICAgICAgIHRoaXMuX29uTWVkaWFLZXlTeXN0ZW1BY2Nlc3NPYnRhaW5lZChrZXlTeXN0ZW0sIG1lZGlhS2V5U3lzdGVtQWNjZXNzKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBvYnRhaW4ga2V5LXN5c3RlbSBcIiR7a2V5U3lzdGVtfVwiIGFjY2VzczpgLCBlcnIpO1xuICAgICAgfSk7XG4gIH1cblxuICBnZXQgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzICgpIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgZnVuY3Rpb24gY29uZmlndXJlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3M7XG4gIH1cblxuICAvKipcbiAgICAgKiBIYW5kbGVzIG9idGFpbmluZyBhY2Nlc3MgdG8gYSBrZXktc3lzdGVtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5U3lzdGVtXG4gICAgICogQHBhcmFtIHtNZWRpYUtleVN5c3RlbUFjY2Vzc30gbWVkaWFLZXlTeXN0ZW1BY2Nlc3MgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhS2V5U3lzdGVtQWNjZXNzXG4gICAgICovXG4gIF9vbk1lZGlhS2V5U3lzdGVtQWNjZXNzT2J0YWluZWQgKGtleVN5c3RlbSwgbWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICBsb2dnZXIubG9nKGBBY2Nlc3MgZm9yIGtleS1zeXN0ZW0gXCIke2tleVN5c3RlbX1cIiBvYnRhaW5lZGApO1xuXG4gICAgY29uc3QgbWVkaWFLZXlzTGlzdEl0ZW0gPSB7XG4gICAgICBtZWRpYUtleXM6IG51bGwsXG4gICAgICBtZWRpYUtleXNTZXNzaW9uOiBudWxsLFxuICAgICAgbWVkaWFLZXlzU2Vzc2lvbkluaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIG1lZGlhS2V5U3lzdGVtQWNjZXNzOiBtZWRpYUtleVN5c3RlbUFjY2VzcyxcbiAgICAgIG1lZGlhS2V5U3lzdGVtRG9tYWluOiBrZXlTeXN0ZW1cbiAgICB9O1xuXG4gICAgdGhpcy5fbWVkaWFLZXlzTGlzdC5wdXNoKG1lZGlhS2V5c0xpc3RJdGVtKTtcblxuICAgIG1lZGlhS2V5U3lzdGVtQWNjZXNzLmNyZWF0ZU1lZGlhS2V5cygpXG4gICAgICAudGhlbigobWVkaWFLZXlzKSA9PiB7XG4gICAgICAgIG1lZGlhS2V5c0xpc3RJdGVtLm1lZGlhS2V5cyA9IG1lZGlhS2V5cztcblxuICAgICAgICBsb2dnZXIubG9nKGBNZWRpYS1rZXlzIGNyZWF0ZWQgZm9yIGtleS1zeXN0ZW0gXCIke2tleVN5c3RlbX1cImApO1xuXG4gICAgICAgIHRoaXMuX29uTWVkaWFLZXlzQ3JlYXRlZCgpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBtZWRpYS1rZXlzOicsIGVycik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIEhhbmRsZXMga2V5LWNyZWF0aW9uIChyZXByZXNlbnRzIGFjY2VzcyB0byBDRE0pLiBXZSBhcmUgZ29pbmcgdG8gY3JlYXRlIGtleS1zZXNzaW9ucyB1cG9uIHRoaXNcbiAgICAgKiBmb3IgYWxsIGV4aXN0aW5nIGtleXMgd2hlcmUgbm8gc2Vzc2lvbiBleGlzdHMgeWV0LlxuICAgICAqL1xuICBfb25NZWRpYUtleXNDcmVhdGVkICgpIHtcbiAgICAvLyBjaGVjayBmb3IgYWxsIGtleS1saXN0IGl0ZW1zIGlmIGEgc2Vzc2lvbiBleGlzdHMsIG90aGVyd2lzZSwgY3JlYXRlIG9uZVxuICAgIHRoaXMuX21lZGlhS2V5c0xpc3QuZm9yRWFjaCgobWVkaWFLZXlzTGlzdEl0ZW0pID0+IHtcbiAgICAgIGlmICghbWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbikge1xuICAgICAgICBtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uID0gbWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzLmNyZWF0ZVNlc3Npb24oKTtcbiAgICAgICAgdGhpcy5fb25OZXdNZWRpYUtleVNlc3Npb24obWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5U2Vzc2lvblxuICAgICAqL1xuICBfb25OZXdNZWRpYUtleVNlc3Npb24gKGtleVNlc3Npb24pIHtcbiAgICBsb2dnZXIubG9nKGBOZXcga2V5LXN5c3RlbSBzZXNzaW9uICR7a2V5U2Vzc2lvbi5zZXNzaW9uSWR9YCk7XG5cbiAgICBrZXlTZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX29uS2V5U2Vzc2lvbk1lc3NhZ2Uoa2V5U2Vzc2lvbiwgZXZlbnQubWVzc2FnZSk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG5cbiAgX29uS2V5U2Vzc2lvbk1lc3NhZ2UgKGtleVNlc3Npb24sIG1lc3NhZ2UpIHtcbiAgICBsb2dnZXIubG9nKCdHb3QgRU1FIG1lc3NhZ2UgZXZlbnQsIGNyZWF0aW5nIGxpY2Vuc2UgcmVxdWVzdCcpO1xuXG4gICAgdGhpcy5fcmVxdWVzdExpY2Vuc2UobWVzc2FnZSwgKGRhdGEpID0+IHtcbiAgICAgIGxvZ2dlci5sb2coJ1JlY2VpdmVkIGxpY2Vuc2UgZGF0YSwgdXBkYXRpbmcga2V5LXNlc3Npb24nKTtcbiAgICAgIGtleVNlc3Npb24udXBkYXRlKGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgX29uTWVkaWFFbmNyeXB0ZWQgKGluaXREYXRhVHlwZSwgaW5pdERhdGEpIHtcbiAgICBsb2dnZXIubG9nKGBNZWRpYSBpcyBlbmNyeXB0ZWQgdXNpbmcgXCIke2luaXREYXRhVHlwZX1cIiBpbml0IGRhdGEgdHlwZWApO1xuXG4gICAgdGhpcy5faXNNZWRpYUVuY3J5cHRlZCA9IHRydWU7XG4gICAgdGhpcy5fbWVkaWFFbmNyeXB0aW9uSW5pdERhdGFUeXBlID0gaW5pdERhdGFUeXBlO1xuICAgIHRoaXMuX21lZGlhRW5jcnlwdGlvbkluaXREYXRhID0gaW5pdERhdGE7XG5cbiAgICB0aGlzLl9hdHRlbXB0U2V0TWVkaWFLZXlzKCk7XG4gICAgdGhpcy5fZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oKTtcbiAgfVxuXG4gIF9hdHRlbXB0U2V0TWVkaWFLZXlzICgpIHtcbiAgICBpZiAoIXRoaXMuX2hhc1NldE1lZGlhS2V5cykge1xuICAgICAgLy8gRklYTUU6IHNlZSBpZiB3ZSBjYW4vd2FudC9uZWVkLXRvIHJlYWxseSB0byBkZWFsIHdpdGggc2V2ZXJhbCBwb3RlbnRpYWwga2V5LXNlc3Npb25zP1xuICAgICAgY29uc3Qga2V5c0xpc3RJdGVtID0gdGhpcy5fbWVkaWFLZXlzTGlzdFswXTtcbiAgICAgIGlmICgha2V5c0xpc3RJdGVtIHx8ICFrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignRmF0YWw6IE1lZGlhIGlzIGVuY3J5cHRlZCBidXQgbm8gQ0RNIGFjY2VzcyBvciBubyBrZXlzIGhhdmUgYmVlbiBvYnRhaW5lZCB5ZXQnKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19LRVlTLFxuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvZ2dlci5sb2coJ1NldHRpbmcga2V5cyBmb3IgZW5jcnlwdGVkIG1lZGlhJyk7XG5cbiAgICAgIHRoaXMuX21lZGlhLnNldE1lZGlhS2V5cyhrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzKTtcbiAgICAgIHRoaXMuX2hhc1NldE1lZGlhS2V5cyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgX2dlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uICgpIHtcbiAgICAvLyBGSVhNRTogc2VlIGlmIHdlIGNhbi93YW50L25lZWQtdG8gcmVhbGx5IHRvIGRlYWwgd2l0aCBzZXZlcmFsIHBvdGVudGlhbCBrZXktc2Vzc2lvbnM/XG4gICAgY29uc3Qga2V5c0xpc3RJdGVtID0gdGhpcy5fbWVkaWFLZXlzTGlzdFswXTtcbiAgICBpZiAoIWtleXNMaXN0SXRlbSkge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYXRhbDogTWVkaWEgaXMgZW5jcnlwdGVkIGJ1dCBub3QgYW55IGtleS1zeXN0ZW0gYWNjZXNzIGhhcyBiZWVuIG9idGFpbmVkIHlldCcpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0FDQ0VTUyxcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbkluaXRpYWxpemVkKSB7XG4gICAgICBsb2dnZXIud2FybignS2V5LVNlc3Npb24gYWxyZWFkeSBpbml0aWFsaXplZCBidXQgcmVxdWVzdGVkIGFnYWluJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qga2V5U2Vzc2lvbiA9IGtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uO1xuICAgIGlmICgha2V5U2Vzc2lvbikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYXRhbDogTWVkaWEgaXMgZW5jcnlwdGVkIGJ1dCBubyBrZXktc2Vzc2lvbiBleGlzdGluZycpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX1NFU1NJT04sXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBpbml0RGF0YVR5cGUgPSB0aGlzLl9tZWRpYUVuY3J5cHRpb25Jbml0RGF0YVR5cGU7XG4gICAgY29uc3QgaW5pdERhdGEgPSB0aGlzLl9tZWRpYUVuY3J5cHRpb25Jbml0RGF0YTtcblxuICAgIGxvZ2dlci5sb2coYEdlbmVyYXRpbmcga2V5LXNlc3Npb24gcmVxdWVzdCBmb3IgXCIke2luaXREYXRhVHlwZX1cIiBpbml0IGRhdGEgdHlwZWApO1xuXG4gICAga2V5c0xpc3RJdGVtLm1lZGlhS2V5c1Nlc3Npb25Jbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICBrZXlTZXNzaW9uLmdlbmVyYXRlUmVxdWVzdChpbml0RGF0YVR5cGUsIGluaXREYXRhKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ0tleS1zZXNzaW9uIGdlbmVyYXRpb24gc3VjY2VlZGVkJyk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIGtleS1zZXNzaW9uIHJlcXVlc3Q6JywgZXJyKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19TRVNTSU9OLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBMaWNlbnNlIHNlcnZlciBVUkxcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBrZXlNZXNzYWdlIE1lc3NhZ2UgZGF0YSBpc3N1ZWQgYnkga2V5LXN5c3RlbVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCB3aGVuIFhIUiBoYXMgc3VjY2VlZGVkXG4gICAgICogQHJldHVybnMge1hNTEh0dHBSZXF1ZXN0fSBVbnNlbnQgKGJ1dCBvcGVuZWQgc3RhdGUpIFhIUiBvYmplY3RcbiAgICAgKi9cbiAgX2NyZWF0ZUxpY2Vuc2VYaHIgKHVybCwga2V5TWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBjb25zdCBsaWNlbnNlWGhyU2V0dXAgPSB0aGlzLl9saWNlbnNlWGhyU2V0dXA7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKGxpY2Vuc2VYaHJTZXR1cCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxpY2Vuc2VYaHJTZXR1cCh4aHIsIHVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBsZXQncyB0cnkgdG8gb3BlbiBiZWZvcmUgcnVubmluZyBzZXR1cFxuICAgICAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgICBsaWNlbnNlWGhyU2V0dXAoeGhyLCB1cmwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBpZiBsaWNlbnNlWGhyU2V0dXAgZGlkIG5vdCB5ZXQgY2FsbCBvcGVuLCBsZXQncyBkbyBpdCBub3dcbiAgICAgIGlmICgheGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCB1cmwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFMTEgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiB4aHIub3BlbiBpZiBhdHRlbXB0aW5nIHRvIGFjY2VzcyBhbiBIVFRQIHJlc291cmNlIG92ZXIgSFRUUFNcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3Igc2V0dGluZyB1cCBrZXktc3lzdGVtIGxpY2Vuc2UgWEhSJywgZSk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCxcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPVxuICAgICAgICB0aGlzLl9vbkxpY2Vuc2VSZXF1ZXN0UmVhZHlTdGFnZUNoYW5nZS5iaW5kKHRoaXMsIHhociwgdXJsLCBrZXlNZXNzYWdlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHhocjtcbiAgfVxuXG4gIC8qKlxuICAgICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R9IHhoclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgTGljZW5zZSBzZXJ2ZXIgVVJMXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0ga2V5TWVzc2FnZSBNZXNzYWdlIGRhdGEgaXNzdWVkIGJ5IGtleS1zeXN0ZW1cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgd2hlbiBYSFIgaGFzIHN1Y2NlZWRlZFxuICAgICAqXG4gICAgICovXG4gIF9vbkxpY2Vuc2VSZXF1ZXN0UmVhZHlTdGFnZUNoYW5nZSAoeGhyLCB1cmwsIGtleU1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgc3dpdGNoICh4aHIucmVhZHlTdGF0ZSkge1xuICAgIGNhc2UgNDpcbiAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPSAwO1xuICAgICAgICBsb2dnZXIubG9nKCdMaWNlbnNlIHJlcXVlc3Qgc3VjY2VlZGVkJyk7XG4gICAgICAgIGNhbGxiYWNrKHhoci5yZXNwb25zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYExpY2Vuc2UgUmVxdWVzdCBYSFIgZmFpbGVkICgke3VybH0pLiBTdGF0dXM6ICR7eGhyLnN0YXR1c30gKCR7eGhyLnN0YXR1c1RleHR9KWApO1xuXG4gICAgICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50Kys7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA8PSBNQVhfTElDRU5TRV9SRVFVRVNUX0ZBSUxVUkVTKSB7XG4gICAgICAgICAgY29uc3QgYXR0ZW1wdHNMZWZ0ID0gTUFYX0xJQ0VOU0VfUkVRVUVTVF9GQUlMVVJFUyAtIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ICsgMTtcbiAgICAgICAgICBsb2dnZXIud2FybihgUmV0cnlpbmcgbGljZW5zZSByZXF1ZXN0LCAke2F0dGVtcHRzTGVmdH0gYXR0ZW1wdHMgbGVmdGApO1xuICAgICAgICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlKGtleU1lc3NhZ2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0ga2V5c0xpc3RJdGVtXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0ga2V5TWVzc2FnZVxuICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gQ2hhbGxlbmdlIGRhdGEgcG9zdGVkIHRvIGxpY2Vuc2Ugc2VydmVyXG4gICAgICovXG4gIF9nZW5lcmF0ZUxpY2Vuc2VSZXF1ZXN0Q2hhbGxlbmdlIChrZXlzTGlzdEl0ZW0sIGtleU1lc3NhZ2UpIHtcbiAgICBsZXQgY2hhbGxlbmdlO1xuXG4gICAgaWYgKGtleXNMaXN0SXRlbS5tZWRpYUtleVN5c3RlbURvbWFpbiA9PT0gS2V5U3lzdGVtcy5QTEFZUkVBRFkpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignUGxheVJlYWR5IGlzIG5vdCBzdXBwb3J0ZWQgKHlldCknKTtcblxuICAgICAgLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0RWRnZS9EZW1vcy9ibG9iL21hc3Rlci9lbWUvc2NyaXB0cy9kZW1vLmpzXG4gICAgICAvKlxuICAgICAgICBpZiAodGhpcy5saWNlbnNlVHlwZSAhPT0gdGhpcy5MSUNFTlNFX1RZUEVfV0lERVZJTkUpIHtcbiAgICAgICAgICAgIC8vIEZvciBQbGF5UmVhZHkgQ0RNcywgd2UgbmVlZCB0byBkaWcgdGhlIENoYWxsZW5nZSBvdXQgb2YgdGhlIFhNTC5cbiAgICAgICAgICAgIHZhciBrZXlNZXNzYWdlWG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShrZXlNZXNzYWdlKSksICdhcHBsaWNhdGlvbi94bWwnKTtcbiAgICAgICAgICAgIGlmIChrZXlNZXNzYWdlWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdDaGFsbGVuZ2UnKVswXSkge1xuICAgICAgICAgICAgICAgIGNoYWxsZW5nZSA9IGF0b2Ioa2V5TWVzc2FnZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnQ2hhbGxlbmdlJylbMF0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQ2Fubm90IGZpbmQgPENoYWxsZW5nZT4gaW4ga2V5IG1lc3NhZ2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhlYWRlck5hbWVzID0ga2V5TWVzc2FnZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbmFtZScpO1xuICAgICAgICAgICAgdmFyIGhlYWRlclZhbHVlcyA9IGtleU1lc3NhZ2VYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZhbHVlJyk7XG4gICAgICAgICAgICBpZiAoaGVhZGVyTmFtZXMubGVuZ3RoICE9PSBoZWFkZXJWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ01pc21hdGNoZWQgaGVhZGVyIDxuYW1lPi88dmFsdWU+IHBhaXIgaW4ga2V5IG1lc3NhZ2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkZXJOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlck5hbWVzW2ldLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlLCBoZWFkZXJWYWx1ZXNbaV0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICovXG4gICAgfSBlbHNlIGlmIChrZXlzTGlzdEl0ZW0ubWVkaWFLZXlTeXN0ZW1Eb21haW4gPT09IEtleVN5c3RlbXMuV0lERVZJTkUpIHtcbiAgICAgIC8vIEZvciBXaWRldmluZSBDRE1zLCB0aGUgY2hhbGxlbmdlIGlzIHRoZSBrZXlNZXNzYWdlLlxuICAgICAgY2hhbGxlbmdlID0ga2V5TWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmVycm9yKCdVbnN1cHBvcnRlZCBrZXktc3lzdGVtOicsIGtleXNMaXN0SXRlbS5tZWRpYUtleVN5c3RlbURvbWFpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYWxsZW5nZTtcbiAgfVxuXG4gIF9yZXF1ZXN0TGljZW5zZSAoa2V5TWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBsb2dnZXIubG9nKCdSZXF1ZXN0aW5nIGNvbnRlbnQgbGljZW5zZSBmb3Iga2V5LXN5c3RlbScpO1xuXG4gICAgY29uc3Qga2V5c0xpc3RJdGVtID0gdGhpcy5fbWVkaWFLZXlzTGlzdFswXTtcbiAgICBpZiAoIWtleXNMaXN0SXRlbSkge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYXRhbCBlcnJvcjogTWVkaWEgaXMgZW5jcnlwdGVkIGJ1dCBubyBrZXktc3lzdGVtIGFjY2VzcyBoYXMgYmVlbiBvYnRhaW5lZCB5ZXQnKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19BQ0NFU1MsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB1cmwgPSB0aGlzLmdldExpY2Vuc2VTZXJ2ZXJVcmwoa2V5c0xpc3RJdGVtLm1lZGlhS2V5U3lzdGVtRG9tYWluKTtcbiAgICBjb25zdCB4aHIgPSB0aGlzLl9jcmVhdGVMaWNlbnNlWGhyKHVybCwga2V5TWVzc2FnZSwgY2FsbGJhY2spO1xuXG4gICAgbG9nZ2VyLmxvZyhgU2VuZGluZyBsaWNlbnNlIHJlcXVlc3QgdG8gVVJMOiAke3VybH1gKTtcblxuICAgIHhoci5zZW5kKHRoaXMuX2dlbmVyYXRlTGljZW5zZVJlcXVlc3RDaGFsbGVuZ2Uoa2V5c0xpc3RJdGVtLCBrZXlNZXNzYWdlKSk7XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoZWQgKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuX2VtZUVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZWRpYSA9IGRhdGEubWVkaWE7XG5cbiAgICAvLyBrZWVwIHJlZmVyZW5jZSBvZiBtZWRpYVxuICAgIHRoaXMuX21lZGlhID0gbWVkaWE7XG5cbiAgICAvLyBGSVhNRTogYWxzbyBoYW5kbGUgZGV0YWNoaW5nIG1lZGlhICFcblxuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VuY3J5cHRlZCcsIChlKSA9PiB7XG4gICAgICB0aGlzLl9vbk1lZGlhRW5jcnlwdGVkKGUuaW5pdERhdGFUeXBlLCBlLmluaXREYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uTWFuaWZlc3RQYXJzZWQgKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuX2VtZUVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhdWRpb0NvZGVjcyA9IGRhdGEubGV2ZWxzLm1hcCgobGV2ZWwpID0+IGxldmVsLmF1ZGlvQ29kZWMpO1xuICAgIGNvbnN0IHZpZGVvQ29kZWNzID0gZGF0YS5sZXZlbHMubWFwKChsZXZlbCkgPT4gbGV2ZWwudmlkZW9Db2RlYyk7XG5cbiAgICB0aGlzLl9hdHRlbXB0S2V5U3lzdGVtQWNjZXNzKEtleVN5c3RlbXMuV0lERVZJTkUsIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRU1FQ29udHJvbGxlcjtcbiIsIi8qXG4gKiBGUFMgQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gd2luZG93O1xuXG5jbGFzcyBGUFNDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuTUVESUFfQVRUQUNISU5HKTtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgIH1cblxuICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IGZhbHNlO1xuICB9XG5cbiAgb25NZWRpYUF0dGFjaGluZyAoZGF0YSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBpZiAoY29uZmlnLmNhcExldmVsT25GUFNEcm9wKSB7XG4gICAgICBjb25zdCB2aWRlbyA9IHRoaXMudmlkZW8gPSBkYXRhLm1lZGlhIGluc3RhbmNlb2Ygd2luZG93LkhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgdmlkZW8uZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrRlBTSW50ZXJ2YWwuYmluZCh0aGlzKSwgY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kKTtcbiAgICB9XG4gIH1cblxuICBjaGVja0ZQUyAodmlkZW8sIGRlY29kZWRGcmFtZXMsIGRyb3BwZWRGcmFtZXMpIHtcbiAgICBsZXQgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoZGVjb2RlZEZyYW1lcykge1xuICAgICAgaWYgKHRoaXMubGFzdFRpbWUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRQZXJpb2QgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWUsXG4gICAgICAgICAgY3VycmVudERyb3BwZWQgPSBkcm9wcGVkRnJhbWVzIC0gdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyxcbiAgICAgICAgICBjdXJyZW50RGVjb2RlZCA9IGRlY29kZWRGcmFtZXMgLSB0aGlzLmxhc3REZWNvZGVkRnJhbWVzLFxuICAgICAgICAgIGRyb3BwZWRGUFMgPSAxMDAwICogY3VycmVudERyb3BwZWQgLyBjdXJyZW50UGVyaW9kLFxuICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUFNfRFJPUCwgeyBjdXJyZW50RHJvcHBlZDogY3VycmVudERyb3BwZWQsIGN1cnJlbnREZWNvZGVkOiBjdXJyZW50RGVjb2RlZCwgdG90YWxEcm9wcGVkRnJhbWVzOiBkcm9wcGVkRnJhbWVzIH0pO1xuICAgICAgICBpZiAoZHJvcHBlZEZQUyA+IDApIHtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdjaGVja0ZQUyA6IGRyb3BwZWRGUFMvZGVjb2RlZEZQUzonICsgZHJvcHBlZEZQUy8oMTAwMCAqIGN1cnJlbnREZWNvZGVkIC8gY3VycmVudFBlcmlvZCkpO1xuICAgICAgICAgIGlmIChjdXJyZW50RHJvcHBlZCA+IGhscy5jb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQgKiBjdXJyZW50RGVjb2RlZCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRMZXZlbCA9IGhscy5jdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICBsb2dnZXIud2FybignZHJvcCBGUFMgcmF0aW8gZ3JlYXRlciB0aGFuIG1heCBhbGxvd2VkIHZhbHVlIGZvciBjdXJyZW50TGV2ZWw6ICcgKyBjdXJyZW50TGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA+IDAgJiYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID09PSAtMSB8fCBobHMuYXV0b0xldmVsQ2FwcGluZyA+PSBjdXJyZW50TGV2ZWwpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbCAtIDE7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHsgbGV2ZWw6IGN1cnJlbnRMZXZlbCwgZHJvcHBlZExldmVsOiBobHMuY3VycmVudExldmVsIH0pO1xuICAgICAgICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IGN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgICAgaGxzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB0aGlzLmxhc3REcm9wcGVkRnJhbWVzID0gZHJvcHBlZEZyYW1lcztcbiAgICAgIHRoaXMubGFzdERlY29kZWRGcmFtZXMgPSBkZWNvZGVkRnJhbWVzO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrRlBTSW50ZXJ2YWwgKCkge1xuICAgIGNvbnN0IHZpZGVvID0gdGhpcy52aWRlbztcbiAgICBpZiAodmlkZW8pIHtcbiAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUpIHtcbiAgICAgICAgbGV0IHZpZGVvUGxheWJhY2tRdWFsaXR5ID0gdmlkZW8uZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkoKTtcbiAgICAgICAgdGhpcy5jaGVja0ZQUyh2aWRlbywgdmlkZW9QbGF5YmFja1F1YWxpdHkudG90YWxWaWRlb0ZyYW1lcywgdmlkZW9QbGF5YmFja1F1YWxpdHkuZHJvcHBlZFZpZGVvRnJhbWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvLndlYmtpdERlY29kZWRGcmFtZUNvdW50LCB2aWRlby53ZWJraXREcm9wcGVkRnJhbWVDb3VudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZQU0NvbnRyb2xsZXI7XG4iLCJpbXBvcnQgQmluYXJ5U2VhcmNoIGZyb20gJy4uL3V0aWxzL2JpbmFyeS1zZWFyY2gnO1xuXG4vKipcbiAqIFJldHVybnMgZmlyc3QgZnJhZ21lbnQgd2hvc2UgZW5kUGR0IHZhbHVlIGV4Y2VlZHMgdGhlIGdpdmVuIFBEVC5cbiAqIEBwYXJhbSB7QXJyYXk8RnJhZ21lbnQ+fSBmcmFnbWVudHMgLSBUaGUgYXJyYXkgb2YgY2FuZGlkYXRlIGZyYWdtZW50c1xuICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gW1BEVFZhbHVlID0gbnVsbF0gLSBUaGUgUERUIHZhbHVlIHdoaWNoIG11c3QgYmUgZXhjZWVkZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0L2VuZCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMgeyp8bnVsbH0gZnJhZ21lbnQgLSBUaGUgYmVzdCBtYXRjaGluZyBmcmFnbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEZyYWdtZW50QnlQRFQgKGZyYWdtZW50cywgUERUVmFsdWUsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZyYWdtZW50cykgfHwgIWZyYWdtZW50cy5sZW5ndGggfHwgIU51bWJlci5pc0Zpbml0ZShQRFRWYWx1ZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGlmIGxlc3MgdGhhbiBzdGFydFxuICBpZiAoUERUVmFsdWUgPCBmcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoUERUVmFsdWUgPj0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXS5lbmRQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHx8IDA7XG4gIGZvciAobGV0IHNlZyA9IDA7IHNlZyA8IGZyYWdtZW50cy5sZW5ndGg7ICsrc2VnKSB7XG4gICAgbGV0IGZyYWcgPSBmcmFnbWVudHNbc2VnXTtcbiAgICBpZiAocGR0V2l0aGluVG9sZXJhbmNlVGVzdChQRFRWYWx1ZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZykpIHtcbiAgICAgIHJldHVybiBmcmFnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEZpbmRzIGEgZnJhZ21lbnQgYmFzZWQgb24gdGhlIFNOIG9mIHRoZSBwcmV2aW91cyBmcmFnbWVudDsgb3IgYmFzZWQgb24gdGhlIG5lZWRzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAqIFRoaXMgbWV0aG9kIGNvbXBlbnNhdGVzIGZvciBzbWFsbCBidWZmZXIgZ2FwcyBieSBhcHBseWluZyBhIHRvbGVyYW5jZSB0byB0aGUgc3RhcnQgb2YgYW55IGNhbmRpZGF0ZSBmcmFnbWVudCwgdGh1c1xuICogYnJlYWtpbmcgYW55IHRyYXBzIHdoaWNoIHdvdWxkIGNhdXNlIHRoZSBzYW1lIGZyYWdtZW50IHRvIGJlIGNvbnRpbnVvdXNseSBzZWxlY3RlZCB3aXRoaW4gYSBzbWFsbCByYW5nZS5cbiAqIEBwYXJhbSB7Kn0gZnJhZ1ByZXZpb3VzIC0gVGhlIGxhc3QgZnJhZyBzdWNjZXNzZnVsbHkgYXBwZW5kZWRcbiAqIEBwYXJhbSB7QXJyYXk8RnJhZ21lbnQ+fSBmcmFnbWVudHMgLSBUaGUgYXJyYXkgb2YgY2FuZGlkYXRlIGZyYWdtZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IFtidWZmZXJFbmQgPSAwXSAtIFRoZSBlbmQgb2YgdGhlIGNvbnRpZ3VvdXMgYnVmZmVyZWQgcmFuZ2UgdGhlIHBsYXloZWFkIGlzIGN1cnJlbnRseSB3aXRoaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0L2VuZCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMgeyp9IGZvdW5kRnJhZyAtIFRoZSBiZXN0IG1hdGNoaW5nIGZyYWdtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRnJhZ21lbnRCeVBUUyAoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCA9IDAsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwKSB7XG4gIGNvbnN0IGZyYWdOZXh0ID0gZnJhZ1ByZXZpb3VzID8gZnJhZ21lbnRzW2ZyYWdQcmV2aW91cy5zbiAtIGZyYWdtZW50c1swXS5zbiArIDFdIDogbnVsbDtcbiAgLy8gUHJlZmVyIHRoZSBuZXh0IGZyYWdtZW50IGlmIGl0J3Mgd2l0aGluIHRvbGVyYW5jZVxuICBpZiAoZnJhZ05leHQgJiYgIWZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWdOZXh0KSkge1xuICAgIHJldHVybiBmcmFnTmV4dDtcbiAgfVxuICByZXR1cm4gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdC5iaW5kKG51bGwsIGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkpO1xufVxuXG4vKipcbiAqIFRoZSB0ZXN0IGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGZpbmRGcmFnbWVudEJ5U24ncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gKiBAcGFyYW0geyp9IGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gKiBAcGFyYW0ge251bWJlcn0gW2J1ZmZlckVuZCA9IDBdIC0gVGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5IHdpdGhpblxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gMCBpZiBpdCBtYXRjaGVzLCAxIGlmIHRvbyBsb3csIC0xIGlmIHRvbyBoaWdoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QgKGJ1ZmZlckVuZCA9IDAsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwLCBjYW5kaWRhdGUpIHtcbiAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxuICAvLyB0aGlzIGlzIHRvIGNvcGUgd2l0aCBzaXR1YXRpb25zIGxpa2VcbiAgLy8gYnVmZmVyRW5kID0gOS45OTFcbiAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cbiAgLy8gZnJhZ1sxXSA6IFsxMCwyMF1cbiAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxuICAvLyAgICAgICAgICAgICAgZnJhZyBzdGFydCAgICAgICAgICAgICAgIGZyYWcgc3RhcnQrZHVyYXRpb25cbiAgLy8gICAgICAgICAgICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxuICAvLyAgLi4uLS0tLS0tLS0+PC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPjwtLS0tLS0tLS0uLi4uXG4gIC8vIHByZXZpb3VzIGZyYWcgICAgICAgICBtYXRjaGluZyBmcmFnbWVudCAgICAgICAgIG5leHQgZnJhZ1xuICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAvLyBsb2dnZXIubG9nKGBsZXZlbC9zbi9zdGFydC9lbmQvYnVmRW5kOiR7bGV2ZWx9LyR7Y2FuZGlkYXRlLnNufS8ke2NhbmRpZGF0ZS5zdGFydH0vJHsoY2FuZGlkYXRlLnN0YXJ0K2NhbmRpZGF0ZS5kdXJhdGlvbil9LyR7YnVmZmVyRW5kfWApO1xuICAvLyBTZXQgdGhlIGxvb2t1cCB0b2xlcmFuY2UgdG8gYmUgc21hbGwgZW5vdWdoIHRvIGRldGVjdCB0aGUgY3VycmVudCBzZWdtZW50IC0gZW5zdXJlcyB3ZSBkb24ndCBza2lwIG92ZXIgdmVyeSBzbWFsbCBzZWdtZW50c1xuICBsZXQgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uICsgKGNhbmRpZGF0ZS5kZWx0YVBUUyA/IGNhbmRpZGF0ZS5kZWx0YVBUUyA6IDApKTtcbiAgaWYgKGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA8PSBidWZmZXJFbmQpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChjYW5kaWRhdGUuc3RhcnQgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBidWZmZXJFbmQgJiYgY2FuZGlkYXRlLnN0YXJ0KSB7XG4gICAgLy8gaWYgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB3aWxsIGhhdmUgbmVnYXRpdmUgdmFsdWUgdGhlbiBkb24ndCByZXR1cm4gLTEgZm9yIGZpcnN0IGVsZW1lbnRcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBUaGUgdGVzdCBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBmaW5kRnJhZ21lbnRCeVBkdCdzIEJpbmFyeVNlYXJjaCB0byBsb29rIGZvciB0aGUgYmVzdCBtYXRjaCB0byB0aGUgY3VycmVudCBidWZmZXIgY29uZGl0aW9ucy5cbiAqIFRoaXMgZnVuY3Rpb24gdGVzdHMgdGhlIGNhbmRpZGF0ZSdzIHByb2dyYW0gZGF0ZSB0aW1lIHZhbHVlcywgYXMgcmVwcmVzZW50ZWQgaW4gVW5peCB0aW1lXG4gKiBAcGFyYW0geyp9IGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gKiBAcGFyYW0ge251bWJlcn0gW3BkdEJ1ZmZlckVuZCA9IDBdIC0gVGhlIFVuaXggdGltZSByZXByZXNlbnRpbmcgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGNvbnRpZ3VvdXMsIGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGR0V2l0aGluVG9sZXJhbmNlVGVzdCAocGR0QnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUpIHtcbiAgbGV0IGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9IE1hdGgubWluKG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZS5kdXJhdGlvbiArIChjYW5kaWRhdGUuZGVsdGFQVFMgPyBjYW5kaWRhdGUuZGVsdGFQVFMgOiAwKSkgKiAxMDAwO1xuICByZXR1cm4gY2FuZGlkYXRlLmVuZFByb2dyYW1EYXRlVGltZSAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IHBkdEJ1ZmZlckVuZDtcbn1cbiIsImltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcblxuZXhwb3J0IGNvbnN0IEZyYWdtZW50U3RhdGUgPSB7XG4gIE5PVF9MT0FERUQ6ICdOT1RfTE9BREVEJyxcbiAgQVBQRU5ESU5HOiAnQVBQRU5ESU5HJyxcbiAgUEFSVElBTDogJ1BBUlRJQUwnLFxuICBPSzogJ09LJ1xufTtcblxuZXhwb3J0IGNsYXNzIEZyYWdtZW50VHJhY2tlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5CVUZGRVJfQVBQRU5ERUQsXG4gICAgICBFdmVudC5GUkFHX0JVRkZFUkVELFxuICAgICAgRXZlbnQuRlJBR19MT0FERURcbiAgICApO1xuXG4gICAgdGhpcy5idWZmZXJQYWRkaW5nID0gMC4yO1xuXG4gICAgdGhpcy5mcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMudGltZVJhbmdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy50aW1lUmFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIEZyYWdtZW50IHRoYXQgbWF0Y2ggdGhlIHBvc2l0aW9uIGFuZCBsZXZlbFR5cGUuXG4gICAqIElmIG5vdCBmb3VuZCBhbnkgRnJhZ21lbnQsIHJldHVybiBudWxsXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxuICAgKiBAcGFyYW0ge0xldmVsVHlwZX0gbGV2ZWxUeXBlXG4gICAqIEByZXR1cm5zIHtGcmFnbWVudHxudWxsfVxuICAgKi9cbiAgZ2V0QnVmZmVyZWRGcmFnIChwb3NpdGlvbiwgbGV2ZWxUeXBlKSB7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gdGhpcy5mcmFnbWVudHM7XG4gICAgY29uc3QgYnVmZmVyZWRGcmFncyA9IE9iamVjdC5rZXlzKGZyYWdtZW50cykuZmlsdGVyKGtleSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IGZyYWdtZW50c1trZXldO1xuICAgICAgaWYgKGZyYWdtZW50RW50aXR5LmJvZHkudHlwZSAhPT0gbGV2ZWxUeXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgcmV0dXJuIGZyYWcuc3RhcnRQVFMgPD0gcG9zaXRpb24gJiYgcG9zaXRpb24gPD0gZnJhZy5lbmRQVFM7XG4gICAgfSk7XG4gICAgaWYgKGJ1ZmZlcmVkRnJhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvcHVsbC8xNTQ1I2Rpc2N1c3Npb25fcjE2NjIyOTU2NlxuICAgICAgY29uc3QgYnVmZmVyZWRGcmFnS2V5ID0gYnVmZmVyZWRGcmFncy5wb3AoKTtcbiAgICAgIHJldHVybiBmcmFnbWVudHNbYnVmZmVyZWRGcmFnS2V5XS5ib2R5O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJ0aWFsIGZyYWdtZW50cyBlZmZlY3RlZCBieSBjb2RlZCBmcmFtZSBldmljdGlvbiB3aWxsIGJlIHJlbW92ZWRcbiAgICogVGhlIGJyb3dzZXIgd2lsbCB1bmxvYWQgcGFydHMgb2YgdGhlIGJ1ZmZlciB0byBmcmVlIHVwIG1lbW9yeSBmb3IgbmV3IGJ1ZmZlciBkYXRhXG4gICAqIEZyYWdtZW50cyB3aWxsIG5lZWQgdG8gYmUgcmVsb2FkZWQgd2hlbiB0aGUgYnVmZmVyIGlzIGZyZWVkIHVwLCByZW1vdmluZyBwYXJ0aWFsIGZyYWdtZW50cyB3aWxsIGFsbG93IHRoZW0gdG8gcmVsb2FkKHNpbmNlIHRoZXJlIG1pZ2h0IGJlIHBhcnRzIHRoYXQgYXJlIHN0aWxsIHBsYXlhYmxlKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZWxlbWVudGFyeVN0cmVhbSBUaGUgZWxlbWVudGFyeVN0cmVhbSBvZiBtZWRpYSB0aGlzIGlzIChlZy4gdmlkZW8vYXVkaW8pXG4gICAqIEBwYXJhbSB7VGltZVJhbmdlc30gdGltZVJhbmdlIFRpbWVSYW5nZSBvYmplY3QgZnJvbSBhIHNvdXJjZUJ1ZmZlclxuICAgKi9cbiAgZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyAoZWxlbWVudGFyeVN0cmVhbSwgdGltZVJhbmdlKSB7XG4gICAgbGV0IGZyYWdtZW50VGltZXMsIHRpbWU7XG4gICAgLy8gQ2hlY2sgaWYgYW55IGZsYWdnZWQgZnJhZ21lbnRzIGhhdmUgYmVlbiB1bmxvYWRlZFxuICAgIE9iamVjdC5rZXlzKHRoaXMuZnJhZ21lbnRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAoZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgZXNEYXRhID0gZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICAgIGlmIChlc0RhdGEpIHtcbiAgICAgICAgICBmcmFnbWVudFRpbWVzID0gZXNEYXRhLnRpbWU7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFnbWVudFRpbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aW1lID0gZnJhZ21lbnRUaW1lc1tpXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNUaW1lQnVmZmVyZWQodGltZS5zdGFydFBUUywgdGltZS5lbmRQVFMsIHRpbWVSYW5nZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIC8vIFVucmVnaXN0ZXIgcGFydGlhbCBmcmFnbWVudCBhcyBpdCBuZWVkcyB0byBsb2FkIGFnYWluIHRvIGJlIHJldXNlZFxuICAgICAgICAgICAgICB0aGlzLnJlbW92ZUZyYWdtZW50KGZyYWdtZW50RW50aXR5LmJvZHkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGZyYWdtZW50IHBhc3NlZCBpbiBpcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlciBwcm9wZXJseVxuICAgKiBQYXJ0aWFsbHkgbG9hZGVkIGZyYWdtZW50cyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmcmFnbWVudCBDaGVjayB0aGUgZnJhZ21lbnQgYWdhaW5zdCBhbGwgc291cmNlQnVmZmVycyBsb2FkZWRcbiAgICovXG4gIGRldGVjdFBhcnRpYWxGcmFnbWVudHMgKGZyYWdtZW50KSB7XG4gICAgbGV0IGZyYWdLZXkgPSB0aGlzLmdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICBsZXQgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICBpZiAoZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkID0gdHJ1ZTtcblxuICAgICAgT2JqZWN0LmtleXModGhpcy50aW1lUmFuZ2VzKS5mb3JFYWNoKGVsZW1lbnRhcnlTdHJlYW0gPT4ge1xuICAgICAgICBpZiAoZnJhZ21lbnQuaGFzRWxlbWVudGFyeVN0cmVhbShlbGVtZW50YXJ5U3RyZWFtKSkge1xuICAgICAgICAgIGxldCB0aW1lUmFuZ2UgPSB0aGlzLnRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIG1hbGZvcm1lZCBmcmFnbWVudHNcbiAgICAgICAgICAvLyBHYXBzIG5lZWQgdG8gYmUgY2FsY3VsYXRlZCBmb3IgZWFjaCBlbGVtZW50YXJ5U3RyZWFtXG4gICAgICAgICAgZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV0gPSB0aGlzLmdldEJ1ZmZlcmVkVGltZXMoZnJhZ21lbnQuc3RhcnRQVFMsIGZyYWdtZW50LmVuZFBUUywgdGltZVJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0QnVmZmVyZWRUaW1lcyAoc3RhcnRQVFMsIGVuZFBUUywgdGltZVJhbmdlKSB7XG4gICAgbGV0IGZyYWdtZW50VGltZXMgPSBbXTtcbiAgICBsZXQgc3RhcnRUaW1lLCBlbmRUaW1lO1xuICAgIGxldCBmcmFnbWVudFBhcnRpYWwgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVSYW5nZS5sZW5ndGg7IGkrKykge1xuICAgICAgc3RhcnRUaW1lID0gdGltZVJhbmdlLnN0YXJ0KGkpIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgZW5kVGltZSA9IHRpbWVSYW5nZS5lbmQoaSkgKyB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBpZiAoc3RhcnRQVFMgPj0gc3RhcnRUaW1lICYmIGVuZFBUUyA8PSBlbmRUaW1lKSB7XG4gICAgICAgIC8vIEZyYWdtZW50IGlzIGVudGlyZWx5IGNvbnRhaW5lZCBpbiBidWZmZXJcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgb3RoZXIgdGltZVJhbmdlIHRpbWVzIHNpbmNlIGl0J3MgY29tcGxldGVseSBwbGF5YWJsZVxuICAgICAgICBmcmFnbWVudFRpbWVzLnB1c2goe1xuICAgICAgICAgIHN0YXJ0UFRTOiBNYXRoLm1heChzdGFydFBUUywgdGltZVJhbmdlLnN0YXJ0KGkpKSxcbiAgICAgICAgICBlbmRQVFM6IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSlcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChzdGFydFBUUyA8IGVuZFRpbWUgJiYgZW5kUFRTID4gc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBpbnRlcnNlY3Rpb24gd2l0aCBidWZmZXJcbiAgICAgICAgLy8gR2V0IHBsYXlhYmxlIHNlY3Rpb25zIG9mIHRoZSBmcmFnbWVudFxuICAgICAgICBmcmFnbWVudFRpbWVzLnB1c2goe1xuICAgICAgICAgIHN0YXJ0UFRTOiBNYXRoLm1heChzdGFydFBUUywgdGltZVJhbmdlLnN0YXJ0KGkpKSxcbiAgICAgICAgICBlbmRQVFM6IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSlcbiAgICAgICAgfSk7XG4gICAgICAgIGZyYWdtZW50UGFydGlhbCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVuZFBUUyA8PSBzdGFydFRpbWUpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0aW1lOiBmcmFnbWVudFRpbWVzLFxuICAgICAgcGFydGlhbDogZnJhZ21lbnRQYXJ0aWFsXG4gICAgfTtcbiAgfVxuXG4gIGdldEZyYWdtZW50S2V5IChmcmFnbWVudCkge1xuICAgIHJldHVybiBgJHtmcmFnbWVudC50eXBlfV8ke2ZyYWdtZW50LmxldmVsc31fJHtmcmFnbWVudC51cmxJZH1fJHtmcmFnbWVudC5zbn1gO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHBhcnRpYWwgZnJhZ21lbnQgZm9yIGEgY2VydGFpbiB0aW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IGZyYWdtZW50IFJldHVybnMgYSBwYXJ0aWFsIGZyYWdtZW50IGF0IGEgdGltZSBvciBudWxsIGlmIHRoZXJlIGlzIG5vIHBhcnRpYWwgZnJhZ21lbnRcbiAgICovXG4gIGdldFBhcnRpYWxGcmFnbWVudCAodGltZSkge1xuICAgIGxldCB0aW1lUGFkZGluZywgc3RhcnRUaW1lLCBlbmRUaW1lO1xuICAgIGxldCBiZXN0RnJhZ21lbnQgPSBudWxsO1xuICAgIGxldCBiZXN0T3ZlcmxhcCA9IDA7XG4gICAgT2JqZWN0LmtleXModGhpcy5mcmFnbWVudHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNba2V5XTtcbiAgICAgIGlmICh0aGlzLmlzUGFydGlhbChmcmFnbWVudEVudGl0eSkpIHtcbiAgICAgICAgc3RhcnRUaW1lID0gZnJhZ21lbnRFbnRpdHkuYm9keS5zdGFydFBUUyAtIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgICAgZW5kVGltZSA9IGZyYWdtZW50RW50aXR5LmJvZHkuZW5kUFRTICsgdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgICBpZiAodGltZSA+PSBzdGFydFRpbWUgJiYgdGltZSA8PSBlbmRUaW1lKSB7XG4gICAgICAgICAgLy8gVXNlIHRoZSBmcmFnbWVudCB0aGF0IGhhcyB0aGUgbW9zdCBwYWRkaW5nIGZyb20gc3RhcnQgYW5kIGVuZCB0aW1lXG4gICAgICAgICAgdGltZVBhZGRpbmcgPSBNYXRoLm1pbih0aW1lIC0gc3RhcnRUaW1lLCBlbmRUaW1lIC0gdGltZSk7XG4gICAgICAgICAgaWYgKGJlc3RPdmVybGFwIDw9IHRpbWVQYWRkaW5nKSB7XG4gICAgICAgICAgICBiZXN0RnJhZ21lbnQgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgICAgICAgYmVzdE92ZXJsYXAgPSB0aW1lUGFkZGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYmVzdEZyYWdtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmcmFnbWVudCBUaGUgZnJhZ21lbnQgdG8gY2hlY2tcbiAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJucyB0aGUgZnJhZ21lbnQgc3RhdGUgd2hlbiBhIGZyYWdtZW50IG5ldmVyIGxvYWRlZCBvciBpZiBpdCBwYXJ0aWFsbHkgbG9hZGVkXG4gICAqL1xuICBnZXRTdGF0ZSAoZnJhZ21lbnQpIHtcbiAgICBsZXQgZnJhZ0tleSA9IHRoaXMuZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgIGxldCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICAgIGxldCBzdGF0ZSA9IEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRDtcblxuICAgIGlmIChmcmFnbWVudEVudGl0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkKSB7XG4gICAgICAgIHN0YXRlID0gRnJhZ21lbnRTdGF0ZS5BUFBFTkRJTkc7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSA9PT0gdHJ1ZSkge1xuICAgICAgICBzdGF0ZSA9IEZyYWdtZW50U3RhdGUuUEFSVElBTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlID0gRnJhZ21lbnRTdGF0ZS5PSztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBpc1BhcnRpYWwgKGZyYWdtZW50RW50aXR5KSB7XG4gICAgcmV0dXJuIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkID09PSB0cnVlICYmXG4gICAgICAoKGZyYWdtZW50RW50aXR5LnJhbmdlLnZpZGVvICE9PSB1bmRlZmluZWQgJiYgZnJhZ21lbnRFbnRpdHkucmFuZ2UudmlkZW8ucGFydGlhbCA9PT0gdHJ1ZSkgfHxcbiAgICAgICAgKGZyYWdtZW50RW50aXR5LnJhbmdlLmF1ZGlvICE9PSB1bmRlZmluZWQgJiYgZnJhZ21lbnRFbnRpdHkucmFuZ2UuYXVkaW8ucGFydGlhbCA9PT0gdHJ1ZSkpO1xuICB9XG5cbiAgaXNUaW1lQnVmZmVyZWQgKHN0YXJ0UFRTLCBlbmRQVFMsIHRpbWVSYW5nZSkge1xuICAgIGxldCBzdGFydFRpbWUsIGVuZFRpbWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lUmFuZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YXJ0VGltZSA9IHRpbWVSYW5nZS5zdGFydChpKSAtIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGVuZFRpbWUgPSB0aW1lUmFuZ2UuZW5kKGkpICsgdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgaWYgKHN0YXJ0UFRTID49IHN0YXJ0VGltZSAmJiBlbmRQVFMgPD0gZW5kVGltZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFBUUyA8PSBzdGFydFRpbWUpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgaXMgY29tcGxldGVkXG4gICAqL1xuICBvbkZyYWdMb2FkZWQgKGUpIHtcbiAgICBjb25zdCBmcmFnbWVudCA9IGUuZnJhZztcbiAgICAvLyBkb24ndCB0cmFjayBpbml0c2VnbWVudCAoZm9yIHdoaWNoIHNuIGlzIG5vdCBhIG51bWJlcilcbiAgICAvLyBkb24ndCB0cmFjayBmcmFncyB1c2VkIGZvciBiaXRyYXRlVGVzdCwgdGhleSdyZSBpcnJlbGV2YW50LlxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGZyYWdtZW50LnNuKSB8fCBmcmFnbWVudC5iaXRyYXRlVGVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZnJhZ21lbnRzW3RoaXMuZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpXSA9IHtcbiAgICAgIGJvZHk6IGZyYWdtZW50LFxuICAgICAgcmFuZ2U6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBidWZmZXJlZDogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gdGhlIGJ1ZmZlciBpcyB1cGRhdGVkXG4gICAqL1xuICBvbkJ1ZmZlckFwcGVuZGVkIChlKSB7XG4gICAgLy8gU3RvcmUgdGhlIGxhdGVzdCB0aW1lUmFuZ2VzIGxvYWRlZCBpbiB0aGUgYnVmZmVyXG4gICAgdGhpcy50aW1lUmFuZ2VzID0gZS50aW1lUmFuZ2VzO1xuICAgIE9iamVjdC5rZXlzKHRoaXMudGltZVJhbmdlcykuZm9yRWFjaChlbGVtZW50YXJ5U3RyZWFtID0+IHtcbiAgICAgIGxldCB0aW1lUmFuZ2UgPSB0aGlzLnRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICB0aGlzLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMoZWxlbWVudGFyeVN0cmVhbSwgdGltZVJhbmdlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyBhZnRlciBhIGZyYWdtZW50IGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBzb3VyY2UgYnVmZmVyXG4gICAqL1xuICBvbkZyYWdCdWZmZXJlZCAoZSkge1xuICAgIHRoaXMuZGV0ZWN0UGFydGlhbEZyYWdtZW50cyhlLmZyYWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIGZyYWdtZW50IHRyYWNrZXIgaGFzIHRoZSBmcmFnbWVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGZyYWdtZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaGFzRnJhZ21lbnQgKGZyYWdtZW50KSB7XG4gICAgY29uc3QgZnJhZ0tleSA9IHRoaXMuZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XSAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZyYWdtZW50IGZyb20gZnJhZ21lbnQgdHJhY2tlciB1bnRpbCBpdCBpcyBsb2FkZWQgYWdhaW5cbiAgICogQHBhcmFtIHtPYmplY3R9IGZyYWdtZW50IFRoZSBmcmFnbWVudCB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZUZyYWdtZW50IChmcmFnbWVudCkge1xuICAgIGxldCBmcmFnS2V5ID0gdGhpcy5nZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgZGVsZXRlIHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgZnJhZ21lbnRzIGZyb20gZnJhZ21lbnQgdHJhY2tlci5cbiAgICovXG4gIHJlbW92ZUFsbEZyYWdtZW50cyAoKSB7XG4gICAgdGhpcy5mcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBCdWZmZXJIZWxwZXIgfSBmcm9tICcuLi91dGlscy9idWZmZXItaGVscGVyJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNvbnN0IHN0YWxsRGVib3VuY2VJbnRlcnZhbCA9IDEwMDA7XG5jb25zdCBqdW1wVGhyZXNob2xkID0gMC41OyAvLyB0b2xlcmFuY2UgbmVlZGVkIGFzIHNvbWUgYnJvd3NlcnMgc3RhbGxzIHBsYXliYWNrIGJlZm9yZSByZWFjaGluZyBidWZmZXJlZCByYW5nZSBlbmRcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FwQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcsIG1lZGlhLCBmcmFnbWVudFRyYWNrZXIsIGhscykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHBsYXloZWFkIGlzIHN0dWNrIHdpdGhpbiBhIGdhcCwgYW5kIGlmIHNvLCBhdHRlbXB0cyB0byBmcmVlIGl0LlxuICAgKiBBIGdhcCBpcyBhbiB1bmJ1ZmZlcmVkIHJhbmdlIGJldHdlZW4gdHdvIGJ1ZmZlcmVkIHJhbmdlcyAob3IgdGhlIHN0YXJ0IGFuZCB0aGUgZmlyc3QgYnVmZmVyZWQgcmFuZ2UpLlxuICAgKiBAcGFyYW0gbGFzdEN1cnJlbnRUaW1lXG4gICAqIEBwYXJhbSBidWZmZXJlZFxuICAgKi9cbiAgcG9sbCAobGFzdEN1cnJlbnRUaW1lLCBidWZmZXJlZCkge1xuICAgIGNvbnN0IHsgY29uZmlnLCBtZWRpYSB9ID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IHRub3cgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICBpZiAoY3VycmVudFRpbWUgIT09IGxhc3RDdXJyZW50VGltZSkge1xuICAgICAgLy8gVGhlIHBsYXloZWFkIGlzIG5vdyBtb3ZpbmcsIGJ1dCB3YXMgcHJldmlvdXNseSBzdGFsbGVkXG4gICAgICBpZiAodGhpcy5zdGFsbFJlcG9ydGVkKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBwbGF5YmFjayBub3Qgc3R1Y2sgYW55bW9yZSBAJHtjdXJyZW50VGltZX0sIGFmdGVyICR7TWF0aC5yb3VuZCh0bm93IC0gdGhpcy5zdGFsbGVkKX1tc2ApO1xuICAgICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtZWRpYS5lbmRlZCB8fCAhbWVkaWEuYnVmZmVyZWQubGVuZ3RoIHx8IG1lZGlhLnJlYWR5U3RhdGUgPiAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1lZGlhLnNlZWtpbmcgJiYgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsIGN1cnJlbnRUaW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoZSBwbGF5aGVhZCBpc24ndCBtb3ZpbmcgYnV0IGl0IHNob3VsZCBiZVxuICAgIC8vIEFsbG93IHNvbWUgc2xhY2sgdGltZSB0byBmb3Igc21hbGwgc3RhbGxzIHRvIHJlc29sdmUgdGhlbXNlbHZlc1xuICAgIGNvbnN0IHN0YWxsZWREdXJhdGlvbiA9IHRub3cgLSB0aGlzLnN0YWxsZWQ7XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBjdXJyZW50VGltZSwgY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgIGlmICghdGhpcy5zdGFsbGVkKSB7XG4gICAgICB0aGlzLnN0YWxsZWQgPSB0bm93O1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoc3RhbGxlZER1cmF0aW9uID49IHN0YWxsRGVib3VuY2VJbnRlcnZhbCkge1xuICAgICAgLy8gUmVwb3J0IHN0YWxsaW5nIGFmdGVyIHRyeWluZyB0byBmaXhcbiAgICAgIHRoaXMuX3JlcG9ydFN0YWxsKGJ1ZmZlckluZm8ubGVuKTtcbiAgICB9XG5cbiAgICB0aGlzLl90cnlGaXhCdWZmZXJTdGFsbChidWZmZXJJbmZvLCBzdGFsbGVkRHVyYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdHMgYW5kIGF0dGVtcHRzIHRvIGZpeCBrbm93biBidWZmZXIgc3RhbGxpbmcgaXNzdWVzLlxuICAgKiBAcGFyYW0gYnVmZmVySW5mbyAtIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAgICogQHBhcmFtIHN0YWxsZWREdXJhdGlvbiAtIFRoZSBhbW91bnQgb2YgdGltZSBIbHMuanMgaGFzIGJlZW4gc3RhbGxpbmcgZm9yLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyeUZpeEJ1ZmZlclN0YWxsIChidWZmZXJJbmZvLCBzdGFsbGVkRHVyYXRpb24pIHtcbiAgICBjb25zdCB7IGNvbmZpZywgZnJhZ21lbnRUcmFja2VyLCBtZWRpYSB9ID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuXG4gICAgY29uc3QgcGFydGlhbCA9IGZyYWdtZW50VHJhY2tlci5nZXRQYXJ0aWFsRnJhZ21lbnQoY3VycmVudFRpbWUpO1xuICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICAvLyBUcnkgdG8gc2tpcCBvdmVyIHRoZSBidWZmZXIgaG9sZSBjYXVzZWQgYnkgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAgICAvLyBUaGlzIG1ldGhvZCBpc24ndCBsaW1pdGVkIGJ5IHRoZSBzaXplIG9mIHRoZSBnYXAgYmV0d2VlbiBidWZmZXJlZCByYW5nZXNcbiAgICAgIHRoaXMuX3RyeVNraXBCdWZmZXJIb2xlKHBhcnRpYWwpO1xuICAgIH1cblxuICAgIGlmIChidWZmZXJJbmZvLmxlbiA+IGp1bXBUaHJlc2hvbGQgJiYgc3RhbGxlZER1cmF0aW9uID4gY29uZmlnLmhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZCAqIDEwMDApIHtcbiAgICAgIC8vIFRyeSB0byBudWRnZSBjdXJyZW50VGltZSBvdmVyIGEgYnVmZmVyIGhvbGUgaWYgd2UndmUgYmVlbiBzdGFsbGluZyBmb3IgdGhlIGNvbmZpZ3VyZWQgYW1vdW50IG9mIHNlY29uZHNcbiAgICAgIC8vIFdlIG9ubHkgdHJ5IHRvIGp1bXAgdGhlIGhvbGUgaWYgaXQncyB1bmRlciB0aGUgY29uZmlndXJlZCBzaXplXG4gICAgICAvLyBSZXNldCBzdGFsbGVkIHNvIHRvIHJlYXJtIHdhdGNoZG9nIHRpbWVyXG4gICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgdGhpcy5fdHJ5TnVkZ2VCdWZmZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSBCVUZGRVJfU1RBTExFRF9FUlJPUiBldmVudCwgYnV0IG9ubHkgb25jZSBwZXIgc3RhbGwgcGVyaW9kLlxuICAgKiBAcGFyYW0gYnVmZmVyTGVuIC0gVGhlIHBsYXloZWFkIGRpc3RhbmNlIGZyb20gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXIgc2VnbWVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXBvcnRTdGFsbCAoYnVmZmVyTGVuKSB7XG4gICAgY29uc3QgeyBobHMsIG1lZGlhLCBzdGFsbFJlcG9ydGVkIH0gPSB0aGlzO1xuICAgIGlmICghc3RhbGxSZXBvcnRlZCkge1xuICAgICAgLy8gUmVwb3J0IHN0YWxsZWQgZXJyb3Igb25jZVxuICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gdHJ1ZTtcbiAgICAgIGxvZ2dlci53YXJuKGBQbGF5YmFjayBzdGFsbGluZyBhdCBAJHttZWRpYS5jdXJyZW50VGltZX0gZHVlIHRvIGxvdyBidWZmZXJgKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBidWZmZXI6IGJ1ZmZlckxlblxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGZpeCBidWZmZXIgc3RhbGxzIGJ5IGp1bXBpbmcgb3ZlciBrbm93biBnYXBzIGNhdXNlZCBieSBwYXJ0aWFsIGZyYWdtZW50c1xuICAgKiBAcGFyYW0gcGFydGlhbCAtIFRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvdW5kIGF0IHRoZSBjdXJyZW50IHRpbWUgKHdoZXJlIHBsYXliYWNrIGlzIHN0YWxsaW5nKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90cnlTa2lwQnVmZmVySG9sZSAocGFydGlhbCkge1xuICAgIGNvbnN0IHsgaGxzLCBtZWRpYSB9ID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGxldCBsYXN0RW5kVGltZSA9IDA7XG4gICAgLy8gQ2hlY2sgaWYgY3VycmVudFRpbWUgaXMgYmV0d2VlbiB1bmJ1ZmZlcmVkIHJlZ2lvbnMgb2YgcGFydGlhbCBmcmFnbWVudHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lZGlhLmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc3RhcnRUaW1lID0gbWVkaWEuYnVmZmVyZWQuc3RhcnQoaSk7XG4gICAgICBpZiAoY3VycmVudFRpbWUgPj0gbGFzdEVuZFRpbWUgJiYgY3VycmVudFRpbWUgPCBzdGFydFRpbWUpIHtcbiAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBNYXRoLm1heChzdGFydFRpbWUsIG1lZGlhLmN1cnJlbnRUaW1lICsgMC4xKTtcbiAgICAgICAgbG9nZ2VyLndhcm4oYHNraXBwaW5nIGhvbGUsIGFkanVzdGluZyBjdXJyZW50VGltZSBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7bWVkaWEuY3VycmVudFRpbWV9YCk7XG4gICAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NFRUtfT1ZFUl9IT0xFLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICByZWFzb246IGBmcmFnbWVudCBsb2FkZWQgd2l0aCBidWZmZXIgaG9sZXMsIHNlZWtpbmcgZnJvbSAke2N1cnJlbnRUaW1lfSB0byAke21lZGlhLmN1cnJlbnRUaW1lfWAsXG4gICAgICAgICAgZnJhZzogcGFydGlhbFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGFzdEVuZFRpbWUgPSBtZWRpYS5idWZmZXJlZC5lbmQoaSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGZpeCBidWZmZXIgc3RhbGxzIGJ5IGFkdmFuY2luZyB0aGUgbWVkaWFFbGVtZW50J3MgY3VycmVudCB0aW1lIGJ5IGEgc21hbGwgYW1vdW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyeU51ZGdlQnVmZmVyICgpIHtcbiAgICBjb25zdCB7IGNvbmZpZywgaGxzLCBtZWRpYSB9ID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IG51ZGdlUmV0cnkgPSAodGhpcy5udWRnZVJldHJ5IHx8IDApICsgMTtcbiAgICB0aGlzLm51ZGdlUmV0cnkgPSBudWRnZVJldHJ5O1xuXG4gICAgaWYgKG51ZGdlUmV0cnkgPCBjb25maWcubnVkZ2VNYXhSZXRyeSkge1xuICAgICAgY29uc3QgdGFyZ2V0VGltZSA9IGN1cnJlbnRUaW1lICsgbnVkZ2VSZXRyeSAqIGNvbmZpZy5udWRnZU9mZnNldDtcbiAgICAgIGxvZ2dlci5sb2coYGFkanVzdCBjdXJyZW50VGltZSBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7dGFyZ2V0VGltZX1gKTtcbiAgICAgIC8vIHBsYXliYWNrIHN0YWxsZWQgaW4gYnVmZmVyZWQgYXJlYSAuLi4gbGV0J3MgbnVkZ2UgY3VycmVudFRpbWUgdG8gdHJ5IHRvIG92ZXJjb21lIHRoaXNcbiAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gdGFyZ2V0VGltZTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfTlVER0VfT05fU1RBTEwsXG4gICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5lcnJvcihgc3RpbGwgc3R1Y2sgaW4gaGlnaCBidWZmZXIgQCR7Y3VycmVudFRpbWV9IGFmdGVyICR7Y29uZmlnLm51ZGdlTWF4UmV0cnl9LCByYWlzZSBmYXRhbCBlcnJvcmApO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogaWQzIG1ldGFkYXRhIHRyYWNrIGNvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCBJRDMgZnJvbSAnLi4vZGVtdXgvaWQzJztcbmltcG9ydCB7IHNlbmRBZGRUcmFja0V2ZW50LCBjbGVhckN1cnJlbnRDdWVzIH0gZnJvbSAnLi4vdXRpbHMvdGV4dHRyYWNrLXV0aWxzJztcblxuY2xhc3MgSUQzVHJhY2tDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSEVELFxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBKTtcbiAgICB0aGlzLmlkM1RyYWNrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWVkaWEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8vIEFkZCBJRDMgbWV0YXRhZGF0YSB0ZXh0IHRyYWNrLlxuICBvbk1lZGlhQXR0YWNoZWQgKGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcblxuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcgKCkge1xuICAgIGNsZWFyQ3VycmVudEN1ZXModGhpcy5pZDNUcmFjayk7XG4gICAgdGhpcy5pZDNUcmFjayA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1lZGlhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0SUQzVHJhY2sgKHRleHRUcmFja3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB0ZXh0VHJhY2sgPSB0ZXh0VHJhY2tzW2ldO1xuICAgICAgaWYgKHRleHRUcmFjay5raW5kID09PSAnbWV0YWRhdGEnICYmIHRleHRUcmFjay5sYWJlbCA9PT0gJ2lkMycpIHtcbiAgICAgICAgLy8gc2VuZCAnYWRkdHJhY2snIHdoZW4gcmV1c2luZyB0aGUgdGV4dFRyYWNrIGZvciBtZXRhZGF0YSxcbiAgICAgICAgLy8gc2FtZSBhcyB3aGF0IHdlIGRvIGZvciBjYXB0aW9uc1xuICAgICAgICBzZW5kQWRkVHJhY2tFdmVudCh0ZXh0VHJhY2ssIHRoaXMubWVkaWEpO1xuXG4gICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lZGlhLmFkZFRleHRUcmFjaygnbWV0YWRhdGEnLCAnaWQzJyk7XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nTWV0YWRhdGEgKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnbWVudCA9IGRhdGEuZnJhZztcbiAgICBjb25zdCBzYW1wbGVzID0gZGF0YS5zYW1wbGVzO1xuXG4gICAgLy8gY3JlYXRlIHRyYWNrIGR5bmFtaWNhbGx5XG4gICAgaWYgKCF0aGlzLmlkM1RyYWNrKSB7XG4gICAgICB0aGlzLmlkM1RyYWNrID0gdGhpcy5nZXRJRDNUcmFjayh0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xuICAgICAgdGhpcy5pZDNUcmFjay5tb2RlID0gJ2hpZGRlbic7XG4gICAgfVxuXG4gICAgLy8gQXR0ZW1wdCB0byByZWNyZWF0ZSBTYWZhcmkgZnVuY3Rpb25hbGl0eSBieSBjcmVhdGluZ1xuICAgIC8vIFdlYktpdERhdGFDdWUgb2JqZWN0cyB3aGVuIGF2YWlsYWJsZSBhbmQgc3RvcmUgdGhlIGRlY29kZWRcbiAgICAvLyBJRDMgZGF0YSBpbiB0aGUgdmFsdWUgcHJvcGVydHkgb2YgdGhlIGN1ZVxuICAgIGxldCBDdWUgPSB3aW5kb3cuV2ViS2l0RGF0YUN1ZSB8fCB3aW5kb3cuVlRUQ3VlIHx8IHdpbmRvdy5UZXh0VHJhY2tDdWU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZyYW1lcyA9IElEMy5nZXRJRDNGcmFtZXMoc2FtcGxlc1tpXS5kYXRhKTtcbiAgICAgIGlmIChmcmFtZXMpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gc2FtcGxlc1tpXS5wdHM7XG4gICAgICAgIGxldCBlbmRUaW1lID0gaSA8IHNhbXBsZXMubGVuZ3RoIC0gMSA/IHNhbXBsZXNbaSArIDFdLnB0cyA6IGZyYWdtZW50LmVuZFBUUztcblxuICAgICAgICAvLyBHaXZlIGEgc2xpZ2h0IGJ1bXAgdG8gdGhlIGVuZFRpbWUgaWYgaXQncyBlcXVhbCB0byBzdGFydFRpbWUgdG8gYXZvaWQgYSBTeW50YXhFcnJvciBpbiBJRVxuICAgICAgICBpZiAoc3RhcnRUaW1lID09PSBlbmRUaW1lKSB7XG4gICAgICAgICAgZW5kVGltZSArPSAwLjAwMDE7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZyYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IGZyYW1lID0gZnJhbWVzW2pdO1xuICAgICAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IHB1dCB0aGUgdGltZXN0YW1wIGZyYW1lIGluIHRoZSBUZXh0VHJhY2tcbiAgICAgICAgICBpZiAoIUlEMy5pc1RpbWVTdGFtcEZyYW1lKGZyYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgY3VlID0gbmV3IEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsICcnKTtcbiAgICAgICAgICAgIGN1ZS52YWx1ZSA9IGZyYW1lO1xuICAgICAgICAgICAgdGhpcy5pZDNUcmFjay5hZGRDdWUoY3VlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSUQzVHJhY2tDb250cm9sbGVyO1xuIiwiLypcbiAqIExldmVsIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgaXNDb2RlY1N1cHBvcnRlZEluTXA0IH0gZnJvbSAnLi4vdXRpbHMvY29kZWNzJztcbmltcG9ydCB7IGFkZEdyb3VwSWQsIGNvbXB1dGVSZWxvYWRJbnRlcnZhbCB9IGZyb20gJy4vbGV2ZWwtaGVscGVyJztcblxuY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gd2luZG93O1xubGV0IGNocm9tZU9yRmlyZWZveDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGV2ZWxDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURFRCxcbiAgICAgIEV2ZW50LkxFVkVMX0xPQURFRCxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELFxuICAgICAgRXZlbnQuRlJBR19MT0FERUQsXG4gICAgICBFdmVudC5FUlJPUik7XG5cbiAgICB0aGlzLmNhbmxvYWQgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gbnVsbDtcbiAgICB0aGlzLm1hbnVhbExldmVsSW5kZXggPSAtMTtcbiAgICB0aGlzLnRpbWVyID0gbnVsbDtcblxuICAgIGNocm9tZU9yRmlyZWZveCA9IC9jaHJvbWV8ZmlyZWZveC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xuICB9XG5cbiAgb25IYW5kbGVyRGVzdHJveWluZyAoKSB7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gLTE7XG4gIH1cblxuICBjbGVhclRpbWVyICgpIHtcbiAgICBpZiAodGhpcy50aW1lciAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgc3RhcnRMb2FkICgpIHtcbiAgICBsZXQgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzO1xuXG4gICAgdGhpcy5jYW5sb2FkID0gdHJ1ZTtcbiAgICB0aGlzLmxldmVsUmV0cnlDb3VudCA9IDA7XG5cbiAgICAvLyBjbGVhbiB1cCBsaXZlIGxldmVsIGRldGFpbHMgdG8gZm9yY2UgcmVsb2FkIHRoZW0sIGFuZCByZXNldCBsb2FkIGVycm9yc1xuICAgIGlmIChsZXZlbHMpIHtcbiAgICAgIGxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICAgICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICAgICAgaWYgKGxldmVsRGV0YWlscyAmJiBsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgICAgIGxldmVsLmRldGFpbHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBzcGVlZCB1cCBsaXZlIHBsYXlsaXN0IHJlZnJlc2ggaWYgdGltZXIgZXhpc3RzXG4gICAgaWYgKHRoaXMudGltZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMubG9hZExldmVsKCk7XG4gICAgfVxuICB9XG5cbiAgc3RvcExvYWQgKCkge1xuICAgIHRoaXMuY2FubG9hZCA9IGZhbHNlO1xuICB9XG5cbiAgb25NYW5pZmVzdExvYWRlZCAoZGF0YSkge1xuICAgIGxldCBsZXZlbHMgPSBbXTtcbiAgICBsZXQgYXVkaW9UcmFja3MgPSBbXTtcbiAgICBsZXQgYml0cmF0ZVN0YXJ0O1xuICAgIGxldCBsZXZlbFNldCA9IHt9O1xuICAgIGxldCBsZXZlbEZyb21TZXQgPSBudWxsO1xuICAgIGxldCB2aWRlb0NvZGVjRm91bmQgPSBmYWxzZTtcbiAgICBsZXQgYXVkaW9Db2RlY0ZvdW5kID0gZmFsc2U7XG5cbiAgICAvLyByZWdyb3VwIHJlZHVuZGFudCBsZXZlbHMgdG9nZXRoZXJcbiAgICBkYXRhLmxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBsZXZlbC5hdHRycztcbiAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gZmFsc2U7XG5cbiAgICAgIHZpZGVvQ29kZWNGb3VuZCA9IHZpZGVvQ29kZWNGb3VuZCB8fCAhIWxldmVsLnZpZGVvQ29kZWM7XG4gICAgICBhdWRpb0NvZGVjRm91bmQgPSBhdWRpb0NvZGVjRm91bmQgfHwgISFsZXZlbC5hdWRpb0NvZGVjO1xuXG4gICAgICAvLyBlcmFzZSBhdWRpbyBjb2RlYyBpbmZvIGlmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBtcDRhLjQwLjM0LlxuICAgICAgLy8gZGVtdXhlciB3aWxsIGF1dG9kZXRlY3QgY29kZWMgYW5kIGZhbGxiYWNrIHRvIG1wZWcvYXVkaW9cbiAgICAgIGlmIChjaHJvbWVPckZpcmVmb3ggJiYgbGV2ZWwuYXVkaW9Db2RlYyAmJiBsZXZlbC5hdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMzQnKSAhPT0gLTEpIHtcbiAgICAgICAgbGV2ZWwuYXVkaW9Db2RlYyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgbGV2ZWxGcm9tU2V0ID0gbGV2ZWxTZXRbbGV2ZWwuYml0cmF0ZV07IC8vIEZJWE1FOiB3ZSB3b3VsZCBhbHNvIGhhdmUgdG8gbWF0Y2ggdGhlIHJlc29sdXRpb24gaGVyZVxuXG4gICAgICBpZiAoIWxldmVsRnJvbVNldCkge1xuICAgICAgICBsZXZlbC51cmwgPSBbbGV2ZWwudXJsXTtcbiAgICAgICAgbGV2ZWwudXJsSWQgPSAwO1xuICAgICAgICBsZXZlbFNldFtsZXZlbC5iaXRyYXRlXSA9IGxldmVsO1xuICAgICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbEZyb21TZXQudXJsLnB1c2gobGV2ZWwudXJsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMuQVVESU8pIHtcbiAgICAgICAgICBhdWRpb0NvZGVjRm91bmQgPSB0cnVlO1xuICAgICAgICAgIGFkZEdyb3VwSWQobGV2ZWxGcm9tU2V0IHx8IGxldmVsLCAnYXVkaW8nLCBhdHRyaWJ1dGVzLkFVRElPKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlcy5TVUJUSVRMRVMpIHtcbiAgICAgICAgICBhZGRHcm91cElkKGxldmVsRnJvbVNldCB8fCBsZXZlbCwgJ3RleHQnLCBhdHRyaWJ1dGVzLlNVQlRJVExFUyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHJlbW92ZSBhdWRpby1vbmx5IGxldmVsIGlmIHdlIGFsc28gaGF2ZSBsZXZlbHMgd2l0aCBhdWRpbyt2aWRlbyBjb2RlY3Mgc2lnbmFsbGVkXG4gICAgaWYgKHZpZGVvQ29kZWNGb3VuZCAmJiBhdWRpb0NvZGVjRm91bmQpIHtcbiAgICAgIGxldmVscyA9IGxldmVscy5maWx0ZXIoKHsgdmlkZW9Db2RlYyB9KSA9PiAhIXZpZGVvQ29kZWMpO1xuICAgIH1cblxuICAgIC8vIG9ubHkga2VlcCBsZXZlbHMgd2l0aCBzdXBwb3J0ZWQgYXVkaW8vdmlkZW8gY29kZWNzXG4gICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcigoeyBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjIH0pID0+IHtcbiAgICAgIHJldHVybiAoIWF1ZGlvQ29kZWMgfHwgaXNDb2RlY1N1cHBvcnRlZEluTXA0KGF1ZGlvQ29kZWMsICdhdWRpbycpKSAmJiAoIXZpZGVvQ29kZWMgfHwgaXNDb2RlY1N1cHBvcnRlZEluTXA0KHZpZGVvQ29kZWMsICd2aWRlbycpKTtcbiAgICB9KTtcblxuICAgIGlmIChkYXRhLmF1ZGlvVHJhY2tzKSB7XG4gICAgICBhdWRpb1RyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MuZmlsdGVyKHRyYWNrID0+ICF0cmFjay5hdWRpb0NvZGVjIHx8IGlzQ29kZWNTdXBwb3J0ZWRJbk1wNCh0cmFjay5hdWRpb0NvZGVjLCAnYXVkaW8nKSk7XG4gICAgICAvLyBSZWFzc2lnbiBpZCdzIGFmdGVyIGZpbHRlcmluZyBzaW5jZSB0aGV5J3JlIHVzZWQgYXMgYXJyYXkgaW5kaWNlc1xuICAgICAgYXVkaW9UcmFja3MuZm9yRWFjaCgodHJhY2ssIGluZGV4KSA9PiB7XG4gICAgICAgIHRyYWNrLmlkID0gaW5kZXg7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHN0YXJ0IGJpdHJhdGUgaXMgdGhlIGZpcnN0IGJpdHJhdGUgb2YgdGhlIG1hbmlmZXN0XG4gICAgICBiaXRyYXRlU3RhcnQgPSBsZXZlbHNbMF0uYml0cmF0ZTtcbiAgICAgIC8vIHNvcnQgbGV2ZWwgb24gYml0cmF0ZVxuICAgICAgbGV2ZWxzLnNvcnQoKGEsIGIpID0+IGEuYml0cmF0ZSAtIGIuYml0cmF0ZSk7XG4gICAgICB0aGlzLl9sZXZlbHMgPSBsZXZlbHM7XG4gICAgICAvLyBmaW5kIGluZGV4IG9mIGZpcnN0IGxldmVsIGluIHNvcnRlZCBsZXZlbHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsZXZlbHNbaV0uYml0cmF0ZSA9PT0gYml0cmF0ZVN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IGk7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbWFuaWZlc3QgbG9hZGVkLCR7bGV2ZWxzLmxlbmd0aH0gbGV2ZWwocykgZm91bmQsIGZpcnN0IGJpdHJhdGU6JHtiaXRyYXRlU3RhcnR9YCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQXVkaW8gaXMgb25seSBhbHRlcm5hdGUgaWYgbWFuaWZlc3QgaW5jbHVkZSBhIFVSSSBhbG9uZyB3aXRoIHRoZSBhdWRpbyBncm91cCB0YWdcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTUFOSUZFU1RfUEFSU0VELCB7XG4gICAgICAgIGxldmVscyxcbiAgICAgICAgYXVkaW9UcmFja3MsXG4gICAgICAgIGZpcnN0TGV2ZWw6IHRoaXMuX2ZpcnN0TGV2ZWwsXG4gICAgICAgIHN0YXRzOiBkYXRhLnN0YXRzLFxuICAgICAgICBhdWRpbzogYXVkaW9Db2RlY0ZvdW5kLFxuICAgICAgICB2aWRlbzogdmlkZW9Db2RlY0ZvdW5kLFxuICAgICAgICBhbHRBdWRpbzogYXVkaW9UcmFja3Muc29tZSh0ID0+ICEhdC51cmwpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUixcbiAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgIHVybDogdGhpcy5obHMudXJsLFxuICAgICAgICByZWFzb246ICdubyBsZXZlbCB3aXRoIGNvbXBhdGlibGUgY29kZWNzIGZvdW5kIGluIG1hbmlmZXN0J1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGxldmVscyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xldmVscztcbiAgfVxuXG4gIGdldCBsZXZlbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gIH1cblxuICBzZXQgbGV2ZWwgKG5ld0xldmVsKSB7XG4gICAgbGV0IGxldmVscyA9IHRoaXMuX2xldmVscztcbiAgICBpZiAobGV2ZWxzKSB7XG4gICAgICBuZXdMZXZlbCA9IE1hdGgubWluKG5ld0xldmVsLCBsZXZlbHMubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAodGhpcy5jdXJyZW50TGV2ZWxJbmRleCAhPT0gbmV3TGV2ZWwgfHwgIWxldmVsc1tuZXdMZXZlbF0uZGV0YWlscykge1xuICAgICAgICB0aGlzLnNldExldmVsSW50ZXJuYWwobmV3TGV2ZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldExldmVsSW50ZXJuYWwgKG5ld0xldmVsKSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzO1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgIGlmIChuZXdMZXZlbCA+PSAwICYmIG5ld0xldmVsIDwgbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRMZXZlbEluZGV4ICE9PSBuZXdMZXZlbCkge1xuICAgICAgICBsb2dnZXIubG9nKGBzd2l0Y2hpbmcgdG8gbGV2ZWwgJHtuZXdMZXZlbH1gKTtcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG5ld0xldmVsO1xuICAgICAgICBjb25zdCBsZXZlbFByb3BlcnRpZXMgPSBsZXZlbHNbbmV3TGV2ZWxdO1xuICAgICAgICBsZXZlbFByb3BlcnRpZXMubGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfU1dJVENISU5HLCBsZXZlbFByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxdO1xuICAgICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcblxuICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIGxldmVsXG4gICAgICBpZiAoIWxldmVsRGV0YWlscyB8fCBsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgICAvLyBsZXZlbCBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICAgIGxldCB1cmxJZCA9IGxldmVsLnVybElkO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5MRVZFTF9MT0FESU5HLCB7IHVybDogbGV2ZWwudXJsW3VybElkXSwgbGV2ZWw6IG5ld0xldmVsLCBpZDogdXJsSWQgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGludmFsaWQgbGV2ZWwgaWQgZ2l2ZW4sIHRyaWdnZXIgZXJyb3JcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5MRVZFTF9TV0lUQ0hfRVJST1IsXG4gICAgICAgIGxldmVsOiBuZXdMZXZlbCxcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICByZWFzb246ICdpbnZhbGlkIGxldmVsIGlkeCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGdldCBtYW51YWxMZXZlbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFudWFsTGV2ZWxJbmRleDtcbiAgfVxuXG4gIHNldCBtYW51YWxMZXZlbCAobmV3TGV2ZWwpIHtcbiAgICB0aGlzLm1hbnVhbExldmVsSW5kZXggPSBuZXdMZXZlbDtcbiAgICBpZiAodGhpcy5fc3RhcnRMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuXG4gICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgdGhpcy5sZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgfVxuXG4gIGdldCBmaXJzdExldmVsICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcbiAgfVxuXG4gIHNldCBmaXJzdExldmVsIChuZXdMZXZlbCkge1xuICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIGdldCBzdGFydExldmVsICgpIHtcbiAgICAvLyBobHMuc3RhcnRMZXZlbCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgY29uZmlnLnN0YXJ0TGV2ZWxcbiAgICAvLyBpZiBub25lIG9mIHRoZXNlIHZhbHVlcyBhcmUgZGVmaW5lZCwgZmFsbGJhY2sgb24gdGhpcy5fZmlyc3RMZXZlbCAoZmlyc3QgcXVhbGl0eSBsZXZlbCBhcHBlYXJpbmcgaW4gdmFyaWFudCBtYW5pZmVzdClcbiAgICBpZiAodGhpcy5fc3RhcnRMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgY29uZmlnU3RhcnRMZXZlbCA9IHRoaXMuaGxzLmNvbmZpZy5zdGFydExldmVsO1xuICAgICAgaWYgKGNvbmZpZ1N0YXJ0TGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY29uZmlnU3RhcnRMZXZlbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhcnRMZXZlbDtcbiAgICB9XG4gIH1cblxuICBzZXQgc3RhcnRMZXZlbCAobmV3TGV2ZWwpIHtcbiAgICB0aGlzLl9zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICBvbkVycm9yIChkYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUikge1xuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBsZXZlbEVycm9yID0gZmFsc2UsIGZyYWdtZW50RXJyb3IgPSBmYWxzZTtcbiAgICBsZXQgbGV2ZWxJbmRleDtcblxuICAgIC8vIHRyeSB0byByZWNvdmVyIG5vdCBmYXRhbCBlcnJvcnNcbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgbGV2ZWxJbmRleCA9IGRhdGEuZnJhZy5sZXZlbHM7XG4gICAgICBmcmFnbWVudEVycm9yID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgICAgbGV2ZWxJbmRleCA9IGRhdGEuY29udGV4dC5sZXZlbHM7XG4gICAgICBsZXZlbEVycm9yID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SOlxuICAgICAgbGV2ZWxJbmRleCA9IGRhdGEubGV2ZWxzO1xuICAgICAgbGV2ZWxFcnJvciA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAobGV2ZWxJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnJlY292ZXJMZXZlbChkYXRhLCBsZXZlbEluZGV4LCBsZXZlbEVycm9yLCBmcmFnbWVudEVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3dpdGNoIHRvIGEgcmVkdW5kYW50IHN0cmVhbSBpZiBhbnkgYXZhaWxhYmxlLlxuICAgKiBJZiByZWR1bmRhbnQgc3RyZWFtIGlzIG5vdCBhdmFpbGFibGUsIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBpZiBBQlIgbW9kZSBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXJyb3JFdmVudFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxJbmRleCBjdXJyZW50IGxldmVsIGluZGV4XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbGV2ZWxFcnJvclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZyYWdtZW50RXJyb3JcbiAgICovXG4gIC8vIEZJWE1FIEZpbmQgYSBiZXR0ZXIgYWJzdHJhY3Rpb24gd2hlcmUgZnJhZ21lbnQvbGV2ZWwgcmV0cnkgbWFuYWdlbWVudCBpcyB3ZWxsIGRlY291cGxlZFxuICByZWNvdmVyTGV2ZWwgKGVycm9yRXZlbnQsIGxldmVsSW5kZXgsIGxldmVsRXJyb3IsIGZyYWdtZW50RXJyb3IpIHtcbiAgICBsZXQgeyBjb25maWcgfSA9IHRoaXMuaGxzO1xuICAgIGxldCB7IGRldGFpbHM6IGVycm9yRGV0YWlscyB9ID0gZXJyb3JFdmVudDtcbiAgICBsZXQgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxJbmRleF07XG4gICAgbGV0IHJlZHVuZGFudExldmVscywgZGVsYXksIG5leHRMZXZlbDtcblxuICAgIGxldmVsLmxvYWRFcnJvcisrO1xuICAgIGxldmVsLmZyYWdtZW50RXJyb3IgPSBmcmFnbWVudEVycm9yO1xuXG4gICAgaWYgKGxldmVsRXJyb3IpIHtcbiAgICAgIGlmICgodGhpcy5sZXZlbFJldHJ5Q291bnQgKyAxKSA8PSBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnkpIHtcbiAgICAgICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gbWF4IHJldHJ5IHRpbWVvdXRcbiAgICAgICAgZGVsYXkgPSBNYXRoLm1pbihNYXRoLnBvdygyLCB0aGlzLmxldmVsUmV0cnlDb3VudCkgKiBjb25maWcubGV2ZWxMb2FkaW5nUmV0cnlEZWxheSwgY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dCk7XG4gICAgICAgIC8vIFNjaGVkdWxlIGxldmVsIHJlbG9hZFxuICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmxvYWRMZXZlbCgpLCBkZWxheSk7XG4gICAgICAgIC8vIGJvb2xlYW4gdXNlZCB0byBpbmZvcm0gc3RyZWFtIGNvbnRyb2xsZXIgbm90IHRvIHN3aXRjaCBiYWNrIHRvIElETEUgb24gbm9uIGZhdGFsIGVycm9yXG4gICAgICAgIGVycm9yRXZlbnQubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICAgIHRoaXMubGV2ZWxSZXRyeUNvdW50Kys7XG4gICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCAke2Vycm9yRGV0YWlsc30sIHJldHJ5IGluICR7ZGVsYXl9IG1zLCBjdXJyZW50IHJldHJ5IGNvdW50IGlzICR7dGhpcy5sZXZlbFJldHJ5Q291bnR9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYGxldmVsIGNvbnRyb2xsZXIsIGNhbm5vdCByZWNvdmVyIGZyb20gJHtlcnJvckRldGFpbHN9IGVycm9yYCk7XG4gICAgICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSBudWxsO1xuICAgICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgIC8vIHN3aXRjaCBlcnJvciB0byBmYXRhbFxuICAgICAgICBlcnJvckV2ZW50LmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyeSBhbnkgcmVkdW5kYW50IHN0cmVhbXMgaWYgYXZhaWxhYmxlIGZvciBib3RoIGVycm9yczogbGV2ZWwgYW5kIGZyYWdtZW50XG4gICAgLy8gSWYgbGV2ZWwubG9hZEVycm9yIHJlYWNoZXMgcmVkdW5kYW50TGV2ZWxzIGl0IG1lYW5zIHRoYXQgd2UgdHJpZWQgdGhlbSBhbGwsIG5vIGhvcGUgID0+IGxldCdzIHN3aXRjaCBkb3duXG4gICAgaWYgKGxldmVsRXJyb3IgfHwgZnJhZ21lbnRFcnJvcikge1xuICAgICAgcmVkdW5kYW50TGV2ZWxzID0gbGV2ZWwudXJsLmxlbmd0aDtcblxuICAgICAgaWYgKHJlZHVuZGFudExldmVscyA+IDEgJiYgbGV2ZWwubG9hZEVycm9yIDwgcmVkdW5kYW50TGV2ZWxzKSB7XG4gICAgICAgIGxldmVsLnVybElkID0gKGxldmVsLnVybElkICsgMSkgJSByZWR1bmRhbnRMZXZlbHM7XG4gICAgICAgIGxldmVsLmRldGFpbHMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgbG9nZ2VyLndhcm4oYGxldmVsIGNvbnRyb2xsZXIsICR7ZXJyb3JEZXRhaWxzfSBmb3IgbGV2ZWwgJHtsZXZlbEluZGV4fTogc3dpdGNoaW5nIHRvIHJlZHVuZGFudCBVUkwtaWQgJHtsZXZlbC51cmxJZH1gKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnQ3VycmVudCBhdWRpbyB0cmFjayBncm91cCBJRDonLCB0aGlzLmhscy5hdWRpb1RyYWNrc1t0aGlzLmhscy5hdWRpb1RyYWNrXS5ncm91cElkKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ05ldyB2aWRlbyBxdWFsaXR5IGxldmVsIGF1ZGlvIGdyb3VwIGlkOicsIGxldmVsLmF0dHJzLkFVRElPKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNlYXJjaCBmb3IgYXZhaWxhYmxlIGxldmVsXG4gICAgICAgIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgLy8gV2hlbiBsb3dlc3QgbGV2ZWwgaGFzIGJlZW4gcmVhY2hlZCwgbGV0J3Mgc3RhcnQgaHVudCBmcm9tIHRoZSB0b3BcbiAgICAgICAgICBuZXh0TGV2ZWwgPSAobGV2ZWxJbmRleCA9PT0gMCkgPyB0aGlzLl9sZXZlbHMubGVuZ3RoIC0gMSA6IGxldmVsSW5kZXggLSAxO1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCAke2Vycm9yRGV0YWlsc306IHN3aXRjaCB0byAke25leHRMZXZlbH1gKTtcbiAgICAgICAgICB0aGlzLmhscy5uZXh0QXV0b0xldmVsID0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG5leHRMZXZlbDtcbiAgICAgICAgfSBlbHNlIGlmIChmcmFnbWVudEVycm9yKSB7XG4gICAgICAgICAgLy8gQWxsb3cgZnJhZ21lbnQgcmV0cnkgYXMgbG9uZyBhcyBjb25maWd1cmF0aW9uIGFsbG93cy5cbiAgICAgICAgICAvLyByZXNldCB0aGlzLl9sZXZlbCBzbyB0aGF0IGFub3RoZXIgY2FsbCB0byBzZXQgbGV2ZWwoKSB3aWxsIHRyaWdnZXIgYWdhaW4gYSBmcmFnIGxvYWRcbiAgICAgICAgICBsb2dnZXIud2FybihgbGV2ZWwgY29udHJvbGxlciwgJHtlcnJvckRldGFpbHN9OiByZWxvYWQgYSBmcmFnbWVudGApO1xuICAgICAgICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzZXQgZXJyb3JzIG9uIHRoZSBzdWNjZXNzZnVsIGxvYWQgb2YgYSBmcmFnbWVudFxuICBvbkZyYWdMb2FkZWQgKHsgZnJhZyB9KSB7XG4gICAgaWYgKGZyYWcgIT09IHVuZGVmaW5lZCAmJiBmcmFnLnR5cGUgPT09ICdtYWluJykge1xuICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbZnJhZy5sZXZlbHNdO1xuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IGZhbHNlO1xuICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgICB0aGlzLmxldmVsUmV0cnlDb3VudCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25MZXZlbExvYWRlZCAoZGF0YSkge1xuICAgIGNvbnN0IHsgbGV2ZWwsIGRldGFpbHMgfSA9IGRhdGE7XG4gICAgLy8gb25seSBwcm9jZXNzIGxldmVsIGxvYWRlZCBldmVudHMgbWF0Y2hpbmcgd2l0aCBleHBlY3RlZCBsZXZlbFxuICAgIGlmIChsZXZlbCAhPT0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGN1ckxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsXTtcbiAgICAvLyByZXNldCBsZXZlbCBsb2FkIGVycm9yIGNvdW50ZXIgb24gc3VjY2Vzc2Z1bCBsZXZlbCBsb2FkZWQgb25seSBpZiB0aGVyZSBpcyBubyBpc3N1ZXMgd2l0aCBmcmFnbWVudHNcbiAgICBpZiAoIWN1ckxldmVsLmZyYWdtZW50RXJyb3IpIHtcbiAgICAgIGN1ckxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICB0aGlzLmxldmVsUmV0cnlDb3VudCA9IDA7XG4gICAgfVxuICAgIC8vIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0LCBhcm0gYSB0aW1lciB0byByZWxvYWQgaXRcbiAgICBpZiAoZGV0YWlscy5saXZlKSB7XG4gICAgICBjb25zdCByZWxvYWRJbnRlcnZhbCA9IGNvbXB1dGVSZWxvYWRJbnRlcnZhbChjdXJMZXZlbC5kZXRhaWxzLCBkZXRhaWxzLCBkYXRhLnN0YXRzLnRyZXF1ZXN0KTtcbiAgICAgIGxvZ2dlci5sb2coYGxpdmUgcGxheWxpc3QsIHJlbG9hZCBpbiAke01hdGgucm91bmQocmVsb2FkSW50ZXJ2YWwpfSBtc2ApO1xuICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5sb2FkTGV2ZWwoKSwgcmVsb2FkSW50ZXJ2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB9XG4gIH1cblxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hlZCAoZGF0YSkge1xuICAgIGNvbnN0IGF1ZGlvR3JvdXBJZCA9IHRoaXMuaGxzLmF1ZGlvVHJhY2tzW2RhdGEuaWRdLmdyb3VwSWQ7XG5cbiAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbdGhpcy5jdXJyZW50TGV2ZWxJbmRleF07XG4gICAgaWYgKCFjdXJyZW50TGV2ZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudExldmVsLmF1ZGlvR3JvdXBJZHMpIHtcbiAgICAgIGxldCB1cmxJZCA9IC0xO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjdXJyZW50TGV2ZWwuYXVkaW9Hcm91cElkc1tpXSA9PT0gYXVkaW9Hcm91cElkKSB7XG4gICAgICAgICAgdXJsSWQgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh1cmxJZCAhPT0gY3VycmVudExldmVsLnVybElkKSB7XG4gICAgICAgIGN1cnJlbnRMZXZlbC51cmxJZCA9IHVybElkO1xuICAgICAgICB0aGlzLnN0YXJ0TG9hZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxvYWRMZXZlbCAoKSB7XG4gICAgbG9nZ2VyLmRlYnVnKCdjYWxsIHRvIGxvYWRMZXZlbCcpO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudExldmVsSW5kZXggIT09IG51bGwgJiYgdGhpcy5jYW5sb2FkKSB7XG4gICAgICBjb25zdCBsZXZlbE9iamVjdCA9IHRoaXMuX2xldmVsc1t0aGlzLmN1cnJlbnRMZXZlbEluZGV4XTtcblxuICAgICAgaWYgKHR5cGVvZiBsZXZlbE9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgbGV2ZWxPYmplY3QudXJsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICAgICAgICBjb25zdCBpZCA9IGxldmVsT2JqZWN0LnVybElkO1xuICAgICAgICBjb25zdCB1cmwgPSBsZXZlbE9iamVjdC51cmxbaWRdO1xuXG4gICAgICAgIGxvZ2dlci5sb2coYEF0dGVtcHQgbG9hZGluZyBsZXZlbCBpbmRleCAke2xldmVsfSB3aXRoIFVSTC1pZCAke2lkfWApO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdDdXJyZW50IGF1ZGlvIHRyYWNrIGdyb3VwIElEOicsIHRoaXMuaGxzLmF1ZGlvVHJhY2tzW3RoaXMuaGxzLmF1ZGlvVHJhY2tdLmdyb3VwSWQpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnTmV3IHZpZGVvIHF1YWxpdHkgbGV2ZWwgYXVkaW8gZ3JvdXAgaWQ6JywgbGV2ZWxPYmplY3QuYXR0cnMuQVVESU8sIGxldmVsKTtcblxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX0xPQURJTkcsIHsgdXJsLCBsZXZlbCwgaWQgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IG5leHRMb2FkTGV2ZWwgKCkge1xuICAgIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggIT09IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5obHMubmV4dEF1dG9MZXZlbDtcbiAgICB9XG4gIH1cblxuICBzZXQgbmV4dExvYWRMZXZlbCAobmV4dExldmVsKSB7XG4gICAgdGhpcy5sZXZlbCA9IG5leHRMZXZlbDtcbiAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ID09PSAtMSkge1xuICAgICAgdGhpcy5obHMubmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQG1vZHVsZSBMZXZlbEhlbHBlclxuICpcbiAqIFByb3ZpZGluZyBtZXRob2RzIGRlYWxpbmcgd2l0aCBwbGF5bGlzdCBzbGlkaW5nIGFuZCBkcmlmdFxuICpcbiAqIFRPRE86IENyZWF0ZSBhbiBhY3R1YWwgYExldmVsYCBjbGFzcy9tb2RlbCB0aGF0IGRlYWxzIHdpdGggYWxsIHRoaXMgbG9naWMgaW4gYW4gb2JqZWN0LW9yaWVudGVkLW1hbm5lci5cbiAqXG4gKiAqL1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkR3JvdXBJZCAobGV2ZWwsIHR5cGUsIGlkKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICBjYXNlICdhdWRpbyc6XG4gICAgaWYgKCFsZXZlbC5hdWRpb0dyb3VwSWRzKSB7XG4gICAgICBsZXZlbC5hdWRpb0dyb3VwSWRzID0gW107XG4gICAgfVxuICAgIGxldmVsLmF1ZGlvR3JvdXBJZHMucHVzaChpZCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3RleHQnOlxuICAgIGlmICghbGV2ZWwudGV4dEdyb3VwSWRzKSB7XG4gICAgICBsZXZlbC50ZXh0R3JvdXBJZHMgPSBbXTtcbiAgICB9XG4gICAgbGV2ZWwudGV4dEdyb3VwSWRzLnB1c2goaWQpO1xuICAgIGJyZWFrO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVQVFMgKGZyYWdtZW50cywgZnJvbUlkeCwgdG9JZHgpIHtcbiAgbGV0IGZyYWdGcm9tID0gZnJhZ21lbnRzW2Zyb21JZHhdLCBmcmFnVG8gPSBmcmFnbWVudHNbdG9JZHhdLCBmcmFnVG9QVFMgPSBmcmFnVG8uc3RhcnRQVFM7XG4gIC8vIGlmIHdlIGtub3cgc3RhcnRQVFNbdG9JZHhdXG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoZnJhZ1RvUFRTKSkge1xuICAgIC8vIHVwZGF0ZSBmcmFnbWVudCBkdXJhdGlvbi5cbiAgICAvLyBpdCBoZWxwcyB0byBmaXggZHJpZnRzIGJldHdlZW4gcGxheWxpc3QgcmVwb3J0ZWQgZHVyYXRpb24gYW5kIGZyYWdtZW50IHJlYWwgZHVyYXRpb25cbiAgICBpZiAodG9JZHggPiBmcm9tSWR4KSB7XG4gICAgICBmcmFnRnJvbS5kdXJhdGlvbiA9IGZyYWdUb1BUUyAtIGZyYWdGcm9tLnN0YXJ0O1xuICAgICAgaWYgKGZyYWdGcm9tLmR1cmF0aW9uIDwgMCkge1xuICAgICAgICBsb2dnZXIud2FybihgbmVnYXRpdmUgZHVyYXRpb24gY29tcHV0ZWQgZm9yIGZyYWcgJHtmcmFnRnJvbS5zbn0sbGV2ZWwgJHtmcmFnRnJvbS5sZXZlbHN9LCB0aGVyZSBzaG91bGQgYmUgc29tZSBkdXJhdGlvbiBkcmlmdCBiZXR3ZWVuIHBsYXlsaXN0IGFuZCBmcmFnbWVudCFgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ1RvLmR1cmF0aW9uID0gZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG9QVFM7XG4gICAgICBpZiAoZnJhZ1RvLmR1cmF0aW9uIDwgMCkge1xuICAgICAgICBsb2dnZXIud2FybihgbmVnYXRpdmUgZHVyYXRpb24gY29tcHV0ZWQgZm9yIGZyYWcgJHtmcmFnVG8uc259LGxldmVsICR7ZnJhZ1RvLmxldmVsc30sIHRoZXJlIHNob3VsZCBiZSBzb21lIGR1cmF0aW9uIGRyaWZ0IGJldHdlZW4gcGxheWxpc3QgYW5kIGZyYWdtZW50IWApO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyB3ZSBkb250IGtub3cgc3RhcnRQVFNbdG9JZHhdXG4gICAgaWYgKHRvSWR4ID4gZnJvbUlkeCkge1xuICAgICAgZnJhZ1RvLnN0YXJ0ID0gZnJhZ0Zyb20uc3RhcnQgKyBmcmFnRnJvbS5kdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ1RvLnN0YXJ0ID0gTWF0aC5tYXgoZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG8uZHVyYXRpb24sIDApO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlRnJhZ1BUU0RUUyAoZGV0YWlscywgZnJhZywgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUykge1xuICAvLyB1cGRhdGUgZnJhZyBQVFMvRFRTXG4gIGxldCBtYXhTdGFydFBUUyA9IHN0YXJ0UFRTO1xuICBpZiAoTnVtYmVyLmlzRmluaXRlKGZyYWcuc3RhcnRQVFMpKSB7XG4gICAgLy8gZGVsdGEgUFRTIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvXG4gICAgbGV0IGRlbHRhUFRTID0gTWF0aC5hYnMoZnJhZy5zdGFydFBUUyAtIHN0YXJ0UFRTKTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFnLmRlbHRhUFRTKSkge1xuICAgICAgZnJhZy5kZWx0YVBUUyA9IGRlbHRhUFRTO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnLmRlbHRhUFRTID0gTWF0aC5tYXgoZGVsdGFQVFMsIGZyYWcuZGVsdGFQVFMpO1xuICAgIH1cblxuICAgIG1heFN0YXJ0UFRTID0gTWF0aC5tYXgoc3RhcnRQVFMsIGZyYWcuc3RhcnRQVFMpO1xuICAgIHN0YXJ0UFRTID0gTWF0aC5taW4oc3RhcnRQVFMsIGZyYWcuc3RhcnRQVFMpO1xuICAgIGVuZFBUUyA9IE1hdGgubWF4KGVuZFBUUywgZnJhZy5lbmRQVFMpO1xuICAgIHN0YXJ0RFRTID0gTWF0aC5taW4oc3RhcnREVFMsIGZyYWcuc3RhcnREVFMpO1xuICAgIGVuZERUUyA9IE1hdGgubWF4KGVuZERUUywgZnJhZy5lbmREVFMpO1xuICB9XG5cbiAgY29uc3QgZHJpZnQgPSBzdGFydFBUUyAtIGZyYWcuc3RhcnQ7XG4gIGZyYWcuc3RhcnQgPSBmcmFnLnN0YXJ0UFRTID0gc3RhcnRQVFM7XG4gIGZyYWcubWF4U3RhcnRQVFMgPSBtYXhTdGFydFBUUztcbiAgZnJhZy5lbmRQVFMgPSBlbmRQVFM7XG4gIGZyYWcuc3RhcnREVFMgPSBzdGFydERUUztcbiAgZnJhZy5lbmREVFMgPSBlbmREVFM7XG4gIGZyYWcuZHVyYXRpb24gPSBlbmRQVFMgLSBzdGFydFBUUztcblxuICBjb25zdCBzbiA9IGZyYWcuc247XG4gIC8vIGV4aXQgaWYgc24gb3V0IG9mIHJhbmdlXG4gIGlmICghZGV0YWlscyB8fCBzbiA8IGRldGFpbHMuc3RhcnRTTiB8fCBzbiA+IGRldGFpbHMuZW5kU04pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGxldCBmcmFnSWR4LCBmcmFnbWVudHMsIGk7XG4gIGZyYWdJZHggPSBzbiAtIGRldGFpbHMuc3RhcnRTTjtcbiAgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gIC8vIHVwZGF0ZSBmcmFnIHJlZmVyZW5jZSBpbiBmcmFnbWVudHMgYXJyYXlcbiAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgZnJhZ21lbnRzIGFycmF5IG1pZ2h0IG5vdCBjb250YWluIHRoaXMgZnJhZyBvYmplY3QuXG4gIC8vIHRoaXMgd2lsbCBoYXBwZW4gaWYgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIGJldHdlZW4gZnJhZyBsb2FkaW5nIGFuZCBjYWxsIHRvIHVwZGF0ZUZyYWdQVFNEVFMoKVxuICAvLyBpZiB3ZSBkb24ndCB1cGRhdGUgZnJhZywgd2Ugd29uJ3QgYmUgYWJsZSB0byBwcm9wYWdhdGUgUFRTIGluZm8gb24gdGhlIHBsYXlsaXN0XG4gIC8vIHJlc3VsdGluZyBpbiBpbnZhbGlkIHNsaWRpbmcgY29tcHV0YXRpb25cbiAgZnJhZ21lbnRzW2ZyYWdJZHhdID0gZnJhZztcbiAgLy8gYWRqdXN0IGZyYWdtZW50IFBUUy9kdXJhdGlvbiBmcm9tIHNlcW51bS0xIHRvIGZyYWcgMFxuICBmb3IgKGkgPSBmcmFnSWR4OyBpID4gMDsgaS0tKSB7XG4gICAgdXBkYXRlUFRTKGZyYWdtZW50cywgaSwgaSAtIDEpO1xuICB9XG5cbiAgLy8gYWRqdXN0IGZyYWdtZW50IFBUUy9kdXJhdGlvbiBmcm9tIHNlcW51bSB0byBsYXN0IGZyYWdcbiAgZm9yIChpID0gZnJhZ0lkeDsgaSA8IGZyYWdtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB1cGRhdGVQVFMoZnJhZ21lbnRzLCBpLCBpICsgMSk7XG4gIH1cblxuICBkZXRhaWxzLlBUU0tub3duID0gdHJ1ZTtcbiAgcmV0dXJuIGRyaWZ0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VEZXRhaWxzIChvbGREZXRhaWxzLCBuZXdEZXRhaWxzKSB7XG4gIC8vIHBvdGVudGlhbGx5IHJldHJpZXZlIGNhY2hlZCBpbml0c2VnbWVudFxuICBpZiAobmV3RGV0YWlscy5pbml0U2VnbWVudCAmJiBvbGREZXRhaWxzLmluaXRTZWdtZW50KSB7XG4gICAgbmV3RGV0YWlscy5pbml0U2VnbWVudCA9IG9sZERldGFpbHMuaW5pdFNlZ21lbnQ7XG4gIH1cblxuICAvLyBjaGVjayBpZiBvbGQvbmV3IHBsYXlsaXN0cyBoYXZlIGZyYWdtZW50cyBpbiBjb21tb25cbiAgLy8gbG9vcCB0aHJvdWdoIG92ZXJsYXBwaW5nIFNOIGFuZCB1cGRhdGUgc3RhcnRQVFMgLCBjYywgYW5kIGR1cmF0aW9uIGlmIGFueSBmb3VuZFxuICBsZXQgY2NPZmZzZXQgPSAwO1xuICBsZXQgUFRTRnJhZztcbiAgbWFwRnJhZ21lbnRJbnRlcnNlY3Rpb24ob2xkRGV0YWlscywgbmV3RGV0YWlscywgKG9sZEZyYWcsIG5ld0ZyYWcpID0+IHtcbiAgICBjY09mZnNldCA9IG9sZEZyYWcuY2MgLSBuZXdGcmFnLmNjO1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUob2xkRnJhZy5zdGFydFBUUykpIHtcbiAgICAgIG5ld0ZyYWcuc3RhcnQgPSBuZXdGcmFnLnN0YXJ0UFRTID0gb2xkRnJhZy5zdGFydFBUUztcbiAgICAgIG5ld0ZyYWcuZW5kUFRTID0gb2xkRnJhZy5lbmRQVFM7XG4gICAgICBuZXdGcmFnLmR1cmF0aW9uID0gb2xkRnJhZy5kdXJhdGlvbjtcbiAgICAgIG5ld0ZyYWcuYmFja3RyYWNrZWQgPSBvbGRGcmFnLmJhY2t0cmFja2VkO1xuICAgICAgbmV3RnJhZy5kcm9wcGVkID0gb2xkRnJhZy5kcm9wcGVkO1xuICAgICAgUFRTRnJhZyA9IG5ld0ZyYWc7XG4gICAgfVxuICAgIC8vIFBUUyBpcyBrbm93biB3aGVuIHRoZXJlIGFyZSBvdmVybGFwcGluZyBzZWdtZW50c1xuICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSB0cnVlO1xuICB9KTtcblxuICBpZiAoIW5ld0RldGFpbHMuUFRTS25vd24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2NPZmZzZXQpIHtcbiAgICBsb2dnZXIubG9nKCdkaXNjb250aW51aXR5IHNsaWRpbmcgZnJvbSBwbGF5bGlzdCwgdGFrZSBkcmlmdCBpbnRvIGFjY291bnQnKTtcbiAgICBjb25zdCBuZXdGcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0ZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgbmV3RnJhZ21lbnRzW2ldLmNjICs9IGNjT2Zmc2V0O1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIGF0IGxlYXN0IG9uZSBmcmFnbWVudCBjb250YWlucyBQVFMgaW5mbywgcmVjb21wdXRlIFBUUyBpbmZvcm1hdGlvbiBmb3IgYWxsIGZyYWdtZW50c1xuICBpZiAoUFRTRnJhZykge1xuICAgIHVwZGF0ZUZyYWdQVFNEVFMobmV3RGV0YWlscywgUFRTRnJhZywgUFRTRnJhZy5zdGFydFBUUywgUFRTRnJhZy5lbmRQVFMsIFBUU0ZyYWcuc3RhcnREVFMsIFBUU0ZyYWcuZW5kRFRTKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbnN1cmUgdGhhdCBkZWx0YSBpcyB3aXRoaW4gb2xkRnJhZ21lbnRzIHJhbmdlXG4gICAgLy8gYWxzbyBhZGp1c3Qgc2xpZGluZyBpbiBjYXNlIGRlbHRhIGlzIDAgKHdlIGNvdWxkIGhhdmUgb2xkPVs1MC02MF0gYW5kIG5ldz1vbGQ9WzUwLTYxXSlcbiAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgYWxzbyBuZWVkIHRvIGFkanVzdCBzdGFydCBvZmZzZXQgb2YgYWxsIGZyYWdtZW50c1xuICAgIGFkanVzdFNsaWRpbmcob2xkRGV0YWlscywgbmV3RGV0YWlscyk7XG4gIH1cbiAgLy8gaWYgd2UgYXJlIGhlcmUsIGl0IG1lYW5zIHdlIGhhdmUgZnJhZ21lbnRzIG92ZXJsYXBwaW5nIGJldHdlZW5cbiAgLy8gb2xkIGFuZCBuZXcgbGV2ZWwuIHJlbGlhYmxlIFBUUyBpbmZvIGlzIHRodXMgcmVseWluZyBvbiBvbGQgbGV2ZWxcbiAgbmV3RGV0YWlscy5QVFNLbm93biA9IG9sZERldGFpbHMuUFRTS25vd247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVN1YnRpdGxlUGxheWxpc3RzIChvbGRQbGF5bGlzdCwgbmV3UGxheWxpc3QsIHJlZmVyZW5jZVN0YXJ0ID0gMCkge1xuICBsZXQgbGFzdEluZGV4ID0gLTE7XG4gIG1hcEZyYWdtZW50SW50ZXJzZWN0aW9uKG9sZFBsYXlsaXN0LCBuZXdQbGF5bGlzdCwgKG9sZEZyYWcsIG5ld0ZyYWcsIGluZGV4KSA9PiB7XG4gICAgbmV3RnJhZy5zdGFydCA9IG9sZEZyYWcuc3RhcnQ7XG4gICAgbGFzdEluZGV4ID0gaW5kZXg7XG4gIH0pO1xuXG4gIGNvbnN0IGZyYWdzID0gbmV3UGxheWxpc3QuZnJhZ21lbnRzO1xuICBpZiAobGFzdEluZGV4IDwgMCkge1xuICAgIGZyYWdzLmZvckVhY2goZnJhZyA9PiB7XG4gICAgICBmcmFnLnN0YXJ0ICs9IHJlZmVyZW5jZVN0YXJ0O1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSBsYXN0SW5kZXggKyAxOyBpIDwgZnJhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBmcmFnc1tpXS5zdGFydCA9IChmcmFnc1tpIC0gMV0uc3RhcnQgKyBmcmFnc1tpIC0gMV0uZHVyYXRpb24pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBGcmFnbWVudEludGVyc2VjdGlvbiAob2xkUGxheWxpc3QsIG5ld1BsYXlsaXN0LCBpbnRlcnNlY3Rpb25Gbikge1xuICBpZiAoIW9sZFBsYXlsaXN0IHx8ICFuZXdQbGF5bGlzdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgob2xkUGxheWxpc3Quc3RhcnRTTiwgbmV3UGxheWxpc3Quc3RhcnRTTikgLSBuZXdQbGF5bGlzdC5zdGFydFNOO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbihvbGRQbGF5bGlzdC5lbmRTTiwgbmV3UGxheWxpc3QuZW5kU04pIC0gbmV3UGxheWxpc3Quc3RhcnRTTjtcbiAgY29uc3QgZGVsdGEgPSBuZXdQbGF5bGlzdC5zdGFydFNOIC0gb2xkUGxheWxpc3Quc3RhcnRTTjtcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICBjb25zdCBvbGRGcmFnID0gb2xkUGxheWxpc3QuZnJhZ21lbnRzW2RlbHRhICsgaV07XG4gICAgY29uc3QgbmV3RnJhZyA9IG5ld1BsYXlsaXN0LmZyYWdtZW50c1tpXTtcbiAgICBpZiAoIW9sZEZyYWcgfHwgIW5ld0ZyYWcpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbnRlcnNlY3Rpb25GbihvbGRGcmFnLCBuZXdGcmFnLCBpKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRqdXN0U2xpZGluZyAob2xkUGxheWxpc3QsIG5ld1BsYXlsaXN0KSB7XG4gIGNvbnN0IGRlbHRhID0gbmV3UGxheWxpc3Quc3RhcnRTTiAtIG9sZFBsYXlsaXN0LnN0YXJ0U047XG4gIGNvbnN0IG9sZEZyYWdtZW50cyA9IG9sZFBsYXlsaXN0LmZyYWdtZW50cztcbiAgY29uc3QgbmV3RnJhZ21lbnRzID0gbmV3UGxheWxpc3QuZnJhZ21lbnRzO1xuXG4gIGlmIChkZWx0YSA8IDAgfHwgZGVsdGEgPiBvbGRGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3RnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgbmV3RnJhZ21lbnRzW2ldLnN0YXJ0ICs9IG9sZEZyYWdtZW50c1tkZWx0YV0uc3RhcnQ7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVSZWxvYWRJbnRlcnZhbCAoY3VycmVudFBsYXlsaXN0LCBuZXdQbGF5bGlzdCwgbGFzdFJlcXVlc3RUaW1lKSB7XG4gIGxldCByZWxvYWRJbnRlcnZhbCA9IDEwMDAgKiAobmV3UGxheWxpc3QuYXZlcmFnZXRhcmdldGR1cmF0aW9uID8gbmV3UGxheWxpc3QuYXZlcmFnZXRhcmdldGR1cmF0aW9uIDogbmV3UGxheWxpc3QudGFyZ2V0ZHVyYXRpb24pO1xuICBjb25zdCBtaW5SZWxvYWRJbnRlcnZhbCA9IHJlbG9hZEludGVydmFsIC8gMjtcbiAgaWYgKGN1cnJlbnRQbGF5bGlzdCAmJiBuZXdQbGF5bGlzdC5lbmRTTiA9PT0gY3VycmVudFBsYXlsaXN0LmVuZFNOKSB7XG4gICAgLy8gZm9sbG93IEhMUyBTcGVjLCBJZiB0aGUgY2xpZW50IHJlbG9hZHMgYSBQbGF5bGlzdCBmaWxlIGFuZCBmaW5kcyB0aGF0IGl0IGhhcyBub3RcbiAgICAvLyBjaGFuZ2VkIHRoZW4gaXQgTVVTVCB3YWl0IGZvciBhIHBlcmlvZCBvZiBvbmUtaGFsZiB0aGUgdGFyZ2V0XG4gICAgLy8gZHVyYXRpb24gYmVmb3JlIHJldHJ5aW5nLlxuICAgIHJlbG9hZEludGVydmFsID0gbWluUmVsb2FkSW50ZXJ2YWw7XG4gIH1cblxuICBpZiAobGFzdFJlcXVlc3RUaW1lKSB7XG4gICAgcmVsb2FkSW50ZXJ2YWwgPSBNYXRoLm1heChtaW5SZWxvYWRJbnRlcnZhbCwgcmVsb2FkSW50ZXJ2YWwgLSAod2luZG93LnBlcmZvcm1hbmNlLm5vdygpIC0gbGFzdFJlcXVlc3RUaW1lKSk7XG4gIH1cbiAgLy8gaW4gYW55IGNhc2UsIGRvbid0IHJlbG9hZCBtb3JlIHRoYW4gaGFsZiBvZiB0YXJnZXQgZHVyYXRpb25cbiAgcmV0dXJuIE1hdGgucm91bmQocmVsb2FkSW50ZXJ2YWwpO1xufVxuIiwiLypcbiAqIFN0cmVhbSBDb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgQmluYXJ5U2VhcmNoIGZyb20gJy4uL3V0aWxzL2JpbmFyeS1zZWFyY2gnO1xuaW1wb3J0IHsgQnVmZmVySGVscGVyIH0gZnJvbSAnLi4vdXRpbHMvYnVmZmVyLWhlbHBlcic7XG5pbXBvcnQgRGVtdXhlciBmcm9tICcuLi9kZW11eC9kZW11eGVyJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgRnJhZ21lbnRTdGF0ZSB9IGZyb20gJy4vZnJhZ21lbnQtdHJhY2tlcic7XG5pbXBvcnQgRnJhZ21lbnQgZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCBQbGF5bGlzdExvYWRlciBmcm9tICcuLi9sb2FkZXIvcGxheWxpc3QtbG9hZGVyJztcbmltcG9ydCAqIGFzIExldmVsSGVscGVyIGZyb20gJy4vbGV2ZWwtaGVscGVyJztcbmltcG9ydCBUaW1lUmFuZ2VzIGZyb20gJy4uL3V0aWxzL3RpbWUtcmFuZ2VzJztcbmltcG9ydCB7IEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgYWxpZ25TdHJlYW0gfSBmcm9tICcuLi91dGlscy9kaXNjb250aW51aXRpZXMnO1xuaW1wb3J0IHsgZmluZEZyYWdtZW50QnlQRFQsIGZpbmRGcmFnbWVudEJ5UFRTIH0gZnJvbSAnLi9mcmFnbWVudC1maW5kZXJzJztcbmltcG9ydCBHYXBDb250cm9sbGVyIGZyb20gJy4vZ2FwLWNvbnRyb2xsZXInO1xuaW1wb3J0IEJhc2VTdHJlYW1Db250cm9sbGVyLCB7IFN0YXRlIH0gZnJvbSAnLi9iYXNlLXN0cmVhbS1jb250cm9sbGVyJztcblxuY29uc3QgVElDS19JTlRFUlZBTCA9IDEwMDsgLy8gaG93IG9mdGVuIHRvIHRpY2sgaW4gbXNcblxuY2xhc3MgU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIEJhc2VTdHJlYW1Db250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscywgZnJhZ21lbnRUcmFja2VyKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNIRUQsXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfUEFSU0VELFxuICAgICAgRXZlbnQuTEVWRUxfTE9BREVELFxuICAgICAgRXZlbnQuS0VZX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxuICAgICAgRXZlbnQuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELFxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLFxuICAgICAgRXZlbnQuRlJBR19QQVJTRUQsXG4gICAgICBFdmVudC5FUlJPUixcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSElORyxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELFxuICAgICAgRXZlbnQuQlVGRkVSX0NSRUFURUQsXG4gICAgICBFdmVudC5CVUZGRVJfQVBQRU5ERUQsXG4gICAgICBFdmVudC5CVUZGRVJfRkxVU0hFRCk7XG5cbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMuX3N0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmdhcENvbnRyb2xsZXIgPSBudWxsO1xuICB9XG5cbiAgc3RhcnRMb2FkIChzdGFydFBvc2l0aW9uKSB7XG4gICAgaWYgKHRoaXMubGV2ZWxzKSB7XG4gICAgICBsZXQgbGFzdEN1cnJlbnRUaW1lID0gdGhpcy5sYXN0Q3VycmVudFRpbWUsIGhscyA9IHRoaXMuaGxzO1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICAgIHRoaXMubGV2ZWwgPSAtMTtcbiAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgICAgIC8vIGRldGVybWluZSBsb2FkIGxldmVsXG4gICAgICAgIGxldCBzdGFydExldmVsID0gaGxzLnN0YXJ0TGV2ZWw7XG4gICAgICAgIGlmIChzdGFydExldmVsID09PSAtMSkge1xuICAgICAgICAgIC8vIC0xIDogZ3Vlc3Mgc3RhcnQgTGV2ZWwgYnkgZG9pbmcgYSBiaXRyYXRlIHRlc3QgYnkgbG9hZGluZyBmaXJzdCBmcmFnbWVudCBvZiBsb3dlc3QgcXVhbGl0eSBsZXZlbFxuICAgICAgICAgIHN0YXJ0TGV2ZWwgPSAwO1xuICAgICAgICAgIHRoaXMuYml0cmF0ZVRlc3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBuZXcgbGV2ZWwgdG8gcGxheWxpc3QgbG9hZGVyIDogdGhpcyB3aWxsIHRyaWdnZXIgc3RhcnQgbGV2ZWwgbG9hZFxuICAgICAgICAvLyBobHMubmV4dExvYWRMZXZlbCByZW1haW5zIHVudGlsIGl0IGlzIHNldCB0byBhIG5ldyB2YWx1ZSBvciB1bnRpbCBhIG5ldyBmcmFnIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWRcbiAgICAgICAgdGhpcy5sZXZlbCA9IGhscy5uZXh0TG9hZExldmVsID0gc3RhcnRMZXZlbDtcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gaWYgc3RhcnRQb3NpdGlvbiB1bmRlZmluZWQgYnV0IGxhc3RDdXJyZW50VGltZSBzZXQsIHNldCBzdGFydFBvc2l0aW9uIHRvIGxhc3QgY3VycmVudFRpbWVcbiAgICAgIGlmIChsYXN0Q3VycmVudFRpbWUgPiAwICYmIHN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYG92ZXJyaWRlIHN0YXJ0UG9zaXRpb24gd2l0aCBsYXN0Q3VycmVudFRpbWUgQCR7bGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSBsYXN0Q3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvcmNlU3RhcnRMb2FkID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIH1cbiAgfVxuXG4gIHN0b3BMb2FkICgpIHtcbiAgICB0aGlzLmZvcmNlU3RhcnRMb2FkID0gZmFsc2U7XG4gICAgc3VwZXIuc3RvcExvYWQoKTtcbiAgfVxuXG4gIGRvVGljayAoKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgY2FzZSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc6XG4gICAgICAvLyBpbiBidWZmZXIgZmx1c2hpbmcgc3RhdGUsIHJlc2V0IGZyYWdMb2FkRXJyb3IgY291bnRlclxuICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU3RhdGUuSURMRTpcbiAgICAgIHRoaXMuX2RvVGlja0lkbGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU3RhdGUuV0FJVElOR19MRVZFTDpcbiAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdO1xuICAgICAgLy8gY2hlY2sgaWYgcGxheWxpc3QgaXMgYWxyZWFkeSBsb2FkZWRcbiAgICAgIGlmIChsZXZlbCAmJiBsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgdmFyIG5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHZhciByZXRyeURhdGUgPSB0aGlzLnJldHJ5RGF0ZTtcbiAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXG4gICAgICBpZiAoIXJldHJ5RGF0ZSB8fCAobm93ID49IHJldHJ5RGF0ZSkgfHwgKHRoaXMubWVkaWEgJiYgdGhpcy5tZWRpYS5zZWVraW5nKSkge1xuICAgICAgICBsb2dnZXIubG9nKCdtZWRpYUNvbnRyb2xsZXI6IHJldHJ5RGF0ZSByZWFjaGVkLCBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTdGF0ZS5FUlJPUjpcbiAgICBjYXNlIFN0YXRlLlNUT1BQRUQ6XG4gICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkc6XG4gICAgY2FzZSBTdGF0ZS5QQVJTSU5HOlxuICAgIGNhc2UgU3RhdGUuUEFSU0VEOlxuICAgIGNhc2UgU3RhdGUuRU5ERUQ6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIGNoZWNrIGJ1ZmZlclxuICAgIHRoaXMuX2NoZWNrQnVmZmVyKCk7XG4gICAgLy8gY2hlY2svdXBkYXRlIGN1cnJlbnQgZnJhZ21lbnRcbiAgICB0aGlzLl9jaGVja0ZyYWdtZW50Q2hhbmdlZCgpO1xuICB9XG5cbiAgLy8gSXJvbmljYWxseSB0aGUgXCJpZGxlXCIgc3RhdGUgaXMgdGhlIG9uIHdlIGRvIHRoZSBtb3N0IGxvZ2ljIGluIGl0IHNlZW1zIC4uLi5cbiAgLy8gTk9URTogTWF5YmUgd2UgY291bGQgcmF0aGVyIHNjaGVkdWxlIGEgY2hlY2sgZm9yIGJ1ZmZlciBsZW5ndGggYWZ0ZXIgaGFsZiBvZiB0aGUgY3VycmVudGx5XG4gIC8vICAgICAgIHBsYXllZCBzZWdtZW50LCBvciBvbiBwYXVzZS9wbGF5L3NlZWsgaW5zdGVhZCBvZiBuYWl2ZWx5IGNoZWNraW5nIGV2ZXJ5IDEwMG1zP1xuICBfZG9UaWNrSWRsZSAoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHMsXG4gICAgICBjb25maWcgPSBobHMuY29uZmlnLFxuICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgLy8gaWYgc3RhcnQgbGV2ZWwgbm90IHBhcnNlZCB5ZXQgT1JcbiAgICAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggZGlzYWJsZVxuICAgIC8vIGV4aXQgbG9vcCwgYXMgd2UgZWl0aGVyIG5lZWQgbW9yZSBpbmZvIChsZXZlbCBub3QgcGFyc2VkKSBvciB3ZSBuZWVkIG1lZGlhIHRvIGJlIGF0dGFjaGVkIHRvIGxvYWQgbmV3IGZyYWdtZW50XG4gICAgaWYgKHRoaXMubGV2ZWxMYXN0TG9hZGVkID09PSB1bmRlZmluZWQgfHwgKFxuICAgICAgIW1lZGlhICYmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCB8fCAhY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIG5vdCB5ZXQgbG9hZGVkIGFueSBmcmFnbWVudCwgc3RhcnQgbG9hZGluZyBmcm9tIHN0YXJ0IHBvc2l0aW9uXG4gICAgbGV0IHBvcztcbiAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgcG9zID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IHRoaXMubmV4dExvYWRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvLyBkZXRlcm1pbmUgbmV4dCBsb2FkIGxldmVsXG4gICAgbGV0IGxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwsXG4gICAgICBsZXZlbEluZm8gPSB0aGlzLmxldmVsc1tsZXZlbF07XG5cbiAgICBpZiAoIWxldmVsSW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBsZXZlbEJpdHJhdGUgPSBsZXZlbEluZm8uYml0cmF0ZSxcbiAgICAgIG1heEJ1ZkxlbjtcblxuICAgIC8vIGNvbXB1dGUgbWF4IEJ1ZmZlciBMZW5ndGggdGhhdCB3ZSBjb3VsZCBnZXQgZnJvbSB0aGlzIGxvYWQgbGV2ZWwsIGJhc2VkIG9uIGxldmVsIGJpdHJhdGUuIGRvbid0IGJ1ZmZlciBtb3JlIHRoYW4gNjAgTUIgYW5kIG1vcmUgdGhhbiAzMHNcbiAgICBpZiAobGV2ZWxCaXRyYXRlKSB7XG4gICAgICBtYXhCdWZMZW4gPSBNYXRoLm1heCg4ICogY29uZmlnLm1heEJ1ZmZlclNpemUgLyBsZXZlbEJpdHJhdGUsIGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhCdWZMZW4gPSBjb25maWcubWF4QnVmZmVyTGVuZ3RoO1xuICAgIH1cblxuICAgIG1heEJ1ZkxlbiA9IE1hdGgubWluKG1heEJ1ZkxlbiwgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCk7XG5cbiAgICAvLyBkZXRlcm1pbmUgbmV4dCBjYW5kaWRhdGUgZnJhZ21lbnQgdG8gYmUgbG9hZGVkLCBiYXNlZCBvbiBjdXJyZW50IHBvc2l0aW9uIGFuZCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgLy8gZW5zdXJlIHVwIHRvIGBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoYCBvZiBidWZmZXIgdXBmcm9udFxuXG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogbWVkaWEsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLFxuICAgICAgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XG4gICAgLy8gU3RheSBpZGxlIGlmIHdlIGFyZSBzdGlsbCB3aXRoIGJ1ZmZlciBtYXJnaW5zXG4gICAgaWYgKGJ1ZmZlckxlbiA+PSBtYXhCdWZMZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4gdHJ5IHRvIGxvYWQgYSBuZXcgZnJhZ21lbnQgLi4uXG4gICAgbG9nZ2VyLnRyYWNlKGBidWZmZXIgbGVuZ3RoIG9mICR7YnVmZmVyTGVuLnRvRml4ZWQoMyl9IGlzIGJlbG93IG1heCBvZiAke21heEJ1Zkxlbi50b0ZpeGVkKDMpfS4gY2hlY2tpbmcgZm9yIG1vcmUgcGF5bG9hZCAuLi5gKTtcblxuICAgIC8vIHNldCBuZXh0IGxvYWQgbGV2ZWwgOiB0aGlzIHdpbGwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWQgaWYgbmVlZGVkXG4gICAgdGhpcy5sZXZlbCA9IGhscy5uZXh0TG9hZExldmVsID0gbGV2ZWw7XG5cbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcbiAgICAvLyBpZiBsZXZlbCBpbmZvIG5vdCByZXRyaWV2ZWQgeWV0LCBzd2l0Y2ggc3RhdGUgYW5kIHdhaXQgZm9yIGxldmVsIHJldHJpZXZhbFxuICAgIC8vIGlmIGxpdmUgcGxheWxpc3QsIGVuc3VyZSB0aGF0IG5ldyBwbGF5bGlzdCBoYXMgYmVlbiByZWZyZXNoZWQgdG8gYXZvaWQgbG9hZGluZy90cnkgdG8gbG9hZFxuICAgIC8vIGEgdXNlbGVzcyBhbmQgb3V0ZGF0ZWQgZnJhZ21lbnQgKHRoYXQgbWlnaHQgZXZlbiBpbnRyb2R1Y2UgbG9hZCBlcnJvciBpZiBpdCBpcyBhbHJlYWR5IG91dCBvZiB0aGUgbGl2ZSBwbGF5bGlzdClcbiAgICBpZiAoIWxldmVsRGV0YWlscyB8fCAobGV2ZWxEZXRhaWxzLmxpdmUgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IGxldmVsKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfTEVWRUw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIGxldmVsRGV0YWlscykpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICAgIGlmICh0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICAgIGRhdGEudHlwZSA9ICd2aWRlbyc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0VPUywgZGF0YSk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRU5ERUQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGlmIHdlIGhhdmUgdGhlIGxldmVsRGV0YWlscyBmb3IgdGhlIHNlbGVjdGVkIHZhcmlhbnQsIGxldHMgY29udGludWUgZW5yaWNoZW4gb3VyIHN0cmVhbSAobG9hZCBrZXlzL2ZyYWdtZW50cyBvciB0cmlnZ2VyIEVPUywgZXRjLi4pXG4gICAgdGhpcy5fZmV0Y2hQYXlsb2FkT3JFb3MocG9zLCBidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpO1xuICB9XG5cbiAgX2ZldGNoUGF5bG9hZE9yRW9zIChwb3MsIGJ1ZmZlckluZm8sIGxldmVsRGV0YWlscykge1xuICAgIGNvbnN0IGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzLFxuICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsLFxuICAgICAgZnJhZ21lbnRzID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cyxcbiAgICAgIGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuXG4gICAgLy8gZW1wdHkgcGxheWxpc3RcbiAgICBpZiAoZnJhZ0xlbiA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGZpbmQgZnJhZ21lbnQgaW5kZXgsIGNvbnRpZ3VvdXMgd2l0aCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgbGV0IHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0LFxuICAgICAgZW5kID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXS5zdGFydCArIGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uZHVyYXRpb24sXG4gICAgICBidWZmZXJFbmQgPSBidWZmZXJJbmZvLmVuZCxcbiAgICAgIGZyYWc7XG5cbiAgICBpZiAobGV2ZWxEZXRhaWxzLmluaXRTZWdtZW50ICYmICFsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSkge1xuICAgICAgZnJhZyA9IGxldmVsRGV0YWlscy5pbml0U2VnbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW4gY2FzZSBvZiBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgcmVxdWVzdGVkIHBvc2l0aW9uIGlzIG5vdCBsb2NhdGVkIGJlZm9yZSBwbGF5bGlzdCBzdGFydFxuICAgICAgaWYgKGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAgIGxldCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSA9IHRoaXMuY29uZmlnLmluaXRpYWxMaXZlTWFuaWZlc3RTaXplO1xuICAgICAgICBpZiAoZnJhZ0xlbiA8IGluaXRpYWxMaXZlTWFuaWZlc3RTaXplKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYENhbiBub3Qgc3RhcnQgcGxheWJhY2sgb2YgYSBsZXZlbCwgcmVhc29uOiBub3QgZW5vdWdoIGZyYWdtZW50cyAke2ZyYWdMZW59IDwgJHtpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZX1gKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmcmFnID0gdGhpcy5fZW5zdXJlRnJhZ21lbnRBdExpdmVQb2ludChsZXZlbERldGFpbHMsIGJ1ZmZlckVuZCwgc3RhcnQsIGVuZCwgZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGZyYWdMZW4pO1xuICAgICAgICAvLyBpZiBpdCBleHBsaWNpdGVseSByZXR1cm5zIG51bGwgZG9uJ3QgbG9hZCBhbnkgZnJhZ21lbnQgYW5kIGV4aXQgZnVuY3Rpb24gbm93XG4gICAgICAgIGlmIChmcmFnID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBWb0QgcGxheWxpc3Q6IGlmIGJ1ZmZlckVuZCBiZWZvcmUgc3RhcnQgb2YgcGxheWxpc3QsIGxvYWQgZmlyc3QgZnJhZ21lbnRcbiAgICAgICAgaWYgKGJ1ZmZlckVuZCA8IHN0YXJ0KSB7XG4gICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIGZyYWcgPSB0aGlzLl9maW5kRnJhZ21lbnQoc3RhcnQsIGZyYWdQcmV2aW91cywgZnJhZ0xlbiwgZnJhZ21lbnRzLCBidWZmZXJFbmQsIGVuZCwgbGV2ZWxEZXRhaWxzKTtcbiAgICB9XG5cbiAgICBpZiAoZnJhZykge1xuICAgICAgaWYgKGZyYWcuZW5jcnlwdGVkKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcga2V5IGZvciAke2ZyYWcuc259IG9mIFske2xldmVsRGV0YWlscy5zdGFydFNOfSAsJHtsZXZlbERldGFpbHMuZW5kU059XSxsZXZlbCAke2xldmVsfWApO1xuICAgICAgICB0aGlzLl9sb2FkS2V5KGZyYWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyAke2ZyYWcuc259IG9mIFske2xldmVsRGV0YWlscy5zdGFydFNOfSAsJHtsZXZlbERldGFpbHMuZW5kU059XSxsZXZlbCAke2xldmVsfSwgY3VycmVudFRpbWU6JHtwb3MudG9GaXhlZCgzKX0sYnVmZmVyRW5kOiR7YnVmZmVyRW5kLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgIHRoaXMuX2xvYWRGcmFnbWVudChmcmFnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZW5zdXJlRnJhZ21lbnRBdExpdmVQb2ludCAobGV2ZWxEZXRhaWxzLCBidWZmZXJFbmQsIHN0YXJ0LCBlbmQsIGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBmcmFnTGVuKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnLCBtZWRpYSA9IHRoaXMubWVkaWE7XG5cbiAgICBsZXQgZnJhZztcblxuICAgIC8vIGNoZWNrIGlmIHJlcXVlc3RlZCBwb3NpdGlvbiBpcyB3aXRoaW4gc2Vla2FibGUgYm91bmRhcmllcyA6XG4gICAgLy8gbG9nZ2VyLmxvZyhgc3RhcnQvcG9zL2J1ZkVuZC9zZWVraW5nOiR7c3RhcnQudG9GaXhlZCgzKX0vJHtwb3MudG9GaXhlZCgzKX0vJHtidWZmZXJFbmQudG9GaXhlZCgzKX0vJHt0aGlzLm1lZGlhLnNlZWtpbmd9YCk7XG4gICAgbGV0IG1heExhdGVuY3kgPSBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gOiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICogbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuXG4gICAgaWYgKGJ1ZmZlckVuZCA8IE1hdGgubWF4KHN0YXJ0IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGVuZCAtIG1heExhdGVuY3kpKSB7XG4gICAgICBsZXQgbGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMubGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzdGFydCwgbGV2ZWxEZXRhaWxzKTtcbiAgICAgIGxvZ2dlci5sb2coYGJ1ZmZlciBlbmQ6ICR7YnVmZmVyRW5kLnRvRml4ZWQoMyl9IGlzIGxvY2F0ZWQgdG9vIGZhciBmcm9tIHRoZSBlbmQgb2YgbGl2ZSBzbGlkaW5nIHBsYXlsaXN0LCByZXNldCBjdXJyZW50VGltZSB0byA6ICR7bGl2ZVN5bmNQb3NpdGlvbi50b0ZpeGVkKDMpfWApO1xuICAgICAgYnVmZmVyRW5kID0gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgIGlmIChtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlICYmIG1lZGlhLmR1cmF0aW9uID4gbGl2ZVN5bmNQb3NpdGlvbikge1xuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgfVxuXG4gICAgLy8gaWYgZW5kIG9mIGJ1ZmZlciBncmVhdGVyIHRoYW4gbGl2ZSBlZGdlLCBkb24ndCBsb2FkIGFueSBmcmFnbWVudFxuICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGlmIGxpdmUgcGxheWxpc3QgaW50ZXJtaXR0ZW50bHkgc2xpZGVzIGluIHRoZSBwYXN0LlxuICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjEsMTgyNTgwMTY3XVxuICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjIsMTgyNTgwMTY5XVxuICAgIC8vIExvYWRpbmcgMTgyNTgwMTY4IG9mIFsxODI1ODAxNjIgLDE4MjU4MDE2OV0sbGV2ZWwgMSAuLlxuICAgIC8vIExvYWRpbmcgMTgyNTgwMTY5IG9mIFsxODI1ODAxNjIgLDE4MjU4MDE2OV0sbGV2ZWwgMSAuLlxuICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjIsMTgyNTgwMTY4XSA8PT09PT09PT09PT09PSBoZXJlIHdlIHNob3VsZCBoYXZlIGJ1ZmZlckVuZCA+IGVuZC4gaW4gdGhhdCBjYXNlIGJyZWFrIHRvIGF2b2lkIHJlbG9hZGluZyAxODI1ODAxNjhcbiAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTY0LDE4MjU4MDE3MV1cbiAgICAvL1xuICAgIC8vIGRvbid0IHJldHVybiBudWxsIGluIGNhc2UgbWVkaWEgbm90IGxvYWRlZCB5ZXQgKHJlYWR5c3RhdGUgPT09IDApXG4gICAgaWYgKGxldmVsRGV0YWlscy5QVFNLbm93biAmJiBidWZmZXJFbmQgPiBlbmQgJiYgbWVkaWEgJiYgbWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkICYmICFsZXZlbERldGFpbHMuUFRTS25vd24pIHtcbiAgICAgIC8qIHdlIGFyZSBzd2l0Y2hpbmcgbGV2ZWwgb24gbGl2ZSBwbGF5bGlzdCwgYnV0IHdlIGRvbid0IGhhdmUgYW55IFBUUyBpbmZvIGZvciB0aGF0IHF1YWxpdHkgbGV2ZWwgLi4uXG4gICAgICAgICB0cnkgdG8gbG9hZCBmcmFnIG1hdGNoaW5nIHdpdGggbmV4dCBTTi5cbiAgICAgICAgIGV2ZW4gaWYgU04gYXJlIG5vdCBzeW5jaHJvbml6ZWQgYmV0d2VlbiBwbGF5bGlzdHMsIGxvYWRpbmcgdGhpcyBmcmFnIHdpbGwgaGVscCB1c1xuICAgICAgICAgY29tcHV0ZSBwbGF5bGlzdCBzbGlkaW5nIGFuZCBmaW5kIHRoZSByaWdodCBvbmUgYWZ0ZXIgaW4gY2FzZSBpdCB3YXMgbm90IHRoZSByaWdodCBjb25zZWN1dGl2ZSBvbmUgKi9cbiAgICAgIGlmIChmcmFnUHJldmlvdXMpIHtcbiAgICAgICAgaWYgKGxldmVsRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgICAvLyBSZWxpZXMgb24gUERUIGluIG9yZGVyIHRvIHN3aXRjaCBiaXRyYXRlcyAoU3VwcG9ydCBFWFQtWC1ESVNDT05USU5VSVRZIHdpdGhvdXQgRVhULVgtRElTQ09OVElOVUlUWS1TRVFVRU5DRSlcbiAgICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgUERUOiAke2ZyYWdQcmV2aW91cy5wcm9ncmFtRGF0ZVRpbWV9YCk7XG4gICAgICAgICAgZnJhZyA9IGZpbmRGcmFnbWVudEJ5UERUKGZyYWdtZW50cywgZnJhZ1ByZXZpb3VzLmVuZFByb2dyYW1EYXRlVGltZSwgY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFVzZXMgYnVmZmVyIGFuZCBzZXF1ZW5jZSBudW1iZXIgdG8gY2FsY3VsYXRlIHN3aXRjaCBzZWdtZW50IChyZXF1aXJlZCBpZiB1c2luZyBFWFQtWC1ESVNDT05USU5VSVRZLVNFUVVFTkNFKVxuICAgICAgICAgIGNvbnN0IHRhcmdldFNOID0gZnJhZ1ByZXZpb3VzLnNuICsgMTtcbiAgICAgICAgICBpZiAodGFyZ2V0U04gPj0gbGV2ZWxEZXRhaWxzLnN0YXJ0U04gJiYgdGFyZ2V0U04gPD0gbGV2ZWxEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgICBjb25zdCBmcmFnTmV4dCA9IGZyYWdtZW50c1t0YXJnZXRTTiAtIGxldmVsRGV0YWlscy5zdGFydFNOXTtcbiAgICAgICAgICAgIGlmIChmcmFnUHJldmlvdXMuY2MgPT09IGZyYWdOZXh0LmNjKSB7XG4gICAgICAgICAgICAgIGZyYWcgPSBmcmFnTmV4dDtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBuZXh0IFNOOiAke2ZyYWcuc259YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG5leHQgZnJhZyBTTiBub3QgYXZhaWxhYmxlIChvciBub3Qgd2l0aCBzYW1lIGNvbnRpbnVpdHkgY291bnRlcilcbiAgICAgICAgICAvLyBsb29rIGZvciBhIGZyYWcgc2hhcmluZyB0aGUgc2FtZSBDQ1xuICAgICAgICAgIGlmICghZnJhZykge1xuICAgICAgICAgICAgZnJhZyA9IEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCBmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICAgICAgICByZXR1cm4gZnJhZ1ByZXZpb3VzLmNjIC0gZnJhZy5jYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIENDOiAke2ZyYWcuc259YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgLyogd2UgaGF2ZSBubyBpZGVhIGFib3V0IHdoaWNoIGZyYWdtZW50IHNob3VsZCBiZSBsb2FkZWQuXG4gICAgICAgICAgIHNvIGxldCdzIGxvYWQgbWlkIGZyYWdtZW50LiBpdCB3aWxsIGhlbHAgY29tcHV0aW5nIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGZpbmQgdGhlIHJpZ2h0IG9uZVxuICAgICAgICAqL1xuICAgICAgICBmcmFnID0gZnJhZ21lbnRzW01hdGgubWluKGZyYWdMZW4gLSAxLCBNYXRoLnJvdW5kKGZyYWdMZW4gLyAyKSldO1xuICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIHVua25vd24sIGxvYWQgbWlkZGxlIGZyYWcgOiAke2ZyYWcuc259YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cblxuICBfZmluZEZyYWdtZW50IChzdGFydCwgZnJhZ1ByZXZpb3VzLCBmcmFnTGVuLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgZW5kLCBsZXZlbERldGFpbHMpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgbGV0IGZyYWc7XG5cbiAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XG4gICAgICBjb25zdCBsb29rdXBUb2xlcmFuY2UgPSAoYnVmZmVyRW5kID4gZW5kIC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UpID8gMCA6IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgLy8gUmVtb3ZlIHRoZSB0b2xlcmFuY2UgaWYgaXQgd291bGQgcHV0IHRoZSBidWZmZXJFbmQgcGFzdCB0aGUgYWN0dWFsIGVuZCBvZiBzdHJlYW1cbiAgICAgIC8vIFVzZXMgYnVmZmVyIGFuZCBzZXF1ZW5jZSBudW1iZXIgdG8gY2FsY3VsYXRlIHN3aXRjaCBzZWdtZW50IChyZXF1aXJlZCBpZiB1c2luZyBFWFQtWC1ESVNDT05USU5VSVRZLVNFUVVFTkNFKVxuICAgICAgZnJhZyA9IGZpbmRGcmFnbWVudEJ5UFRTKGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBidWZmZXJFbmQsIGxvb2t1cFRvbGVyYW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlYWNoIGVuZCBvZiBwbGF5bGlzdFxuICAgICAgZnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV07XG4gICAgfVxuICAgIGlmIChmcmFnKSB7XG4gICAgICBjb25zdCBjdXJTTklkeCA9IGZyYWcuc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcbiAgICAgIGNvbnN0IHNhbWVMZXZlbCA9IGZyYWdQcmV2aW91cyAmJiBmcmFnLmxldmVscyA9PT0gZnJhZ1ByZXZpb3VzLmxldmVscztcbiAgICAgIGNvbnN0IHByZXZGcmFnID0gZnJhZ21lbnRzW2N1clNOSWR4IC0gMV07XG4gICAgICBjb25zdCBuZXh0RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCArIDFdO1xuICAgICAgLy8gbG9nZ2VyLmxvZygnZmluZCBTTiBtYXRjaGluZyB3aXRoIHBvczonICsgIGJ1ZmZlckVuZCArICc6JyArIGZyYWcuc24pO1xuICAgICAgaWYgKGZyYWdQcmV2aW91cyAmJiBmcmFnLnNuID09PSBmcmFnUHJldmlvdXMuc24pIHtcbiAgICAgICAgaWYgKHNhbWVMZXZlbCAmJiAhZnJhZy5iYWNrdHJhY2tlZCkge1xuICAgICAgICAgIGlmIChmcmFnLnNuIDwgbGV2ZWxEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgICBsZXQgZGVsdGFQVFMgPSBmcmFnUHJldmlvdXMuZGVsdGFQVFM7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNpZ25pZmljYW50IGRlbHRhIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCBsYXJnZXIgdGhhbiBtYXggYWxsb3dlZCBob2xlLFxuICAgICAgICAgICAgLy8gYW5kIGlmIHByZXZpb3VzIHJlbXV4ZWQgZnJhZ21lbnQgZGlkIG5vdCBzdGFydCB3aXRoIGEga2V5ZnJhbWUuIChmcmFnUHJldmlvdXMuZHJvcHBlZClcbiAgICAgICAgICAgIC8vIGxldCdzIHRyeSB0byBsb2FkIHByZXZpb3VzIGZyYWdtZW50IGFnYWluIHRvIGdldCBsYXN0IGtleWZyYW1lXG4gICAgICAgICAgICAvLyB0aGVuIHdlIHdpbGwgcmVsb2FkIGFnYWluIGN1cnJlbnQgZnJhZ21lbnQgKHRoYXQgd2F5IHdlIHNob3VsZCBiZSBhYmxlIHRvIGZpbGwgdGhlIGJ1ZmZlciBob2xlIC4uLilcbiAgICAgICAgICAgIGlmIChkZWx0YVBUUyAmJiBkZWx0YVBUUyA+IGNvbmZpZy5tYXhCdWZmZXJIb2xlICYmIGZyYWdQcmV2aW91cy5kcm9wcGVkICYmIGN1clNOSWR4KSB7XG4gICAgICAgICAgICAgIGZyYWcgPSBwcmV2RnJhZztcbiAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ1NOIGp1c3QgbG9hZGVkLCB3aXRoIGxhcmdlIFBUUyBnYXAgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW8sIG1heWJlIGZyYWcgaXMgbm90IHN0YXJ0aW5nIHdpdGggYSBrZXlmcmFtZSA/IGxvYWQgcHJldmlvdXMgb25lIHRvIHRyeSB0byBvdmVyY29tZSB0aGlzJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmcmFnID0gbmV4dEZyYWc7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYFNOIGp1c3QgbG9hZGVkLCBsb2FkIG5leHQgb25lOiAke2ZyYWcuc259YCwgZnJhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmcmFnLmJhY2t0cmFja2VkKSB7XG4gICAgICAgICAgLy8gT25seSBiYWNrdHJhY2sgYSBtYXggb2YgMSBjb25zZWN1dGl2ZSBmcmFnbWVudCB0byBwcmV2ZW50IHNsaWRpbmcgYmFjayB0b28gZmFyIHdoZW4gbGl0dGxlIG9yIG5vIGZyYWdzIHN0YXJ0IHdpdGgga2V5ZnJhbWVzXG4gICAgICAgICAgaWYgKG5leHRGcmFnICYmIG5leHRGcmFnLmJhY2t0cmFja2VkKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgQWxyZWFkeSBiYWNrdHJhY2tlZCBmcm9tIGZyYWdtZW50ICR7bmV4dEZyYWcuc259LCB3aWxsIG5vdCBiYWNrdHJhY2sgdG8gZnJhZ21lbnQgJHtmcmFnLnNufS4gTG9hZGluZyBmcmFnbWVudCAke25leHRGcmFnLnNufWApO1xuICAgICAgICAgICAgZnJhZyA9IG5leHRGcmFnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBhIGZyYWdtZW50IGhhcyBkcm9wcGVkIGZyYW1lcyBhbmQgaXQncyBpbiBhIHNhbWUgbGV2ZWwvc2VxdWVuY2UsIGxvYWQgdGhlIHByZXZpb3VzIGZyYWdtZW50IHRvIHRyeSBhbmQgZmluZCB0aGUga2V5ZnJhbWVcbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBkcm9wcGVkIGNvdW50IG5vdyBzaW5jZSBpdCB3b24ndCBiZSByZXNldCB1bnRpbCB3ZSBwYXJzZSB0aGUgZnJhZ21lbnQgYWdhaW4sIHdoaWNoIHByZXZlbnRzIGluZmluaXRlIGJhY2t0cmFja2luZyBvbiB0aGUgc2FtZSBzZWdtZW50XG4gICAgICAgICAgICBsb2dnZXIud2FybignTG9hZGVkIGZyYWdtZW50IHdpdGggZHJvcHBlZCBmcmFtZXMsIGJhY2t0cmFja2luZyAxIHNlZ21lbnQgdG8gZmluZCBhIGtleWZyYW1lJyk7XG4gICAgICAgICAgICBmcmFnLmRyb3BwZWQgPSAwO1xuICAgICAgICAgICAgaWYgKHByZXZGcmFnKSB7XG4gICAgICAgICAgICAgIGZyYWcgPSBwcmV2RnJhZztcbiAgICAgICAgICAgICAgZnJhZy5iYWNrdHJhY2tlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1clNOSWR4KSB7XG4gICAgICAgICAgICAgIC8vIGNhbid0IGJhY2t0cmFjayBvbiB2ZXJ5IGZpcnN0IGZyYWdtZW50XG4gICAgICAgICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuXG4gIF9sb2FkS2V5IChmcmFnKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLktFWV9MT0FESU5HO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuS0VZX0xPQURJTkcsIHsgZnJhZyB9KTtcbiAgfVxuXG4gIF9sb2FkRnJhZ21lbnQgKGZyYWcpIHtcbiAgICAvLyBDaGVjayBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgbGV0IGZyYWdTdGF0ZSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuXG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIC8vIERvbid0IHVwZGF0ZSBuZXh0TG9hZFBvc2l0aW9uIGZvciBmcmFnbWVudHMgd2hpY2ggYXJlIG5vdCBidWZmZXJlZFxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZnJhZy5zbikgJiYgIWZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIC8vIEFsbG93IGJhY2t0cmFja2VkIGZyYWdtZW50cyB0byBsb2FkXG4gICAgaWYgKGZyYWcuYmFja3RyYWNrZWQgfHwgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQgfHwgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwpIHtcbiAgICAgIGZyYWcuYXV0b0xldmVsID0gdGhpcy5obHMuYXV0b0xldmVsRW5hYmxlZDtcbiAgICAgIGZyYWcuYml0cmF0ZVRlc3QgPSB0aGlzLmJpdHJhdGVUZXN0O1xuXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRElORywgeyBmcmFnIH0pO1xuICAgICAgLy8gbGF6eSBkZW11eGVyIGluaXQsIGFzIHRoaXMgY291bGQgdGFrZSBzb21lIHRpbWUgLi4uIGRvIGl0IGR1cmluZyBmcmFnIGxvYWRpbmdcbiAgICAgIGlmICghdGhpcy5kZW11eGVyKSB7XG4gICAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVyKHRoaXMuaGxzLCAnbWFpbicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgIH0gZWxzZSBpZiAoZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLkFQUEVORElORykge1xuICAgICAgLy8gTG93ZXIgdGhlIGJ1ZmZlciBzaXplIGFuZCB0cnkgYWdhaW5cbiAgICAgIGlmICh0aGlzLl9yZWR1Y2VNYXhCdWZmZXJMZW5ndGgoZnJhZy5kdXJhdGlvbikpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0IHN0YXRlIChuZXh0U3RhdGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHRoaXMuX3N0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgbG9nZ2VyLmxvZyhgbWFpbiBzdHJlYW06JHtwcmV2aW91c1N0YXRlfS0+JHtuZXh0U3RhdGV9YCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNUUkVBTV9TVEFURV9UUkFOU0lUSU9OLCB7IHByZXZpb3VzU3RhdGUsIG5leHRTdGF0ZSB9KTtcbiAgICB9XG4gIH1cblxuICBnZXQgc3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIGdldEJ1ZmZlcmVkRnJhZyAocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QnVmZmVyZWRGcmFnKHBvc2l0aW9uLCBQbGF5bGlzdExvYWRlci5MZXZlbFR5cGUuTUFJTik7XG4gIH1cblxuICBnZXQgY3VycmVudExldmVsICgpIHtcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgY29uc3QgZnJhZyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIHJldHVybiBmcmFnLmxldmVscztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZ2V0IG5leHRCdWZmZXJlZEZyYWcgKCkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAvLyBmaXJzdCBnZXQgZW5kIHJhbmdlIG9mIGN1cnJlbnQgZnJhZ21lbnRcbiAgICAgIHJldHVybiB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyh0aGlzLmdldEJ1ZmZlcmVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmb2xsb3dpbmdCdWZmZXJlZEZyYWcgKGZyYWcpIHtcbiAgICBpZiAoZnJhZykge1xuICAgICAgLy8gdHJ5IHRvIGdldCByYW5nZSBvZiBuZXh0IGZyYWdtZW50ICg1MDBtcyBhZnRlciB0aGlzIHJhbmdlKVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyZWRGcmFnKGZyYWcuZW5kUFRTICsgMC41KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXQgbmV4dExldmVsICgpIHtcbiAgICBjb25zdCBmcmFnID0gdGhpcy5uZXh0QnVmZmVyZWRGcmFnO1xuICAgIGlmIChmcmFnKSB7XG4gICAgICByZXR1cm4gZnJhZy5sZXZlbHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICBfY2hlY2tGcmFnbWVudENoYW5nZWQgKCkge1xuICAgIGxldCBmcmFnUGxheWluZ0N1cnJlbnQsIGN1cnJlbnRUaW1lLCB2aWRlbyA9IHRoaXMubWVkaWE7XG4gICAgaWYgKHZpZGVvICYmIHZpZGVvLnJlYWR5U3RhdGUgJiYgdmlkZW8uc2Vla2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIGN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG4gICAgICAvKiBpZiB2aWRlbyBlbGVtZW50IGlzIGluIHNlZWtlZCBzdGF0ZSwgY3VycmVudFRpbWUgY2FuIG9ubHkgaW5jcmVhc2UuXG4gICAgICAgIChhc3N1bWluZyB0aGF0IHBsYXliYWNrIHJhdGUgaXMgcG9zaXRpdmUgLi4uKVxuICAgICAgICBBcyBzb21ldGltZXMgY3VycmVudFRpbWUganVtcHMgYmFjayB0byB6ZXJvIGFmdGVyIGFcbiAgICAgICAgbWVkaWEgZGVjb2RlIGVycm9yLCBjaGVjayB0aGlzLCB0byBhdm9pZCBzZWVraW5nIGJhY2sgdG9cbiAgICAgICAgd3JvbmcgcG9zaXRpb24gYWZ0ZXIgYSBtZWRpYSBkZWNvZGUgZXJyb3JcbiAgICAgICovXG4gICAgICBpZiAoY3VycmVudFRpbWUgPiB0aGlzLmxhc3RDdXJyZW50VGltZSkge1xuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW8sIGN1cnJlbnRUaW1lKSkge1xuICAgICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhjdXJyZW50VGltZSk7XG4gICAgICB9IGVsc2UgaWYgKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvLCBjdXJyZW50VGltZSArIDAuMSkpIHtcbiAgICAgICAgLyogZW5zdXJlIHRoYXQgRlJBR19DSEFOR0VEIGV2ZW50IGlzIHRyaWdnZXJlZCBhdCBzdGFydHVwLFxuICAgICAgICAgIHdoZW4gZmlyc3QgdmlkZW8gZnJhbWUgaXMgZGlzcGxheWVkIGFuZCBwbGF5YmFjayBpcyBwYXVzZWQuXG4gICAgICAgICAgYWRkIGEgdG9sZXJhbmNlIG9mIDEwMG1zLCBpbiBjYXNlIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLFxuICAgICAgICAgIGNoZWNrIGlmIGN1cnJlbnQgcG9zKzEwMG1zIGlzIGJ1ZmZlcmVkIGFuZCB1c2UgdGhhdCBidWZmZXIgcmFuZ2VcbiAgICAgICAgICBmb3IgRlJBR19DSEFOR0VEIGV2ZW50IHJlcG9ydGluZyAqL1xuICAgICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhjdXJyZW50VGltZSArIDAuMSk7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50KSB7XG4gICAgICAgIGxldCBmcmFnUGxheWluZyA9IGZyYWdQbGF5aW5nQ3VycmVudDtcbiAgICAgICAgaWYgKGZyYWdQbGF5aW5nICE9PSB0aGlzLmZyYWdQbGF5aW5nKSB7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0NIQU5HRUQsIHsgZnJhZzogZnJhZ1BsYXlpbmcgfSk7XG4gICAgICAgICAgY29uc3QgZnJhZ1BsYXlpbmdMZXZlbCA9IGZyYWdQbGF5aW5nLmxldmVscztcbiAgICAgICAgICBpZiAoIXRoaXMuZnJhZ1BsYXlpbmcgfHwgdGhpcy5mcmFnUGxheWluZy5sZXZlbHMgIT09IGZyYWdQbGF5aW5nTGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfU1dJVENIRUQsIHsgbGV2ZWw6IGZyYWdQbGF5aW5nTGV2ZWwgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5mcmFnUGxheWluZyA9IGZyYWdQbGF5aW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICBvbiBpbW1lZGlhdGUgbGV2ZWwgc3dpdGNoIDpcbiAgICAgLSBwYXVzZSBwbGF5YmFjayBpZiBwbGF5aW5nXG4gICAgIC0gY2FuY2VsIGFueSBwZW5kaW5nIGxvYWQgcmVxdWVzdFxuICAgICAtIGFuZCB0cmlnZ2VyIGEgYnVmZmVyIGZsdXNoXG4gICovXG4gIGltbWVkaWF0ZUxldmVsU3dpdGNoICgpIHtcbiAgICBsb2dnZXIubG9nKCdpbW1lZGlhdGVMZXZlbFN3aXRjaCcpO1xuICAgIGlmICghdGhpcy5pbW1lZGlhdGVTd2l0Y2gpIHtcbiAgICAgIHRoaXMuaW1tZWRpYXRlU3dpdGNoID0gdHJ1ZTtcbiAgICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWEsIHByZXZpb3VzbHlQYXVzZWQ7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgcHJldmlvdXNseVBhdXNlZCA9IG1lZGlhLnBhdXNlZDtcbiAgICAgICAgbWVkaWEucGF1c2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvbid0IHJlc3RhcnQgcGxheWJhY2sgYWZ0ZXIgaW5zdGFudCBsZXZlbCBzd2l0Y2ggaW4gY2FzZSBtZWRpYSBub3QgYXR0YWNoZWRcbiAgICAgICAgcHJldmlvdXNseVBhdXNlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnByZXZpb3VzbHlQYXVzZWQgPSBwcmV2aW91c2x5UGF1c2VkO1xuICAgIH1cbiAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmIChmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIC8vIGZsdXNoIGV2ZXJ5dGhpbmdcbiAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICB9XG5cbiAgLyoqXG4gICAqIG9uIGltbWVkaWF0ZSBsZXZlbCBzd2l0Y2ggZW5kLCBhZnRlciBuZXcgZnJhZ21lbnQgaGFzIGJlZW4gYnVmZmVyZWQ6XG4gICAqIC0gbnVkZ2UgdmlkZW8gZGVjb2RlciBieSBzbGlnaHRseSBhZGp1c3RpbmcgdmlkZW8gY3VycmVudFRpbWUgKGlmIGN1cnJlbnRUaW1lIGJ1ZmZlcmVkKVxuICAgKiAtIHJlc3VtZSB0aGUgcGxheWJhY2sgaWYgbmVlZGVkXG4gICAqL1xuICBpbW1lZGlhdGVMZXZlbFN3aXRjaEVuZCAoKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSAmJiBtZWRpYS5idWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuaW1tZWRpYXRlU3dpdGNoID0gZmFsc2U7XG4gICAgICBpZiAoQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsIG1lZGlhLmN1cnJlbnRUaW1lKSkge1xuICAgICAgICAvLyBvbmx5IG51ZGdlIGlmIGN1cnJlbnRUaW1lIGlzIGJ1ZmZlcmVkXG4gICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lIC09IDAuMDAwMTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5wcmV2aW91c2x5UGF1c2VkKSB7XG4gICAgICAgIG1lZGlhLnBsYXkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogdHJ5IHRvIHN3aXRjaCBBU0FQIHdpdGhvdXQgYnJlYWtpbmcgdmlkZW8gcGxheWJhY2s6XG4gICAqIGluIG9yZGVyIHRvIGVuc3VyZSBzbW9vdGggYnV0IHF1aWNrIGxldmVsIHN3aXRjaGluZyxcbiAgICogd2UgbmVlZCB0byBmaW5kIHRoZSBuZXh0IGZsdXNoYWJsZSBidWZmZXIgcmFuZ2VcbiAgICogd2Ugc2hvdWxkIHRha2UgaW50byBhY2NvdW50IG5ldyBzZWdtZW50IGZldGNoIHRpbWVcbiAgICovXG4gIG5leHRMZXZlbFN3aXRjaCAoKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIC8vIGVuc3VyZSB0aGF0IG1lZGlhIGlzIGRlZmluZWQgYW5kIHRoYXQgbWV0YWRhdGEgYXJlIGF2YWlsYWJsZSAodG8gcmV0cmlldmUgY3VycmVudFRpbWUpXG4gICAgaWYgKG1lZGlhICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgIGxldCBmZXRjaGRlbGF5LCBmcmFnUGxheWluZ0N1cnJlbnQsIG5leHRCdWZmZXJlZEZyYWc7XG4gICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSk7XG4gICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50ICYmIGZyYWdQbGF5aW5nQ3VycmVudC5zdGFydFBUUyA+IDEpIHtcbiAgICAgICAgLy8gZmx1c2ggYnVmZmVyIHByZWNlZGluZyBjdXJyZW50IGZyYWdtZW50IChmbHVzaCB1bnRpbCBjdXJyZW50IGZyYWdtZW50IHN0YXJ0IG9mZnNldClcbiAgICAgICAgLy8gbWludXMgMXMgdG8gYXZvaWQgdmlkZW8gZnJlZXppbmcsIHRoYXQgY291bGQgaGFwcGVuIGlmIHdlIGZsdXNoIGtleWZyYW1lIG9mIGN1cnJlbnQgdmlkZW8gLi4uXG4gICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIGZyYWdQbGF5aW5nQ3VycmVudC5zdGFydFBUUyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKCFtZWRpYS5wYXVzZWQpIHtcbiAgICAgICAgLy8gYWRkIGEgc2FmZXR5IGRlbGF5IG9mIDFzXG4gICAgICAgIGxldCBuZXh0TGV2ZWxJZCA9IHRoaXMuaGxzLm5leHRMb2FkTGV2ZWwsIG5leHRMZXZlbCA9IHRoaXMubGV2ZWxzW25leHRMZXZlbElkXSwgZnJhZ0xhc3RLYnBzID0gdGhpcy5mcmFnTGFzdEticHM7XG4gICAgICAgIGlmIChmcmFnTGFzdEticHMgJiYgdGhpcy5mcmFnQ3VycmVudCkge1xuICAgICAgICAgIGZldGNoZGVsYXkgPSB0aGlzLmZyYWdDdXJyZW50LmR1cmF0aW9uICogbmV4dExldmVsLmJpdHJhdGUgLyAoMTAwMCAqIGZyYWdMYXN0S2JwcykgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIGxvZ2dlci5sb2coJ2ZldGNoZGVsYXk6JytmZXRjaGRlbGF5KTtcbiAgICAgIC8vIGZpbmQgYnVmZmVyIHJhbmdlIHRoYXQgd2lsbCBiZSByZWFjaGVkIG9uY2UgbmV3IGZyYWdtZW50IHdpbGwgYmUgZmV0Y2hlZFxuICAgICAgbmV4dEJ1ZmZlcmVkRnJhZyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lICsgZmV0Y2hkZWxheSk7XG4gICAgICBpZiAobmV4dEJ1ZmZlcmVkRnJhZykge1xuICAgICAgICAvLyB3ZSBjYW4gZmx1c2ggYnVmZmVyIHJhbmdlIGZvbGxvd2luZyB0aGlzIG9uZSB3aXRob3V0IHN0YWxsaW5nIHBsYXliYWNrXG4gICAgICAgIG5leHRCdWZmZXJlZEZyYWcgPSB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhuZXh0QnVmZmVyZWRGcmFnKTtcbiAgICAgICAgaWYgKG5leHRCdWZmZXJlZEZyYWcpIHtcbiAgICAgICAgICAvLyBpZiB3ZSBhcmUgaGVyZSwgd2UgY2FuIGFsc28gY2FuY2VsIGFueSBsb2FkaW5nL2RlbXV4aW5nIGluIHByb2dyZXNzLCBhcyB0aGV5IGFyZSB1c2VsZXNzXG4gICAgICAgICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAvLyBzdGFydCBmbHVzaCBwb3NpdGlvbiBpcyB0aGUgc3RhcnQgUFRTIG9mIG5leHQgYnVmZmVyZWQgZnJhZy5cbiAgICAgICAgICAvLyB3ZSB1c2UgZnJhZy5uYXhTdGFydFBUUyB3aGljaCBpcyBtYXgoYXVkaW8gc3RhcnRQVFMsIHZpZGVvIHN0YXJ0UFRTKS5cbiAgICAgICAgICAvLyBpbiBjYXNlIHRoZXJlIGlzIGEgc21hbGwgUFRTIERlbHRhIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCB1c2luZyBtYXhTdGFydFBUUyBhdm9pZHMgZmx1c2hpbmcgbGFzdCBzYW1wbGVzIGZyb20gY3VycmVudCBmcmFnbWVudFxuICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKG5leHRCdWZmZXJlZEZyYWcubWF4U3RhcnRQVFMsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmbHVzaE1haW5CdWZmZXIgKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuQlVGRkVSX0ZMVVNISU5HO1xuICAgIGxldCBmbHVzaFNjb3BlID0geyBzdGFydE9mZnNldDogc3RhcnRPZmZzZXQsIGVuZE9mZnNldDogZW5kT2Zmc2V0IH07XG4gICAgLy8gaWYgYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrcyBhcmUgdXNlZCwgb25seSBmbHVzaCB2aWRlbywgb3RoZXJ3aXNlIGZsdXNoIGV2ZXJ5dGhpbmdcbiAgICBpZiAodGhpcy5hbHRBdWRpbykge1xuICAgICAgZmx1c2hTY29wZS50eXBlID0gJ3ZpZGVvJztcbiAgICB9XG5cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9GTFVTSElORywgZmx1c2hTY29wZSk7XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoZWQgKGRhdGEpIHtcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbk1lZGlhU2Vla2luZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub252c2Vla2VkID0gdGhpcy5vbk1lZGlhU2Vla2VkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbnZlbmRlZCA9IHRoaXMub25NZWRpYUVuZGVkLmJpbmQodGhpcyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmICh0aGlzLmxldmVscyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCkge1xuICAgICAgdGhpcy5obHMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICB0aGlzLmdhcENvbnRyb2xsZXIgPSBuZXcgR2FwQ29udHJvbGxlcihjb25maWcsIG1lZGlhLCB0aGlzLmZyYWdtZW50VHJhY2tlciwgdGhpcy5obHMpO1xuICB9XG5cbiAgb25NZWRpYURldGFjaGluZyAoKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEuZW5kZWQpIHtcbiAgICAgIGxvZ2dlci5sb2coJ01TRSBkZXRhY2hpbmcgYW5kIHZpZGVvIGVuZGVkLCByZXNldCBzdGFydFBvc2l0aW9uJyk7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gcmVzZXQgZnJhZ21lbnQgYmFja3RyYWNrZWQgZmxhZ1xuICAgIGxldCBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICBpZiAobGV2ZWxzKSB7XG4gICAgICBsZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICAgIGlmIChsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgICAgbGV2ZWwuZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmcmFnbWVudCA9PiB7XG4gICAgICAgICAgICBmcmFnbWVudC5iYWNrdHJhY2tlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252c2Vla2VkID0gdGhpcy5vbnZlbmRlZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICB9XG5cbiAgb25NZWRpYVNlZWtlZCAoKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhLCBjdXJyZW50VGltZSA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiB1bmRlZmluZWQ7XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShjdXJyZW50VGltZSkpIHtcbiAgICAgIGxvZ2dlci5sb2coYG1lZGlhIHNlZWtlZCB0byAke2N1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XG4gICAgfVxuXG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBGUkFHTUVOVF9QTEFZSU5HIHRyaWdnZXJpbmdcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uTWFuaWZlc3RMb2FkaW5nICgpIHtcbiAgICAvLyByZXNldCBidWZmZXIgb24gbWFuaWZlc3QgbG9hZGluZ1xuICAgIGxvZ2dlci5sb2coJ3RyaWdnZXIgQlVGRkVSX1JFU0VUJyk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfUkVTRVQpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIHRoaXMuc3RhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgfVxuXG4gIG9uTWFuaWZlc3RQYXJzZWQgKGRhdGEpIHtcbiAgICBsZXQgYWFjID0gZmFsc2UsIGhlYWFjID0gZmFsc2UsIGNvZGVjO1xuICAgIGRhdGEubGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgLy8gZGV0ZWN0IGlmIHdlIGhhdmUgZGlmZmVyZW50IGtpbmQgb2YgYXVkaW8gY29kZWNzIHVzZWQgYW1vbmdzdCBwbGF5bGlzdHNcbiAgICAgIGNvZGVjID0gbGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgIGlmIChjb2RlYykge1xuICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xKSB7XG4gICAgICAgICAgYWFjID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICBoZWFhYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2l0Y2ggPSAoYWFjICYmIGhlYWFjKTtcbiAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XG4gICAgICBsb2dnZXIubG9nKCdib3RoIEFBQy9IRS1BQUMgYXVkaW8gZm91bmQgaW4gbGV2ZWxzOyBkZWNsYXJpbmcgbGV2ZWwgY29kZWMgYXMgSEUtQUFDJyk7XG4gICAgfVxuXG4gICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoY29uZmlnLmF1dG9TdGFydExvYWQgfHwgdGhpcy5mb3JjZVN0YXJ0TG9hZCkge1xuICAgICAgdGhpcy5obHMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICBvbkxldmVsTG9hZGVkIChkYXRhKSB7XG4gICAgY29uc3QgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICBjb25zdCBuZXdMZXZlbElkID0gZGF0YS5sZXZlbHM7XG4gICAgY29uc3QgbGFzdExldmVsID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbExhc3RMb2FkZWRdO1xuICAgIGNvbnN0IGN1ckxldmVsID0gdGhpcy5sZXZlbHNbbmV3TGV2ZWxJZF07XG4gICAgY29uc3QgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgbGV0IHNsaWRpbmcgPSAwO1xuXG4gICAgbG9nZ2VyLmxvZyhgbGV2ZWwgJHtuZXdMZXZlbElkfSBsb2FkZWQgWyR7bmV3RGV0YWlscy5zdGFydFNOfSwke25ld0RldGFpbHMuZW5kU059XSxkdXJhdGlvbjoke2R1cmF0aW9ufWApO1xuXG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgbGV0IGN1ckRldGFpbHMgPSBjdXJMZXZlbC5kZXRhaWxzO1xuICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyB3ZSBhbHJlYWR5IGhhdmUgZGV0YWlscyBmb3IgdGhhdCBsZXZlbCwgbWVyZ2UgdGhlbVxuICAgICAgICBMZXZlbEhlbHBlci5tZXJnZURldGFpbHMoY3VyRGV0YWlscywgbmV3RGV0YWlscyk7XG4gICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgICAgdGhpcy5saXZlU3luY1Bvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIGN1ckRldGFpbHMpO1xuICAgICAgICBpZiAobmV3RGV0YWlscy5QVFNLbm93biAmJiBOdW1iZXIuaXNGaW5pdGUoc2xpZGluZykpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0IHNsaWRpbmc6JHtzbGlkaW5nLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnbGl2ZSBwbGF5bGlzdCAtIG91dGRhdGVkIFBUUywgdW5rbm93biBzbGlkaW5nJyk7XG4gICAgICAgICAgYWxpZ25TdHJlYW0odGhpcy5mcmFnUHJldmlvdXMsIGxhc3RMZXZlbCwgbmV3RGV0YWlscyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QgLSBmaXJzdCBsb2FkLCB1bmtub3duIHNsaWRpbmcnKTtcbiAgICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgICAgICBhbGlnblN0cmVhbSh0aGlzLmZyYWdQcmV2aW91cywgbGFzdExldmVsLCBuZXdEZXRhaWxzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBvdmVycmlkZSBsZXZlbCBpbmZvXG4gICAgY3VyTGV2ZWwuZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBuZXdMZXZlbElkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfVVBEQVRFRCwgeyBkZXRhaWxzOiBuZXdEZXRhaWxzLCBsZXZlbDogbmV3TGV2ZWxJZCB9KTtcblxuICAgIGlmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9PT0gZmFsc2UpIHtcbiAgICAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uIGlmIHNldCB0byAtMS4gdXNlIGl0IHN0cmFpZ2h0IGF3YXkgaWYgdmFsdWUgaXMgZGVmaW5lZFxuICAgICAgaWYgKHRoaXMuc3RhcnRQb3NpdGlvbiA9PT0gLTEgfHwgdGhpcy5sYXN0Q3VycmVudFRpbWUgPT09IC0xKSB7XG4gICAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcbiAgICAgICAgbGV0IHN0YXJ0VGltZU9mZnNldCA9IG5ld0RldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgICBpZiAoc3RhcnRUaW1lT2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgbmVnYXRpdmUgc3RhcnQgdGltZSBvZmZzZXQgJHtzdGFydFRpbWVPZmZzZXR9LCBjb3VudCBmcm9tIGVuZCBvZiBsYXN0IGZyYWdtZW50YCk7XG4gICAgICAgICAgICBzdGFydFRpbWVPZmZzZXQgPSBzbGlkaW5nICsgZHVyYXRpb24gKyBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci5sb2coYHN0YXJ0IHRpbWUgb2Zmc2V0IGZvdW5kIGluIHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byAke3N0YXJ0VGltZU9mZnNldH1gKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCwgc2V0IHN0YXJ0IHBvc2l0aW9uIHRvIGJlIGZyYWdtZW50IE4tdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50ICh1c3VhbGx5IDMpXG4gICAgICAgICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIG5ld0RldGFpbHMpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgY29uZmlndXJlIHN0YXJ0UG9zaXRpb24gdG8gJHt0aGlzLnN0YXJ0UG9zaXRpb259YCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgICAvLyBvbmx5IHN3aXRjaCBiYXRjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgbGV2ZWwgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25LZXlMb2FkZWQgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5LRVlfTE9BRElORykge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdMb2FkZWQgKGRhdGEpIHtcbiAgICBjb25zdCB7IGZyYWdDdXJyZW50LCBobHMsIGxldmVscywgbWVkaWEgfSA9IHRoaXM7XG4gICAgY29uc3QgZnJhZ0xvYWRlZCA9IGRhdGEuZnJhZztcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HICYmXG4gICAgICAgIGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGZyYWdMb2FkZWQudHlwZSA9PT0gJ21haW4nICYmXG4gICAgICAgIGZyYWdMb2FkZWQubGV2ZWxzID09PSBmcmFnQ3VycmVudC5sZXZlbHMgJiZcbiAgICAgICAgZnJhZ0xvYWRlZC5zbiA9PT0gZnJhZ0N1cnJlbnQuc24pIHtcbiAgICAgIGNvbnN0IHN0YXRzID0gZGF0YS5zdGF0cztcbiAgICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IGxldmVsc1tmcmFnQ3VycmVudC5sZXZlbHNdO1xuICAgICAgY29uc3QgZGV0YWlscyA9IGN1cnJlbnRMZXZlbC5kZXRhaWxzO1xuICAgICAgLy8gcmVzZXQgZnJhZyBiaXRyYXRlIHRlc3QgaW4gYW55IGNhc2UgYWZ0ZXIgZnJhZyBsb2FkZWQgZXZlbnRcbiAgICAgIC8vIGlmIHRoaXMgZnJhZyB3YXMgbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3QgQU5EIGlmIGhscy5uZXh0TG9hZExldmVsIGlzIGdyZWF0ZXIgdGhhbiAwXG4gICAgICAvLyB0aGVuIHRoaXMgbWVhbnMgdGhhdCB3ZSBzaG91bGQgYmUgYWJsZSB0byBsb2FkIGEgZnJhZ21lbnQgYXQgYSBoaWdoZXIgcXVhbGl0eSBsZXZlbFxuICAgICAgdGhpcy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGF0cyA9IHN0YXRzO1xuXG4gICAgICBsb2dnZXIubG9nKGBMb2FkZWQgJHtmcmFnQ3VycmVudC5zbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtmcmFnQ3VycmVudC5sZXZlbHN9YCk7XG4gICAgICBpZiAoZnJhZ0xvYWRlZC5iaXRyYXRlVGVzdCAmJiBobHMubmV4dExvYWRMZXZlbCkge1xuICAgICAgICAvLyBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIC4uLiB3ZSBqdXN0IGxvYWRlZCBhIGZyYWdtZW50IHRvIGRldGVybWluZSBhZGVxdWF0ZSBzdGFydCBiaXRyYXRlIGFuZCBpbml0aWFsaXplIGF1dG9zd2l0Y2ggYWxnb1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19CVUZGRVJFRCwgeyBzdGF0czogc3RhdHMsIGZyYWc6IGZyYWdDdXJyZW50LCBpZDogJ21haW4nIH0pO1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH0gZWxzZSBpZiAoZnJhZ0xvYWRlZC5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgZGV0YWlscy5pbml0U2VnbWVudC5kYXRhID0gZGF0YS5wYXlsb2FkO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7IHN0YXRzOiBzdGF0cywgZnJhZzogZnJhZ0N1cnJlbnQsIGlkOiAnbWFpbicgfSk7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgUGFyc2luZyAke2ZyYWdDdXJyZW50LnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSxsZXZlbCAke2ZyYWdDdXJyZW50LmxldmVsc30sIGNjICR7ZnJhZ0N1cnJlbnQuY2N9YCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTSU5HO1xuICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmFwcGVuZGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQml0cmF0ZSB0ZXN0IGZyYWdzIGFyZSBub3QgdXN1YWxseSBidWZmZXJlZCBzbyB0aGUgZnJhZ21lbnQgdHJhY2tlciBpZ25vcmVzIHRoZW0uIElmIEhscy5qcyBkZWNpZGVzIHRvIGJ1ZmZlclxuICAgICAgICAvLyBpdCAoYW5kIHRoZXJlZm9yZSBlbmRzIHVwIGF0IHRoaXMgbGluZSksIHRoZW4gdGhlIGZyYWdtZW50IHRyYWNrZXIgbmVlZHMgdG8gYmUgbWFudWFsbHkgaW5mb3JtZWQuXG4gICAgICAgIGlmIChmcmFnTG9hZGVkLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgICAgZnJhZ0xvYWRlZC5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLm9uRnJhZ0xvYWRlZCh7XG4gICAgICAgICAgICBmcmFnOiBmcmFnTG9hZGVkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSkgYW5kIGlmIG1lZGlhIGlzIG5vdCBzZWVraW5nICh0aGlzIGlzIHRvIG92ZXJjb21lIHBvdGVudGlhbCB0aW1lc3RhbXAgZHJpZnRzIGJldHdlZW4gcGxheWxpc3RzIGFuZCBmcmFnbWVudHMpXG4gICAgICAgIGNvbnN0IGFjY3VyYXRlVGltZU9mZnNldCA9ICEobWVkaWEgJiYgbWVkaWEuc2Vla2luZykgJiYgKGRldGFpbHMuUFRTS25vd24gfHwgIWRldGFpbHMubGl2ZSk7XG4gICAgICAgIGNvbnN0IGluaXRTZWdtZW50RGF0YSA9IGRldGFpbHMuaW5pdFNlZ21lbnQgPyBkZXRhaWxzLmluaXRTZWdtZW50LmRhdGEgOiBbXTtcbiAgICAgICAgY29uc3QgYXVkaW9Db2RlYyA9IHRoaXMuX2dldEF1ZGlvQ29kZWMoY3VycmVudExldmVsKTtcblxuICAgICAgICAvLyB0cmFuc211eCB0aGUgTVBFRy1UUyBkYXRhIHRvIElTTy1CTUZGIHNlZ21lbnRzXG4gICAgICAgIGNvbnN0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXIgfHwgbmV3IERlbXV4ZXIodGhpcy5obHMsICdtYWluJyk7XG4gICAgICAgIGRlbXV4ZXIucHVzaChcbiAgICAgICAgICBkYXRhLnBheWxvYWQsXG4gICAgICAgICAgaW5pdFNlZ21lbnREYXRhLFxuICAgICAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICAgICAgY3VycmVudExldmVsLnZpZGVvQ29kZWMsXG4gICAgICAgICAgZnJhZ0N1cnJlbnQsXG4gICAgICAgICAgZGV0YWlscy50b3RhbGR1cmF0aW9uLFxuICAgICAgICAgIGFjY3VyYXRlVGltZU9mZnNldFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICB9XG5cbiAgb25GcmFnUGFyc2luZ0luaXRTZWdtZW50IChkYXRhKSB7XG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XG5cbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ21haW4nICYmXG4gICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgIGZyYWdOZXcubGV2ZWxzID09PSBmcmFnQ3VycmVudC5sZXZlbHMgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgbGV0IHRyYWNrcyA9IGRhdGEudHJhY2tzLCB0cmFja05hbWUsIHRyYWNrO1xuXG4gICAgICAvLyBpZiBhdWRpbyB0cmFjayBpcyBleHBlY3RlZCB0byBjb21lIGZyb20gYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIsIGRpc2NhcmQgYW55IGNvbWluZyBmcm9tIG1haW5cbiAgICAgIGlmICh0cmFja3MuYXVkaW8gJiYgdGhpcy5hbHRBdWRpbykge1xuICAgICAgICBkZWxldGUgdHJhY2tzLmF1ZGlvO1xuICAgICAgfVxuXG4gICAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgICAgdHJhY2sgPSB0cmFja3MuYXVkaW87XG4gICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgbGV0IGF1ZGlvQ29kZWMgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXS5hdWRpb0NvZGVjLFxuICAgICAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoYXVkaW9Db2RlYyAmJiB0aGlzLmF1ZGlvQ29kZWNTd2FwKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnc3dhcHBpbmcgcGxheWxpc3QgYXVkaW8gY29kZWMnKTtcbiAgICAgICAgICBpZiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpbiBjYXNlIEFBQyBhbmQgSEUtQUFDIGF1ZGlvIGNvZGVjcyBhcmUgc2lnbmFsbGVkIGluIG1hbmlmZXN0XG4gICAgICAgIC8vIGZvcmNlIEhFLUFBQyAsIGFzIGl0IHNlZW1zIHRoYXQgbW9zdCBicm93c2VycyBwcmVmZXJzIHRoYXQgd2F5LFxuICAgICAgICAvLyBleGNlcHQgZm9yIG1vbm8gc3RyZWFtcyBPUiBvbiBGRlxuICAgICAgICAvLyB0aGVzZSBjb25kaXRpb25zIG1pZ2h0IG5lZWQgdG8gYmUgcmV2aWV3ZWQgLi4uXG4gICAgICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgbW9ubyBzdHJlYW1cbiAgICAgICAgICBpZiAodHJhY2subWV0YWRhdGEuY2hhbm5lbENvdW50ICE9PSAxICYmXG4gICAgICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgZmlyZWZveFxuICAgICAgICAgICAgdWEuaW5kZXhPZignZmlyZWZveCcpID09PSAtMSkge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIRS1BQUMgaXMgYnJva2VuIG9uIEFuZHJvaWQsIGFsd2F5cyBzaWduYWwgYXVkaW8gY29kZWMgYXMgQUFDIGV2ZW4gaWYgdmFyaWFudCBtYW5pZmVzdCBzdGF0ZXMgb3RoZXJ3aXNlXG4gICAgICAgIGlmICh1YS5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xICYmIHRyYWNrLmNvbnRhaW5lciAhPT0gJ2F1ZGlvL21wZWcnKSB7IC8vIEV4Y2x1ZGUgbXBlZyBhdWRpb1xuICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgICBsb2dnZXIubG9nKGBBbmRyb2lkOiBmb3JjZSBhdWRpbyBjb2RlYyB0byAke2F1ZGlvQ29kZWN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2subGV2ZWxDb2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICAgIHRyYWNrLmlkID0gZGF0YS5pZDtcbiAgICAgIH1cbiAgICAgIHRyYWNrID0gdHJhY2tzLnZpZGVvO1xuICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXS52aWRlb0NvZGVjO1xuICAgICAgICB0cmFjay5pZCA9IGRhdGEuaWQ7XG4gICAgICB9XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9DT0RFQ1MsIHRyYWNrcyk7XG4gICAgICAvLyBsb29wIHRocm91Z2ggdHJhY2tzIHRoYXQgYXJlIGdvaW5nIHRvIGJlIHByb3ZpZGVkIHRvIGJ1ZmZlckNvbnRyb2xsZXJcbiAgICAgIGZvciAodHJhY2tOYW1lIGluIHRyYWNrcykge1xuICAgICAgICB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICBsb2dnZXIubG9nKGBtYWluIHRyYWNrOiR7dHJhY2tOYW1lfSxjb250YWluZXI6JHt0cmFjay5jb250YWluZXJ9LGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske3RyYWNrLmxldmVsQ29kZWN9LyR7dHJhY2suY29kZWN9XWApO1xuICAgICAgICBsZXQgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICAgICAgaWYgKGluaXRTZWdtZW50KSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcbiAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywgeyB0eXBlOiB0cmFja05hbWUsIGRhdGE6IGluaXRTZWdtZW50LCBwYXJlbnQ6ICdtYWluJywgY29udGVudDogJ2luaXRTZWdtZW50JyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnUGFyc2luZ0RhdGEgKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgY29uc3QgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ21haW4nICYmXG4gICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgIGZyYWdOZXcubGV2ZWxzID09PSBmcmFnQ3VycmVudC5sZXZlbHMgJiZcbiAgICAgICAgIShkYXRhLnR5cGUgPT09ICdhdWRpbycgJiYgdGhpcy5hbHRBdWRpbykgJiYgLy8gZmlsdGVyIG91dCBtYWluIGF1ZGlvIGlmIGF1ZGlvIHRyYWNrIGlzIGxvYWRlZCB0aHJvdWdoIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIGxldCBsZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdLFxuICAgICAgICBmcmFnID0gZnJhZ0N1cnJlbnQ7XG4gICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShkYXRhLmVuZFBUUykpIHtcbiAgICAgICAgZGF0YS5lbmRQVFMgPSBkYXRhLnN0YXJ0UFRTICsgZnJhZ0N1cnJlbnQuZHVyYXRpb247XG4gICAgICAgIGRhdGEuZW5kRFRTID0gZGF0YS5zdGFydERUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5oYXNBdWRpbyA9PT0gdHJ1ZSkge1xuICAgICAgICBmcmFnLmFkZEVsZW1lbnRhcnlTdHJlYW0oRnJhZ21lbnQuRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuaGFzVmlkZW8gPT09IHRydWUpIHtcbiAgICAgICAgZnJhZy5hZGRFbGVtZW50YXJ5U3RyZWFtKEZyYWdtZW50LkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTyk7XG4gICAgICB9XG5cbiAgICAgIGxvZ2dlci5sb2coYFBhcnNlZCAke2RhdGEudHlwZX0sUFRTOlske2RhdGEuc3RhcnRQVFMudG9GaXhlZCgzKX0sJHtkYXRhLmVuZFBUUy50b0ZpeGVkKDMpfV0sRFRTOlske2RhdGEuc3RhcnREVFMudG9GaXhlZCgzKX0vJHtkYXRhLmVuZERUUy50b0ZpeGVkKDMpfV0sbmI6JHtkYXRhLm5ifSxkcm9wcGVkOiR7ZGF0YS5kcm9wcGVkIHx8IDB9YCk7XG5cbiAgICAgIC8vIERldGVjdCBnYXBzIGluIGEgZnJhZ21lbnQgIGFuZCB0cnkgdG8gZml4IGl0IGJ5IGZpbmRpbmcgYSBrZXlmcmFtZSBpbiB0aGUgcHJldmlvdXMgZnJhZ21lbnQgKHNlZSBfZmluZEZyYWdtZW50cylcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgZnJhZy5kcm9wcGVkID0gZGF0YS5kcm9wcGVkO1xuICAgICAgICBpZiAoZnJhZy5kcm9wcGVkKSB7XG4gICAgICAgICAgaWYgKCFmcmFnLmJhY2t0cmFja2VkKSB7XG4gICAgICAgICAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgICAgICAgICAgaWYgKGxldmVsRGV0YWlscyAmJiBmcmFnLnNuID09PSBsZXZlbERldGFpbHMuc3RhcnRTTikge1xuICAgICAgICAgICAgICBsb2dnZXIud2FybignbWlzc2luZyB2aWRlbyBmcmFtZShzKSBvbiBmaXJzdCBmcmFnLCBhcHBlbmRpbmcgd2l0aCBnYXAnLCBmcmFnLnNuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdtaXNzaW5nIHZpZGVvIGZyYW1lKHMpLCBiYWNrdHJhY2tpbmcgZnJhZ21lbnQnLCBmcmFnLnNuKTtcbiAgICAgICAgICAgICAgLy8gUmV0dXJuIGJhY2sgdG8gdGhlIElETEUgc3RhdGUgd2l0aG91dCBhcHBlbmRpbmcgdG8gYnVmZmVyXG4gICAgICAgICAgICAgIC8vIENhdXNlcyBmaW5kRnJhZ21lbnRzIHRvIGJhY2t0cmFjayBhIHNlZ21lbnQgYW5kIGZpbmQgdGhlIGtleWZyYW1lXG4gICAgICAgICAgICAgIC8vIEF1ZGlvIGZyYWdtZW50cyBhcnJpdmluZyBiZWZvcmUgdmlkZW8gc2V0cyB0aGUgbmV4dExvYWRQb3NpdGlvbiwgY2F1c2luZyBfZmluZEZyYWdtZW50cyB0byBza2lwIHRoZSBiYWNrdHJhY2tlZCBmcmFnbWVudFxuICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgICAgICAgICAgZnJhZy5iYWNrdHJhY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGRhdGEuc3RhcnRQVFM7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdBbHJlYWR5IGJhY2t0cmFja2VkIG9uIHRoaXMgZnJhZ21lbnQsIGFwcGVuZGluZyB3aXRoIHRoZSBnYXAnLCBmcmFnLnNuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT25seSByZXNldCB0aGUgYmFja3RyYWNrZWQgZmxhZyBpZiB3ZSd2ZSBsb2FkZWQgdGhlIGZyYWcgd2l0aG91dCBhbnkgZHJvcHBlZCBmcmFtZXNcbiAgICAgICAgICBmcmFnLmJhY2t0cmFja2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IGRyaWZ0ID0gTGV2ZWxIZWxwZXIudXBkYXRlRnJhZ1BUU0RUUyhsZXZlbC5kZXRhaWxzLCBmcmFnLCBkYXRhLnN0YXJ0UFRTLCBkYXRhLmVuZFBUUywgZGF0YS5zdGFydERUUywgZGF0YS5lbmREVFMpLFxuICAgICAgICBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX1BUU19VUERBVEVELCB7IGRldGFpbHM6IGxldmVsLmRldGFpbHMsIGxldmVsOiB0aGlzLmxldmVsLCBkcmlmdDogZHJpZnQsIHR5cGU6IGRhdGEudHlwZSwgc3RhcnQ6IGRhdGEuc3RhcnRQVFMsIGVuZDogZGF0YS5lbmRQVFMgfSk7XG4gICAgICAvLyBoYXMgcmVtdXhlciBkcm9wcGVkIHZpZGVvIGZyYW1lcyBsb2NhdGVkIGJlZm9yZSBmaXJzdCBrZXlmcmFtZSA/XG4gICAgICBbZGF0YS5kYXRhMSwgZGF0YS5kYXRhMl0uZm9yRWFjaChidWZmZXIgPT4ge1xuICAgICAgICAvLyBvbmx5IGFwcGVuZCBpbiBQQVJTSU5HIHN0YXRlIChyYXRpb25hbGUgaXMgdGhhdCBhbiBhcHBlbmRpbmcgZXJyb3IgY291bGQgaGFwcGVuIHN5bmNocm9ub3VzbHkgb24gZmlyc3Qgc2VnbWVudCBhcHBlbmRpbmcpXG4gICAgICAgIC8vIGluIHRoYXQgY2FzZSBpdCBpcyB1c2VsZXNzIHRvIGFwcGVuZCBmb2xsb3dpbmcgc2VnbWVudHNcbiAgICAgICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAvLyBhcm0gcGVuZGluZyBCdWZmZXJpbmcgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIGEgc2VnbWVudFxuICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywgeyB0eXBlOiBkYXRhLnR5cGUsIGRhdGE6IGJ1ZmZlciwgcGFyZW50OiAnbWFpbicsIGNvbnRlbnQ6ICdkYXRhJyB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdQYXJzZWQgKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgY29uc3QgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ21haW4nICYmXG4gICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgIGZyYWdOZXcubGV2ZWxzID09PSBmcmFnQ3VycmVudC5sZXZlbHMgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgdGhpcy5zdGF0cy50cGFyc2VkID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcbiAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICB9XG4gIH1cblxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcgKGRhdGEpIHtcbiAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgbGV0IGFsdEF1ZGlvID0gISFkYXRhLnVybCxcbiAgICAgIHRyYWNrSWQgPSBkYXRhLmlkO1xuICAgIC8vIGlmIHdlIHN3aXRjaCBvbiBtYWluIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggbWVkaWEuYnVmZmVyZWRcbiAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiB3ZSBzd2l0Y2ggdG8gYWx0IGF1ZGlvOiBhdWRpbyBzdHJlYW0gY29udHJvbGxlciBpcyBoYW5kbGluZyBpdC5cbiAgICAvLyB3ZSB3aWxsIGp1c3QgaGF2ZSB0byBjaGFuZ2UgYnVmZmVyIHNjaGVkdWxpbmcgb24gYXVkaW9UcmFja1N3aXRjaGVkXG4gICAgaWYgKCFhbHRBdWRpbykge1xuICAgICAgaWYgKHRoaXMubWVkaWFCdWZmZXIgIT09IHRoaXMubWVkaWEpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnc3dpdGNoaW5nIG9uIG1haW4gYXVkaW8sIHVzZSBtZWRpYS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnKTtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVmaWxsIGF1ZGlvIGJ1ZmZlciBmcm9tIG1haW46IGNhbmNlbCBhbnkgZnJhZyBsb2FkaW5nIHRvIHNwZWVkIHVwIGF1ZGlvIHN3aXRjaFxuICAgICAgICBpZiAoZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnc3dpdGNoaW5nIHRvIG1haW4gYXVkaW8gdHJhY2ssIGNhbmNlbCBtYWluIGZyYWdtZW50IGxvYWQnKTtcbiAgICAgICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgICAvLyBkZXN0cm95IGRlbXV4ZXIgdG8gZm9yY2UgaW5pdCBzZWdtZW50IGdlbmVyYXRpb24gKGZvbGxvd2luZyBhdWRpbyBzd2l0Y2gpXG4gICAgICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICBsZXQgaGxzID0gdGhpcy5obHM7XG4gICAgICAvLyBzd2l0Y2hpbmcgdG8gbWFpbiBhdWRpbywgZmx1c2ggYWxsIGF1ZGlvIGFuZCB0cmlnZ2VyIHRyYWNrIHN3aXRjaGVkXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hJTkcsIHsgc3RhcnRPZmZzZXQ6IDAsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0eXBlOiAnYXVkaW8nIH0pO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHsgaWQ6IHRyYWNrSWQgfSk7XG4gICAgICB0aGlzLmFsdEF1ZGlvID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgb25BdWRpb1RyYWNrU3dpdGNoZWQgKGRhdGEpIHtcbiAgICBsZXQgdHJhY2tJZCA9IGRhdGEuaWQsXG4gICAgICBhbHRBdWRpbyA9ICEhdGhpcy5obHMuYXVkaW9UcmFja3NbdHJhY2tJZF0udXJsO1xuICAgIGlmIChhbHRBdWRpbykge1xuICAgICAgbGV0IHZpZGVvQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlcjtcbiAgICAgIC8vIGlmIHdlIHN3aXRjaGVkIG9uIGFsdGVybmF0ZSBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIHZpZGVvIHNvdXJjZWJ1ZmZlciBidWZmZXJlZFxuICAgICAgaWYgKHZpZGVvQnVmZmVyICYmIHRoaXMubWVkaWFCdWZmZXIgIT09IHZpZGVvQnVmZmVyKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyBvbiBhbHRlcm5hdGUgYXVkaW8sIHVzZSB2aWRlby5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnKTtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHZpZGVvQnVmZmVyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFsdEF1ZGlvID0gYWx0QXVkaW87XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbkJ1ZmZlckNyZWF0ZWQgKGRhdGEpIHtcbiAgICBsZXQgdHJhY2tzID0gZGF0YS50cmFja3MsIG1lZGlhVHJhY2ssIG5hbWUsIGFsdGVybmF0ZSA9IGZhbHNlO1xuICAgIGZvciAobGV0IHR5cGUgaW4gdHJhY2tzKSB7XG4gICAgICBsZXQgdHJhY2sgPSB0cmFja3NbdHlwZV07XG4gICAgICBpZiAodHJhY2suaWQgPT09ICdtYWluJykge1xuICAgICAgICBuYW1lID0gdHlwZTtcbiAgICAgICAgbWVkaWFUcmFjayA9IHRyYWNrO1xuICAgICAgICAvLyBrZWVwIHZpZGVvIHNvdXJjZSBidWZmZXIgcmVmZXJlbmNlXG4gICAgICAgIGlmICh0eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IHRyYWNrc1t0eXBlXS5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsdGVybmF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhbHRlcm5hdGUgJiYgbWVkaWFUcmFjaykge1xuICAgICAgbG9nZ2VyLmxvZyhgYWx0ZXJuYXRlIHRyYWNrIGZvdW5kLCB1c2UgJHtuYW1lfS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmdgKTtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBtZWRpYVRyYWNrLmJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgfVxuICB9XG5cbiAgb25CdWZmZXJBcHBlbmRlZCAoZGF0YSkge1xuICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ21haW4nKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICBpZiAoc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcgfHwgc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkge1xuICAgICAgICAvLyBjaGVjayBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gYXBwZW5kZWRcbiAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gKGRhdGEucGVuZGluZyA+IDApO1xuICAgICAgICB0aGlzLl9jaGVja0FwcGVuZGVkUGFyc2VkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2NoZWNrQXBwZW5kZWRQYXJzZWQgKCkge1xuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEICYmICghdGhpcy5hcHBlbmRlZCB8fCAhdGhpcy5wZW5kaW5nQnVmZmVyaW5nKSkge1xuICAgICAgY29uc3QgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICBpZiAoZnJhZykge1xuICAgICAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgbWFpbiBidWZmZXJlZCA6ICR7VGltZVJhbmdlcy50b1N0cmluZyhtZWRpYS5idWZmZXJlZCl9YCk7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgICAgICBzdGF0cy50YnVmZmVyZWQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIC8vIHdlIHNob3VsZCBnZXQgcmlkIG9mIHRoaXMuZnJhZ0xhc3RLYnBzXG4gICAgICAgIHRoaXMuZnJhZ0xhc3RLYnBzID0gTWF0aC5yb3VuZCg4ICogc3RhdHMudG90YWwgLyAoc3RhdHMudGJ1ZmZlcmVkIC0gc3RhdHMudGZpcnN0KSk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19CVUZGRVJFRCwgeyBzdGF0czogc3RhdHMsIGZyYWc6IGZyYWcsIGlkOiAnbWFpbicgfSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25FcnJvciAoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnIHx8wqB0aGlzLmZyYWdDdXJyZW50O1xuICAgIC8vIGRvbid0IGhhbmRsZSBmcmFnIGVycm9yIG5vdCByZWxhdGVkIHRvIG1haW4gZnJhZ21lbnRcbiAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09ICdtYWluJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIDAuNSA6IHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIGVuZFxuICAgIGxldCBtZWRpYUJ1ZmZlcmVkID0gISF0aGlzLm1lZGlhICYmIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHRoaXMubWVkaWEsIHRoaXMubWVkaWEuY3VycmVudFRpbWUpICYmIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHRoaXMubWVkaWEsIHRoaXMubWVkaWEuY3VycmVudFRpbWUgKyAwLjUpO1xuXG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgIGlmICghZGF0YS5mYXRhbCkge1xuICAgICAgICAvLyBrZWVwIHJldHJ5aW5nIHVudGlsIHRoZSBsaW1pdCB3aWxsIGJlIHJlYWNoZWRcbiAgICAgICAgaWYgKCh0aGlzLmZyYWdMb2FkRXJyb3IgKyAxKSA8PSB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5KSB7XG4gICAgICAgICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0XG4gICAgICAgICAgbGV0IGRlbGF5ID0gTWF0aC5taW4oTWF0aC5wb3coMiwgdGhpcy5mcmFnTG9hZEVycm9yKSAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSwgdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQpO1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBtZWRpYUNvbnRyb2xsZXI6IGZyYWcgbG9hZGluZyBmYWlsZWQsIHJldHJ5IGluICR7ZGVsYXl9IG1zYCk7XG4gICAgICAgICAgdGhpcy5yZXRyeURhdGUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgKyBkZWxheTtcbiAgICAgICAgICAvLyByZXRyeSBsb2FkaW5nIHN0YXRlXG4gICAgICAgICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9uIGZpcnN0IGZyYWdcbiAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UsIHJlc2V0IHN0YXJ0RnJhZ1JlcXVlc3RlZCBmbGFnXG4gICAgICAgICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IrKztcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGBtZWRpYUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSByZWFjaGVzIG1heCByZXRyeSwgcmVkaXNwYXRjaCBhcyBmYXRhbCAuLi5gKTtcbiAgICAgICAgICAvLyBzd2l0Y2ggZXJyb3IgdG8gZmF0YWxcbiAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICAgICAgLy8gaWYgZmF0YWwgZXJyb3IsIHN0b3AgcHJvY2Vzc2luZ1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcbiAgICAgICAgICBsb2dnZXIud2Fybihgc3RyZWFtQ29udHJvbGxlcjogJHtkYXRhLmRldGFpbHN9LHN3aXRjaCB0byAke3RoaXMuc3RhdGV9IHN0YXRlIC4uLmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGluIGNhc2Ugb2Ygbm9uIGZhdGFsIGVycm9yIHdoaWxlIGxvYWRpbmcgbGV2ZWwsIGlmIGxldmVsIGNvbnRyb2xsZXIgaXMgbm90IHJldHJ5aW5nIHRvIGxvYWQgbGV2ZWwgLCBzd2l0Y2ggYmFjayB0byBJRExFXG4gICAgICAgICAgaWYgKCFkYXRhLmxldmVsUmV0cnkgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgIC8vIGlmIGluIGFwcGVuZGluZyBzdGF0ZVxuICAgICAgaWYgKGRhdGEucGFyZW50ID09PSAnbWFpbicgJiYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcgfHzCoHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkpIHtcbiAgICAgICAgLy8gcmVkdWNlIG1heCBidWYgbGVuIGlmIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWRcbiAgICAgICAgaWYgKG1lZGlhQnVmZmVyZWQpIHtcbiAgICAgICAgICB0aGlzLl9yZWR1Y2VNYXhCdWZmZXJMZW5ndGgodGhpcy5jb25maWcubWF4QnVmZmVyTGVuZ3RoKTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCwgYnV0IGJyb3dzZXIgaXMgc3RpbGwgY29tcGxhaW5pbmcgYWJvdXQgYnVmZmVyIGZ1bGwgZXJyb3JcbiAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgb24gSUUvRWRnZSwgcmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvcHVsbC83MDhcbiAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgZmx1c2ggdGhlIHdob2xlIGJ1ZmZlciB0byByZWNvdmVyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ2J1ZmZlciBmdWxsIGVycm9yIGFsc28gbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCBldmVyeXRoaW5nJyk7XG4gICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgLy8gZmx1c2ggZXZlcnl0aGluZ1xuICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBfcmVkdWNlTWF4QnVmZmVyTGVuZ3RoIChtaW5MZW5ndGgpIHtcbiAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggPj0gbWluTGVuZ3RoKSB7XG4gICAgICAvLyByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggYXMgaXQgbWlnaHQgYmUgdG9vIGhpZ2guIHdlIGRvIHRoaXMgdG8gYXZvaWQgbG9vcCBmbHVzaGluZyAuLi5cbiAgICAgIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggLz0gMjtcbiAgICAgIGxvZ2dlci53YXJuKGBtYWluOnJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCB0byAke2NvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGh9c2ApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIGhlYWx0aCBvZiB0aGUgYnVmZmVyIGFuZCBhdHRlbXB0cyB0byByZXNvbHZlIHBsYXliYWNrIHN0YWxscy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja0J1ZmZlciAoKSB7XG4gICAgY29uc3QgeyBtZWRpYSB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhIHx8IG1lZGlhLnJlYWR5U3RhdGUgPT09IDApIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBtZWRpYSBvciBpZiB0aGUgbWVkaWEgaGFzbid0IGJ1ZmZlcmQgYW55dGhpbmcgeWV0IChyZWFkeVN0YXRlIDApXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IG1lZGlhO1xuICAgIGNvbnN0IGJ1ZmZlcmVkID0gbWVkaWFCdWZmZXIuYnVmZmVyZWQ7XG5cbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEgJiYgYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3NlZWtUb1N0YXJ0UG9zKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmltbWVkaWF0ZVN3aXRjaCkge1xuICAgICAgdGhpcy5pbW1lZGlhdGVMZXZlbFN3aXRjaEVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdhcENvbnRyb2xsZXIucG9sbCh0aGlzLmxhc3RDdXJyZW50VGltZSwgYnVmZmVyZWQpO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkICgpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAvLyBpZiBsb2FkZWRtZXRhZGF0YSBpcyBub3Qgc2V0LCBpdCBtZWFucyB0aGF0IHdlIGFyZSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb24gZmlyc3QgZnJhZ1xuICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgfVxuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25CdWZmZXJGbHVzaGVkICgpIHtcbiAgICAvKiBhZnRlciBzdWNjZXNzZnVsIGJ1ZmZlciBmbHVzaGluZywgZmlsdGVyIGZsdXNoZWQgZnJhZ21lbnRzIGZyb20gYnVmZmVyZWRGcmFnc1xuICAgICAgdXNlIG1lZGlhQnVmZmVyZWQgaW5zdGVhZCBvZiBtZWRpYSAoc28gdGhhdCB3ZSB3aWxsIGNoZWNrIGFnYWluc3QgdmlkZW8uYnVmZmVyZWQgcmFuZ2VzIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIHRyYWNrKVxuICAgICovXG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAvLyBmaWx0ZXIgZnJhZ21lbnRzIHBvdGVudGlhbGx5IGV2aWN0ZWQgZnJvbSBidWZmZXIuIHRoaXMgaXMgdG8gYXZvaWQgbWVtbGVhayBvbiBsaXZlIHN0cmVhbXNcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMoRnJhZ21lbnQuRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPLCBtZWRpYS5idWZmZXJlZCk7XG4gICAgfVxuICAgIC8vIG1vdmUgdG8gSURMRSBvbmNlIGZsdXNoIGNvbXBsZXRlLiB0aGlzIHNob3VsZCB0cmlnZ2VyIG5ldyBmcmFnbWVudCBsb2FkaW5nXG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIGZyYWdcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gIH1cblxuICBzd2FwQXVkaW9Db2RlYyAoKSB7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9ICF0aGlzLmF1ZGlvQ29kZWNTd2FwO1xuICB9XG5cbiAgY29tcHV0ZUxpdmVQb3NpdGlvbiAoc2xpZGluZywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgbGV0IHRhcmdldExhdGVuY3kgPSB0aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uICE9PSB1bmRlZmluZWQgPyB0aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uIDogdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50ICogbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgIHJldHVybiBzbGlkaW5nICsgTWF0aC5tYXgoMCwgbGV2ZWxEZXRhaWxzLnRvdGFsZHVyYXRpb24gLSB0YXJnZXRMYXRlbmN5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWVrcyB0byB0aGUgc2V0IHN0YXJ0UG9zaXRpb24gaWYgbm90IGVxdWFsIHRvIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2Vla1RvU3RhcnRQb3MgKCkge1xuICAgIGNvbnN0IHsgbWVkaWEgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAvLyBvbmx5IGFkanVzdCBjdXJyZW50VGltZSBpZiBkaWZmZXJlbnQgZnJvbSBzdGFydFBvc2l0aW9uIG9yIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkXG4gICAgLy8gYXQgdGhhdCBzdGFnZSwgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGJ1ZmZlcmVkIHJhbmdlLCBhcyB3ZSByZWFjaCB0aGF0IGNvZGUgYWZ0ZXIgZmlyc3QgZnJhZ21lbnQgaGFzIGJlZW4gYnVmZmVyZWRcbiAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gbWVkaWEuc2Vla2luZyA/IGN1cnJlbnRUaW1lIDogdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIC8vIGlmIGN1cnJlbnRUaW1lIG5vdCBtYXRjaGluZyB3aXRoIGV4cGVjdGVkIHN0YXJ0UG9zaXRpb24gb3Igc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWQgYnV0IGNsb3NlIHRvIGZpcnN0IGJ1ZmZlcmVkXG4gICAgaWYgKGN1cnJlbnRUaW1lICE9PSBzdGFydFBvc2l0aW9uKSB7XG4gICAgICAvLyBpZiBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZCwgbGV0J3Mgc2VlayB0byBidWZmZXJlZC5zdGFydCgwKVxuICAgICAgbG9nZ2VyLmxvZyhgdGFyZ2V0IHN0YXJ0IHBvc2l0aW9uIG5vdCBidWZmZXJlZCwgc2VlayB0byBidWZmZXJlZC5zdGFydCgwKSAke3N0YXJ0UG9zaXRpb259IGZyb20gY3VycmVudCB0aW1lICR7Y3VycmVudFRpbWV9IGApO1xuICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRBdWRpb0NvZGVjIChjdXJyZW50TGV2ZWwpIHtcbiAgICBsZXQgYXVkaW9Db2RlYyA9IHRoaXMuY29uZmlnLmRlZmF1bHRBdWRpb0NvZGVjIHx8IGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjO1xuICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2FwKSB7XG4gICAgICBsb2dnZXIubG9nKCdzd2FwcGluZyBwbGF5bGlzdCBhdWRpbyBjb2RlYycpO1xuICAgICAgaWYgKGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgaWYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XG4gICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhdWRpb0NvZGVjO1xuICB9XG5cbiAgZ2V0IGxpdmVTeW5jUG9zaXRpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9saXZlU3luY1Bvc2l0aW9uO1xuICB9XG5cbiAgc2V0IGxpdmVTeW5jUG9zaXRpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5fbGl2ZVN5bmNQb3NpdGlvbiA9IHZhbHVlO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBTdHJlYW1Db250cm9sbGVyO1xuIiwiLyoqXG4gKiBAY2xhc3MgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyXG4gKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IERlY3J5cHRlciBmcm9tICcuLi9jcnlwdC9kZWNyeXB0ZXInO1xuaW1wb3J0IHsgQnVmZmVySGVscGVyIH0gZnJvbSAnLi4vdXRpbHMvYnVmZmVyLWhlbHBlcic7XG5pbXBvcnQgeyBmaW5kRnJhZ21lbnRCeVBEVCwgZmluZEZyYWdtZW50QnlQVFMgfSBmcm9tICcuL2ZyYWdtZW50LWZpbmRlcnMnO1xuaW1wb3J0IHsgRnJhZ21lbnRTdGF0ZSB9IGZyb20gJy4vZnJhZ21lbnQtdHJhY2tlcic7XG5pbXBvcnQgQmFzZVN0cmVhbUNvbnRyb2xsZXIsIHsgU3RhdGUgfSBmcm9tICcuL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgbWVyZ2VTdWJ0aXRsZVBsYXlsaXN0cyB9IGZyb20gJy4vbGV2ZWwtaGVscGVyJztcblxuY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gd2luZG93O1xuY29uc3QgVElDS19JTlRFUlZBTCA9IDUwMDsgLy8gaG93IG9mdGVuIHRvIHRpY2sgaW4gbXNcblxuZXhwb3J0IGNsYXNzIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIEJhc2VTdHJlYW1Db250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscywgZnJhZ21lbnRUcmFja2VyKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNIRUQsXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXG4gICAgICBFdmVudC5FUlJPUixcbiAgICAgIEV2ZW50LktFWV9MT0FERUQsXG4gICAgICBFdmVudC5GUkFHX0xPQURFRCxcbiAgICAgIEV2ZW50LlNVQlRJVExFX1RSQUNLU19VUERBVEVELFxuICAgICAgRXZlbnQuU1VCVElUTEVfVFJBQ0tfU1dJVENILFxuICAgICAgRXZlbnQuU1VCVElUTEVfVFJBQ0tfTE9BREVELFxuICAgICAgRXZlbnQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsXG4gICAgICBFdmVudC5MRVZFTF9VUERBVEVEKTtcblxuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMudHJhY2tzQnVmZmVyZWQgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRUcmFja0lkID0gLTE7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKGhscywgaGxzLmNvbmZpZyk7XG4gICAgLy8gbGFzdEFWU3RhcnQgc3RvcmVzIHRoZSB0aW1lIGluIHNlY29uZHMgZm9yIHRoZSBzdGFydCB0aW1lIG9mIGEgbGV2ZWwgbG9hZFxuICAgIHRoaXMubGFzdEFWU3RhcnQgPSAwO1xuICAgIHRoaXMuX29uTWVkaWFTZWVraW5nID0gdGhpcy5vbk1lZGlhU2Vla2luZy5iaW5kKHRoaXMpO1xuICB9XG5cbiAgb25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQgKGRhdGEpIHtcbiAgICBjb25zdCB7IGZyYWcsIHN1Y2Nlc3MgfSA9IGRhdGE7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlcmVkID0gdGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXTtcbiAgICBpZiAoIWJ1ZmZlcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlL3VwZGF0ZSBhIGJ1ZmZlcmVkIGFycmF5IG1hdGNoaW5nIHRoZSBpbnRlcmZhY2UgdXNlZCBieSBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvXG4gICAgLy8gc28gd2UgY2FuIHJlLXVzZSB0aGUgbG9naWMgdXNlZCB0byBkZXRlY3QgaG93IG11Y2ggaGF2ZSBiZWVuIGJ1ZmZlcmVkXG4gICAgbGV0IHRpbWVSYW5nZTtcbiAgICBjb25zdCBmcmFnU3RhcnQgPSBmcmFnLnN0YXJ0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChmcmFnU3RhcnQgPj0gYnVmZmVyZWRbaV0uc3RhcnQgJiYgZnJhZ1N0YXJ0IDw9IGJ1ZmZlcmVkW2ldLmVuZCkge1xuICAgICAgICB0aW1lUmFuZ2UgPSBidWZmZXJlZFtpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZnJhZ0VuZCA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgIGlmICh0aW1lUmFuZ2UpIHtcbiAgICAgIHRpbWVSYW5nZS5lbmQgPSBmcmFnRW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lUmFuZ2UgPSB7XG4gICAgICAgIHN0YXJ0OiBmcmFnU3RhcnQsXG4gICAgICAgIGVuZDogZnJhZ0VuZFxuICAgICAgfTtcbiAgICAgIGJ1ZmZlcmVkLnB1c2godGltZVJhbmdlKTtcbiAgICB9XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoZWQgKHsgbWVkaWEgfSkge1xuICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5fb25NZWRpYVNlZWtpbmcpO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICB9XG5cbiAgb25NZWRpYURldGFjaGluZyAoKSB7XG4gICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5fb25NZWRpYVNlZWtpbmcpO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICB9XG5cbiAgLy8gSWYgc29tZXRoaW5nIGdvZXMgd3JvbmcsIHByb2NlZWQgdG8gbmV4dCBmcmFnLCBpZiB3ZSB3ZXJlIHByb2Nlc3Npbmcgb25lLlxuICBvbkVycm9yIChkYXRhKSB7XG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgLy8gZG9uJ3QgaGFuZGxlIGVycm9yIG5vdCByZWxhdGVkIHRvIHN1YnRpdGxlIGZyYWdtZW50XG4gICAgaWYgKCFmcmFnIHx8IGZyYWcudHlwZSAhPT0gJ3N1YnRpdGxlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgfVxuXG4gIC8vIEdvdCBhbGwgbmV3IHN1YnRpdGxlIHRyYWNrcy5cbiAgb25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQgKGRhdGEpIHtcbiAgICBsb2dnZXIubG9nKCdzdWJ0aXRsZSB0cmFja3MgdXBkYXRlZCcpO1xuICAgIHRoaXMudHJhY2tzQnVmZmVyZWQgPSBbXTtcbiAgICB0aGlzLnRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3M7XG4gICAgdGhpcy50cmFja3MuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgIHRoaXMudHJhY2tzQnVmZmVyZWRbdHJhY2suaWRdID0gW107XG4gICAgfSk7XG4gIH1cblxuICBvblN1YnRpdGxlVHJhY2tTd2l0Y2ggKGRhdGEpIHtcbiAgICB0aGlzLmN1cnJlbnRUcmFja0lkID0gZGF0YS5pZDtcblxuICAgIGlmICghdGhpcy50cmFja3MgfHwgdGhpcy5jdXJyZW50VHJhY2tJZCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRyYWNrIGhhcyB0aGUgbmVjZXNzYXJ5IGRldGFpbHMgdG8gbG9hZCBmcmFnbWVudHNcbiAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLmN1cnJlbnRUcmFja0lkXTtcbiAgICBpZiAoY3VycmVudFRyYWNrICYmIGN1cnJlbnRUcmFjay5kZXRhaWxzKSB7XG4gICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdvdCBhIG5ldyBzZXQgb2Ygc3VidGl0bGUgZnJhZ21lbnRzLlxuICBvblN1YnRpdGxlVHJhY2tMb2FkZWQgKGRhdGEpIHtcbiAgICBjb25zdCB7IGlkLCBkZXRhaWxzIH0gPSBkYXRhO1xuICAgIGNvbnN0IHsgY3VycmVudFRyYWNrSWQsIHRyYWNrcyB9ID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0cmFja3NbY3VycmVudFRyYWNrSWRdO1xuICAgIGlmIChpZCA+PSB0cmFja3MubGVuZ3RoIHx8IGlkICE9PSBjdXJyZW50VHJhY2tJZCB8fCAhY3VycmVudFRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRldGFpbHMubGl2ZSkge1xuICAgICAgbWVyZ2VTdWJ0aXRsZVBsYXlsaXN0cyhjdXJyZW50VHJhY2suZGV0YWlscywgZGV0YWlscywgdGhpcy5sYXN0QVZTdGFydCk7XG4gICAgfVxuICAgIGN1cnJlbnRUcmFjay5kZXRhaWxzID0gZGV0YWlscztcbiAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xuICB9XG5cbiAgb25LZXlMb2FkZWQgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5LRVlfTE9BRElORykge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnTG9hZGVkIChkYXRhKSB7XG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGNvbnN0IGRlY3J5cHREYXRhID0gZGF0YS5mcmFnLmRlY3J5cHRkYXRhO1xuICAgIGNvbnN0IGZyYWdMb2FkZWQgPSBkYXRhLmZyYWc7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HICYmXG4gICAgICAgIGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuZnJhZy50eXBlID09PSAnc3VidGl0bGUnICYmXG4gICAgICAgIGZyYWdDdXJyZW50LnNuID09PSBkYXRhLmZyYWcuc24pIHtcbiAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBkZWNyeXB0ZWRcbiAgICAgIGlmIChkYXRhLnBheWxvYWQuYnl0ZUxlbmd0aCA+IDAgJiYgKGRlY3J5cHREYXRhICYmIGRlY3J5cHREYXRhLmtleSAmJiBkZWNyeXB0RGF0YS5tZXRob2QgPT09ICdBRVMtMTI4JykpIHtcbiAgICAgICAgbGV0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAgIC8vIGRlY3J5cHQgdGhlIHN1YnRpdGxlc1xuICAgICAgICB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KGRhdGEucGF5bG9hZCwgZGVjcnlwdERhdGEua2V5LmJ1ZmZlciwgZGVjcnlwdERhdGEuaXYuYnVmZmVyLCBmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICAgIGxldCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19ERUNSWVBURUQsIHsgZnJhZzogZnJhZ0xvYWRlZCwgcGF5bG9hZDogZGVjcnlwdGVkRGF0YSwgc3RhdHM6IHsgdHN0YXJ0OiBzdGFydFRpbWUsIHRkZWNyeXB0OiBlbmRUaW1lIH0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uTGV2ZWxVcGRhdGVkICh7IGRldGFpbHMgfSkge1xuICAgIGNvbnN0IGZyYWdzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gICAgdGhpcy5sYXN0QVZTdGFydCA9IGZyYWdzLmxlbmd0aCA/IGZyYWdzWzBdLnN0YXJ0IDogMDtcbiAgfVxuXG4gIGRvVGljayAoKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICBjYXNlIFN0YXRlLklETEU6IHtcbiAgICAgIGNvbnN0IHsgY29uZmlnLCBjdXJyZW50VHJhY2tJZCwgZnJhZ21lbnRUcmFja2VyLCBtZWRpYSwgdHJhY2tzIH0gPSB0aGlzO1xuICAgICAgaWYgKCF0cmFja3MgfHwgIXRyYWNrc1tjdXJyZW50VHJhY2tJZF0gfHwgIXRyYWNrc1tjdXJyZW50VHJhY2tJZF0uZGV0YWlscykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBtYXhCdWZmZXJIb2xlLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIH0gPSBjb25maWc7XG4gICAgICBjb25zdCBtYXhDb25maWdCdWZmZXIgPSBNYXRoLm1pbihjb25maWcubWF4QnVmZmVyTGVuZ3RoLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKTtcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkSW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm8odGhpcy5fZ2V0QnVmZmVyZWQoKSwgbWVkaWEuY3VycmVudFRpbWUsIG1heEJ1ZmZlckhvbGUpO1xuICAgICAgY29uc3QgeyBlbmQ6IGJ1ZmZlckVuZCwgbGVuOiBidWZmZXJMZW4gfSA9IGJ1ZmZlcmVkSW5mbztcblxuICAgICAgY29uc3QgdHJhY2tEZXRhaWxzID0gdHJhY2tzW2N1cnJlbnRUcmFja0lkXS5kZXRhaWxzO1xuICAgICAgY29uc3QgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cztcbiAgICAgIGNvbnN0IGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgICAgY29uc3QgZW5kID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXS5zdGFydCArIGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uZHVyYXRpb247XG5cbiAgICAgIGlmIChidWZmZXJMZW4gPiBtYXhDb25maWdCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZm91bmRGcmFnO1xuICAgICAgY29uc3QgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXM7XG4gICAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XG4gICAgICAgIGlmIChmcmFnUHJldmlvdXMgJiYgdHJhY2tEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICAgIGZvdW5kRnJhZyA9IGZpbmRGcmFnbWVudEJ5UERUKGZyYWdtZW50cywgZnJhZ1ByZXZpb3VzLmVuZFByb2dyYW1EYXRlVGltZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmb3VuZEZyYWcpIHtcbiAgICAgICAgICBmb3VuZEZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRGcmFnID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvdW5kRnJhZyAmJiBmb3VuZEZyYWcuZW5jcnlwdGVkKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcga2V5IGZvciAke2ZvdW5kRnJhZy5zbn1gKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLktFWV9MT0FESU5HO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FESU5HLCB7IGZyYWc6IGZvdW5kRnJhZyB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZm91bmRGcmFnICYmIGZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmb3VuZEZyYWcpID09PSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQpIHtcbiAgICAgICAgLy8gb25seSBsb2FkIGlmIGZyYWdtZW50IGlzIG5vdCBsb2FkZWRcbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZvdW5kRnJhZztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURJTkcsIHsgZnJhZzogZm91bmRGcmFnIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB9XG4gIH1cblxuICBzdG9wTG9hZCAoKSB7XG4gICAgdGhpcy5sYXN0QVZTdGFydCA9IDA7XG4gICAgc3VwZXIuc3RvcExvYWQoKTtcbiAgfVxuXG4gIF9nZXRCdWZmZXJlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzQnVmZmVyZWRbdGhpcy5jdXJyZW50VHJhY2tJZF0gfHwgW107XG4gIH1cblxuICBvbk1lZGlhU2Vla2luZyAoKSB7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICB9XG59XG4iLCJpbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgY29tcHV0ZVJlbG9hZEludGVydmFsIH0gZnJvbSAnLi9sZXZlbC1oZWxwZXInO1xuXG5jbGFzcyBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURFRCxcbiAgICAgIEV2ZW50LlNVQlRJVExFX1RSQUNLX0xPQURFRCk7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gc3VidGl0bGVEaXNwbGF5IEVuYWJsZS9kaXNhYmxlIHN1YnRpdGxlIGRpc3BsYXkgcmVuZGVyaW5nXG4gICAgICovXG4gICAgdGhpcy5zdWJ0aXRsZURpc3BsYXkgPSB0cnVlO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICAvLyBMaXN0ZW4gZm9yIHN1YnRpdGxlIHRyYWNrIGNoYW5nZSwgdGhlbiBleHRyYWN0IHRoZSBjdXJyZW50IHRyYWNrIElELlxuICBvbk1lZGlhQXR0YWNoZWQgKGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5xdWV1ZWREZWZhdWx0VHJhY2spIHtcbiAgICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IHRoaXMucXVldWVkRGVmYXVsdFRyYWNrO1xuICAgICAgZGVsZXRlIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrO1xuICAgIH1cblxuICAgIHRoaXMudHJhY2tDaGFuZ2VMaXN0ZW5lciA9IHRoaXMuX29uVGV4dFRyYWNrc0NoYW5nZWQuYmluZCh0aGlzKTtcblxuICAgIHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZyA9ICEodGhpcy5tZWRpYS50ZXh0VHJhY2tzICYmICdvbmNoYW5nZScgaW4gdGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcbiAgICBpZiAodGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nKSB7XG4gICAgICB0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICB0aGlzLnRyYWNrQ2hhbmdlTGlzdGVuZXIoKTtcbiAgICAgIH0sIDUwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWEudGV4dFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLnRyYWNrQ2hhbmdlTGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcgKCkge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWEudGV4dFRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLnRyYWNrQ2hhbmdlTGlzdGVuZXIpO1xuICAgIH1cblxuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICB9XG5cbiAgLy8gRmlyZWQgd2hlbmV2ZXIgYSBuZXcgbWFuaWZlc3QgaXMgbG9hZGVkLlxuICBvbk1hbmlmZXN0TG9hZGVkIChkYXRhKSB7XG4gICAgbGV0IHRyYWNrcyA9IGRhdGEuc3VidGl0bGVzIHx8IFtdO1xuICAgIHRoaXMudHJhY2tzID0gdHJhY2tzO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHsgc3VidGl0bGVUcmFja3M6IHRyYWNrcyB9KTtcblxuICAgIC8vIGxvb3AgdGhyb3VnaCBhdmFpbGFibGUgc3VidGl0bGUgdHJhY2tzIGFuZCBhdXRvc2VsZWN0IGRlZmF1bHQgaWYgbmVlZGVkXG4gICAgLy8gVE9ETzogaW1wcm92ZSBzZWxlY3Rpb24gbG9naWMgdG8gaGFuZGxlIGZvcmNlZCwgZXRjXG4gICAgdHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgaWYgKHRyYWNrLmRlZmF1bHQpIHtcbiAgICAgICAgLy8gc2V0dGluZyB0aGlzLnN1YnRpdGxlVHJhY2sgd2lsbCB0cmlnZ2VyIGludGVybmFsIGxvZ2ljXG4gICAgICAgIC8vIGlmIG1lZGlhIGhhcyBub3QgYmVlbiBhdHRhY2hlZCB5ZXQsIGl0IHdpbGwgZmFpbFxuICAgICAgICAvLyB3ZSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBkZWZhdWx0IHRyYWNrIGlkXG4gICAgICAgIC8vIGFuZCB3ZSdsbCBzZXQgc3VidGl0bGVUcmFjayB3aGVuIG9uTWVkaWFBdHRhY2hlZCBpcyB0cmlnZ2VyZWRcbiAgICAgICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgICAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSB0cmFjay5pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IHRyYWNrLmlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBvblN1YnRpdGxlVHJhY2tMb2FkZWQgKGRhdGEpIHtcbiAgICBjb25zdCB7IGlkLCBkZXRhaWxzIH0gPSBkYXRhO1xuICAgIGNvbnN0IHsgdHJhY2tJZCwgdHJhY2tzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRyYWNrc1t0cmFja0lkXTtcbiAgICBpZiAoaWQgPj0gdHJhY2tzLmxlbmd0aCB8fCBpZCAhPT0gdHJhY2tJZCB8fCAhY3VycmVudFRyYWNrIHx8IHRoaXMuc3RvcHBlZCkge1xuICAgICAgdGhpcy5fY2xlYXJSZWxvYWRUaW1lcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvZ2dlci5sb2coYHN1YnRpdGxlIHRyYWNrICR7aWR9IGxvYWRlZGApO1xuICAgIGlmIChkZXRhaWxzLmxpdmUpIHtcbiAgICAgIGNvbnN0IHJlbG9hZEludGVydmFsID0gY29tcHV0ZVJlbG9hZEludGVydmFsKGN1cnJlbnRUcmFjay5kZXRhaWxzLCBkZXRhaWxzLCBkYXRhLnN0YXRzLnRyZXF1ZXN0KTtcbiAgICAgIGxvZ2dlci5sb2coYFJlbG9hZGluZyBsaXZlIHN1YnRpdGxlIHBsYXlsaXN0IGluICR7cmVsb2FkSW50ZXJ2YWx9bXNgKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fbG9hZEN1cnJlbnRUcmFjaygpO1xuICAgICAgfSwgcmVsb2FkSW50ZXJ2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jbGVhclJlbG9hZFRpbWVyKCk7XG4gICAgfVxuICB9XG5cbiAgc3RhcnRMb2FkICgpIHtcbiAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9sb2FkQ3VycmVudFRyYWNrKCk7XG4gIH1cblxuICBzdG9wTG9hZCAoKSB7XG4gICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9jbGVhclJlbG9hZFRpbWVyKCk7XG4gIH1cblxuICAvKiogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xuICBnZXQgc3VidGl0bGVUcmFja3MgKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrcztcbiAgfVxuXG4gIC8qKiBnZXQgaW5kZXggb2YgdGhlIHNlbGVjdGVkIHN1YnRpdGxlIHRyYWNrIChpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cykgKiovXG4gIGdldCBzdWJ0aXRsZVRyYWNrICgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja0lkO1xuICB9XG5cbiAgLyoqIHNlbGVjdCBhIHN1YnRpdGxlIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMqKi9cbiAgc2V0IHN1YnRpdGxlVHJhY2sgKHN1YnRpdGxlVHJhY2tJZCkge1xuICAgIGlmICh0aGlzLnRyYWNrSWQgIT09IHN1YnRpdGxlVHJhY2tJZCkge1xuICAgICAgdGhpcy5fdG9nZ2xlVHJhY2tNb2RlcyhzdWJ0aXRsZVRyYWNrSWQpO1xuICAgICAgdGhpcy5fc2V0U3VidGl0bGVUcmFja0ludGVybmFsKHN1YnRpdGxlVHJhY2tJZCk7XG4gICAgfVxuICB9XG5cbiAgX2NsZWFyUmVsb2FkVGltZXIgKCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBfbG9hZEN1cnJlbnRUcmFjayAoKSB7XG4gICAgY29uc3QgeyB0cmFja0lkLCB0cmFja3MsIGhscyB9ID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0cmFja3NbdHJhY2tJZF07XG4gICAgaWYgKHRyYWNrSWQgPCAwIHx8ICFjdXJyZW50VHJhY2sgfHwgKGN1cnJlbnRUcmFjay5kZXRhaWxzICYmICFjdXJyZW50VHJhY2suZGV0YWlscy5saXZlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIubG9nKGBMb2FkaW5nIHN1YnRpdGxlIHRyYWNrICR7dHJhY2tJZH1gKTtcbiAgICBobHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB7IHVybDogY3VycmVudFRyYWNrLnVybCwgaWQ6IHRyYWNrSWQgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIG9sZCBzdWJ0aXRsZVRyYWNrIGFuZCBzZXRzIGN1cnJlbnQgbW9kZSBvbiB0aGUgbmV4dCBzdWJ0aXRsZVRyYWNrLlxuICAgKiBUaGlzIG9wZXJhdGVzIG9uIHRoZSBET00gdGV4dFRyYWNrcy5cbiAgICogQSB2YWx1ZSBvZiAtMSB3aWxsIGRpc2FibGUgYWxsIHN1YnRpdGxlIHRyYWNrcy5cbiAgICogQHBhcmFtIG5ld0lkIC0gVGhlIGlkIG9mIHRoZSBuZXh0IHRyYWNrIHRvIGVuYWJsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RvZ2dsZVRyYWNrTW9kZXMgKG5ld0lkKSB7XG4gICAgY29uc3QgeyBtZWRpYSwgc3VidGl0bGVEaXNwbGF5LCB0cmFja0lkIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0VHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3MobWVkaWEudGV4dFRyYWNrcyk7XG4gICAgaWYgKG5ld0lkID09PSAtMSkge1xuICAgICAgW10uc2xpY2UuY2FsbCh0ZXh0VHJhY2tzKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgdHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb2xkVHJhY2sgPSB0ZXh0VHJhY2tzW3RyYWNrSWRdO1xuICAgICAgaWYgKG9sZFRyYWNrKSB7XG4gICAgICAgIG9sZFRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG5leHRUcmFjayA9IHRleHRUcmFja3NbbmV3SWRdO1xuICAgIGlmIChuZXh0VHJhY2spIHtcbiAgICAgIG5leHRUcmFjay5tb2RlID0gc3VidGl0bGVEaXNwbGF5ID8gJ3Nob3dpbmcnIDogJ2hpZGRlbic7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgcmVzcG9uc2libGUgZm9yIHZhbGlkYXRpbmcgdGhlIHN1YnRpdGxlIGluZGV4IGFuZCBwZXJpb2RpY2FsbHkgcmVsb2FkaW5nIGlmIGxpdmUuXG4gICAgICogRGlzcGF0Y2hlcyB0aGUgU1VCVElUTEVfVFJBQ0tfU1dJVENIIGV2ZW50LCB3aGljaCBpbnN0cnVjdHMgdGhlIHN1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyIHRvIGxvYWQgdGhlIHNlbGVjdGVkIHRyYWNrLlxuICAgICAqIEBwYXJhbSBuZXdJZCAtIFRoZSBpZCBvZiB0aGUgc3VidGl0bGUgdHJhY2sgdG8gYWN0aXZhdGUuXG4gICAgICovXG4gIF9zZXRTdWJ0aXRsZVRyYWNrSW50ZXJuYWwgKG5ld0lkKSB7XG4gICAgY29uc3QgeyBobHMsIHRyYWNrcyB9ID0gdGhpcztcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShuZXdJZCkgfHwgbmV3SWQgPCAtMSB8fCBuZXdJZCA+PSB0cmFja3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgbG9nZ2VyLmxvZyhgU3dpdGNoaW5nIHRvIHN1YnRpdGxlIHRyYWNrICR7bmV3SWR9YCk7XG4gICAgaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB7IGlkOiBuZXdJZCB9KTtcbiAgICB0aGlzLl9sb2FkQ3VycmVudFRyYWNrKCk7XG4gIH1cblxuICBfb25UZXh0VHJhY2tzQ2hhbmdlZCAoKSB7XG4gICAgLy8gTWVkaWEgaXMgdW5kZWZpbmVkIHdoZW4gc3dpdGNoaW5nIHN0cmVhbXMgdmlhIGxvYWRTb3VyY2UoKVxuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB0cmFja0lkID0gLTE7XG4gICAgbGV0IHRyYWNrcyA9IGZpbHRlclN1YnRpdGxlVHJhY2tzKHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgZm9yIChsZXQgaWQgPSAwOyBpZCA8IHRyYWNrcy5sZW5ndGg7IGlkKyspIHtcbiAgICAgIGlmICh0cmFja3NbaWRdLm1vZGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgIC8vIERvIG5vdCBicmVhayBpbiBjYXNlIHRoZXJlIGlzIGEgZm9sbG93aW5nIHRyYWNrIHdpdGggc2hvd2luZy5cbiAgICAgICAgdHJhY2tJZCA9IGlkO1xuICAgICAgfSBlbHNlIGlmICh0cmFja3NbaWRdLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICB0cmFja0lkID0gaWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldHRpbmcgY3VycmVudCBzdWJ0aXRsZVRyYWNrIHdpbGwgaW52b2tlIGNvZGUuXG4gICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdHJhY2tJZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyAodGV4dFRyYWNrTGlzdCkge1xuICBsZXQgdHJhY2tzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRyYWNrID0gdGV4dFRyYWNrTGlzdFtpXTtcbiAgICAvLyBFZGdlIGFkZHMgYSB0cmFjayB3aXRob3V0IGEgbGFiZWw7IHdlIGRvbid0IHdhbnQgdG8gdXNlIGl0XG4gICAgaWYgKHRyYWNrLmtpbmQgPT09ICdzdWJ0aXRsZXMnICYmIHRyYWNrLmxhYmVsKSB7XG4gICAgICB0cmFja3MucHVzaCh0ZXh0VHJhY2tMaXN0W2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyYWNrcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgU3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4iLCIvKlxuICogVGltZWxpbmUgQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IENlYTYwOFBhcnNlciBmcm9tICcuLi91dGlscy9jZWEtNjA4LXBhcnNlcic7XG5pbXBvcnQgT3V0cHV0RmlsdGVyIGZyb20gJy4uL3V0aWxzL291dHB1dC1maWx0ZXInO1xuaW1wb3J0IFdlYlZUVFBhcnNlciBmcm9tICcuLi91dGlscy93ZWJ2dHQtcGFyc2VyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBzZW5kQWRkVHJhY2tFdmVudCwgY2xlYXJDdXJyZW50Q3VlcyB9IGZyb20gJy4uL3V0aWxzL3RleHR0cmFjay11dGlscyc7XG5cbmZ1bmN0aW9uIGNhblJldXNlVnR0VGV4dFRyYWNrIChpblVzZVRyYWNrLCBtYW5pZmVzdFRyYWNrKSB7XG4gIHJldHVybiBpblVzZVRyYWNrICYmIGluVXNlVHJhY2subGFiZWwgPT09IG1hbmlmZXN0VHJhY2submFtZSAmJiAhKGluVXNlVHJhY2sudGV4dFRyYWNrMSB8fCBpblVzZVRyYWNrLnRleHRUcmFjazIpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24gKHgxLCB4MiwgeTEsIHkyKSB7XG4gIHJldHVybiBNYXRoLm1pbih4MiwgeTIpIC0gTWF0aC5tYXgoeDEsIHkxKTtcbn1cblxuY2xhc3MgVGltZWxpbmVDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuTUVESUFfQVRUQUNISU5HLFxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX1VTRVJEQVRBLFxuICAgICAgRXZlbnQuRlJBR19ERUNSWVBURUQsXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BREVELFxuICAgICAgRXZlbnQuRlJBR19MT0FERUQsXG4gICAgICBFdmVudC5MRVZFTF9TV0lUQ0hJTkcsXG4gICAgICBFdmVudC5JTklUX1BUU19GT1VORCk7XG5cbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLkN1ZXMgPSBobHMuY29uZmlnLmN1ZUhhbmRsZXI7XG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSBbXTtcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xuICAgIHRoaXMuY2FwdGlvbnNUcmFja3MgPSB7fTtcblxuICAgIHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzID0ge1xuICAgICAgdGV4dFRyYWNrMToge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlXG4gICAgICB9LFxuICAgICAgdGV4dFRyYWNrMjoge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVDRUE3MDhDYXB0aW9ucykge1xuICAgICAgbGV0IGNoYW5uZWwxID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrMScpO1xuICAgICAgbGV0IGNoYW5uZWwyID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrMicpO1xuXG4gICAgICB0aGlzLmNlYTYwOFBhcnNlciA9IG5ldyBDZWE2MDhQYXJzZXIoMCwgY2hhbm5lbDEsIGNoYW5uZWwyKTtcbiAgICB9XG4gIH1cblxuICBhZGRDdWVzICh0cmFja05hbWUsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKSB7XG4gICAgLy8gc2tpcCBjdWVzIHdoaWNoIG92ZXJsYXAgbW9yZSB0aGFuIDUwJSB3aXRoIHByZXZpb3VzbHkgcGFyc2VkIHRpbWUgcmFuZ2VzXG4gICAgY29uc3QgcmFuZ2VzID0gdGhpcy5jdWVSYW5nZXM7XG4gICAgbGV0IG1lcmdlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSByYW5nZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBsZXQgY3VlUmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICBsZXQgb3ZlcmxhcCA9IGludGVyc2VjdGlvbihjdWVSYW5nZVswXSwgY3VlUmFuZ2VbMV0sIHN0YXJ0VGltZSwgZW5kVGltZSk7XG4gICAgICBpZiAob3ZlcmxhcCA+PSAwKSB7XG4gICAgICAgIGN1ZVJhbmdlWzBdID0gTWF0aC5taW4oY3VlUmFuZ2VbMF0sIHN0YXJ0VGltZSk7XG4gICAgICAgIGN1ZVJhbmdlWzFdID0gTWF0aC5tYXgoY3VlUmFuZ2VbMV0sIGVuZFRpbWUpO1xuICAgICAgICBtZXJnZWQgPSB0cnVlO1xuICAgICAgICBpZiAoKG92ZXJsYXAgLyAoZW5kVGltZSAtIHN0YXJ0VGltZSkpID4gMC41KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbWVyZ2VkKSB7XG4gICAgICByYW5nZXMucHVzaChbc3RhcnRUaW1lLCBlbmRUaW1lXSk7XG4gICAgfVxuXG4gICAgdGhpcy5DdWVzLm5ld0N1ZSh0aGlzLmNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0sIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcbiAgfVxuXG4gIC8vIFRyaWdnZXJlZCB3aGVuIGFuIGluaXRpYWwgUFRTIGlzIGZvdW5kOyB1c2VkIGZvciBzeW5jaHJvbmlzYXRpb24gb2YgV2ViVlRULlxuICBvbkluaXRQdHNGb3VuZCAoZGF0YSkge1xuICAgIGlmIChkYXRhLmlkID09PSAnbWFpbicpIHtcbiAgICAgIHRoaXMuaW5pdFBUU1tkYXRhLmZyYWcuY2NdID0gZGF0YS5pbml0UFRTO1xuICAgIH1cblxuICAgIC8vIER1ZSB0byBhc3luY2hyb25vdXMgcHJvY2Vzc2luZywgaW5pdGlhbCBQVFMgbWF5IGFycml2ZSBsYXRlciB0aGFuIHRoZSBmaXJzdCBWVFQgZnJhZ21lbnRzIGFyZSBsb2FkZWQuXG4gICAgLy8gUGFyc2UgYW55IHVucGFyc2VkIGZyYWdtZW50cyB1cG9uIHJlY2VpdmluZyB0aGUgaW5pdGlhbCBQVFMuXG4gICAgaWYgKHRoaXMudW5wYXJzZWRWdHRGcmFncy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHVucGFyc2VkVnR0RnJhZ3MgPSB0aGlzLnVucGFyc2VkVnR0RnJhZ3M7XG4gICAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSBbXTtcbiAgICAgIHVucGFyc2VkVnR0RnJhZ3MuZm9yRWFjaChmcmFnID0+IHtcbiAgICAgICAgdGhpcy5vbkZyYWdMb2FkZWQoZnJhZyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBnZXRFeGlzdGluZ1RyYWNrICh0cmFja05hbWUpIHtcbiAgICBjb25zdCB7IG1lZGlhIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWRpYS50ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0ZXh0VHJhY2sgPSBtZWRpYS50ZXh0VHJhY2tzW2ldO1xuICAgICAgICBpZiAodGV4dFRyYWNrW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgICByZXR1cm4gdGV4dFRyYWNrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY3JlYXRlQ2FwdGlvbnNUcmFjayAodHJhY2tOYW1lKSB7XG4gICAgY29uc3QgeyBsYWJlbCwgbGFuZ3VhZ2VDb2RlIH0gPSB0aGlzLmNhcHRpb25zUHJvcGVydGllc1t0cmFja05hbWVdO1xuICAgIGNvbnN0IGNhcHRpb25zVHJhY2tzID0gdGhpcy5jYXB0aW9uc1RyYWNrcztcbiAgICBpZiAoIWNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pIHtcbiAgICAgIC8vIEVuYWJsZSByZXVzZSBvZiBleGlzdGluZyB0ZXh0IHRyYWNrLlxuICAgICAgY29uc3QgZXhpc3RpbmdUcmFjayA9IHRoaXMuZ2V0RXhpc3RpbmdUcmFjayh0cmFja05hbWUpO1xuICAgICAgaWYgKCFleGlzdGluZ1RyYWNrKSB7XG4gICAgICAgIGNvbnN0IHRleHRUcmFjayA9IHRoaXMuY3JlYXRlVGV4dFRyYWNrKCdjYXB0aW9ucycsIGxhYmVsLCBsYW5ndWFnZUNvZGUpO1xuICAgICAgICBpZiAodGV4dFRyYWNrKSB7XG4gICAgICAgICAgLy8gU2V0IGEgc3BlY2lhbCBwcm9wZXJ0eSBvbiB0aGUgdHJhY2sgc28gd2Uga25vdyBpdCdzIG1hbmFnZWQgYnkgSGxzLmpzXG4gICAgICAgICAgdGV4dFRyYWNrW3RyYWNrTmFtZV0gPSB0cnVlO1xuICAgICAgICAgIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSB0ZXh0VHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSBleGlzdGluZ1RyYWNrO1xuICAgICAgICBjbGVhckN1cnJlbnRDdWVzKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pO1xuICAgICAgICBzZW5kQWRkVHJhY2tFdmVudChjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdLCB0aGlzLm1lZGlhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjcmVhdGVUZXh0VHJhY2sgKGtpbmQsIGxhYmVsLCBsYW5nKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgcmV0dXJuIG1lZGlhLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZyk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoaW5nIChkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5fY2xlYW5UcmFja3MoKTtcbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcgKCkge1xuICAgIGNvbnN0IHsgY2FwdGlvbnNUcmFja3MgfSA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXMoY2FwdGlvbnNUcmFja3MpLmZvckVhY2godHJhY2tOYW1lID0+IHtcbiAgICAgIGNsZWFyQ3VycmVudEN1ZXMoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSk7XG4gICAgICBkZWxldGUgY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uTWFuaWZlc3RMb2FkaW5nICgpIHtcbiAgICB0aGlzLmxhc3RTbiA9IC0xOyAvLyBEZXRlY3QgZGlzY29udGlndWl0eSBpbiBmcmFnbWVudCBwYXJzaW5nXG4gICAgdGhpcy5wcmV2Q0MgPSAtMTtcbiAgICB0aGlzLnZ0dENDcyA9IHsgLy8gRGV0ZWN0IGRpc2NvbnRpbnVpdHkgaW4gc3VidGl0bGUgbWFuaWZlc3RzXG4gICAgICBjY09mZnNldDogMCxcbiAgICAgIHByZXNlbnRhdGlvbk9mZnNldDogMCxcbiAgICAgIDA6IHtcbiAgICAgICAgc3RhcnQ6IDAsIHByZXZDQzogLTEsIG5ldzogZmFsc2VcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX2NsZWFuVHJhY2tzKCk7XG4gIH1cblxuICBfY2xlYW5UcmFja3MgKCkge1xuICAgIC8vIGNsZWFyIG91dGRhdGVkIHN1YnRpdGxlc1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGNvbnN0IHRleHRUcmFja3MgPSBtZWRpYS50ZXh0VHJhY2tzO1xuICAgICAgaWYgKHRleHRUcmFja3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2xlYXJDdXJyZW50Q3Vlcyh0ZXh0VHJhY2tzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uTWFuaWZlc3RMb2FkZWQgKGRhdGEpIHtcbiAgICB0aGlzLnRleHRUcmFja3MgPSBbXTtcbiAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgfHwgW107XG4gICAgdGhpcy5pbml0UFRTID0gW107XG4gICAgdGhpcy5jdWVSYW5nZXMgPSBbXTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVXZWJWVFQpIHtcbiAgICAgIHRoaXMudHJhY2tzID0gZGF0YS5zdWJ0aXRsZXMgfHwgW107XG4gICAgICBjb25zdCBpblVzZVRyYWNrcyA9IHRoaXMubWVkaWEgPyB0aGlzLm1lZGlhLnRleHRUcmFja3MgOiBbXTtcblxuICAgICAgdGhpcy50cmFja3MuZm9yRWFjaCgodHJhY2ssIGluZGV4KSA9PiB7XG4gICAgICAgIGxldCB0ZXh0VHJhY2s7XG4gICAgICAgIGlmIChpbmRleCA8IGluVXNlVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgIGxldCBpblVzZVRyYWNrID0gbnVsbDtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5Vc2VUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjYW5SZXVzZVZ0dFRleHRUcmFjayhpblVzZVRyYWNrc1tpXSwgdHJhY2spKSB7XG4gICAgICAgICAgICAgIGluVXNlVHJhY2sgPSBpblVzZVRyYWNrc1tpXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmV1c2UgdHJhY2tzIHdpdGggdGhlIHNhbWUgbGFiZWwsIGJ1dCBkbyBub3QgcmV1c2UgNjA4LzcwOCB0cmFja3NcbiAgICAgICAgICBpZiAoaW5Vc2VUcmFjaykge1xuICAgICAgICAgICAgdGV4dFRyYWNrID0gaW5Vc2VUcmFjaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0ZXh0VHJhY2spIHtcbiAgICAgICAgICB0ZXh0VHJhY2sgPSB0aGlzLmNyZWF0ZVRleHRUcmFjaygnc3VidGl0bGVzJywgdHJhY2submFtZSwgdHJhY2subGFuZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhY2suZGVmYXVsdCkge1xuICAgICAgICAgIHRleHRUcmFjay5tb2RlID0gdGhpcy5obHMuc3VidGl0bGVEaXNwbGF5ID8gJ3Nob3dpbmcnIDogJ2hpZGRlbic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dFRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50ZXh0VHJhY2tzLnB1c2godGV4dFRyYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIG9uTGV2ZWxTd2l0Y2hpbmcgKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHRoaXMuaGxzLmN1cnJlbnRMZXZlbC5jbG9zZWRDYXB0aW9ucyAhPT0gJ05PTkUnO1xuICB9XG5cbiAgb25GcmFnTG9hZGVkIChkYXRhKSB7XG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgIGlmIChmcmFnLnR5cGUgPT09ICdtYWluJykge1xuICAgICAgbGV0IHNuID0gZnJhZy5zbjtcbiAgICAgIC8vIGlmIHRoaXMgZnJhZyBpc24ndCBjb250aWd1b3VzLCBjbGVhciB0aGUgcGFyc2VyIHNvIGN1ZXMgd2l0aCBiYWQgc3RhcnQvZW5kIHRpbWVzIGFyZW4ndCBhZGRlZCB0byB0aGUgdGV4dFRyYWNrXG4gICAgICBpZiAoc24gIT09IHRoaXMubGFzdFNuICsgMSkge1xuICAgICAgICBjb25zdCBjZWE2MDhQYXJzZXIgPSB0aGlzLmNlYTYwOFBhcnNlcjtcbiAgICAgICAgaWYgKGNlYTYwOFBhcnNlcikge1xuICAgICAgICAgIGNlYTYwOFBhcnNlci5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RTbiA9IHNuO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBicmFjZS1zdHlsZVxuICAgIC8vIElmIGZyYWdtZW50IGlzIHN1YnRpdGxlIHR5cGUsIHBhcnNlIGFzIFdlYlZUVC5cbiAgICBlbHNlIGlmIChmcmFnLnR5cGUgPT09ICdzdWJ0aXRsZScpIHtcbiAgICAgIGlmIChwYXlsb2FkLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgLy8gV2UgbmVlZCBhbiBpbml0aWFsIHN5bmNocm9uaXNhdGlvbiBQVFMuIFN0b3JlIGZyYWdtZW50cyBhcyBsb25nIGFzIG5vbmUgaGFzIGFycml2ZWQuXG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHRoaXMuaW5pdFBUU1tmcmFnLmNjXSkpIHtcbiAgICAgICAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MucHVzaChkYXRhKTtcbiAgICAgICAgICBpZiAodGhpcy5pbml0UFRTLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gZmluaXNoIHVuc3VjY2Vzc2Z1bGx5LCBvdGhlcndpc2UgdGhlIHN1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyIGNvdWxkIGJlIGJsb2NrZWQgZnJvbSBsb2FkaW5nIG5ldyBmcmFncy5cbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHsgc3VjY2VzczogZmFsc2UsIGZyYWc6IGZyYWcgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkZWNyeXB0RGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgICAgIC8vIElmIHRoZSBzdWJ0aXRsZXMgYXJlIG5vdCBlbmNyeXB0ZWQsIHBhcnNlIFZUVHMgbm93LiBPdGhlcndpc2UsIHdlIG5lZWQgdG8gd2FpdC5cbiAgICAgICAgaWYgKChkZWNyeXB0RGF0YSA9PSBudWxsKSB8fCAoZGVjcnlwdERhdGEua2V5ID09IG51bGwpIHx8IChkZWNyeXB0RGF0YS5tZXRob2QgIT09ICdBRVMtMTI4JykpIHtcbiAgICAgICAgICB0aGlzLl9wYXJzZVZUVHMoZnJhZywgcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlcmUgaXMgbm8gcGF5bG9hZCwgZmluaXNoIHVuc3VjY2Vzc2Z1bGx5LlxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7IHN1Y2Nlc3M6IGZhbHNlLCBmcmFnOiBmcmFnIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9wYXJzZVZUVHMgKGZyYWcsIHBheWxvYWQpIHtcbiAgICBsZXQgdnR0Q0NzID0gdGhpcy52dHRDQ3M7XG4gICAgaWYgKCF2dHRDQ3NbZnJhZy5jY10pIHtcbiAgICAgIHZ0dENDc1tmcmFnLmNjXSA9IHsgc3RhcnQ6IGZyYWcuc3RhcnQsIHByZXZDQzogdGhpcy5wcmV2Q0MsIG5ldzogdHJ1ZSB9O1xuICAgICAgdGhpcy5wcmV2Q0MgPSBmcmFnLmNjO1xuICAgIH1cbiAgICBsZXQgdGV4dFRyYWNrcyA9IHRoaXMudGV4dFRyYWNrcyxcbiAgICAgIGhscyA9IHRoaXMuaGxzO1xuXG4gICAgLy8gUGFyc2UgdGhlIFdlYlZUVCBmaWxlIGNvbnRlbnRzLlxuICAgIFdlYlZUVFBhcnNlci5wYXJzZShwYXlsb2FkLCB0aGlzLmluaXRQVFNbZnJhZy5jY10sIHZ0dENDcywgZnJhZy5jYywgZnVuY3Rpb24gKGN1ZXMpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRleHRUcmFja3NbZnJhZy5sZXZlbHNdO1xuICAgICAgLy8gV2ViVlRUUGFyc2VyLnBhcnNlIGlzIGFuIGFzeW5jIG1ldGhvZCBhbmQgaWYgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0IHRyYWNrIG1vZGUgaXMgc2V0IHRvIFwiZGlzYWJsZWRcIlxuICAgICAgLy8gYmVmb3JlIHBhcnNpbmcgaXMgZG9uZSB0aGVuIGRvbid0IHRyeSB0byBhY2Nlc3MgY3VycmVudFRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZCBhcyBjdWVzIHdpbGwgYmUgbnVsbFxuICAgICAgLy8gYW5kIHRyeWluZyB0byBhY2Nlc3MgZ2V0Q3VlQnlJZCBtZXRob2Qgb2YgY3VlcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvblxuICAgICAgaWYgKGN1cnJlbnRUcmFjay5tb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7IHN1Y2Nlc3M6IGZhbHNlLCBmcmFnOiBmcmFnIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBBZGQgY3VlcyBhbmQgdHJpZ2dlciBldmVudCB3aXRoIHN1Y2Nlc3MgdHJ1ZS5cbiAgICAgIGN1ZXMuZm9yRWFjaChjdWUgPT4ge1xuICAgICAgICAvLyBTb21ldGltZXMgdGhlcmUgYXJlIGN1ZSBvdmVybGFwcyBvbiBzZWdtZW50ZWQgdnR0cyBzbyB0aGUgc2FtZVxuICAgICAgICAvLyBjdWUgY2FuIGFwcGVhciBtb3JlIHRoYW4gb25jZSBpbiBkaWZmZXJlbnQgdnR0IGZpbGVzLlxuICAgICAgICAvLyBUaGlzIGF2b2lkIHNob3dpbmcgZHVwbGljYXRlZCBjdWVzIHdpdGggc2FtZSB0aW1lY29kZSBhbmQgdGV4dC5cbiAgICAgICAgaWYgKCFjdXJyZW50VHJhY2suY3Vlcy5nZXRDdWVCeUlkKGN1ZS5pZCkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY3VycmVudFRyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc3QgdGV4dFRyYWNrQ3VlID0gbmV3IHdpbmRvdy5UZXh0VHJhY2tDdWUoY3VlLnN0YXJ0VGltZSwgY3VlLmVuZFRpbWUsIGN1ZS50ZXh0KTtcbiAgICAgICAgICAgIHRleHRUcmFja0N1ZS5pZCA9IGN1ZS5pZDtcbiAgICAgICAgICAgIGN1cnJlbnRUcmFjay5hZGRDdWUodGV4dFRyYWNrQ3VlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiB0cnVlLCBmcmFnOiBmcmFnIH0pO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIHBhcnNpbmcuIFRyaWdnZXIgZXZlbnQgd2l0aCBzdWNjZXNzIGZhbHNlLlxuICAgICAgbG9nZ2VyLmxvZyhgRmFpbGVkIHRvIHBhcnNlIFZUVCBjdWU6ICR7ZX1gKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7IHN1Y2Nlc3M6IGZhbHNlLCBmcmFnOiBmcmFnIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgb25GcmFnRGVjcnlwdGVkIChkYXRhKSB7XG4gICAgbGV0IGRlY3J5cHRlZERhdGEgPSBkYXRhLnBheWxvYWQsXG4gICAgICBmcmFnID0gZGF0YS5mcmFnO1xuXG4gICAgaWYgKGZyYWcudHlwZSA9PT0gJ3N1YnRpdGxlJykge1xuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodGhpcy5pbml0UFRTW2ZyYWcuY2NdKSkge1xuICAgICAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MucHVzaChkYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wYXJzZVZUVHMoZnJhZywgZGVjcnlwdGVkRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnUGFyc2luZ1VzZXJkYXRhIChkYXRhKSB7XG4gICAgLy8gcHVzaCBhbGwgb2YgdGhlIENFQS03MDggbWVzc2FnZXMgaW50byB0aGUgaW50ZXJwcmV0ZXJcbiAgICAvLyBpbW1lZGlhdGVseS4gSXQgd2lsbCBjcmVhdGUgdGhlIHByb3BlciB0aW1lc3RhbXBzIGJhc2VkIG9uIG91ciBQVFMgdmFsdWVcbiAgICBpZiAodGhpcy5lbmFibGVkICYmIHRoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEuc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2NkYXRhcyA9IHRoaXMuZXh0cmFjdENlYTYwOERhdGEoZGF0YS5zYW1wbGVzW2ldLmJ5dGVzKTtcbiAgICAgICAgdGhpcy5jZWE2MDhQYXJzZXIuYWRkRGF0YShkYXRhLnNhbXBsZXNbaV0ucHRzLCBjY2RhdGFzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBleHRyYWN0Q2VhNjA4RGF0YSAoYnl0ZUFycmF5KSB7XG4gICAgbGV0IGNvdW50ID0gYnl0ZUFycmF5WzBdICYgMzE7XG4gICAgbGV0IHBvc2l0aW9uID0gMjtcbiAgICBsZXQgdG1wQnl0ZSwgY2NieXRlMSwgY2NieXRlMiwgY2NWYWxpZCwgY2NUeXBlO1xuICAgIGxldCBhY3R1YWxDQ0J5dGVzID0gW107XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgIHRtcEJ5dGUgPSBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICBjY2J5dGUxID0gMHg3RiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgIGNjYnl0ZTIgPSAweDdGICYgYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgY2NWYWxpZCA9ICg0ICYgdG1wQnl0ZSkgIT09IDA7XG4gICAgICBjY1R5cGUgPSAzICYgdG1wQnl0ZTtcblxuICAgICAgaWYgKGNjYnl0ZTEgPT09IDAgJiYgY2NieXRlMiA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNjVmFsaWQpIHtcbiAgICAgICAgaWYgKGNjVHlwZSA9PT0gMCkgeyAvLyB8fCBjY1R5cGUgPT09IDFcbiAgICAgICAgICBhY3R1YWxDQ0J5dGVzLnB1c2goY2NieXRlMSk7XG4gICAgICAgICAgYWN0dWFsQ0NCeXRlcy5wdXNoKGNjYnl0ZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY3R1YWxDQ0J5dGVzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVsaW5lQ29udHJvbGxlcjtcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEFFU0NyeXB0byB7XG4gIGNvbnN0cnVjdG9yIChzdWJ0bGUsIGl2KSB7XG4gICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGU7XG4gICAgdGhpcy5hZXNJViA9IGl2O1xuICB9XG5cbiAgZGVjcnlwdCAoZGF0YSwga2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3VidGxlLmRlY3J5cHQoeyBuYW1lOiAnQUVTLUNCQycsIGl2OiB0aGlzLmFlc0lWIH0sIGtleSwgZGF0YSk7XG4gIH1cbn1cbiIsIi8vIFBLQ1M3XG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUGFkZGluZyAoYnVmZmVyKSB7XG4gIGNvbnN0IG91dHB1dEJ5dGVzID0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gIGNvbnN0IHBhZGRpbmdCeXRlcyA9IG91dHB1dEJ5dGVzICYmIChuZXcgRGF0YVZpZXcoYnVmZmVyKSkuZ2V0VWludDgob3V0cHV0Qnl0ZXMgLSAxKTtcbiAgaWYgKHBhZGRpbmdCeXRlcykge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoMCwgb3V0cHV0Qnl0ZXMgLSBwYWRkaW5nQnl0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWZmZXI7XG4gIH1cbn1cblxuY2xhc3MgQUVTRGVjcnlwdG9yIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8vIFN0YXRpYyBhZnRlciBydW5uaW5nIGluaXRUYWJsZVxuICAgIHRoaXMucmNvbiA9IFsweDAsIDB4MSwgMHgyLCAweDQsIDB4OCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XG4gICAgdGhpcy5zdWJNaXggPSBbbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NildO1xuICAgIHRoaXMuaW52U3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpXTtcbiAgICB0aGlzLnNCb3ggPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB0aGlzLmludlNCb3ggPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcblxuICAgIC8vIENoYW5nZXMgZHVyaW5nIHJ1bnRpbWVcbiAgICB0aGlzLmtleSA9IG5ldyBVaW50MzJBcnJheSgwKTtcblxuICAgIHRoaXMuaW5pdFRhYmxlKCk7XG4gIH1cblxuICAvLyBVc2luZyB2aWV3LmdldFVpbnQzMigpIGFsc28gc3dhcHMgdGhlIGJ5dGUgb3JkZXIuXG4gIHVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyAoYXJyYXlCdWZmZXIpIHtcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgbGV0IG5ld0FycmF5ID0gbmV3IFVpbnQzMkFycmF5KDQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBuZXdBcnJheVtpXSA9IHZpZXcuZ2V0VWludDMyKGkgKiA0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH1cblxuICBpbml0VGFibGUgKCkge1xuICAgIGxldCBzQm94ID0gdGhpcy5zQm94O1xuICAgIGxldCBpbnZTQm94ID0gdGhpcy5pbnZTQm94O1xuICAgIGxldCBzdWJNaXggPSB0aGlzLnN1Yk1peDtcbiAgICBsZXQgc3ViTWl4MCA9IHN1Yk1peFswXTtcbiAgICBsZXQgc3ViTWl4MSA9IHN1Yk1peFsxXTtcbiAgICBsZXQgc3ViTWl4MiA9IHN1Yk1peFsyXTtcbiAgICBsZXQgc3ViTWl4MyA9IHN1Yk1peFszXTtcbiAgICBsZXQgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgbGV0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgbGV0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgbGV0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgbGV0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG5cbiAgICBsZXQgZCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeGkgPSAwO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGlmIChpIDwgMTI4KSB7XG4gICAgICAgIGRbaV0gPSBpIDw8IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkW2ldID0gKGkgPDwgMSkgXiAweDExYjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGxldCBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpO1xuICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xuICAgICAgc0JveFt4XSA9IHN4O1xuICAgICAgaW52U0JveFtzeF0gPSB4O1xuXG4gICAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXG4gICAgICBsZXQgeDIgPSBkW3hdO1xuICAgICAgbGV0IHg0ID0gZFt4Ml07XG4gICAgICBsZXQgeDggPSBkW3g0XTtcblxuICAgICAgLy8gQ29tcHV0ZSBzdWIvaW52U3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcbiAgICAgIGxldCB0ID0gKGRbc3hdICogMHgxMDEpIF4gKHN4ICogMHgxMDEwMTAwKTtcbiAgICAgIHN1Yk1peDBbeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG4gICAgICBzdWJNaXgxW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcbiAgICAgIHN1Yk1peDJbeF0gPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG4gICAgICBzdWJNaXgzW3hdID0gdDtcblxuICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApO1xuICAgICAgaW52U3ViTWl4MFtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG4gICAgICBpbnZTdWJNaXgxW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG4gICAgICBpbnZTdWJNaXgyW3N4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcbiAgICAgIGludlN1Yk1peDNbc3hdID0gdDtcblxuICAgICAgLy8gQ29tcHV0ZSBuZXh0IGNvdW50ZXJcbiAgICAgIGlmICgheCkge1xuICAgICAgICB4ID0geGkgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcbiAgICAgICAgeGkgXj0gZFtkW3hpXV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZXhwYW5kS2V5IChrZXlCdWZmZXIpIHtcbiAgICAvLyBjb252ZXJ0IGtleUJ1ZmZlciB0byBVaW50MzJBcnJheVxuICAgIGxldCBrZXkgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhrZXlCdWZmZXIpO1xuICAgIGxldCBzYW1lS2V5ID0gdHJ1ZTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBrZXkubGVuZ3RoICYmIHNhbWVLZXkpIHtcbiAgICAgIHNhbWVLZXkgPSAoa2V5W29mZnNldF0gPT09IHRoaXMua2V5W29mZnNldF0pO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuXG4gICAgaWYgKHNhbWVLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICBsZXQga2V5U2l6ZSA9IHRoaXMua2V5U2l6ZSA9IGtleS5sZW5ndGg7XG5cbiAgICBpZiAoa2V5U2l6ZSAhPT0gNCAmJiBrZXlTaXplICE9PSA2ICYmIGtleVNpemUgIT09IDgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZXMga2V5IHNpemU9JyArIGtleVNpemUpO1xuICAgIH1cblxuICAgIGxldCBrc1Jvd3MgPSB0aGlzLmtzUm93cyA9IChrZXlTaXplICsgNiArIDEpICogNDtcbiAgICBsZXQga3NSb3c7XG4gICAgbGV0IGludktzUm93O1xuXG4gICAgbGV0IGtleVNjaGVkdWxlID0gdGhpcy5rZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xuICAgIGxldCBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcbiAgICBsZXQgc2JveCA9IHRoaXMuc0JveDtcbiAgICBsZXQgcmNvbiA9IHRoaXMucmNvbjtcblxuICAgIGxldCBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICBsZXQgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICBsZXQgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICBsZXQgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICBsZXQgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcblxuICAgIGxldCBwcmV2O1xuICAgIGxldCB0O1xuXG4gICAgZm9yIChrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG4gICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG4gICAgICAgIHByZXYgPSBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlba3NSb3ddO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHQgPSBwcmV2O1xuXG4gICAgICBpZiAoa3NSb3cgJSBrZXlTaXplID09PSAwKSB7XG4gICAgICAgIC8vIFJvdCB3b3JkXG4gICAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG5cbiAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgdCA9IChzYm94W3QgPj4+IDI0XSA8PCAyNCkgfCAoc2JveFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKHNib3hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBzYm94W3QgJiAweGZmXTtcblxuICAgICAgICAvLyBNaXggUmNvblxuICAgICAgICB0IF49IHJjb25bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNDtcbiAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0KSB7XG4gICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgIHQgPSAoc2JveFt0ID4+PiAyNF0gPDwgMjQpIHwgKHNib3hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChzYm94Wyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgc2JveFt0ICYgMHhmZl07XG4gICAgICB9XG5cbiAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IHByZXYgPSAoa2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQpID4+PiAwO1xuICAgIH1cblxuICAgIGZvciAoaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcbiAgICAgIGlmIChpbnZLc1JvdyAmIDMpIHtcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludlN1Yk1peDBbc2JveFt0ID4+PiAyNF1dIF4gaW52U3ViTWl4MVtzYm94Wyh0ID4+PiAxNikgJiAweGZmXV0gXiBpbnZTdWJNaXgyW3Nib3hbKHQgPj4+IDgpICYgMHhmZl1dIF4gaW52U3ViTWl4M1tzYm94W3QgJiAweGZmXV07XG4gICAgICB9XG5cbiAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludktleVNjaGVkdWxlW2ludktzUm93XSA+Pj4gMDtcbiAgICB9XG4gIH1cblxuICAvLyBBZGRpbmcgdGhpcyBhcyBhIG1ldGhvZCBncmVhdGx5IGltcHJvdmVzIHBlcmZvcm1hbmNlLlxuICBuZXR3b3JrVG9Ib3N0T3JkZXJTd2FwICh3b3JkKSB7XG4gICAgcmV0dXJuICh3b3JkIDw8IDI0KSB8ICgod29yZCAmIDB4ZmYwMCkgPDwgOCkgfCAoKHdvcmQgJiAweGZmMDAwMCkgPj4gOCkgfCAod29yZCA+Pj4gMjQpO1xuICB9XG5cbiAgZGVjcnlwdCAoaW5wdXRBcnJheUJ1ZmZlciwgb2Zmc2V0LCBhZXNJViwgcmVtb3ZlUEtDUzdQYWRkaW5nKSB7XG4gICAgbGV0IG5Sb3VuZHMgPSB0aGlzLmtleVNpemUgKyA2O1xuICAgIGxldCBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGU7XG4gICAgbGV0IGludlNCT1ggPSB0aGlzLmludlNCb3g7XG5cbiAgICBsZXQgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgbGV0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgbGV0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgbGV0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgbGV0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG5cbiAgICBsZXQgaW5pdFZlY3RvciA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGFlc0lWKTtcbiAgICBsZXQgaW5pdFZlY3RvcjAgPSBpbml0VmVjdG9yWzBdO1xuICAgIGxldCBpbml0VmVjdG9yMSA9IGluaXRWZWN0b3JbMV07XG4gICAgbGV0IGluaXRWZWN0b3IyID0gaW5pdFZlY3RvclsyXTtcbiAgICBsZXQgaW5pdFZlY3RvcjMgPSBpbml0VmVjdG9yWzNdO1xuXG4gICAgbGV0IGlucHV0SW50MzIgPSBuZXcgSW50MzJBcnJheShpbnB1dEFycmF5QnVmZmVyKTtcbiAgICBsZXQgb3V0cHV0SW50MzIgPSBuZXcgSW50MzJBcnJheShpbnB1dEludDMyLmxlbmd0aCk7XG5cbiAgICBsZXQgdDAsIHQxLCB0MiwgdDM7XG4gICAgbGV0IHMwLCBzMSwgczIsIHMzO1xuICAgIGxldCBpbnB1dFdvcmRzMCwgaW5wdXRXb3JkczEsIGlucHV0V29yZHMyLCBpbnB1dFdvcmRzMztcblxuICAgIGxldCBrc1JvdywgaTtcbiAgICBsZXQgc3dhcFdvcmQgPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXA7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgaW5wdXRJbnQzMi5sZW5ndGgpIHtcbiAgICAgIGlucHV0V29yZHMwID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXRdKTtcbiAgICAgIGlucHV0V29yZHMxID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAxXSk7XG4gICAgICBpbnB1dFdvcmRzMiA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgMl0pO1xuICAgICAgaW5wdXRXb3JkczMgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDNdKTtcblxuICAgICAgczAgPSBpbnB1dFdvcmRzMCBeIGludktleVNjaGVkdWxlWzBdO1xuICAgICAgczEgPSBpbnB1dFdvcmRzMyBeIGludktleVNjaGVkdWxlWzFdO1xuICAgICAgczIgPSBpbnB1dFdvcmRzMiBeIGludktleVNjaGVkdWxlWzJdO1xuICAgICAgczMgPSBpbnB1dFdvcmRzMSBeIGludktleVNjaGVkdWxlWzNdO1xuXG4gICAgICBrc1JvdyA9IDQ7XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcm91bmRzIG9mIGRlY3J5cHRpb25cbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuUm91bmRzOyBpKyspIHtcbiAgICAgICAgdDAgPSBpbnZTdWJNaXgwW3MwID4+PiAyNF0gXiBpbnZTdWJNaXgxWyhzMSA+PiAxNikgJiAweGZmXSBeIGludlN1Yk1peDJbKHMyID4+IDgpICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MzICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICAgIHQxID0gaW52U3ViTWl4MFtzMSA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczIgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMyA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMCAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgICAgdDIgPSBpbnZTdWJNaXgwW3MyID4+PiAyNF0gXiBpbnZTdWJNaXgxWyhzMyA+PiAxNikgJiAweGZmXSBeIGludlN1Yk1peDJbKHMwID4+IDgpICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MxICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xuICAgICAgICB0MyA9IGludlN1Yk1peDBbczMgPj4+IDI0XSBeIGludlN1Yk1peDFbKHMwID4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4MlsoczEgPj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbczIgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107XG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgICAgICBzMCA9IHQwO1xuICAgICAgICBzMSA9IHQxO1xuICAgICAgICBzMiA9IHQyO1xuICAgICAgICBzMyA9IHQzO1xuXG4gICAgICAgIGtzUm93ID0ga3NSb3cgKyA0O1xuICAgICAgfVxuXG4gICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcbiAgICAgIHQwID0gKChpbnZTQk9YW3MwID4+PiAyNF0gPDwgMjQpIF4gKGludlNCT1hbKHMxID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeIChpbnZTQk9YWyhzMiA+PiA4KSAmIDB4ZmZdIDw8IDgpIF4gaW52U0JPWFtzMyAmIDB4ZmZdKSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgIHQxID0gKChpbnZTQk9YW3MxID4+PiAyNF0gPDwgMjQpIF4gKGludlNCT1hbKHMyID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeIChpbnZTQk9YWyhzMyA+PiA4KSAmIDB4ZmZdIDw8IDgpIF4gaW52U0JPWFtzMCAmIDB4ZmZdKSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICB0MiA9ICgoaW52U0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSBeIChpbnZTQk9YWyhzMyA+PiAxNikgJiAweGZmXSA8PCAxNikgXiAoaW52U0JPWFsoczAgPj4gOCkgJiAweGZmXSA8PCA4KSBeIGludlNCT1hbczEgJiAweGZmXSkgXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xuICAgICAgdDMgPSAoKGludlNCT1hbczMgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczAgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMxID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MyICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcbiAgICAgIGtzUm93ID0ga3NSb3cgKyAzO1xuXG4gICAgICAvLyBXcml0ZVxuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0XSA9IHN3YXBXb3JkKHQwIF4gaW5pdFZlY3RvcjApO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgMV0gPSBzd2FwV29yZCh0MyBeIGluaXRWZWN0b3IxKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDJdID0gc3dhcFdvcmQodDIgXiBpbml0VmVjdG9yMik7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAzXSA9IHN3YXBXb3JkKHQxIF4gaW5pdFZlY3RvcjMpO1xuXG4gICAgICAvLyByZXNldCBpbml0VmVjdG9yIHRvIGxhc3QgNCB1bnNpZ25lZCBpbnRcbiAgICAgIGluaXRWZWN0b3IwID0gaW5wdXRXb3JkczA7XG4gICAgICBpbml0VmVjdG9yMSA9IGlucHV0V29yZHMxO1xuICAgICAgaW5pdFZlY3RvcjIgPSBpbnB1dFdvcmRzMjtcbiAgICAgIGluaXRWZWN0b3IzID0gaW5wdXRXb3JkczM7XG5cbiAgICAgIG9mZnNldCA9IG9mZnNldCArIDQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbW92ZVBLQ1M3UGFkZGluZyA/IHJlbW92ZVBhZGRpbmcob3V0cHV0SW50MzIuYnVmZmVyKSA6IG91dHB1dEludDMyLmJ1ZmZlcjtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMua2V5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMua2V5U2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmtzUm93cyA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuc0JveCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmludlNCb3ggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdWJNaXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbnZTdWJNaXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5rZXlTY2hlZHVsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmludktleVNjaGVkdWxlID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5yY29uID0gdW5kZWZpbmVkO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFFU0RlY3J5cHRvcjtcbiIsImltcG9ydCBBRVNDcnlwdG8gZnJvbSAnLi9hZXMtY3J5cHRvJztcbmltcG9ydCBGYXN0QUVTS2V5IGZyb20gJy4vZmFzdC1hZXMta2V5JztcbmltcG9ydCBBRVNEZWNyeXB0b3IgZnJvbSAnLi9hZXMtZGVjcnlwdG9yJztcblxuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuXG5pbXBvcnQgeyBnZXRTZWxmU2NvcGUgfSBmcm9tICcuLi91dGlscy9nZXQtc2VsZi1zY29wZSc7XG5cbi8vIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTEyMzcyNTkvNTg5NDkzXG5jb25zdCBnbG9iYWwgPSBnZXRTZWxmU2NvcGUoKTsgLy8gc2FmZWd1YXJkIGZvciBjb2RlIHRoYXQgbWlnaHQgcnVuIGJvdGggb24gd29ya2VyIGFuZCBtYWluIHRocmVhZFxuXG5jbGFzcyBEZWNyeXB0ZXIge1xuICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIsIGNvbmZpZywgeyByZW1vdmVQS0NTN1BhZGRpbmcgPSB0cnVlIH0gPSB7fSkge1xuICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nID0gcmVtb3ZlUEtDUzdQYWRkaW5nO1xuICAgIC8vIGJ1aWx0IGluIGRlY3J5cHRvciBleHBlY3RzIFBLQ1M3IHBhZGRpbmdcbiAgICBpZiAocmVtb3ZlUEtDUzdQYWRkaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBicm93c2VyQ3J5cHRvID0gZ2xvYmFsLmNyeXB0bztcbiAgICAgICAgaWYgKGJyb3dzZXJDcnlwdG8pIHtcbiAgICAgICAgICB0aGlzLnN1YnRsZSA9IGJyb3dzZXJDcnlwdG8uc3VidGxlIHx8IGJyb3dzZXJDcnlwdG8ud2Via2l0U3VidGxlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgICB0aGlzLmRpc2FibGVXZWJDcnlwdG8gPSAhdGhpcy5zdWJ0bGU7XG4gIH1cblxuICBpc1N5bmMgKCkge1xuICAgIHJldHVybiAodGhpcy5kaXNhYmxlV2ViQ3J5cHRvICYmIHRoaXMuY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTKTtcbiAgfVxuXG4gIGRlY3J5cHQgKGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZVdlYkNyeXB0byAmJiB0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUykge1xuICAgICAgaWYgKHRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgICBsb2dnZXIubG9nKCdKUyBBRVMgZGVjcnlwdCcpO1xuICAgICAgICB0aGlzLmxvZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBkZWNyeXB0b3IgPSB0aGlzLmRlY3J5cHRvcjtcbiAgICAgIGlmICghZGVjcnlwdG9yKSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdG9yID0gZGVjcnlwdG9yID0gbmV3IEFFU0RlY3J5cHRvcigpO1xuICAgICAgfVxuXG4gICAgICBkZWNyeXB0b3IuZXhwYW5kS2V5KGtleSk7XG4gICAgICBjYWxsYmFjayhkZWNyeXB0b3IuZGVjcnlwdChkYXRhLCAwLCBpdiwgdGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgICBsb2dnZXIubG9nKCdXZWJDcnlwdG8gQUVTIGRlY3J5cHQnKTtcbiAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBzdWJ0bGUgPSB0aGlzLnN1YnRsZTtcbiAgICAgIGlmICh0aGlzLmtleSAhPT0ga2V5KSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmZhc3RBZXNLZXkgPSBuZXcgRmFzdEFFU0tleShzdWJ0bGUsIGtleSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmFzdEFlc0tleS5leHBhbmRLZXkoKVxuICAgICAgICAudGhlbigoYWVzS2V5KSA9PiB7XG4gICAgICAgICAgLy8gZGVjcnlwdCB1c2luZyB3ZWIgY3J5cHRvXG4gICAgICAgICAgbGV0IGNyeXB0byA9IG5ldyBBRVNDcnlwdG8oc3VidGxlLCBpdik7XG4gICAgICAgICAgY3J5cHRvLmRlY3J5cHQoZGF0YSwgYWVzS2V5KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5vbldlYkNyeXB0b0Vycm9yKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHRoaXMub25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgb25XZWJDcnlwdG9FcnJvciAoZXJyLCBkYXRhLCBrZXksIGl2LCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUykge1xuICAgICAgbG9nZ2VyLmxvZygnV2ViQ3J5cHRvIEVycm9yLCBkaXNhYmxlIFdlYkNyeXB0byBBUEknKTtcbiAgICAgIHRoaXMuZGlzYWJsZVdlYkNyeXB0byA9IHRydWU7XG4gICAgICB0aGlzLmxvZ0VuYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5kZWNyeXB0KGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmVycm9yKGBkZWNyeXB0aW5nIGVycm9yIDogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiBlcnIubWVzc2FnZSB9KTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBsZXQgZGVjcnlwdG9yID0gdGhpcy5kZWNyeXB0b3I7XG4gICAgaWYgKGRlY3J5cHRvcikge1xuICAgICAgZGVjcnlwdG9yLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZGVjcnlwdG9yID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZWNyeXB0ZXI7XG4iLCJjbGFzcyBGYXN0QUVTS2V5IHtcbiAgY29uc3RydWN0b3IgKHN1YnRsZSwga2V5KSB7XG4gICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGU7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gIH1cblxuICBleHBhbmRLZXkgKCkge1xuICAgIHJldHVybiB0aGlzLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIHRoaXMua2V5LCB7IG5hbWU6ICdBRVMtQ0JDJyB9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRmFzdEFFU0tleTtcbiIsIi8qKlxuICogQUFDIGRlbXV4ZXJcbiAqL1xuaW1wb3J0ICogYXMgQURUUyBmcm9tICcuL2FkdHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCBJRDMgZnJvbSAnLi4vZGVtdXgvaWQzJztcblxuY2xhc3MgQUFDRGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yIChvYnNlcnZlciwgcmVtdXhlciwgY29uZmlnKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XG4gIH1cblxuICByZXNldEluaXRTZWdtZW50IChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0geyBjb250YWluZXI6ICdhdWRpby9hZHRzJywgdHlwZTogJ2F1ZGlvJywgaWQ6IDAsIHNlcXVlbmNlTnVtYmVyOiAwLCBpc0FBQzogdHJ1ZSwgc2FtcGxlczogW10sIGxlbjogMCwgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYywgZHVyYXRpb246IGR1cmF0aW9uLCBpbnB1dFRpbWVTY2FsZTogOTAwMDAgfTtcbiAgfVxuXG4gIHJlc2V0VGltZVN0YW1wICgpIHtcbiAgfVxuXG4gIHN0YXRpYyBwcm9iZSAoZGF0YSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciB0aGUgQURUUyBzeW5jIHdvcmRcbiAgICAvLyBMb29rIGZvciBBRFRTIGhlYWRlciB8IDExMTEgMTExMSB8IDExMTEgWDAwWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDFcbiAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcbiAgICAvLyBNb3JlIGluZm8gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgICBjb25zdCBpZDNEYXRhID0gSUQzLmdldElEM0RhdGEoZGF0YSwgMCkgfHwgW107XG4gICAgbGV0IG9mZnNldCA9IGlkM0RhdGEubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgbGVuZ3RoID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICAgIGlmIChBRFRTLnByb2JlKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnQURUUyBzeW5jIHdvcmQgZm91bmQgIScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICBhcHBlbmQgKGRhdGEsIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIGxldCB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG4gICAgbGV0IGlkM0RhdGEgPSBJRDMuZ2V0SUQzRGF0YShkYXRhLCAwKSB8fCBbXTtcbiAgICBsZXQgdGltZXN0YW1wID0gSUQzLmdldFRpbWVTdGFtcChpZDNEYXRhKTtcbiAgICBsZXQgcHRzID0gTnVtYmVyLmlzRmluaXRlKHRpbWVzdGFtcCkgPyB0aW1lc3RhbXAgKiA5MCA6IHRpbWVPZmZzZXQgKiA5MDAwMDtcbiAgICBsZXQgZnJhbWVJbmRleCA9IDA7XG4gICAgbGV0IHN0YW1wID0gcHRzO1xuICAgIGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICBsZXQgb2Zmc2V0ID0gaWQzRGF0YS5sZW5ndGg7XG5cbiAgICBsZXQgaWQzU2FtcGxlcyA9IFt7IHB0czogc3RhbXAsIGR0czogc3RhbXAsIGRhdGE6IGlkM0RhdGEgfV07XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoIC0gMSkge1xuICAgICAgaWYgKEFEVFMuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSAmJiAob2Zmc2V0ICsgNSkgPCBsZW5ndGgpIHtcbiAgICAgICAgQURUUy5pbml0VHJhY2tDb25maWcodHJhY2ssIHRoaXMub2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgdHJhY2subWFuaWZlc3RDb2RlYyk7XG4gICAgICAgIGxldCBmcmFtZSA9IEFEVFMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICBzdGFtcCA9IGZyYW1lLnNhbXBsZS5wdHM7XG4gICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBBQUMgZnJhbWUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChJRDMuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBpZDNEYXRhID0gSUQzLmdldElEM0RhdGEoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgaWQzU2FtcGxlcy5wdXNoKHsgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcCwgZGF0YTogaWQzRGF0YSB9KTtcbiAgICAgICAgb2Zmc2V0ICs9IGlkM0RhdGEubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBmb3VuZCwga2VlcCBsb29raW5nXG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVtdXhlci5yZW11eCh0cmFjayxcbiAgICAgIHsgc2FtcGxlczogW10gfSxcbiAgICAgIHsgc2FtcGxlczogaWQzU2FtcGxlcywgaW5wdXRUaW1lU2NhbGU6IDkwMDAwIH0sXG4gICAgICB7IHNhbXBsZXM6IFtdIH0sXG4gICAgICB0aW1lT2Zmc2V0LFxuICAgICAgY29udGlndW91cyxcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBQUNEZW11eGVyO1xuIiwiLyoqXG4gKiAgQURUUyBwYXJzZXIgaGVscGVyXG4gKi9cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcblxuaW1wb3J0IHsgZ2V0U2VsZlNjb3BlIH0gZnJvbSAnLi4vdXRpbHMvZ2V0LXNlbGYtc2NvcGUnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXVkaW9Db25maWcgKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgbGV0IGFkdHNPYmplY3RUeXBlLCAvLyA6aW50XG4gICAgYWR0c1NhbXBsZWluZ0luZGV4LCAvLyA6aW50XG4gICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4LCAvLyA6aW50XG4gICAgYWR0c0NoYW5lbENvbmZpZywgLy8gOmludFxuICAgIGNvbmZpZyxcbiAgICB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksXG4gICAgbWFuaWZlc3RDb2RlYyA9IGF1ZGlvQ29kZWMsXG4gICAgYWR0c1NhbXBsZWluZ1JhdGVzID0gW1xuICAgICAgOTYwMDAsIDg4MjAwLFxuICAgICAgNjQwMDAsIDQ4MDAwLFxuICAgICAgNDQxMDAsIDMyMDAwLFxuICAgICAgMjQwMDAsIDIyMDUwLFxuICAgICAgMTYwMDAsIDEyMDAwLFxuICAgICAgMTEwMjUsIDgwMDAsXG4gICAgICA3MzUwXTtcbiAgLy8gYnl0ZSAyXG4gIGFkdHNPYmplY3RUeXBlID0gKChkYXRhW29mZnNldCArIDJdICYgMHhDMCkgPj4+IDYpICsgMTtcbiAgYWR0c1NhbXBsZWluZ0luZGV4ID0gKChkYXRhW29mZnNldCArIDJdICYgMHgzQykgPj4+IDIpO1xuICBpZiAoYWR0c1NhbXBsZWluZ0luZGV4ID4gYWR0c1NhbXBsZWluZ1JhdGVzLmxlbmd0aCAtIDEpIHtcbiAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCByZWFzb246IGBpbnZhbGlkIEFEVFMgc2FtcGxpbmcgaW5kZXg6JHthZHRzU2FtcGxlaW5nSW5kZXh9YCB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgYWR0c0NoYW5lbENvbmZpZyA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4MDEpIDw8IDIpO1xuICAvLyBieXRlIDNcbiAgYWR0c0NoYW5lbENvbmZpZyB8PSAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweEMwKSA+Pj4gNik7XG4gIGxvZ2dlci5sb2coYG1hbmlmZXN0IGNvZGVjOiR7YXVkaW9Db2RlY30sQURUUyBkYXRhOnR5cGU6JHthZHRzT2JqZWN0VHlwZX0sc2FtcGxlaW5nSW5kZXg6JHthZHRzU2FtcGxlaW5nSW5kZXh9WyR7YWR0c1NhbXBsZWluZ1JhdGVzW2FkdHNTYW1wbGVpbmdJbmRleF19SHpdLGNoYW5uZWxDb25maWc6JHthZHRzQ2hhbmVsQ29uZmlnfWApO1xuICAvLyBmaXJlZm94OiBmcmVxIGxlc3MgdGhhbiAyNGtIeiA9IEFBQyBTQlIgKEhFLUFBQylcbiAgaWYgKC9maXJlZm94L2kudGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgaWYgKGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2KSB7XG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4IC0gMztcbiAgICB9IGVsc2Uge1xuICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xuICAgIH1cbiAgICAvLyBBbmRyb2lkIDogYWx3YXlzIHVzZSBBQUNcbiAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSkge1xuICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xuICB9IGVsc2Uge1xuICAgIC8qICBmb3Igb3RoZXIgYnJvd3NlcnMgKENocm9tZS9WaXZhbGRpL09wZXJhIC4uLilcbiAgICAgICAgYWx3YXlzIGZvcmNlIGF1ZGlvIHR5cGUgdG8gYmUgSEUtQUFDIFNCUiwgYXMgc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBhdWRpbyBjb2RlYyBzd2l0Y2ggcHJvcGVybHkgKGxpa2UgQ2hyb21lIC4uLilcbiAgICAqL1xuICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEhFLUFBQyBvciBIRS1BQUN2MikgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgQU5EIGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHopXG4gICAgaWYgKChhdWRpb0NvZGVjICYmICgoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjI5JykgIT09IC0xKSB8fFxuICAgICAgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSkpIHx8XG4gICAgICAoIWF1ZGlvQ29kZWMgJiYgYWR0c1NhbXBsZWluZ0luZGV4ID49IDYpKSB7XG4gICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4IC0gMztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEFBQykgQU5EIChmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6IEFORCBuYiBjaGFubmVsIGlzIDEpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIGFuZCBtb25vIGF1ZGlvKVxuICAgICAgLy8gQ2hyb21lIGZhaWxzIHRvIHBsYXkgYmFjayB3aXRoIGxvdyBmcmVxdWVuY3kgQUFDIExDIG1vbm8gd2hlbiBpbml0aWFsaXplZCB3aXRoIEhFLUFBQy4gIFRoaXMgaXMgbm90IGEgcHJvYmxlbSB3aXRoIHN0ZXJlby5cbiAgICAgIGlmIChhdWRpb0NvZGVjICYmIGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xICYmICgoYWR0c1NhbXBsZWluZ0luZGV4ID49IDYgJiYgYWR0c0NoYW5lbENvbmZpZyA9PT0gMSkgfHxcbiAgICAgICAgICAgIC92aXZhbGRpL2kudGVzdCh1c2VyQWdlbnQpKSB8fFxuICAgICAgICAoIWF1ZGlvQ29kZWMgJiYgYWR0c0NoYW5lbENvbmZpZyA9PT0gMSkpIHtcbiAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICB9XG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXg7XG4gICAgfVxuICB9XG4gIC8qIHJlZmVyIHRvIGh0dHA6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPU1QRUctNF9BdWRpbyNBdWRpb19TcGVjaWZpY19Db25maWdcbiAgICAgIElTTyAxNDQ5Ni0zIChBQUMpLnBkZiAtIFRhYmxlIDEuMTMg4oCUIFN5bnRheCBvZiBBdWRpb1NwZWNpZmljQ29uZmlnKClcbiAgICBBdWRpbyBQcm9maWxlIC8gQXVkaW8gT2JqZWN0IFR5cGVcbiAgICAwOiBOdWxsXG4gICAgMTogQUFDIE1haW5cbiAgICAyOiBBQUMgTEMgKExvdyBDb21wbGV4aXR5KVxuICAgIDM6IEFBQyBTU1IgKFNjYWxhYmxlIFNhbXBsZSBSYXRlKVxuICAgIDQ6IEFBQyBMVFAgKExvbmcgVGVybSBQcmVkaWN0aW9uKVxuICAgIDU6IFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbilcbiAgICA2OiBBQUMgU2NhbGFibGVcbiAgIHNhbXBsaW5nIGZyZXFcbiAgICAwOiA5NjAwMCBIelxuICAgIDE6IDg4MjAwIEh6XG4gICAgMjogNjQwMDAgSHpcbiAgICAzOiA0ODAwMCBIelxuICAgIDQ6IDQ0MTAwIEh6XG4gICAgNTogMzIwMDAgSHpcbiAgICA2OiAyNDAwMCBIelxuICAgIDc6IDIyMDUwIEh6XG4gICAgODogMTYwMDAgSHpcbiAgICA5OiAxMjAwMCBIelxuICAgIDEwOiAxMTAyNSBIelxuICAgIDExOiA4MDAwIEh6XG4gICAgMTI6IDczNTAgSHpcbiAgICAxMzogUmVzZXJ2ZWRcbiAgICAxNDogUmVzZXJ2ZWRcbiAgICAxNTogZnJlcXVlbmN5IGlzIHdyaXR0ZW4gZXhwbGljdGx5XG4gICAgQ2hhbm5lbCBDb25maWd1cmF0aW9uc1xuICAgIFRoZXNlIGFyZSB0aGUgY2hhbm5lbCBjb25maWd1cmF0aW9uczpcbiAgICAwOiBEZWZpbmVkIGluIEFPVCBTcGVjaWZjIENvbmZpZ1xuICAgIDE6IDEgY2hhbm5lbDogZnJvbnQtY2VudGVyXG4gICAgMjogMiBjaGFubmVsczogZnJvbnQtbGVmdCwgZnJvbnQtcmlnaHRcbiAgKi9cbiAgLy8gYXVkaW9PYmplY3RUeXBlID0gcHJvZmlsZSA9PiBwcm9maWxlLCB0aGUgTVBFRy00IEF1ZGlvIE9iamVjdCBUeXBlIG1pbnVzIDFcbiAgY29uZmlnWzBdID0gYWR0c09iamVjdFR5cGUgPDwgMztcbiAgLy8gc2FtcGxpbmdGcmVxdWVuY3lJbmRleFxuICBjb25maWdbMF0gfD0gKGFkdHNTYW1wbGVpbmdJbmRleCAmIDB4MEUpID4+IDE7XG4gIGNvbmZpZ1sxXSB8PSAoYWR0c1NhbXBsZWluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgLy8gY2hhbm5lbENvbmZpZ3VyYXRpb25cbiAgY29uZmlnWzFdIHw9IGFkdHNDaGFuZWxDb25maWcgPDwgMztcbiAgaWYgKGFkdHNPYmplY3RUeXBlID09PSA1KSB7XG4gICAgLy8gYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4XG4gICAgY29uZmlnWzFdIHw9IChhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggJiAweDBFKSA+PiAxO1xuICAgIGNvbmZpZ1syXSA9IChhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAgIC8vIGFkdHNPYmplY3RUeXBlIChmb3JjZSB0byAyLCBjaHJvbWUgaXMgY2hlY2tpbmcgdGhhdCBvYmplY3QgdHlwZSBpcyBsZXNzIHRoYW4gNSA/Pz9cbiAgICAvLyAgICBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLmdpdC8rL21hc3Rlci9tZWRpYS9mb3JtYXRzL21wNC9hYWMuY2NcbiAgICBjb25maWdbMl0gfD0gMiA8PCAyO1xuICAgIGNvbmZpZ1szXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHsgY29uZmlnOiBjb25maWcsIHNhbXBsZXJhdGU6IGFkdHNTYW1wbGVpbmdSYXRlc1thZHRzU2FtcGxlaW5nSW5kZXhdLCBjaGFubmVsQ291bnQ6IGFkdHNDaGFuZWxDb25maWcsIGNvZGVjOiAoJ21wNGEuNDAuJyArIGFkdHNPYmplY3RUeXBlKSwgbWFuaWZlc3RDb2RlYzogbWFuaWZlc3RDb2RlYyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNIZWFkZXJQYXR0ZXJuIChkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRhdGFbb2Zmc2V0XSA9PT0gMHhmZiAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZjYpID09PSAweGYwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGVhZGVyTGVuZ3RoIChkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIChkYXRhW29mZnNldCArIDFdICYgMHgwMSA/IDcgOiA5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZ1bGxGcmFtZUxlbmd0aCAoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDAzKSA8PCAxMSkgfFxuICAgIChkYXRhW29mZnNldCArIDRdIDw8IDMpIHxcbiAgICAoKGRhdGFbb2Zmc2V0ICsgNV0gJiAweEUwKSA+Pj4gNSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hlYWRlciAoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxuICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcbiAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gIGlmIChvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2JlIChkYXRhLCBvZmZzZXQpIHtcbiAgLy8gc2FtZSBhcyBpc0hlYWRlciBidXQgd2UgYWxzbyBjaGVjayB0aGF0IEFEVFMgZnJhbWUgZm9sbG93cyBsYXN0IEFEVFMgZnJhbWVcbiAgLy8gb3IgZW5kIG9mIGRhdGEgaXMgcmVhY2hlZFxuICBpZiAob2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpKSB7XG4gICAgLy8gQURUUyBoZWFkZXIgTGVuZ3RoXG4gICAgbGV0IGhlYWRlckxlbmd0aCA9IGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAgIC8vIEFEVFMgZnJhbWUgTGVuZ3RoXG4gICAgbGV0IGZyYW1lTGVuZ3RoID0gaGVhZGVyTGVuZ3RoO1xuICAgIGlmIChvZmZzZXQgKyA1IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgIGZyYW1lTGVuZ3RoID0gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgbGV0IG5ld09mZnNldCA9IG9mZnNldCArIGZyYW1lTGVuZ3RoO1xuICAgIGlmIChuZXdPZmZzZXQgPT09IGRhdGEubGVuZ3RoIHx8IChuZXdPZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG5ld09mZnNldCkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFRyYWNrQ29uZmlnICh0cmFjaywgb2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYykge1xuICBpZiAoIXRyYWNrLnNhbXBsZXJhdGUpIHtcbiAgICBsZXQgY29uZmlnID0gZ2V0QXVkaW9Db25maWcob2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYyk7XG4gICAgdHJhY2suY29uZmlnID0gY29uZmlnLmNvbmZpZztcbiAgICB0cmFjay5zYW1wbGVyYXRlID0gY29uZmlnLnNhbXBsZXJhdGU7XG4gICAgdHJhY2suY2hhbm5lbENvdW50ID0gY29uZmlnLmNoYW5uZWxDb3VudDtcbiAgICB0cmFjay5jb2RlYyA9IGNvbmZpZy5jb2RlYztcbiAgICB0cmFjay5tYW5pZmVzdENvZGVjID0gY29uZmlnLm1hbmlmZXN0Q29kZWM7XG4gICAgbG9nZ2VyLmxvZyhgcGFyc2VkIGNvZGVjOiR7dHJhY2suY29kZWN9LHJhdGU6JHtjb25maWcuc2FtcGxlcmF0ZX0sbmIgY2hhbm5lbDoke2NvbmZpZy5jaGFubmVsQ291bnR9YCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYW1lRHVyYXRpb24gKHNhbXBsZXJhdGUpIHtcbiAgcmV0dXJuIDEwMjQgKiA5MDAwMCAvIHNhbXBsZXJhdGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZyYW1lSGVhZGVyIChkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCwgZnJhbWVEdXJhdGlvbikge1xuICBsZXQgaGVhZGVyTGVuZ3RoLCBmcmFtZUxlbmd0aCwgc3RhbXA7XG4gIGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAvLyBUaGUgcHJvdGVjdGlvbiBza2lwIGJpdCB0ZWxscyB1cyBpZiB3ZSBoYXZlIDIgYnl0ZXMgb2YgQ1JDIGRhdGEgYXQgdGhlIGVuZCBvZiB0aGUgQURUUyBoZWFkZXJcbiAgaGVhZGVyTGVuZ3RoID0gZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG4gIC8vIHJldHJpZXZlIGZyYW1lIHNpemVcbiAgZnJhbWVMZW5ndGggPSBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgZnJhbWVMZW5ndGggLT0gaGVhZGVyTGVuZ3RoO1xuXG4gIGlmICgoZnJhbWVMZW5ndGggPiAwKSAmJiAoKG9mZnNldCArIGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoKSA8PSBsZW5ndGgpKSB7XG4gICAgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICAvLyBsb2dnZXIubG9nKGBBQUMgZnJhbWUsIG9mZnNldC9sZW5ndGgvdG90YWwvcHRzOiR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtmcmFtZUxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9LyR7KHN0YW1wLzkwKS50b0ZpeGVkKDApfWApO1xuICAgIHJldHVybiB7IGhlYWRlckxlbmd0aCwgZnJhbWVMZW5ndGgsIHN0YW1wIH07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kRnJhbWUgKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCkge1xuICBsZXQgZnJhbWVEdXJhdGlvbiA9IGdldEZyYW1lRHVyYXRpb24odHJhY2suc2FtcGxlcmF0ZSk7XG4gIGxldCBoZWFkZXIgPSBwYXJzZUZyYW1lSGVhZGVyKGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4LCBmcmFtZUR1cmF0aW9uKTtcbiAgaWYgKGhlYWRlcikge1xuICAgIGxldCBzdGFtcCA9IGhlYWRlci5zdGFtcDtcbiAgICBsZXQgaGVhZGVyTGVuZ3RoID0gaGVhZGVyLmhlYWRlckxlbmd0aDtcbiAgICBsZXQgZnJhbWVMZW5ndGggPSBoZWFkZXIuZnJhbWVMZW5ndGg7XG5cbiAgICAvLyBsb2dnZXIubG9nKGBBQUMgZnJhbWUsIG9mZnNldC9sZW5ndGgvdG90YWwvcHRzOiR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtmcmFtZUxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9LyR7KHN0YW1wLzkwKS50b0ZpeGVkKDApfWApO1xuICAgIGxldCBhYWNTYW1wbGUgPSB7XG4gICAgICB1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgb2Zmc2V0ICsgaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGgpLFxuICAgICAgcHRzOiBzdGFtcCxcbiAgICAgIGR0czogc3RhbXBcbiAgICB9O1xuXG4gICAgdHJhY2suc2FtcGxlcy5wdXNoKGFhY1NhbXBsZSk7XG4gICAgdHJhY2subGVuICs9IGZyYW1lTGVuZ3RoO1xuXG4gICAgcmV0dXJuIHsgc2FtcGxlOiBhYWNTYW1wbGUsIGxlbmd0aDogZnJhbWVMZW5ndGggKyBoZWFkZXJMZW5ndGggfTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iLCIvKipcbiAqXG4gKiBpbmxpbmUgZGVtdXhlcjogcHJvYmUgZnJhZ21lbnRzIGFuZCBpbnN0YW50aWF0ZVxuICogYXBwcm9wcmlhdGUgZGVtdXhlciBkZXBlbmRpbmcgb24gY29udGVudCB0eXBlIChUU0RlbXV4ZXIsIEFBQ0RlbXV4ZXIsIC4uLilcbiAqXG4gKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IERlY3J5cHRlciBmcm9tICcuLi9jcnlwdC9kZWNyeXB0ZXInO1xuaW1wb3J0IEFBQ0RlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvYWFjZGVtdXhlcic7XG5pbXBvcnQgTVA0RGVtdXhlciBmcm9tICcuLi9kZW11eC9tcDRkZW11eGVyJztcbmltcG9ydCBUU0RlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvdHNkZW11eGVyJztcbmltcG9ydCBNUDNEZW11eGVyIGZyb20gJy4uL2RlbXV4L21wM2RlbXV4ZXInO1xuaW1wb3J0IE1QNFJlbXV4ZXIgZnJvbSAnLi4vcmVtdXgvbXA0LXJlbXV4ZXInO1xuaW1wb3J0IFBhc3NUaHJvdWdoUmVtdXhlciBmcm9tICcuLi9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyJztcblxuaW1wb3J0IHsgZ2V0U2VsZlNjb3BlIH0gZnJvbSAnLi4vdXRpbHMvZ2V0LXNlbGYtc2NvcGUnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuLy8gc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTIzNzI1OS81ODk0OTNcbmNvbnN0IGdsb2JhbCA9IGdldFNlbGZTY29wZSgpOyAvLyBzYWZlZ3VhcmQgZm9yIGNvZGUgdGhhdCBtaWdodCBydW4gYm90aCBvbiB3b3JrZXIgYW5kIG1haW4gdGhyZWFkXG5cbmxldCBub3c7XG4vLyBwZXJmb3JtYW5jZS5ub3coKSBub3QgYXZhaWxhYmxlIG9uIFdlYldvcmtlciwgYXQgbGVhc3Qgb24gU2FmYXJpIERlc2t0b3BcbnRyeSB7XG4gIG5vdyA9IGdsb2JhbC5wZXJmb3JtYW5jZS5ub3cuYmluZChnbG9iYWwucGVyZm9ybWFuY2UpO1xufSBjYXRjaCAoZXJyKSB7XG4gIGxvZ2dlci5kZWJ1ZygnVW5hYmxlIHRvIHVzZSBQZXJmb3JtYW5jZSBBUEkgb24gdGhpcyBlbnZpcm9ubWVudCcpO1xuICBub3cgPSBnbG9iYWwuRGF0ZS5ub3c7XG59XG5cbmNsYXNzIERlbXV4ZXJJbmxpbmUge1xuICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgdmVuZG9yKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy52ZW5kb3IgPSB2ZW5kb3I7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICBpZiAoZGVtdXhlcikge1xuICAgICAgZGVtdXhlci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG5cbiAgcHVzaCAoZGF0YSwgZGVjcnlwdGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICBpZiAoKGRhdGEuYnl0ZUxlbmd0aCA+IDApICYmIChkZWNyeXB0ZGF0YSAhPSBudWxsKSAmJiAoZGVjcnlwdGRhdGEua2V5ICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5tZXRob2QgPT09ICdBRVMtMTI4JykpIHtcbiAgICAgIGxldCBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlcjtcbiAgICAgIGlmIChkZWNyeXB0ZXIgPT0gbnVsbCkge1xuICAgICAgICBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIodGhpcy5vYnNlcnZlciwgdGhpcy5jb25maWcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBub3coKTtcbiAgICAgIGRlY3J5cHRlci5kZWNyeXB0KGRhdGEsIGRlY3J5cHRkYXRhLmtleS5idWZmZXIsIGRlY3J5cHRkYXRhLml2LmJ1ZmZlciwgKGRlY3J5cHRlZERhdGEpID0+IHtcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IG5vdygpO1xuICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19ERUNSWVBURUQsIHsgc3RhdHM6IHsgdHN0YXJ0OiBzdGFydFRpbWUsIHRkZWNyeXB0OiBlbmRUaW1lIH0gfSk7XG4gICAgICAgIHRoaXMucHVzaERlY3J5cHRlZChuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKSwgZGVjcnlwdGRhdGEsIG5ldyBVaW50OEFycmF5KGluaXRTZWdtZW50KSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hEZWNyeXB0ZWQobmV3IFVpbnQ4QXJyYXkoZGF0YSksIGRlY3J5cHRkYXRhLCBuZXcgVWludDhBcnJheShpbml0U2VnbWVudCksIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUyk7XG4gICAgfVxuICB9XG5cbiAgcHVzaERlY3J5cHRlZCAoZGF0YSwgZGVjcnlwdGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICBpZiAoIWRlbXV4ZXIgfHxcbiAgICAgIC8vIGluIGNhc2Ugb2YgY29udGludWl0eSBjaGFuZ2UsIG9yIHRyYWNrIHN3aXRjaFxuICAgICAgLy8gd2UgbWlnaHQgc3dpdGNoIGZyb20gY29udGVudCB0eXBlIChBQUMgY29udGFpbmVyIHRvIFRTIGNvbnRhaW5lciwgb3IgVFMgdG8gZm1wNCBmb3IgZXhhbXBsZSlcbiAgICAgIC8vIHNvIGxldCdzIGNoZWNrIHRoYXQgY3VycmVudCBkZW11eGVyIGlzIHN0aWxsIHZhbGlkXG4gICAgICAoKGRpc2NvbnRpbnVpdHkgfHwgdHJhY2tTd2l0Y2gpICYmICF0aGlzLnByb2JlKGRhdGEpKSkge1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgICAgY29uc3QgdHlwZVN1cHBvcnRlZCA9IHRoaXMudHlwZVN1cHBvcnRlZDtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgLy8gcHJvYmluZyBvcmRlciBpcyBUUy9BQUMvTVAzL01QNFxuICAgICAgY29uc3QgbXV4Q29uZmlnID0gW1xuICAgICAgICB7IGRlbXV4OiBUU0RlbXV4ZXIsIHJlbXV4OiBNUDRSZW11eGVyIH0sXG4gICAgICAgIHsgZGVtdXg6IE1QNERlbXV4ZXIsIHJlbXV4OiBQYXNzVGhyb3VnaFJlbXV4ZXIgfSxcbiAgICAgICAgeyBkZW11eDogQUFDRGVtdXhlciwgcmVtdXg6IE1QNFJlbXV4ZXIgfSxcbiAgICAgICAgeyBkZW11eDogTVAzRGVtdXhlciwgcmVtdXg6IE1QNFJlbXV4ZXIgfVxuICAgICAgXTtcblxuICAgICAgLy8gcHJvYmUgZm9yIGNvbnRlbnQgdHlwZVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG11eENvbmZpZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBtdXggPSBtdXhDb25maWdbaV07XG4gICAgICAgIGNvbnN0IHByb2JlID0gbXV4LmRlbXV4LnByb2JlO1xuICAgICAgICBpZiAocHJvYmUoZGF0YSkpIHtcbiAgICAgICAgICBjb25zdCByZW11eGVyID0gdGhpcy5yZW11eGVyID0gbmV3IG11eC5yZW11eChvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCB0aGlzLnZlbmRvcik7XG4gICAgICAgICAgZGVtdXhlciA9IG5ldyBtdXguZGVtdXgob2JzZXJ2ZXIsIHJlbXV4ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCk7XG4gICAgICAgICAgdGhpcy5wcm9iZSA9IHByb2JlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWRlbXV4ZXIpIHtcbiAgICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiAnbm8gZGVtdXggbWF0Y2hpbmcgd2l0aCBjb250ZW50IGZvdW5kJyB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5kZW11eGVyID0gZGVtdXhlcjtcbiAgICB9XG4gICAgY29uc3QgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcblxuICAgIGlmIChkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoKSB7XG4gICAgICBkZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKTtcbiAgICAgIHJlbXV4ZXIucmVzZXRJbml0U2VnbWVudCgpO1xuICAgIH1cbiAgICBpZiAoZGlzY29udGludWl0eSkge1xuICAgICAgZGVtdXhlci5yZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFBUUyk7XG4gICAgICByZW11eGVyLnJlc2V0VGltZVN0YW1wKGRlZmF1bHRJbml0UFRTKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkZW11eGVyLnNldERlY3J5cHREYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkZW11eGVyLnNldERlY3J5cHREYXRhKGRlY3J5cHRkYXRhKTtcbiAgICB9XG5cbiAgICBkZW11eGVyLmFwcGVuZChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERlbXV4ZXJJbmxpbmU7XG4iLCIvKiBkZW11eGVyIHdlYiB3b3JrZXIuXG4gKiAgLSBsaXN0ZW4gdG8gd29ya2VyIG1lc3NhZ2UsIGFuZCB0cmlnZ2VyIERlbXV4ZXJJbmxpbmUgdXBvbiByZWNlcHRpb24gb2YgRnJhZ21lbnRzLlxuICogIC0gcHJvdmlkZXMgTVA0IEJveGVzIGJhY2sgdG8gbWFpbiB0aHJlYWQgdXNpbmcgW3RyYW5zZmVyYWJsZSBvYmplY3RzXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDExLzEyL1RyYW5zZmVyYWJsZS1PYmplY3RzLUxpZ2h0bmluZy1GYXN0KSBpbiBvcmRlciB0byBtaW5pbWl6ZSBtZXNzYWdlIHBhc3Npbmcgb3ZlcmhlYWQuXG4gKi9cblxuaW1wb3J0IERlbXV4ZXJJbmxpbmUgZnJvbSAnLi4vZGVtdXgvZGVtdXhlci1pbmxpbmUnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBlbmFibGVMb2dzIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcblxubGV0IERlbXV4ZXJXb3JrZXIgPSBmdW5jdGlvbiAoc2VsZikge1xuICAvLyBvYnNlcnZlciBzZXR1cFxuICBsZXQgb2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIG9ic2VydmVyLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyIChldmVudCwgLi4uZGF0YSkge1xuICAgIG9ic2VydmVyLmVtaXQoZXZlbnQsIGV2ZW50LCAuLi5kYXRhKTtcbiAgfTtcblxuICBvYnNlcnZlci5vZmYgPSBmdW5jdGlvbiBvZmYgKGV2ZW50LCAuLi5kYXRhKSB7XG4gICAgb2JzZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIC4uLmRhdGEpO1xuICB9O1xuXG4gIGxldCBmb3J3YXJkTWVzc2FnZSA9IGZ1bmN0aW9uIChldiwgZGF0YSkge1xuICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBldmVudDogZXYsIGRhdGE6IGRhdGEgfSk7XG4gIH07XG5cbiAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgbGV0IGRhdGEgPSBldi5kYXRhO1xuICAgIC8vIGNvbnNvbGUubG9nKCdkZW11eGVyIGNtZDonICsgZGF0YS5jbWQpO1xuICAgIHN3aXRjaCAoZGF0YS5jbWQpIHtcbiAgICBjYXNlICdpbml0JzpcbiAgICAgIGNvbnN0IGNvbmZpZyA9IEpTT04ucGFyc2UoZGF0YS5jb25maWcpO1xuICAgICAgc2VsZi5kZW11eGVyID0gbmV3IERlbXV4ZXJJbmxpbmUob2JzZXJ2ZXIsIGRhdGEudHlwZVN1cHBvcnRlZCwgY29uZmlnLCBkYXRhLnZlbmRvcik7XG5cbiAgICAgIGVuYWJsZUxvZ3MoY29uZmlnLmRlYnVnKTtcblxuICAgICAgLy8gc2lnbmFsIGVuZCBvZiB3b3JrZXIgaW5pdFxuICAgICAgZm9yd2FyZE1lc3NhZ2UoJ2luaXQnLCBudWxsKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RlbXV4JzpcbiAgICAgIHNlbGYuZGVtdXhlci5wdXNoKGRhdGEuZGF0YSwgZGF0YS5kZWNyeXB0ZGF0YSwgZGF0YS5pbml0U2VnbWVudCwgZGF0YS5hdWRpb0NvZGVjLCBkYXRhLnZpZGVvQ29kZWMsIGRhdGEudGltZU9mZnNldCwgZGF0YS5kaXNjb250aW51aXR5LCBkYXRhLnRyYWNrU3dpdGNoLCBkYXRhLmNvbnRpZ3VvdXMsIGRhdGEuZHVyYXRpb24sIGRhdGEuYWNjdXJhdGVUaW1lT2Zmc2V0LCBkYXRhLmRlZmF1bHRJbml0UFRTKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGZvcndhcmQgZXZlbnRzIHRvIG1haW4gdGhyZWFkXG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfREVDUllQVEVELCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTRUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRVJST1IsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuICBvYnNlcnZlci5vbihFdmVudC5JTklUX1BUU19GT1VORCwgZm9yd2FyZE1lc3NhZ2UpO1xuXG4gIC8vIHNwZWNpYWwgY2FzZSBmb3IgRlJBR19QQVJTSU5HX0RBVEE6IHBhc3MgZGF0YTEvZGF0YTIgYXMgdHJhbnNmZXJhYmxlIG9iamVjdCAobm8gY29weSlcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIGZ1bmN0aW9uIChldiwgZGF0YSkge1xuICAgIGxldCB0cmFuc2ZlcmFibGUgPSBbXTtcbiAgICBsZXQgbWVzc2FnZSA9IHsgZXZlbnQ6IGV2LCBkYXRhOiBkYXRhIH07XG4gICAgaWYgKGRhdGEuZGF0YTEpIHtcbiAgICAgIG1lc3NhZ2UuZGF0YTEgPSBkYXRhLmRhdGExLmJ1ZmZlcjtcbiAgICAgIHRyYW5zZmVyYWJsZS5wdXNoKGRhdGEuZGF0YTEuYnVmZmVyKTtcbiAgICAgIGRlbGV0ZSBkYXRhLmRhdGExO1xuICAgIH1cbiAgICBpZiAoZGF0YS5kYXRhMikge1xuICAgICAgbWVzc2FnZS5kYXRhMiA9IGRhdGEuZGF0YTIuYnVmZmVyO1xuICAgICAgdHJhbnNmZXJhYmxlLnB1c2goZGF0YS5kYXRhMi5idWZmZXIpO1xuICAgICAgZGVsZXRlIGRhdGEuZGF0YTI7XG4gICAgfVxuICAgIHNlbGYucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXJhYmxlKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEZW11eGVyV29ya2VyO1xuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCAqIGFzIHdvcmsgZnJvbSAnd2Vid29ya2lmeS13ZWJwYWNrJztcblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRGVtdXhlcklubGluZSBmcm9tICcuLi9kZW11eC9kZW11eGVyLWlubGluZSc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGdldE1lZGlhU291cmNlIH0gZnJvbSAnLi4vdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyJztcbmltcG9ydCB7IGdldFNlbGZTY29wZSB9IGZyb20gJy4uL3V0aWxzL2dldC1zZWxmLXNjb3BlJztcblxuaW1wb3J0IHsgT2JzZXJ2ZXIgfSBmcm9tICcuLi9vYnNlcnZlcic7XG5cbi8vIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTEyMzcyNTkvNTg5NDkzXG5jb25zdCBnbG9iYWwgPSBnZXRTZWxmU2NvcGUoKTsgLy8gc2FmZWd1YXJkIGZvciBjb2RlIHRoYXQgbWlnaHQgcnVuIGJvdGggb24gd29ya2VyIGFuZCBtYWluIHRocmVhZFxuY29uc3QgTWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSgpO1xuXG5jbGFzcyBEZW11eGVyIHtcbiAgY29uc3RydWN0b3IgKGhscywgaWQpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmlkID0gaWQ7XG5cbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXIoKTtcbiAgICBjb25zdCBjb25maWcgPSBobHMuY29uZmlnO1xuXG4gICAgY29uc3QgZm9yd2FyZE1lc3NhZ2UgPSAoZXYsIGRhdGEpID0+IHtcbiAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgZGF0YS5mcmFnID0gdGhpcy5mcmFnO1xuICAgICAgZGF0YS5pZCA9IHRoaXMuaWQ7XG4gICAgICBobHMudHJpZ2dlcihldiwgZGF0YSk7XG4gICAgfTtcblxuICAgIC8vIGZvcndhcmQgZXZlbnRzIHRvIG1haW4gdGhyZWFkXG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19ERUNSWVBURUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKEV2ZW50LkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuSU5JVF9QVFNfRk9VTkQsIGZvcndhcmRNZXNzYWdlKTtcblxuICAgIGNvbnN0IHR5cGVTdXBwb3J0ZWQgPSB7XG4gICAgICBtcDQ6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXA0JyksXG4gICAgICBtcGVnOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wZWcnKSxcbiAgICAgIG1wMzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcDQ7IGNvZGVjcz1cIm1wM1wiJylcbiAgICB9O1xuICAgIC8vIG5hdmlnYXRvci52ZW5kb3IgaXMgbm90IGFsd2F5cyBhdmFpbGFibGUgaW4gV2ViIFdvcmtlclxuICAgIC8vIHJlZmVyIHRvIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Xb3JrZXJHbG9iYWxTY29wZS9uYXZpZ2F0b3JcbiAgICBjb25zdCB2ZW5kb3IgPSBuYXZpZ2F0b3IudmVuZG9yO1xuICAgIGlmIChjb25maWcuZW5hYmxlV29ya2VyICYmICh0eXBlb2YgKFdvcmtlcikgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgbG9nZ2VyLmxvZygnZGVtdXhpbmcgaW4gd2Vid29ya2VyJyk7XG4gICAgICBsZXQgdztcbiAgICAgIHRyeSB7XG4gICAgICAgIHcgPSB0aGlzLncgPSB3b3JrKHJlcXVpcmUucmVzb2x2ZSgnLi4vZGVtdXgvZGVtdXhlci13b3JrZXIuanMnKSk7XG4gICAgICAgIHRoaXMub253bXNnID0gdGhpcy5vbldvcmtlck1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xuICAgICAgICB3Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLCBmYXRhbDogdHJ1ZSwgZXZlbnQ6ICdkZW11eGVyV29ya2VyJywgZXJyOiB7IG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UgKyAnICgnICsgZXZlbnQuZmlsZW5hbWUgKyAnOicgKyBldmVudC5saW5lbm8gKyAnKScgfSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdy5wb3N0TWVzc2FnZSh7IGNtZDogJ2luaXQnLCB0eXBlU3VwcG9ydGVkOiB0eXBlU3VwcG9ydGVkLCB2ZW5kb3I6IHZlbmRvciwgaWQ6IGlkLCBjb25maWc6IEpTT04uc3RyaW5naWZ5KGNvbmZpZykgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ0Vycm9yIGluIHdvcmtlcjonLCBlcnIpO1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIHdoaWxlIGluaXRpYWxpemluZyBEZW11eGVyV29ya2VyLCBmYWxsYmFjayBvbiBEZW11eGVySW5saW5lJyk7XG4gICAgICAgIGlmICh3KSB7XG4gICAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIGRlbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICAgIGdsb2JhbC5VUkwucmV2b2tlT2JqZWN0VVJMKHcub2JqZWN0VVJMKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcklubGluZShvYnNlcnZlciwgdHlwZVN1cHBvcnRlZCwgY29uZmlnLCB2ZW5kb3IpO1xuICAgICAgICB0aGlzLncgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVySW5saW5lKG9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvcik7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgaWYgKHcpIHtcbiAgICAgIHcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMub253bXNnKTtcbiAgICAgIHcudGVybWluYXRlKCk7XG4gICAgICB0aGlzLncgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICAgIGlmIChkZW11eGVyKSB7XG4gICAgICAgIGRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICBvYnNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1c2ggKGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBmcmFnLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUykge1xuICAgIGNvbnN0IHcgPSB0aGlzLnc7XG4gICAgY29uc3QgdGltZU9mZnNldCA9IE51bWJlci5pc0Zpbml0ZShmcmFnLnN0YXJ0UFRTKSA/IGZyYWcuc3RhcnRQVFMgOiBmcmFnLnN0YXJ0O1xuICAgIGNvbnN0IGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICBjb25zdCBsYXN0RnJhZyA9IHRoaXMuZnJhZztcbiAgICBjb25zdCBkaXNjb250aW51aXR5ID0gIShsYXN0RnJhZyAmJiAoZnJhZy5jYyA9PT0gbGFzdEZyYWcuY2MpKTtcbiAgICBjb25zdCB0cmFja1N3aXRjaCA9ICEobGFzdEZyYWcgJiYgKGZyYWcubGV2ZWxzID09PSBsYXN0RnJhZy5sZXZlbHMpKTtcbiAgICBjb25zdCBuZXh0U04gPSBsYXN0RnJhZyAmJiAoZnJhZy5zbiA9PT0gKGxhc3RGcmFnLnNuICsgMSkpO1xuICAgIGNvbnN0IGNvbnRpZ3VvdXMgPSAhdHJhY2tTd2l0Y2ggJiYgbmV4dFNOO1xuICAgIGlmIChkaXNjb250aW51aXR5KSB7XG4gICAgICBsb2dnZXIubG9nKGAke3RoaXMuaWR9OmRpc2NvbnRpbnVpdHkgZGV0ZWN0ZWRgKTtcbiAgICB9XG5cbiAgICBpZiAodHJhY2tTd2l0Y2gpIHtcbiAgICAgIGxvZ2dlci5sb2coYCR7dGhpcy5pZH06c3dpdGNoIGRldGVjdGVkYCk7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFnID0gZnJhZztcbiAgICBpZiAodykge1xuICAgICAgLy8gcG9zdCBmcmFnbWVudCBwYXlsb2FkIGFzIHRyYW5zZmVyYWJsZSBvYmplY3RzIGZvciBBcnJheUJ1ZmZlciAobm8gY29weSlcbiAgICAgIHcucG9zdE1lc3NhZ2UoeyBjbWQ6ICdkZW11eCcsIGRhdGEsIGRlY3J5cHRkYXRhLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTIH0sIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IFtkYXRhXSA6IFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgICBpZiAoZGVtdXhlcikge1xuICAgICAgICBkZW11eGVyLnB1c2goZGF0YSwgZGVjcnlwdGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uV29ya2VyTWVzc2FnZSAoZXYpIHtcbiAgICBsZXQgZGF0YSA9IGV2LmRhdGEsXG4gICAgICBobHMgPSB0aGlzLmhscztcbiAgICBzd2l0Y2ggKGRhdGEuZXZlbnQpIHtcbiAgICBjYXNlICdpbml0JzpcbiAgICAgIC8vIHJldm9rZSB0aGUgT2JqZWN0IFVSTCB0aGF0IHdhcyB1c2VkIHRvIGNyZWF0ZSBkZW11eGVyIHdvcmtlciwgc28gYXMgbm90IHRvIGxlYWsgaXRcbiAgICAgIGdsb2JhbC5VUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMudy5vYmplY3RVUkwpO1xuICAgICAgYnJlYWs7XG4gICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIEZSQUdfUEFSU0lOR19EQVRBOiBkYXRhMSBhbmQgZGF0YTIgYXJlIHRyYW5zZmVyYWJsZSBvYmplY3RzXG4gICAgY2FzZSBFdmVudC5GUkFHX1BBUlNJTkdfREFUQTpcbiAgICAgIGRhdGEuZGF0YS5kYXRhMSA9IG5ldyBVaW50OEFycmF5KGRhdGEuZGF0YTEpO1xuICAgICAgaWYgKGRhdGEuZGF0YTIpIHtcbiAgICAgICAgZGF0YS5kYXRhLmRhdGEyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhMik7XG4gICAgICB9XG5cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBkZWZhdWx0OlxuICAgICAgZGF0YS5kYXRhID0gZGF0YS5kYXRhIHx8IHt9O1xuICAgICAgZGF0YS5kYXRhLmZyYWcgPSB0aGlzLmZyYWc7XG4gICAgICBkYXRhLmRhdGEuaWQgPSB0aGlzLmlkO1xuICAgICAgaGxzLnRyaWdnZXIoZGF0YS5ldmVudCwgZGF0YS5kYXRhKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZW11eGVyO1xuIiwiLyoqXG4gKiBQYXJzZXIgZm9yIGV4cG9uZW50aWFsIEdvbG9tYiBjb2RlcywgYSB2YXJpYWJsZS1iaXR3aWR0aCBudW1iZXIgZW5jb2Rpbmcgc2NoZW1lIHVzZWQgYnkgaDI2NC5cbiovXG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIEV4cEdvbG9tYiB7XG4gIGNvbnN0cnVjdG9yIChkYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGlzLmRhdGFcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIC8vIHRoZSBjdXJyZW50IHdvcmQgYmVpbmcgZXhhbWluZWRcbiAgICB0aGlzLndvcmQgPSAwOyAvLyA6dWludFxuICAgIC8vIHRoZSBudW1iZXIgb2YgYml0cyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhlIGN1cnJlbnQgd29yZFxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IDA7IC8vIDp1aW50XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIGxvYWRXb3JkICgpIHtcbiAgICBsZXRcbiAgICAgIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICBieXRlc0F2YWlsYWJsZSA9IHRoaXMuYnl0ZXNBdmFpbGFibGUsXG4gICAgICBwb3NpdGlvbiA9IGRhdGEuYnl0ZUxlbmd0aCAtIGJ5dGVzQXZhaWxhYmxlLFxuICAgICAgd29ya2luZ0J5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCksXG4gICAgICBhdmFpbGFibGVCeXRlcyA9IE1hdGgubWluKDQsIGJ5dGVzQXZhaWxhYmxlKTtcbiAgICBpZiAoYXZhaWxhYmxlQnl0ZXMgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gYnl0ZXMgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgd29ya2luZ0J5dGVzLnNldChkYXRhLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGF2YWlsYWJsZUJ5dGVzKSk7XG4gICAgdGhpcy53b3JkID0gbmV3IERhdGFWaWV3KHdvcmtpbmdCeXRlcy5idWZmZXIpLmdldFVpbnQzMigwKTtcbiAgICAvLyB0cmFjayB0aGUgYW1vdW50IG9mIHRoaXMuZGF0YSB0aGF0IGhhcyBiZWVuIHByb2Nlc3NlZFxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IGF2YWlsYWJsZUJ5dGVzICogODtcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IGF2YWlsYWJsZUJ5dGVzO1xuICB9XG5cbiAgLy8gKGNvdW50OmludCk6dm9pZFxuICBza2lwQml0cyAoY291bnQpIHtcbiAgICBsZXQgc2tpcEJ5dGVzOyAvLyA6aW50XG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IGNvdW50KSB7XG4gICAgICB0aGlzLndvcmQgPDw9IGNvdW50O1xuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCAtPSB0aGlzLmJpdHNBdmFpbGFibGU7XG4gICAgICBza2lwQnl0ZXMgPSBjb3VudCA+PiAzO1xuICAgICAgY291bnQgLT0gKHNraXBCeXRlcyA+PiAzKTtcbiAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gc2tpcEJ5dGVzO1xuICAgICAgdGhpcy5sb2FkV29yZCgpO1xuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICB9XG4gIH1cblxuICAvLyAoc2l6ZTppbnQpOnVpbnRcbiAgcmVhZEJpdHMgKHNpemUpIHtcbiAgICBsZXRcbiAgICAgIGJpdHMgPSBNYXRoLm1pbih0aGlzLmJpdHNBdmFpbGFibGUsIHNpemUpLCAvLyA6dWludFxuICAgICAgdmFsdSA9IHRoaXMud29yZCA+Pj4gKDMyIC0gYml0cyk7IC8vIDp1aW50XG4gICAgaWYgKHNpemUgPiAzMikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdDYW5ub3QgcmVhZCBtb3JlIHRoYW4gMzIgYml0cyBhdCBhIHRpbWUnKTtcbiAgICB9XG5cbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gYml0cztcbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gMCkge1xuICAgICAgdGhpcy53b3JkIDw8PSBiaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ieXRlc0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICB9XG5cbiAgICBiaXRzID0gc2l6ZSAtIGJpdHM7XG4gICAgaWYgKGJpdHMgPiAwICYmIHRoaXMuYml0c0F2YWlsYWJsZSkge1xuICAgICAgcmV0dXJuIHZhbHUgPDwgYml0cyB8IHRoaXMucmVhZEJpdHMoYml0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWx1O1xuICAgIH1cbiAgfVxuXG4gIC8vICgpOnVpbnRcbiAgc2tpcExaICgpIHtcbiAgICBsZXQgbGVhZGluZ1plcm9Db3VudDsgLy8gOnVpbnRcbiAgICBmb3IgKGxlYWRpbmdaZXJvQ291bnQgPSAwOyBsZWFkaW5nWmVyb0NvdW50IDwgdGhpcy5iaXRzQXZhaWxhYmxlOyArK2xlYWRpbmdaZXJvQ291bnQpIHtcbiAgICAgIGlmICgodGhpcy53b3JkICYgKDB4ODAwMDAwMDAgPj4+IGxlYWRpbmdaZXJvQ291bnQpKSAhPT0gMCkge1xuICAgICAgICAvLyB0aGUgZmlyc3QgYml0IG9mIHdvcmtpbmcgd29yZCBpcyAxXG4gICAgICAgIHRoaXMud29yZCA8PD0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB3ZSBleGhhdXN0ZWQgd29yZCBhbmQgc3RpbGwgaGF2ZSBub3QgZm91bmQgYSAxXG4gICAgdGhpcy5sb2FkV29yZCgpO1xuICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50ICsgdGhpcy5za2lwTFooKTtcbiAgfVxuXG4gIC8vICgpOnZvaWRcbiAgc2tpcFVFRyAoKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIHNraXBFRyAoKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH1cblxuICAvLyAoKTp1aW50XG4gIHJlYWRVRUcgKCkge1xuICAgIGxldCBjbHogPSB0aGlzLnNraXBMWigpOyAvLyA6dWludFxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKGNseiArIDEpIC0gMTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkRUcgKCkge1xuICAgIGxldCB2YWx1ID0gdGhpcy5yZWFkVUVHKCk7IC8vIDppbnRcbiAgICBpZiAoMHgwMSAmIHZhbHUpIHtcbiAgICAgIC8vIHRoZSBudW1iZXIgaXMgb2RkIGlmIHRoZSBsb3cgb3JkZXIgYml0IGlzIHNldFxuICAgICAgcmV0dXJuICgxICsgdmFsdSkgPj4+IDE7IC8vIGFkZCAxIHRvIG1ha2UgaXQgZXZlbiwgYW5kIGRpdmlkZSBieSAyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMSAqICh2YWx1ID4+PiAxKTsgLy8gZGl2aWRlIGJ5IHR3byB0aGVuIG1ha2UgaXQgbmVnYXRpdmVcbiAgICB9XG4gIH1cblxuICAvLyBTb21lIGNvbnZlbmllbmNlIGZ1bmN0aW9uc1xuICAvLyA6Qm9vbGVhblxuICByZWFkQm9vbGVhbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMSkgPT09IDE7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZFVCeXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cyg4KTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVVNob3J0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygxNik7XG4gIH1cbiAgLy8gKCk6aW50XG4gIHJlYWRVSW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygzMik7XG4gIH1cblxuICAvKipcbiAgICogQWR2YW5jZSB0aGUgRXhwR29sb21iIGRlY29kZXIgcGFzdCBhIHNjYWxpbmcgbGlzdC4gVGhlIHNjYWxpbmdcbiAgICogbGlzdCBpcyBvcHRpb25hbGx5IHRyYW5zbWl0dGVkIGFzIHBhcnQgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXJcbiAgICogc2V0IGFuZCBpcyBub3QgcmVsZXZhbnQgdG8gdHJhbnNtdXhpbmcuXG4gICAqIEBwYXJhbSBjb3VudCB7bnVtYmVyfSB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhpcyBzY2FsaW5nIGxpc3RcbiAgICogQHNlZSBSZWNvbW1lbmRhdGlvbiBJVFUtVCBILjI2NCwgU2VjdGlvbiA3LjMuMi4xLjEuMVxuICAgKi9cbiAgc2tpcFNjYWxpbmdMaXN0IChjb3VudCkge1xuICAgIGxldFxuICAgICAgbGFzdFNjYWxlID0gOCxcbiAgICAgIG5leHRTY2FsZSA9IDgsXG4gICAgICBqLFxuICAgICAgZGVsdGFTY2FsZTtcbiAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgaWYgKG5leHRTY2FsZSAhPT0gMCkge1xuICAgICAgICBkZWx0YVNjYWxlID0gdGhpcy5yZWFkRUcoKTtcbiAgICAgICAgbmV4dFNjYWxlID0gKGxhc3RTY2FsZSArIGRlbHRhU2NhbGUgKyAyNTYpICUgMjU2O1xuICAgICAgfVxuICAgICAgbGFzdFNjYWxlID0gKG5leHRTY2FsZSA9PT0gMCkgPyBsYXN0U2NhbGUgOiBuZXh0U2NhbGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGFuZCByZXR1cm4gc29tZSBpbnRlcmVzdGluZyB2aWRlb1xuICAgKiBwcm9wZXJ0aWVzLiBBIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgaXMgdGhlIEgyNjQgbWV0YWRhdGEgdGhhdFxuICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxuICAgKiBAcGFyYW0gZGF0YSB7VWludDhBcnJheX0gdGhlIGJ5dGVzIG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldFxuICAgKiBAcmV0dXJuIHtvYmplY3R9IGFuIG9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gcGFyc2VkIGZyb20gdGhlXG4gICAqIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQsIGluY2x1ZGluZyB0aGUgZGltZW5zaW9ucyBvZiB0aGVcbiAgICogYXNzb2NpYXRlZCB2aWRlbyBmcmFtZXMuXG4gICAqL1xuICByZWFkU1BTICgpIHtcbiAgICBsZXRcbiAgICAgIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSAwLFxuICAgICAgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSAwLFxuICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gMCxcbiAgICAgIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IDAsXG4gICAgICBwcm9maWxlSWRjLCBwcm9maWxlQ29tcGF0LCBsZXZlbElkYyxcbiAgICAgIG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZSwgcGljV2lkdGhJbk1ic01pbnVzMSxcbiAgICAgIHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEsXG4gICAgICBmcmFtZU1ic09ubHlGbGFnLFxuICAgICAgc2NhbGluZ0xpc3RDb3VudCxcbiAgICAgIGksXG4gICAgICByZWFkVUJ5dGUgPSB0aGlzLnJlYWRVQnl0ZS5iaW5kKHRoaXMpLFxuICAgICAgcmVhZEJpdHMgPSB0aGlzLnJlYWRCaXRzLmJpbmQodGhpcyksXG4gICAgICByZWFkVUVHID0gdGhpcy5yZWFkVUVHLmJpbmQodGhpcyksXG4gICAgICByZWFkQm9vbGVhbiA9IHRoaXMucmVhZEJvb2xlYW4uYmluZCh0aGlzKSxcbiAgICAgIHNraXBCaXRzID0gdGhpcy5za2lwQml0cy5iaW5kKHRoaXMpLFxuICAgICAgc2tpcEVHID0gdGhpcy5za2lwRUcuYmluZCh0aGlzKSxcbiAgICAgIHNraXBVRUcgPSB0aGlzLnNraXBVRUcuYmluZCh0aGlzKSxcbiAgICAgIHNraXBTY2FsaW5nTGlzdCA9IHRoaXMuc2tpcFNjYWxpbmdMaXN0LmJpbmQodGhpcyk7XG5cbiAgICByZWFkVUJ5dGUoKTtcbiAgICBwcm9maWxlSWRjID0gcmVhZFVCeXRlKCk7IC8vIHByb2ZpbGVfaWRjXG4gICAgcHJvZmlsZUNvbXBhdCA9IHJlYWRCaXRzKDUpOyAvLyBjb25zdHJhaW50X3NldFswLTRdX2ZsYWcsIHUoNSlcbiAgICBza2lwQml0cygzKTsgLy8gcmVzZXJ2ZWRfemVyb18zYml0cyB1KDMpLFxuICAgIGxldmVsSWRjID0gcmVhZFVCeXRlKCk7IC8vIGxldmVsX2lkYyB1KDgpXG4gICAgc2tpcFVFRygpOyAvLyBzZXFfcGFyYW1ldGVyX3NldF9pZFxuICAgIC8vIHNvbWUgcHJvZmlsZXMgaGF2ZSBtb3JlIG9wdGlvbmFsIGRhdGEgd2UgZG9uJ3QgbmVlZFxuICAgIGlmIChwcm9maWxlSWRjID09PSAxMDAgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTEwIHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDEyMiB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSAyNDQgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gNDQgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gODMgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gODYgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTE4IHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDEyOCkge1xuICAgICAgbGV0IGNocm9tYUZvcm1hdElkYyA9IHJlYWRVRUcoKTtcbiAgICAgIGlmIChjaHJvbWFGb3JtYXRJZGMgPT09IDMpIHtcbiAgICAgICAgc2tpcEJpdHMoMSk7XG4gICAgICB9IC8vIHNlcGFyYXRlX2NvbG91cl9wbGFuZV9mbGFnXG5cbiAgICAgIHNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2x1bWFfbWludXM4XG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9jaHJvbWFfbWludXM4XG4gICAgICBza2lwQml0cygxKTsgLy8gcXBwcmltZV95X3plcm9fdHJhbnNmb3JtX2J5cGFzc19mbGFnXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkgeyAvLyBzZXFfc2NhbGluZ19tYXRyaXhfcHJlc2VudF9mbGFnXG4gICAgICAgIHNjYWxpbmdMaXN0Q291bnQgPSAoY2hyb21hRm9ybWF0SWRjICE9PSAzKSA/IDggOiAxMjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYWxpbmdMaXN0Q291bnQ7IGkrKykge1xuICAgICAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7IC8vIHNlcV9zY2FsaW5nX2xpc3RfcHJlc2VudF9mbGFnWyBpIF1cbiAgICAgICAgICAgIGlmIChpIDwgNikge1xuICAgICAgICAgICAgICBza2lwU2NhbGluZ0xpc3QoMTYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDY0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc2tpcFVFRygpOyAvLyBsb2cyX21heF9mcmFtZV9udW1fbWludXM0XG4gICAgbGV0IHBpY09yZGVyQ250VHlwZSA9IHJlYWRVRUcoKTtcbiAgICBpZiAocGljT3JkZXJDbnRUeXBlID09PSAwKSB7XG4gICAgICByZWFkVUVHKCk7IC8vIGxvZzJfbWF4X3BpY19vcmRlcl9jbnRfbHNiX21pbnVzNFxuICAgIH0gZWxzZSBpZiAocGljT3JkZXJDbnRUeXBlID09PSAxKSB7XG4gICAgICBza2lwQml0cygxKTsgLy8gZGVsdGFfcGljX29yZGVyX2Fsd2F5c196ZXJvX2ZsYWdcbiAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX25vbl9yZWZfcGljXG4gICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl90b3BfdG9fYm90dG9tX2ZpZWxkXG4gICAgICBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUgPSByZWFkVUVHKCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlOyBpKyspIHtcbiAgICAgICAgc2tpcEVHKCk7XG4gICAgICB9IC8vIG9mZnNldF9mb3JfcmVmX2ZyYW1lWyBpIF1cbiAgICB9XG4gICAgc2tpcFVFRygpOyAvLyBtYXhfbnVtX3JlZl9mcmFtZXNcbiAgICBza2lwQml0cygxKTsgLy8gZ2Fwc19pbl9mcmFtZV9udW1fdmFsdWVfYWxsb3dlZF9mbGFnXG4gICAgcGljV2lkdGhJbk1ic01pbnVzMSA9IHJlYWRVRUcoKTtcbiAgICBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxID0gcmVhZFVFRygpO1xuICAgIGZyYW1lTWJzT25seUZsYWcgPSByZWFkQml0cygxKTtcbiAgICBpZiAoZnJhbWVNYnNPbmx5RmxhZyA9PT0gMCkge1xuICAgICAgc2tpcEJpdHMoMSk7XG4gICAgfSAvLyBtYl9hZGFwdGl2ZV9mcmFtZV9maWVsZF9mbGFnXG5cbiAgICBza2lwQml0cygxKTsgLy8gZGlyZWN0Xzh4OF9pbmZlcmVuY2VfZmxhZ1xuICAgIGlmIChyZWFkQm9vbGVhbigpKSB7IC8vIGZyYW1lX2Nyb3BwaW5nX2ZsYWdcbiAgICAgIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BSaWdodE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgIGZyYW1lQ3JvcFRvcE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICB9XG4gICAgbGV0IHBpeGVsUmF0aW8gPSBbMSwgMV07XG4gICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgIC8vIHZ1aV9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZ1xuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgLy8gYXNwZWN0X3JhdGlvX2luZm9fcHJlc2VudF9mbGFnXG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvSWRjID0gcmVhZFVCeXRlKCk7XG4gICAgICAgIHN3aXRjaCAoYXNwZWN0UmF0aW9JZGMpIHtcbiAgICAgICAgY2FzZSAxOiBwaXhlbFJhdGlvID0gWzEsIDFdOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBwaXhlbFJhdGlvID0gWzEyLCAxMV07IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IHBpeGVsUmF0aW8gPSBbMTAsIDExXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogcGl4ZWxSYXRpbyA9IFsxNiwgMTFdOyBicmVhaztcbiAgICAgICAgY2FzZSA1OiBwaXhlbFJhdGlvID0gWzQwLCAzM107IGJyZWFrO1xuICAgICAgICBjYXNlIDY6IHBpeGVsUmF0aW8gPSBbMjQsIDExXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNzogcGl4ZWxSYXRpbyA9IFsyMCwgMTFdOyBicmVhaztcbiAgICAgICAgY2FzZSA4OiBwaXhlbFJhdGlvID0gWzMyLCAxMV07IGJyZWFrO1xuICAgICAgICBjYXNlIDk6IHBpeGVsUmF0aW8gPSBbODAsIDMzXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA6IHBpeGVsUmF0aW8gPSBbMTgsIDExXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE6IHBpeGVsUmF0aW8gPSBbMTUsIDExXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6IHBpeGVsUmF0aW8gPSBbNjQsIDMzXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6IHBpeGVsUmF0aW8gPSBbMTYwLCA5OV07IGJyZWFrO1xuICAgICAgICBjYXNlIDE0OiBwaXhlbFJhdGlvID0gWzQsIDNdOyBicmVhaztcbiAgICAgICAgY2FzZSAxNTogcGl4ZWxSYXRpbyA9IFszLCAyXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMTY6IHBpeGVsUmF0aW8gPSBbMiwgMV07IGJyZWFrO1xuICAgICAgICBjYXNlIDI1NToge1xuICAgICAgICAgIHBpeGVsUmF0aW8gPSBbcmVhZFVCeXRlKCkgPDwgOCB8IHJlYWRVQnl0ZSgpLCByZWFkVUJ5dGUoKSA8PCA4IHwgcmVhZFVCeXRlKCldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBNYXRoLmNlaWwoKCgocGljV2lkdGhJbk1ic01pbnVzMSArIDEpICogMTYpIC0gZnJhbWVDcm9wTGVmdE9mZnNldCAqIDIgLSBmcmFtZUNyb3BSaWdodE9mZnNldCAqIDIpKSxcbiAgICAgIGhlaWdodDogKCgyIC0gZnJhbWVNYnNPbmx5RmxhZykgKiAocGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSArIDEpICogMTYpIC0gKChmcmFtZU1ic09ubHlGbGFnID8gMiA6IDQpICogKGZyYW1lQ3JvcFRvcE9mZnNldCArIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCkpLFxuICAgICAgcGl4ZWxSYXRpbzogcGl4ZWxSYXRpb1xuICAgIH07XG4gIH1cblxuICByZWFkU2xpY2VUeXBlICgpIHtcbiAgICAvLyBza2lwIE5BTHUgdHlwZVxuICAgIHRoaXMucmVhZFVCeXRlKCk7XG4gICAgLy8gZGlzY2FyZCBmaXJzdF9tYl9pbl9zbGljZVxuICAgIHRoaXMucmVhZFVFRygpO1xuICAgIC8vIHJldHVybiBzbGljZV90eXBlXG4gICAgcmV0dXJuIHRoaXMucmVhZFVFRygpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV4cEdvbG9tYjtcbiIsIi8qKlxuICogSUQzIHBhcnNlclxuICovXG5jbGFzcyBJRDMge1xuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGFuIElEMyBoZWFkZXIgY2FuIGJlIGZvdW5kIGF0IG9mZnNldCBpbiBkYXRhXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaCBpblxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIGFuIElEMyBoZWFkZXIgaXMgZm91bmRcbiAgICovXG4gIHN0YXRpYyBpc0hlYWRlciAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgLypcbiAgICAqIGh0dHA6Ly9pZDMub3JnL2lkM3YyLjMuMFxuICAgICogWzBdICAgICA9ICdJJ1xuICAgICogWzFdICAgICA9ICdEJ1xuICAgICogWzJdICAgICA9ICczJ1xuICAgICogWzMsNF0gICA9IHtWZXJzaW9ufVxuICAgICogWzVdICAgICA9IHtGbGFnc31cbiAgICAqIFs2LTldICAgPSB7SUQzIFNpemV9XG4gICAgKlxuICAgICogQW4gSUQzdjIgdGFnIGNhbiBiZSBkZXRlY3RlZCB3aXRoIHRoZSBmb2xsb3dpbmcgcGF0dGVybjpcbiAgICAqICAkNDkgNDQgMzMgeXkgeXkgeHggenogenogenogenpcbiAgICAqIFdoZXJlIHl5IGlzIGxlc3MgdGhhbiAkRkYsIHh4IGlzIHRoZSAnZmxhZ3MnIGJ5dGUgYW5kIHp6IGlzIGxlc3MgdGhhbiAkODBcbiAgICAqL1xuICAgIGlmIChvZmZzZXQgKyAxMCA8PSBkYXRhLmxlbmd0aCkge1xuICAgICAgLy8gbG9vayBmb3IgJ0lEMycgaWRlbnRpZmllclxuICAgICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHg0OSAmJiBkYXRhW29mZnNldCArIDFdID09PSAweDQ0ICYmIGRhdGFbb2Zmc2V0ICsgMl0gPT09IDB4MzMpIHtcbiAgICAgICAgLy8gY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgM10gPCAweEZGICYmIGRhdGFbb2Zmc2V0ICsgNF0gPCAweEZGKSB7XG4gICAgICAgICAgLy8gY2hlY2sgc2l6ZSBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA3XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA4XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYW4gSUQzIGZvb3RlciBjYW4gYmUgZm91bmQgYXQgb2Zmc2V0IGluIGRhdGFcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgYW4gSUQzIGZvb3RlciBpcyBmb3VuZFxuICAgKi9cbiAgc3RhdGljIGlzRm9vdGVyIChkYXRhLCBvZmZzZXQpIHtcbiAgICAvKlxuICAgICogVGhlIGZvb3RlciBpcyBhIGNvcHkgb2YgdGhlIGhlYWRlciwgYnV0IHdpdGggYSBkaWZmZXJlbnQgaWRlbnRpZmllclxuICAgICovXG4gICAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgICAvLyBsb29rIGZvciAnM0RJJyBpZGVudGlmaWVyXG4gICAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweDMzICYmIGRhdGFbb2Zmc2V0ICsgMV0gPT09IDB4NDQgJiYgZGF0YVtvZmZzZXQgKyAyXSA9PT0gMHg0OSkge1xuICAgICAgICAvLyBjaGVjayB2ZXJzaW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyAzXSA8IDB4RkYgJiYgZGF0YVtvZmZzZXQgKyA0XSA8IDB4RkYpIHtcbiAgICAgICAgICAvLyBjaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICAgIGlmIChkYXRhW29mZnNldCArIDZdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDddIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDhdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDldIDwgMHg4MCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW55IGFkamFjZW50IElEMyB0YWdzIGZvdW5kIGluIGRhdGEgc3RhcnRpbmcgYXQgb2Zmc2V0LCBhcyBvbmUgYmxvY2sgb2YgZGF0YVxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2ggaW5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IC0gVGhlIGJsb2NrIG9mIGRhdGEgY29udGFpbmluZyBhbnkgSUQzIHRhZ3MgZm91bmRcbiAgICovXG4gIHN0YXRpYyBnZXRJRDNEYXRhIChkYXRhLCBvZmZzZXQpIHtcbiAgICBjb25zdCBmcm9udCA9IG9mZnNldDtcbiAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgIHdoaWxlIChJRDMuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgLy8gSUQzIGhlYWRlciBpcyAxMCBieXRlc1xuICAgICAgbGVuZ3RoICs9IDEwO1xuXG4gICAgICBjb25zdCBzaXplID0gSUQzLl9yZWFkU2l6ZShkYXRhLCBvZmZzZXQgKyA2KTtcbiAgICAgIGxlbmd0aCArPSBzaXplO1xuXG4gICAgICBpZiAoSUQzLmlzRm9vdGVyKGRhdGEsIG9mZnNldCArIDEwKSkge1xuICAgICAgICAvLyBJRDMgZm9vdGVyIGlzIDEwIGJ5dGVzXG4gICAgICAgIGxlbmd0aCArPSAxMDtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGRhdGEuc3ViYXJyYXkoZnJvbnQsIGZyb250ICsgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgc3RhdGljIF9yZWFkU2l6ZSAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgbGV0IHNpemUgPSAwO1xuICAgIHNpemUgPSAoKGRhdGFbb2Zmc2V0XSAmIDB4N2YpIDw8IDIxKTtcbiAgICBzaXplIHw9ICgoZGF0YVtvZmZzZXQgKyAxXSAmIDB4N2YpIDw8IDE0KTtcbiAgICBzaXplIHw9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4N2YpIDw8IDcpO1xuICAgIHNpemUgfD0gKGRhdGFbb2Zmc2V0ICsgM10gJiAweDdmKTtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3IgdGhlIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmb3VuZCBpbiB0aGUgSUQzIGRhdGEgY2h1bmtcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gQmxvY2sgb2YgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgdGltZXN0YW1wXG4gICAqL1xuICBzdGF0aWMgZ2V0VGltZVN0YW1wIChkYXRhKSB7XG4gICAgY29uc3QgZnJhbWVzID0gSUQzLmdldElEM0ZyYW1lcyhkYXRhKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZnJhbWUgPSBmcmFtZXNbaV07XG4gICAgICBpZiAoSUQzLmlzVGltZVN0YW1wRnJhbWUoZnJhbWUpKSB7XG4gICAgICAgIHJldHVybiBJRDMuX3JlYWRUaW1lU3RhbXAoZnJhbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBJRDMgZnJhbWUgaXMgYW4gRWxlbWVudGFyeSBTdHJlYW0gdGltZXN0YW1wIGZyYW1lXG4gICAqIEBwYXJhbSB7SUQzIGZyYW1lfSBmcmFtZVxuICAgKi9cbiAgc3RhdGljIGlzVGltZVN0YW1wRnJhbWUgKGZyYW1lKSB7XG4gICAgcmV0dXJuIChmcmFtZSAmJiBmcmFtZS5rZXkgPT09ICdQUklWJyAmJiBmcmFtZS5pbmZvID09PSAnY29tLmFwcGxlLnN0cmVhbWluZy50cmFuc3BvcnRTdHJlYW1UaW1lc3RhbXAnKTtcbiAgfVxuXG4gIHN0YXRpYyBfZ2V0RnJhbWVEYXRhIChkYXRhKSB7XG4gICAgLypcbiAgICBGcmFtZSBJRCAgICAgICAkeHggeHggeHggeHggKGZvdXIgY2hhcmFjdGVycylcbiAgICBTaXplICAgICAgICAgICAkeHggeHggeHggeHhcbiAgICBGbGFncyAgICAgICAgICAkeHggeHhcbiAgICAqL1xuICAgIGNvbnN0IHR5cGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0sIGRhdGFbM10pO1xuICAgIGNvbnN0IHNpemUgPSBJRDMuX3JlYWRTaXplKGRhdGEsIDQpO1xuXG4gICAgLy8gc2tpcCBmcmFtZSBpZCwgc2l6ZSwgYW5kIGZsYWdzXG4gICAgbGV0IG9mZnNldCA9IDEwO1xuXG4gICAgcmV0dXJuIHsgdHlwZSwgc2l6ZSwgZGF0YTogZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHNpemUpIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBJRDMgZnJhbWVzIGZvdW5kIGluIGFsbCB0aGUgSUQzIHRhZ3MgaW4gdGhlIGlkM0RhdGFcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBpZDNEYXRhIC0gVGhlIElEMyBkYXRhIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgSUQzIHRhZ3NcbiAgICogQHJldHVybiB7SUQzIGZyYW1lW119IC0gQXJyYXkgb2YgSUQzIGZyYW1lIG9iamVjdHNcbiAgICovXG4gIHN0YXRpYyBnZXRJRDNGcmFtZXMgKGlkM0RhdGEpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBmcmFtZXMgPSBbXTtcblxuICAgIHdoaWxlIChJRDMuaXNIZWFkZXIoaWQzRGF0YSwgb2Zmc2V0KSkge1xuICAgICAgY29uc3Qgc2l6ZSA9IElEMy5fcmVhZFNpemUoaWQzRGF0YSwgb2Zmc2V0ICsgNik7XG4gICAgICAvLyBza2lwIHBhc3QgSUQzIGhlYWRlclxuICAgICAgb2Zmc2V0ICs9IDEwO1xuICAgICAgY29uc3QgZW5kID0gb2Zmc2V0ICsgc2l6ZTtcbiAgICAgIC8vIGxvb3AgdGhyb3VnaCBmcmFtZXMgaW4gdGhlIElEMyB0YWdcbiAgICAgIHdoaWxlIChvZmZzZXQgKyA4IDwgZW5kKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lRGF0YSA9IElEMy5fZ2V0RnJhbWVEYXRhKGlkM0RhdGEuc3ViYXJyYXkob2Zmc2V0KSk7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gSUQzLl9kZWNvZGVGcmFtZShmcmFtZURhdGEpO1xuICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICBmcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBza2lwIGZyYW1lIGhlYWRlciBhbmQgZnJhbWUgZGF0YVxuICAgICAgICBvZmZzZXQgKz0gZnJhbWVEYXRhLnNpemUgKyAxMDtcbiAgICAgIH1cblxuICAgICAgaWYgKElEMy5pc0Zvb3RlcihpZDNEYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIG9mZnNldCArPSAxMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnJhbWVzO1xuICB9XG5cbiAgc3RhdGljIF9kZWNvZGVGcmFtZSAoZnJhbWUpIHtcbiAgICBpZiAoZnJhbWUudHlwZSA9PT0gJ1BSSVYnKSB7XG4gICAgICByZXR1cm4gSUQzLl9kZWNvZGVQcml2RnJhbWUoZnJhbWUpO1xuICAgIH0gZWxzZSBpZiAoZnJhbWUudHlwZVswXSA9PT0gJ1QnKSB7XG4gICAgICByZXR1cm4gSUQzLl9kZWNvZGVUZXh0RnJhbWUoZnJhbWUpO1xuICAgIH0gZWxzZSBpZiAoZnJhbWUudHlwZVswXSA9PT0gJ1cnKSB7XG4gICAgICByZXR1cm4gSUQzLl9kZWNvZGVVUkxGcmFtZShmcmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHN0YXRpYyBfcmVhZFRpbWVTdGFtcCAodGltZVN0YW1wRnJhbWUpIHtcbiAgICBpZiAodGltZVN0YW1wRnJhbWUuZGF0YS5ieXRlTGVuZ3RoID09PSA4KSB7XG4gICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGltZVN0YW1wRnJhbWUuZGF0YSk7XG4gICAgICAvLyB0aW1lc3RhbXAgaXMgMzMgYml0IGV4cHJlc3NlZCBhcyBhIGJpZy1lbmRpYW4gZWlnaHQtb2N0ZXQgbnVtYmVyLFxuICAgICAgLy8gd2l0aCB0aGUgdXBwZXIgMzEgYml0cyBzZXQgdG8gemVyby5cbiAgICAgIGNvbnN0IHB0czMzQml0ID0gZGF0YVszXSAmIDB4MTtcbiAgICAgIGxldCB0aW1lc3RhbXAgPSAoZGF0YVs0XSA8PCAyMykgK1xuICAgICAgICAgICAgICAgICAgICAgIChkYXRhWzVdIDw8IDE1KSArXG4gICAgICAgICAgICAgICAgICAgICAgKGRhdGFbNl0gPDwgNykgK1xuICAgICAgICAgICAgICAgICAgICAgICBkYXRhWzddO1xuICAgICAgdGltZXN0YW1wIC89IDQ1O1xuXG4gICAgICBpZiAocHRzMzNCaXQpIHtcbiAgICAgICAgdGltZXN0YW1wICs9IDQ3NzIxODU4Ljg0O1xuICAgICAgfSAvLyAyXjMyIC8gOTBcblxuICAgICAgcmV0dXJuIE1hdGgucm91bmQodGltZXN0YW1wKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgc3RhdGljIF9kZWNvZGVQcml2RnJhbWUgKGZyYW1lKSB7XG4gICAgLypcbiAgICBGb3JtYXQ6IDx0ZXh0IHN0cmluZz5cXDA8YmluYXJ5IGRhdGE+XG4gICAgKi9cbiAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgb3duZXIgPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEsIHRydWUpO1xuICAgIGNvbnN0IHByaXZhdGVEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZnJhbWUuZGF0YS5zdWJhcnJheShvd25lci5sZW5ndGggKyAxKSk7XG5cbiAgICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGluZm86IG93bmVyLCBkYXRhOiBwcml2YXRlRGF0YS5idWZmZXIgfTtcbiAgfVxuXG4gIHN0YXRpYyBfZGVjb2RlVGV4dEZyYW1lIChmcmFtZSkge1xuICAgIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoZnJhbWUudHlwZSA9PT0gJ1RYWFgnKSB7XG4gICAgICAvKlxuICAgICAgRm9ybWF0OlxuICAgICAgWzBdICAgPSB7VGV4dCBFbmNvZGluZ31cbiAgICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtWYWx1ZX1cbiAgICAgICovXG4gICAgICBsZXQgaW5kZXggPSAxO1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcblxuICAgICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICAgIGNvbnN0IHZhbHVlID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XG5cbiAgICAgIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgaW5mbzogZGVzY3JpcHRpb24sIGRhdGE6IHZhbHVlIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qXG4gICAgICBGb3JtYXQ6XG4gICAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgICAgWzEtP10gPSB7VmFsdWV9XG4gICAgICAqL1xuICAgICAgY29uc3QgdGV4dCA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheSgxKSk7XG4gICAgICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGRhdGE6IHRleHQgfTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgX2RlY29kZVVSTEZyYW1lIChmcmFtZSkge1xuICAgIGlmIChmcmFtZS50eXBlID09PSAnV1hYWCcpIHtcbiAgICAgIC8qXG4gICAgICBGb3JtYXQ6XG4gICAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgICAgWzEtP10gPSB7RGVzY3JpcHRpb259XFwwe1VSTH1cbiAgICAgICovXG4gICAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgbGV0IGluZGV4ID0gMTtcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XG5cbiAgICAgIGluZGV4ICs9IGRlc2NyaXB0aW9uLmxlbmd0aCArIDE7XG4gICAgICBjb25zdCB2YWx1ZSA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuXG4gICAgICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGluZm86IGRlc2NyaXB0aW9uLCBkYXRhOiB2YWx1ZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvKlxuICAgICAgRm9ybWF0OlxuICAgICAgWzAtP10gPSB7VVJMfVxuICAgICAgKi9cbiAgICAgIGNvbnN0IHVybCA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YSk7XG4gICAgICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGRhdGE6IHVybCB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODkzNjk4NC91aW50OGFycmF5LXRvLXN0cmluZy1pbi1qYXZhc2NyaXB0LzIyMzczMTk3XG4gIC8vIGh0dHA6Ly93d3cub25pY29zLmNvbS9zdGFmZi9pei9hbXVzZS9qYXZhc2NyaXB0L2V4cGVydC91dGYudHh0XG4gIC8qIHV0Zi5qcyAtIFVURi04IDw9PiBVVEYtMTYgY29udmVydGlvblxuICAgKlxuICAgKiBDb3B5cmlnaHQgKEMpIDE5OTkgTWFzYW5hbyBJenVtbyA8aXpAb25pY29zLmNvLmpwPlxuICAgKiBWZXJzaW9uOiAxLjBcbiAgICogTGFzdE1vZGlmaWVkOiBEZWMgMjUgMTk5OVxuICAgKiBUaGlzIGxpYnJhcnkgaXMgZnJlZS4gIFlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXQuXG4gICAqL1xuICBzdGF0aWMgX3V0ZjhBcnJheVRvU3RyIChhcnJheSwgZXhpdE9uTnVsbCA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgIGxldCBjO1xuICAgIGxldCBjaGFyMjtcbiAgICBsZXQgY2hhcjM7XG4gICAgbGV0IG91dCA9ICcnO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgYyA9IGFycmF5W2krK107XG4gICAgICBpZiAoYyA9PT0gMHgwMCAmJiBleGl0T25OdWxsKSB7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IDB4MDAgfHwgYyA9PT0gMHgwMykge1xuICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIDMgKEVORF9PRl9URVhUKSBvciAwIChOVUxMKSB0aGVuIHNraXAgaXRcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGMgPj4gNCkge1xuICAgICAgY2FzZSAwOiBjYXNlIDE6IGNhc2UgMjogY2FzZSAzOiBjYXNlIDQ6IGNhc2UgNTogY2FzZSA2OiBjYXNlIDc6XG4gICAgICAgIC8vIDB4eHh4eHh4XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI6IGNhc2UgMTM6XG4gICAgICAgIC8vIDExMHggeHh4eCAgIDEweHggeHh4eFxuICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MUYpIDw8IDYpIHwgKGNoYXIyICYgMHgzRikpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTQ6XG4gICAgICAgIC8vIDExMTAgeHh4eCAgMTB4eCB4eHh4ICAxMHh4IHh4eHhcbiAgICAgICAgY2hhcjIgPSBhcnJheVtpKytdO1xuICAgICAgICBjaGFyMyA9IGFycmF5W2krK107XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MEYpIDw8IDEyKSB8XG4gICAgICAgICAgICAgICAgICAgICgoY2hhcjIgJiAweDNGKSA8PCA2KSB8XG4gICAgICAgICAgICAgICAgICAgICgoY2hhcjMgJiAweDNGKSA8PCAwKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufVxuXG5jb25zdCB1dGY4QXJyYXlUb1N0ciA9IElEMy5fdXRmOEFycmF5VG9TdHI7XG5cbmV4cG9ydCBkZWZhdWx0IElEMztcblxuZXhwb3J0IHsgdXRmOEFycmF5VG9TdHIgfTtcbiIsIi8qKlxuICogTVAzIGRlbXV4ZXJcbiAqL1xuaW1wb3J0IElEMyBmcm9tICcuLi9kZW11eC9pZDMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCBNcGVnQXVkaW8gZnJvbSAnLi9tcGVnYXVkaW8nO1xuXG5jbGFzcyBNUDNEZW11eGVyIHtcbiAgY29uc3RydWN0b3IgKG9ic2VydmVyLCByZW11eGVyLCBjb25maWcpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5yZW11eGVyID0gcmVtdXhlcjtcbiAgfVxuXG4gIHJlc2V0SW5pdFNlZ21lbnQgKGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbikge1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7IGNvbnRhaW5lcjogJ2F1ZGlvL21wZWcnLCB0eXBlOiAnYXVkaW8nLCBpZDogLTEsIHNlcXVlbmNlTnVtYmVyOiAwLCBpc0FBQzogZmFsc2UsIHNhbXBsZXM6IFtdLCBsZW46IDAsIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsIGR1cmF0aW9uOiBkdXJhdGlvbiwgaW5wdXRUaW1lU2NhbGU6IDkwMDAwIH07XG4gIH1cblxuICByZXNldFRpbWVTdGFtcCAoKSB7XG4gIH1cblxuICBzdGF0aWMgcHJvYmUgKGRhdGEpIHtcbiAgICAvLyBjaGVjayBpZiBkYXRhIGNvbnRhaW5zIElEMyB0aW1lc3RhbXAgYW5kIE1QRUcgc3luYyB3b3JkXG4gICAgbGV0IG9mZnNldCwgbGVuZ3RoO1xuICAgIGxldCBpZDNEYXRhID0gSUQzLmdldElEM0RhdGEoZGF0YSwgMCk7XG4gICAgaWYgKGlkM0RhdGEgJiYgSUQzLmdldFRpbWVTdGFtcChpZDNEYXRhKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBMb29rIGZvciBNUEVHIGhlYWRlciB8IDExMTEgMTExMSB8IDExMVggWFlaWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDEgYW5kIFkgb3IgWiBzaG91bGQgYmUgMVxuICAgICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyBkaWZmZXJlbnQgZnJvbSAwIChMYXllciBJIG9yIExheWVyIElJIG9yIExheWVyIElJSSlcbiAgICAgIC8vIE1vcmUgaW5mbyBodHRwOi8vd3d3Lm1wMy10ZWNoLm9yZy9wcm9ncmFtbWVyL2ZyYW1lX2hlYWRlci5odG1sXG4gICAgICBmb3IgKG9mZnNldCA9IGlkM0RhdGEubGVuZ3RoLCBsZW5ndGggPSBNYXRoLm1pbihkYXRhLmxlbmd0aCAtIDEsIG9mZnNldCArIDEwMCk7IG9mZnNldCA8IGxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICAgICAgaWYgKE1wZWdBdWRpby5wcm9iZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnTVBFRyBBdWRpbyBzeW5jIHdvcmQgZm91bmQgIScpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgYXBwZW5kIChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICBsZXQgaWQzRGF0YSA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIDApO1xuICAgIGxldCB0aW1lc3RhbXAgPSBJRDMuZ2V0VGltZVN0YW1wKGlkM0RhdGEpO1xuICAgIGxldCBwdHMgPSB0aW1lc3RhbXAgPyA5MCAqIHRpbWVzdGFtcCA6IHRpbWVPZmZzZXQgKiA5MDAwMDtcbiAgICBsZXQgb2Zmc2V0ID0gaWQzRGF0YS5sZW5ndGg7XG4gICAgbGV0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIGxldCBmcmFtZUluZGV4ID0gMCwgc3RhbXAgPSAwO1xuICAgIGxldCB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG5cbiAgICBsZXQgaWQzU2FtcGxlcyA9IFt7IHB0czogcHRzLCBkdHM6IHB0cywgZGF0YTogaWQzRGF0YSB9XTtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgIGlmIChNcGVnQXVkaW8uaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBsZXQgZnJhbWUgPSBNcGVnQXVkaW8uYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICBzdGFtcCA9IGZyYW1lLnNhbXBsZS5wdHM7XG4gICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBNcGVnIGF1ZGlvIGZyYW1lJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoSUQzLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgaWQzRGF0YSA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIG9mZnNldCk7XG4gICAgICAgIGlkM1NhbXBsZXMucHVzaCh7IHB0czogc3RhbXAsIGR0czogc3RhbXAsIGRhdGE6IGlkM0RhdGEgfSk7XG4gICAgICAgIG9mZnNldCArPSBpZDNEYXRhLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlbXV4ZXIucmVtdXgodHJhY2ssXG4gICAgICB7IHNhbXBsZXM6IFtdIH0sXG4gICAgICB7IHNhbXBsZXM6IGlkM1NhbXBsZXMsIGlucHV0VGltZVNjYWxlOiA5MDAwMCB9LFxuICAgICAgeyBzYW1wbGVzOiBbXSB9LFxuICAgICAgdGltZU9mZnNldCxcbiAgICAgIGNvbnRpZ3VvdXMsXG4gICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTVAzRGVtdXhlcjtcbiIsIi8qKlxuICogTVA0IGRlbXV4ZXJcbiAqL1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuXG5jb25zdCBVSU5UMzJfTUFYID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcblxuY2xhc3MgTVA0RGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yIChvYnNlcnZlciwgcmVtdXhlcikge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLnJlbXV4ZXIgPSByZW11eGVyO1xuICB9XG5cbiAgcmVzZXRUaW1lU3RhbXAgKGluaXRQVFMpIHtcbiAgICB0aGlzLmluaXRQVFMgPSBpbml0UFRTO1xuICB9XG5cbiAgcmVzZXRJbml0U2VnbWVudCAoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XG4gICAgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICAgIGlmIChpbml0U2VnbWVudCAmJiBpbml0U2VnbWVudC5ieXRlTGVuZ3RoKSB7XG4gICAgICBjb25zdCBpbml0RGF0YSA9IHRoaXMuaW5pdERhdGEgPSBNUDREZW11eGVyLnBhcnNlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpO1xuXG4gICAgICAvLyBkZWZhdWx0IGF1ZGlvIGNvZGVjIGlmIG5vdGhpbmcgc3BlY2lmaWVkXG4gICAgICAvLyBUT0RPIDogZXh0cmFjdCB0aGF0IGZyb20gaW5pdHNlZ21lbnRcbiAgICAgIGlmIChhdWRpb0NvZGVjID09IG51bGwpIHtcbiAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgfVxuXG4gICAgICBpZiAodmlkZW9Db2RlYyA9PSBudWxsKSB7XG4gICAgICAgIHZpZGVvQ29kZWMgPSAnYXZjMS40MmUwMWUnO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0cmFja3MgPSB7fTtcbiAgICAgIGlmIChpbml0RGF0YS5hdWRpbyAmJiBpbml0RGF0YS52aWRlbykge1xuICAgICAgICB0cmFja3MuYXVkaW92aWRlbyA9IHsgY29udGFpbmVyOiAndmlkZW8vbXA0JywgY29kZWM6IGF1ZGlvQ29kZWMgKyAnLCcgKyB2aWRlb0NvZGVjLCBpbml0U2VnbWVudDogZHVyYXRpb24gPyBpbml0U2VnbWVudCA6IG51bGwgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbml0RGF0YS5hdWRpbykge1xuICAgICAgICAgIHRyYWNrcy5hdWRpbyA9IHsgY29udGFpbmVyOiAnYXVkaW8vbXA0JywgY29kZWM6IGF1ZGlvQ29kZWMsIGluaXRTZWdtZW50OiBkdXJhdGlvbiA/IGluaXRTZWdtZW50IDogbnVsbCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluaXREYXRhLnZpZGVvKSB7XG4gICAgICAgICAgdHJhY2tzLnZpZGVvID0geyBjb250YWluZXI6ICd2aWRlby9tcDQnLCBjb2RlYzogdmlkZW9Db2RlYywgaW5pdFNlZ21lbnQ6IGR1cmF0aW9uID8gaW5pdFNlZ21lbnQgOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCB7IHRyYWNrcyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICAgIH1cblxuICAgICAgaWYgKHZpZGVvQ29kZWMpIHtcbiAgICAgICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcHJvYmUgKGRhdGEpIHtcbiAgICAvLyBlbnN1cmUgd2UgZmluZCBhIG1vb2YgYm94IGluIHRoZSBmaXJzdCAxNiBrQlxuICAgIHJldHVybiBNUDREZW11eGVyLmZpbmRCb3goeyBkYXRhOiBkYXRhLCBzdGFydDogMCwgZW5kOiBNYXRoLm1pbihkYXRhLmxlbmd0aCwgMTYzODQpIH0sIFsnbW9vZiddKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgc3RhdGljIGJpbjJzdHIgKGJ1ZmZlcikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ1ZmZlcik7XG4gIH1cblxuICBzdGF0aWMgcmVhZFVpbnQxNiAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICBpZiAoYnVmZmVyLmRhdGEpIHtcbiAgICAgIG9mZnNldCArPSBidWZmZXIuc3RhcnQ7XG4gICAgICBidWZmZXIgPSBidWZmZXIuZGF0YTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWwgPSBidWZmZXJbb2Zmc2V0XSA8PCA4IHxcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMV07XG5cbiAgICByZXR1cm4gdmFsIDwgMCA/IDY1NTM2ICsgdmFsIDogdmFsO1xuICB9XG5cbiAgc3RhdGljIHJlYWRVaW50MzIgKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgaWYgKGJ1ZmZlci5kYXRhKSB7XG4gICAgICBvZmZzZXQgKz0gYnVmZmVyLnN0YXJ0O1xuICAgICAgYnVmZmVyID0gYnVmZmVyLmRhdGE7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsID0gYnVmZmVyW29mZnNldF0gPDwgMjQgfFxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAxXSA8PCAxNiB8XG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIDJdIDw8IDggfFxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAzXTtcbiAgICByZXR1cm4gdmFsIDwgMCA/IDQyOTQ5NjcyOTYgKyB2YWwgOiB2YWw7XG4gIH1cblxuICBzdGF0aWMgd3JpdGVVaW50MzIgKGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgIGlmIChidWZmZXIuZGF0YSkge1xuICAgICAgb2Zmc2V0ICs9IGJ1ZmZlci5zdGFydDtcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5kYXRhO1xuICAgIH1cbiAgICBidWZmZXJbb2Zmc2V0XSA9IHZhbHVlID4+IDI0O1xuICAgIGJ1ZmZlcltvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlcltvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW29mZnNldCArIDNdID0gdmFsdWUgJiAweGZmO1xuICB9XG5cbiAgLy8gRmluZCB0aGUgZGF0YSBmb3IgYSBib3ggc3BlY2lmaWVkIGJ5IGl0cyBwYXRoXG4gIHN0YXRpYyBmaW5kQm94IChkYXRhLCBwYXRoKSB7XG4gICAgbGV0IHJlc3VsdHMgPSBbXSxcbiAgICAgIGksIHNpemUsIHR5cGUsIGVuZCwgc3VicmVzdWx0cywgc3RhcnQsIGVuZGJveDtcblxuICAgIGlmIChkYXRhLmRhdGEpIHtcbiAgICAgIHN0YXJ0ID0gZGF0YS5zdGFydDtcbiAgICAgIGVuZCA9IGRhdGEuZW5kO1xuICAgICAgZGF0YSA9IGRhdGEuZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgZW5kID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICghcGF0aC5sZW5ndGgpIHtcbiAgICAgIC8vIHNob3J0LWNpcmN1aXQgdGhlIHNlYXJjaCBmb3IgZW1wdHkgcGF0aHNcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOykge1xuICAgICAgc2l6ZSA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMihkYXRhLCBpKTtcbiAgICAgIHR5cGUgPSBNUDREZW11eGVyLmJpbjJzdHIoZGF0YS5zdWJhcnJheShpICsgNCwgaSArIDgpKTtcbiAgICAgIGVuZGJveCA9IHNpemUgPiAxID8gaSArIHNpemUgOiBlbmQ7XG5cbiAgICAgIGlmICh0eXBlID09PSBwYXRoWzBdKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgcGF0aCBhbmQgd2UndmUgZm91bmQgdGhlIGJveCB3ZSB3ZXJlXG4gICAgICAgICAgLy8gbG9va2luZyBmb3JcbiAgICAgICAgICByZXN1bHRzLnB1c2goeyBkYXRhOiBkYXRhLCBzdGFydDogaSArIDgsIGVuZDogZW5kYm94IH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgdGhlIG5leHQgYm94IGFsb25nIHRoZSBwYXRoXG4gICAgICAgICAgc3VicmVzdWx0cyA9IE1QNERlbXV4ZXIuZmluZEJveCh7IGRhdGE6IGRhdGEsIHN0YXJ0OiBpICsgOCwgZW5kOiBlbmRib3ggfSwgcGF0aC5zbGljZSgxKSk7XG4gICAgICAgICAgaWYgKHN1YnJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQoc3VicmVzdWx0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpID0gZW5kYm94O1xuICAgIH1cblxuICAgIC8vIHdlJ3ZlIGZpbmlzaGVkIHNlYXJjaGluZyBhbGwgb2YgZGF0YVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlU2VnbWVudEluZGV4IChpbml0U2VnbWVudCkge1xuICAgIGNvbnN0IG1vb3YgPSBNUDREZW11eGVyLmZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdiddKVswXTtcbiAgICBjb25zdCBtb292RW5kT2Zmc2V0ID0gbW9vdiA/IG1vb3YuZW5kIDogbnVsbDsgLy8gd2UgbmVlZCB0aGlzIGluIGNhc2Ugd2UgbmVlZCB0byBjaG9wIG9mIGdhcmJhZ2Ugb2YgdGhlIGVuZCBvZiBjdXJyZW50IGRhdGFcblxuICAgIGxldCBpbmRleCA9IDA7XG4gICAgbGV0IHNpZHggPSBNUDREZW11eGVyLmZpbmRCb3goaW5pdFNlZ21lbnQsIFsnc2lkeCddKTtcbiAgICBsZXQgcmVmZXJlbmNlcztcblxuICAgIGlmICghc2lkeCB8fCAhc2lkeFswXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmVmZXJlbmNlcyA9IFtdO1xuICAgIHNpZHggPSBzaWR4WzBdO1xuXG4gICAgY29uc3QgdmVyc2lvbiA9IHNpZHguZGF0YVswXTtcblxuICAgIC8vIHNldCBpbml0aWFsIG9mZnNldCwgd2Ugc2tpcCB0aGUgcmVmZXJlbmNlIElEIChub3QgbmVlZGVkKVxuICAgIGluZGV4ID0gdmVyc2lvbiA9PT0gMCA/IDggOiAxNjtcblxuICAgIGNvbnN0IHRpbWVzY2FsZSA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMihzaWR4LCBpbmRleCk7XG4gICAgaW5kZXggKz0gNDtcblxuICAgIC8vIFRPRE86IHBhcnNlIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSBhbmQgZmlyc3RPZmZzZXRcbiAgICAvLyB1c3VhbGx5IHplcm8gaW4gb3VyIGNhc2VcbiAgICBsZXQgZWFybGllc3RQcmVzZW50YXRpb25UaW1lID0gMDtcbiAgICBsZXQgZmlyc3RPZmZzZXQgPSAwO1xuXG4gICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgIGluZGV4ICs9IDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4ICs9IDE2O1xuICAgIH1cblxuICAgIC8vIHNraXAgcmVzZXJ2ZWRcbiAgICBpbmRleCArPSAyO1xuXG4gICAgbGV0IHN0YXJ0Qnl0ZSA9IHNpZHguZW5kICsgZmlyc3RPZmZzZXQ7XG5cbiAgICBjb25zdCByZWZlcmVuY2VzQ291bnQgPSBNUDREZW11eGVyLnJlYWRVaW50MTYoc2lkeCwgaW5kZXgpO1xuICAgIGluZGV4ICs9IDI7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZmVyZW5jZXNDb3VudDsgaSsrKSB7XG4gICAgICBsZXQgcmVmZXJlbmNlSW5kZXggPSBpbmRleDtcblxuICAgICAgY29uc3QgcmVmZXJlbmNlSW5mbyA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMihzaWR4LCByZWZlcmVuY2VJbmRleCk7XG4gICAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuXG4gICAgICBjb25zdCByZWZlcmVuY2VTaXplID0gcmVmZXJlbmNlSW5mbyAmIDB4N0ZGRkZGRkY7XG4gICAgICBjb25zdCByZWZlcmVuY2VUeXBlID0gKHJlZmVyZW5jZUluZm8gJiAweDgwMDAwMDAwKSA+Pj4gMzE7XG5cbiAgICAgIGlmIChyZWZlcmVuY2VUeXBlID09PSAxKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignU0lEWCBoYXMgaGllcmFyY2hpY2FsIHJlZmVyZW5jZXMgKG5vdCBzdXBwb3J0ZWQpJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3Vic2VnbWVudER1cmF0aW9uID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHNpZHgsIHJlZmVyZW5jZUluZGV4KTtcbiAgICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG5cbiAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgIHJlZmVyZW5jZVNpemUsXG4gICAgICAgIHN1YnNlZ21lbnREdXJhdGlvbiwgLy8gdW5zY2FsZWRcbiAgICAgICAgaW5mbzoge1xuICAgICAgICAgIGR1cmF0aW9uOiBzdWJzZWdtZW50RHVyYXRpb24gLyB0aW1lc2NhbGUsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0Qnl0ZSxcbiAgICAgICAgICBlbmQ6IHN0YXJ0Qnl0ZSArIHJlZmVyZW5jZVNpemUgLSAxXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBzdGFydEJ5dGUgKz0gcmVmZXJlbmNlU2l6ZTtcblxuICAgICAgLy8gU2tpcHBpbmcgMSBiaXQgZm9yIHxzdGFydHNXaXRoU2FwfCwgMyBiaXRzIGZvciB8c2FwVHlwZXwsIGFuZCAyOCBiaXRzXG4gICAgICAvLyBmb3IgfHNhcERlbHRhfC5cbiAgICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG5cbiAgICAgIC8vIHNraXAgdG8gbmV4dCByZWZcbiAgICAgIGluZGV4ID0gcmVmZXJlbmNlSW5kZXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSxcbiAgICAgIHRpbWVzY2FsZSxcbiAgICAgIHZlcnNpb24sXG4gICAgICByZWZlcmVuY2VzQ291bnQsXG4gICAgICByZWZlcmVuY2VzLFxuICAgICAgbW9vdkVuZE9mZnNldFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIE1QNCBpbml0aWFsaXphdGlvbiBzZWdtZW50IGFuZCBleHRyYWN0cyBzdHJlYW0gdHlwZSBhbmRcbiAgICogdGltZXNjYWxlIHZhbHVlcyBmb3IgYW55IGRlY2xhcmVkIHRyYWNrcy4gVGltZXNjYWxlIHZhbHVlcyBpbmRpY2F0ZSB0aGVcbiAgICogbnVtYmVyIG9mIGNsb2NrIHRpY2tzIHBlciBzZWNvbmQgdG8gYXNzdW1lIGZvciB0aW1lLWJhc2VkIHZhbHVlc1xuICAgKiBlbHNld2hlcmUgaW4gdGhlIE1QNC5cbiAgICpcbiAgICogVG8gZGV0ZXJtaW5lIHRoZSBzdGFydCB0aW1lIG9mIGFuIE1QNCwgeW91IG5lZWQgdHdvIHBpZWNlcyBvZlxuICAgKiBpbmZvcm1hdGlvbjogdGhlIHRpbWVzY2FsZSB1bml0IGFuZCB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGVcbiAgICogdGltZS4gTXVsdGlwbGUgdGltZXNjYWxlcyBjYW4gYmUgc3BlY2lmaWVkIHdpdGhpbiBhbiBNUDQgYnV0IHRoZVxuICAgKiBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGlzIGFsd2F5cyBleHByZXNzZWQgaW4gdGhlIHRpbWVzY2FsZSBmcm9tXG4gICAqIHRoZSBtZWRpYSBoZWFkZXIgYm94IGZvciB0aGUgdHJhY2s6XG4gICAqIGBgYFxuICAgKiBtb292ID4gdHJhayA+IG1kaWEgPiBtZGhkLnRpbWVzY2FsZVxuICAgKiBtb292ID4gdHJhayA+IG1kaWEgPiBoZGxyXG4gICAqIGBgYFxuICAgKiBAcGFyYW0gaW5pdCB7VWludDhBcnJheX0gdGhlIGJ5dGVzIG9mIHRoZSBpbml0IHNlZ21lbnRcbiAgICogQHJldHVybiB7b2JqZWN0fSBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzIG9yIG51bGwgaWZcbiAgICogdGhlIGluaXQgc2VnbWVudCBpcyBtYWxmb3JtZWQuXG4gICAqL1xuICBzdGF0aWMgcGFyc2VJbml0U2VnbWVudCAoaW5pdFNlZ21lbnQpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgbGV0IHRyYWtzID0gTVA0RGVtdXhlci5maW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnLCAndHJhayddKTtcblxuICAgIHRyYWtzLmZvckVhY2godHJhayA9PiB7XG4gICAgICBjb25zdCB0a2hkID0gTVA0RGVtdXhlci5maW5kQm94KHRyYWssIFsndGtoZCddKVswXTtcbiAgICAgIGlmICh0a2hkKSB7XG4gICAgICAgIGxldCB2ZXJzaW9uID0gdGtoZC5kYXRhW3RraGQuc3RhcnRdO1xuICAgICAgICBsZXQgaW5kZXggPSB2ZXJzaW9uID09PSAwID8gMTIgOiAyMDtcbiAgICAgICAgbGV0IHRyYWNrSWQgPSBNUDREZW11eGVyLnJlYWRVaW50MzIodGtoZCwgaW5kZXgpO1xuXG4gICAgICAgIGNvbnN0IG1kaGQgPSBNUDREZW11eGVyLmZpbmRCb3godHJhaywgWydtZGlhJywgJ21kaGQnXSlbMF07XG4gICAgICAgIGlmIChtZGhkKSB7XG4gICAgICAgICAgdmVyc2lvbiA9IG1kaGQuZGF0YVttZGhkLnN0YXJ0XTtcbiAgICAgICAgICBpbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xuICAgICAgICAgIGNvbnN0IHRpbWVzY2FsZSA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMihtZGhkLCBpbmRleCk7XG5cbiAgICAgICAgICBjb25zdCBoZGxyID0gTVA0RGVtdXhlci5maW5kQm94KHRyYWssIFsnbWRpYScsICdoZGxyJ10pWzBdO1xuICAgICAgICAgIGlmIChoZGxyKSB7XG4gICAgICAgICAgICBjb25zdCBoZGxyVHlwZSA9IE1QNERlbXV4ZXIuYmluMnN0cihoZGxyLmRhdGEuc3ViYXJyYXkoaGRsci5zdGFydCArIDgsIGhkbHIuc3RhcnQgKyAxMikpO1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB7ICdzb3VuJzogJ2F1ZGlvJywgJ3ZpZGUnOiAndmlkZW8nIH1baGRsclR5cGVdO1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgLy8gZXh0cmFjdCBjb2RlYyBpbmZvLiBUT0RPIDogcGFyc2UgY29kZWMgZGV0YWlscyB0byBiZSBhYmxlIHRvIGJ1aWxkIE1JTUUgdHlwZVxuICAgICAgICAgICAgICBsZXQgY29kZWNCb3ggPSBNUDREZW11eGVyLmZpbmRCb3godHJhaywgWydtZGlhJywgJ21pbmYnLCAnc3RibCcsICdzdHNkJ10pO1xuICAgICAgICAgICAgICBpZiAoY29kZWNCb3gubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29kZWNCb3ggPSBjb2RlY0JveFswXTtcbiAgICAgICAgICAgICAgICBsZXQgY29kZWNUeXBlID0gTVA0RGVtdXhlci5iaW4yc3RyKGNvZGVjQm94LmRhdGEuc3ViYXJyYXkoY29kZWNCb3guc3RhcnQgKyAxMiwgY29kZWNCb3guc3RhcnQgKyAxNikpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYE1QNERlbXV4ZXI6JHt0eXBlfToke2NvZGVjVHlwZX0gZm91bmRgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHRbdHJhY2tJZF0gPSB7IHRpbWVzY2FsZTogdGltZXNjYWxlLCB0eXBlOiB0eXBlIH07XG4gICAgICAgICAgICAgIHJlc3VsdFt0eXBlXSA9IHsgdGltZXNjYWxlOiB0aW1lc2NhbGUsIGlkOiB0cmFja0lkIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICogRGV0ZXJtaW5lIHRoZSBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lLCBpbiBzZWNvbmRzLCBmb3IgYW4gTVA0XG4gKiBmcmFnbWVudC4gSWYgbXVsdGlwbGUgZnJhZ21lbnRzIGFyZSBzcGVjaWZpZWQsIHRoZSBlYXJsaWVzdCB0aW1lIGlzXG4gKiByZXR1cm5lZC5cbiAqXG4gKiBUaGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBjYW4gYmUgcGFyc2VkIGZyb20gdHJhY2sgZnJhZ21lbnRcbiAqIG1ldGFkYXRhOlxuICogYGBgXG4gKiBtb29mID4gdHJhZiA+IHRmZHQuYmFzZU1lZGlhRGVjb2RlVGltZVxuICogYGBgXG4gKiBJdCByZXF1aXJlcyB0aGUgdGltZXNjYWxlIHZhbHVlIGZyb20gdGhlIG1kaGQgdG8gaW50ZXJwcmV0LlxuICpcbiAqIEBwYXJhbSB0aW1lc2NhbGUge29iamVjdH0gYSBoYXNoIG9mIHRyYWNrIGlkcyB0byB0aW1lc2NhbGUgdmFsdWVzLlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSBmb3IgdGhlXG4gKiBmcmFnbWVudCwgaW4gc2Vjb25kc1xuICovXG4gIHN0YXRpYyBnZXRTdGFydERUUyAoaW5pdERhdGEsIGZyYWdtZW50KSB7XG4gICAgbGV0IHRyYWZzLCBiYXNlVGltZXMsIHJlc3VsdDtcblxuICAgIC8vIHdlIG5lZWQgaW5mbyBmcm9tIHR3byBjaGlsZHJlbmQgb2YgZWFjaCB0cmFjayBmcmFnbWVudCBib3hcbiAgICB0cmFmcyA9IE1QNERlbXV4ZXIuZmluZEJveChmcmFnbWVudCwgWydtb29mJywgJ3RyYWYnXSk7XG5cbiAgICAvLyBkZXRlcm1pbmUgdGhlIHN0YXJ0IHRpbWVzIGZvciBlYWNoIHRyYWNrXG4gICAgYmFzZVRpbWVzID0gW10uY29uY2F0LmFwcGx5KFtdLCB0cmFmcy5tYXAoZnVuY3Rpb24gKHRyYWYpIHtcbiAgICAgIHJldHVybiBNUDREZW11eGVyLmZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLm1hcChmdW5jdGlvbiAodGZoZCkge1xuICAgICAgICBsZXQgaWQsIHNjYWxlLCBiYXNlVGltZTtcblxuICAgICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgICAgaWQgPSBNUDREZW11eGVyLnJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgICAgIC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXG4gICAgICAgIHNjYWxlID0gaW5pdERhdGFbaWRdLnRpbWVzY2FsZSB8fCA5MGUzO1xuXG4gICAgICAgIC8vIGdldCB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBmcm9tIHRoZSB0ZmR0XG4gICAgICAgIGJhc2VUaW1lID0gTVA0RGVtdXhlci5maW5kQm94KHRyYWYsIFsndGZkdCddKS5tYXAoZnVuY3Rpb24gKHRmZHQpIHtcbiAgICAgICAgICBsZXQgdmVyc2lvbiwgcmVzdWx0O1xuXG4gICAgICAgICAgdmVyc2lvbiA9IHRmZHQuZGF0YVt0ZmR0LnN0YXJ0XTtcbiAgICAgICAgICByZXN1bHQgPSBNUDREZW11eGVyLnJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgICAgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdCAqPSBNYXRoLnBvdygyLCAzMik7XG5cbiAgICAgICAgICAgIHJlc3VsdCArPSBNUDREZW11eGVyLnJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pWzBdO1xuICAgICAgICAvLyBjb252ZXJ0IGJhc2UgdGltZSB0byBzZWNvbmRzXG4gICAgICAgIHJldHVybiBiYXNlVGltZSAvIHNjYWxlO1xuICAgICAgfSk7XG4gICAgfSkpO1xuXG4gICAgLy8gcmV0dXJuIHRoZSBtaW5pbXVtXG4gICAgcmVzdWx0ID0gTWF0aC5taW4uYXBwbHkobnVsbCwgYmFzZVRpbWVzKTtcbiAgICByZXR1cm4gaXNGaW5pdGUocmVzdWx0KSA/IHJlc3VsdCA6IDA7XG4gIH1cblxuICBzdGF0aWMgb2Zmc2V0U3RhcnREVFMgKGluaXREYXRhLCBmcmFnbWVudCwgdGltZU9mZnNldCkge1xuICAgIE1QNERlbXV4ZXIuZmluZEJveChmcmFnbWVudCwgWydtb29mJywgJ3RyYWYnXSkubWFwKGZ1bmN0aW9uICh0cmFmKSB7XG4gICAgICByZXR1cm4gTVA0RGVtdXhlci5maW5kQm94KHRyYWYsIFsndGZoZCddKS5tYXAoZnVuY3Rpb24gKHRmaGQpIHtcbiAgICAgIC8vIGdldCB0aGUgdHJhY2sgaWQgZnJvbSB0aGUgdGZoZFxuICAgICAgICBsZXQgaWQgPSBNUDREZW11eGVyLnJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgICAgIC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXG4gICAgICAgIGxldCB0aW1lc2NhbGUgPSBpbml0RGF0YVtpZF0udGltZXNjYWxlIHx8IDkwZTM7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGZyb20gdGhlIHRmZHRcbiAgICAgICAgTVA0RGVtdXhlci5maW5kQm94KHRyYWYsIFsndGZkdCddKS5tYXAoZnVuY3Rpb24gKHRmZHQpIHtcbiAgICAgICAgICBsZXQgdmVyc2lvbiA9IHRmZHQuZGF0YVt0ZmR0LnN0YXJ0XTtcbiAgICAgICAgICBsZXQgYmFzZU1lZGlhRGVjb2RlVGltZSA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmR0LCA0KTtcbiAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgTVA0RGVtdXhlci53cml0ZVVpbnQzMih0ZmR0LCA0LCBiYXNlTWVkaWFEZWNvZGVUaW1lIC0gdGltZU9mZnNldCAqIHRpbWVzY2FsZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgKj0gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSArPSBNUDREZW11eGVyLnJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lIC09IHRpbWVPZmZzZXQgKiB0aW1lc2NhbGU7XG4gICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5tYXgoYmFzZU1lZGlhRGVjb2RlVGltZSwgMCk7XG4gICAgICAgICAgICBjb25zdCB1cHBlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgICAgICAgY29uc3QgbG93ZXIgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICAgICAgICAgIE1QNERlbXV4ZXIud3JpdGVVaW50MzIodGZkdCwgNCwgdXBwZXIpO1xuICAgICAgICAgICAgTVA0RGVtdXhlci53cml0ZVVpbnQzMih0ZmR0LCA4LCBsb3dlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICBhcHBlbmQgKGRhdGEsIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIGxldCBpbml0RGF0YSA9IHRoaXMuaW5pdERhdGE7XG4gICAgaWYgKCFpbml0RGF0YSkge1xuICAgICAgdGhpcy5yZXNldEluaXRTZWdtZW50KGRhdGEsIHRoaXMuYXVkaW9Db2RlYywgdGhpcy52aWRlb0NvZGVjLCBmYWxzZSk7XG4gICAgICBpbml0RGF0YSA9IHRoaXMuaW5pdERhdGE7XG4gICAgfVxuICAgIGxldCBzdGFydERUUywgaW5pdFBUUyA9IHRoaXMuaW5pdFBUUztcbiAgICBpZiAoaW5pdFBUUyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgc3RhcnREVFMgPSBNUDREZW11eGVyLmdldFN0YXJ0RFRTKGluaXREYXRhLCBkYXRhKTtcbiAgICAgIHRoaXMuaW5pdFBUUyA9IGluaXRQVFMgPSBzdGFydERUUyAtIHRpbWVPZmZzZXQ7XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuSU5JVF9QVFNfRk9VTkQsIHsgaW5pdFBUUzogaW5pdFBUUyB9KTtcbiAgICB9XG4gICAgTVA0RGVtdXhlci5vZmZzZXRTdGFydERUUyhpbml0RGF0YSwgZGF0YSwgaW5pdFBUUyk7XG4gICAgc3RhcnREVFMgPSBNUDREZW11eGVyLmdldFN0YXJ0RFRTKGluaXREYXRhLCBkYXRhKTtcbiAgICB0aGlzLnJlbXV4ZXIucmVtdXgoaW5pdERhdGEuYXVkaW8sIGluaXREYXRhLnZpZGVvLCBudWxsLCBudWxsLCBzdGFydERUUywgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkYXRhKTtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTVA0RGVtdXhlcjtcbiIsIi8qKlxuICogIE1QRUcgcGFyc2VyIGhlbHBlclxuICovXG5cbmNvbnN0IE1wZWdBdWRpbyA9IHtcblxuICBCaXRyYXRlc01hcDogW1xuICAgIDMyLCA2NCwgOTYsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAyODgsIDMyMCwgMzUyLCAzODQsIDQxNiwgNDQ4LFxuICAgIDMyLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCwgMzg0LFxuICAgIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsXG4gICAgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwLCAxNzYsIDE5MiwgMjI0LCAyNTYsXG4gICAgOCwgMTYsIDI0LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwXSxcblxuICBTYW1wbGluZ1JhdGVNYXA6IFs0NDEwMCwgNDgwMDAsIDMyMDAwLCAyMjA1MCwgMjQwMDAsIDE2MDAwLCAxMTAyNSwgMTIwMDAsIDgwMDBdLFxuXG4gIFNhbXBsZXNDb2VmZmljaWVudHM6IFtcbiAgICAvLyBNUEVHIDIuNVxuICAgIFtcbiAgICAgIDAsIC8vIFJlc2VydmVkXG4gICAgICA3MiwgLy8gTGF5ZXIzXG4gICAgICAxNDQsIC8vIExheWVyMlxuICAgICAgMTIgLy8gTGF5ZXIxXG4gICAgXSxcbiAgICAvLyBSZXNlcnZlZFxuICAgIFtcbiAgICAgIDAsIC8vIFJlc2VydmVkXG4gICAgICAwLCAvLyBMYXllcjNcbiAgICAgIDAsIC8vIExheWVyMlxuICAgICAgMCAvLyBMYXllcjFcbiAgICBdLFxuICAgIC8vIE1QRUcgMlxuICAgIFtcbiAgICAgIDAsIC8vIFJlc2VydmVkXG4gICAgICA3MiwgLy8gTGF5ZXIzXG4gICAgICAxNDQsIC8vIExheWVyMlxuICAgICAgMTIgLy8gTGF5ZXIxXG4gICAgXSxcbiAgICAvLyBNUEVHIDFcbiAgICBbXG4gICAgICAwLCAvLyBSZXNlcnZlZFxuICAgICAgMTQ0LCAvLyBMYXllcjNcbiAgICAgIDE0NCwgLy8gTGF5ZXIyXG4gICAgICAxMiAvLyBMYXllcjFcbiAgICBdXG4gIF0sXG5cbiAgQnl0ZXNJblNsb3Q6IFtcbiAgICAwLCAvLyBSZXNlcnZlZFxuICAgIDEsIC8vIExheWVyM1xuICAgIDEsIC8vIExheWVyMlxuICAgIDQgLy8gTGF5ZXIxXG4gIF0sXG5cbiAgYXBwZW5kRnJhbWU6IGZ1bmN0aW9uICh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpIHtcbiAgICAvLyBVc2luZyBodHRwOi8vd3d3LmRhdGF2b3lhZ2UuY29tL21wZ3NjcmlwdC9tcGVnaGRyLmh0bSBhcyBhIHJlZmVyZW5jZVxuICAgIGlmIChvZmZzZXQgKyAyNCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGxldCBoZWFkZXIgPSB0aGlzLnBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gICAgaWYgKGhlYWRlciAmJiBvZmZzZXQgKyBoZWFkZXIuZnJhbWVMZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIGxldCBmcmFtZUR1cmF0aW9uID0gaGVhZGVyLnNhbXBsZXNQZXJGcmFtZSAqIDkwMDAwIC8gaGVhZGVyLnNhbXBsZVJhdGU7XG4gICAgICBsZXQgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICAgIGxldCBzYW1wbGUgPSB7IHVuaXQ6IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBoZWFkZXIuZnJhbWVMZW5ndGgpLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wIH07XG5cbiAgICAgIHRyYWNrLmNvbmZpZyA9IFtdO1xuICAgICAgdHJhY2suY2hhbm5lbENvdW50ID0gaGVhZGVyLmNoYW5uZWxDb3VudDtcbiAgICAgIHRyYWNrLnNhbXBsZXJhdGUgPSBoZWFkZXIuc2FtcGxlUmF0ZTtcbiAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChzYW1wbGUpO1xuICAgICAgdHJhY2subGVuICs9IGhlYWRlci5mcmFtZUxlbmd0aDtcblxuICAgICAgcmV0dXJuIHsgc2FtcGxlLCBsZW5ndGg6IGhlYWRlci5mcmFtZUxlbmd0aCB9O1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgcGFyc2VIZWFkZXI6IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcbiAgICBsZXQgaGVhZGVyQiA9IChkYXRhW29mZnNldCArIDFdID4+IDMpICYgMztcbiAgICBsZXQgaGVhZGVyQyA9IChkYXRhW29mZnNldCArIDFdID4+IDEpICYgMztcbiAgICBsZXQgaGVhZGVyRSA9IChkYXRhW29mZnNldCArIDJdID4+IDQpICYgMTU7XG4gICAgbGV0IGhlYWRlckYgPSAoZGF0YVtvZmZzZXQgKyAyXSA+PiAyKSAmIDM7XG4gICAgbGV0IGhlYWRlckcgPSAoZGF0YVtvZmZzZXQgKyAyXSA+PiAxKSAmIDE7XG4gICAgaWYgKGhlYWRlckIgIT09IDEgJiYgaGVhZGVyRSAhPT0gMCAmJiBoZWFkZXJFICE9PSAxNSAmJiBoZWFkZXJGICE9PSAzKSB7XG4gICAgICBsZXQgY29sdW1uSW5CaXRyYXRlcyA9IGhlYWRlckIgPT09IDMgPyAoMyAtIGhlYWRlckMpIDogKGhlYWRlckMgPT09IDMgPyAzIDogNCk7XG4gICAgICBsZXQgYml0UmF0ZSA9IE1wZWdBdWRpby5CaXRyYXRlc01hcFtjb2x1bW5JbkJpdHJhdGVzICogMTQgKyBoZWFkZXJFIC0gMV0gKiAxMDAwO1xuICAgICAgbGV0IGNvbHVtbkluU2FtcGxlUmF0ZXMgPSBoZWFkZXJCID09PSAzID8gMCA6IGhlYWRlckIgPT09IDIgPyAxIDogMjtcbiAgICAgIGxldCBzYW1wbGVSYXRlID0gTXBlZ0F1ZGlvLlNhbXBsaW5nUmF0ZU1hcFtjb2x1bW5JblNhbXBsZVJhdGVzICogMyArIGhlYWRlckZdO1xuICAgICAgbGV0IGNoYW5uZWxDb3VudCA9IGRhdGFbb2Zmc2V0ICsgM10gPj4gNiA9PT0gMyA/IDEgOiAyOyAvLyBJZiBiaXRzIG9mIGNoYW5uZWwgbW9kZSBhcmUgYDExYCB0aGVuIGl0IGlzIGEgc2luZ2xlIGNoYW5uZWwgKE1vbm8pXG4gICAgICBsZXQgc2FtcGxlQ29lZmZpY2llbnQgPSBNcGVnQXVkaW8uU2FtcGxlc0NvZWZmaWNpZW50c1toZWFkZXJCXVtoZWFkZXJDXTtcbiAgICAgIGxldCBieXRlc0luU2xvdCA9IE1wZWdBdWRpby5CeXRlc0luU2xvdFtoZWFkZXJDXTtcbiAgICAgIGxldCBzYW1wbGVzUGVyRnJhbWUgPSBzYW1wbGVDb2VmZmljaWVudCAqIDggKiBieXRlc0luU2xvdDtcbiAgICAgIGxldCBmcmFtZUxlbmd0aCA9IHBhcnNlSW50KHNhbXBsZUNvZWZmaWNpZW50ICogYml0UmF0ZSAvIHNhbXBsZVJhdGUgKyBoZWFkZXJHLCAxMCkgKiBieXRlc0luU2xvdDtcblxuICAgICAgcmV0dXJuIHsgc2FtcGxlUmF0ZSwgY2hhbm5lbENvdW50LCBmcmFtZUxlbmd0aCwgc2FtcGxlc1BlckZyYW1lIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSxcblxuICBpc0hlYWRlclBhdHRlcm46IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVtvZmZzZXRdID09PSAweGZmICYmIChkYXRhW29mZnNldCArIDFdICYgMHhlMCkgPT09IDB4ZTAgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDA2KSAhPT0gMHgwMDtcbiAgfSxcblxuICBpc0hlYWRlcjogZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgIC8vIExvb2sgZm9yIE1QRUcgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExWCBYWVpYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMSBhbmQgWSBvciBaIHNob3VsZCBiZSAxXG4gICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyBkaWZmZXJlbnQgZnJvbSAwIChMYXllciBJIG9yIExheWVyIElJIG9yIExheWVyIElJSSlcbiAgICAvLyBNb3JlIGluZm8gaHR0cDovL3d3dy5tcDMtdGVjaC5vcmcvcHJvZ3JhbW1lci9mcmFtZV9oZWFkZXIuaHRtbFxuICAgIGlmIChvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgdGhpcy5pc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHByb2JlOiBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgLy8gc2FtZSBhcyBpc0hlYWRlciBidXQgd2UgYWxzbyBjaGVjayB0aGF0IE1QRUcgZnJhbWUgZm9sbG93cyBsYXN0IE1QRUcgZnJhbWVcbiAgICAvLyBvciBlbmQgb2YgZGF0YSBpcyByZWFjaGVkXG4gICAgaWYgKG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiB0aGlzLmlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAvLyBNUEVHIGhlYWRlciBMZW5ndGhcbiAgICAgIGxldCBoZWFkZXJMZW5ndGggPSA0O1xuICAgICAgLy8gTVBFRyBmcmFtZSBMZW5ndGhcbiAgICAgIGxldCBoZWFkZXIgPSB0aGlzLnBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gICAgICBsZXQgZnJhbWVMZW5ndGggPSBoZWFkZXJMZW5ndGg7XG4gICAgICBpZiAoaGVhZGVyICYmIGhlYWRlci5mcmFtZUxlbmd0aCkge1xuICAgICAgICBmcmFtZUxlbmd0aCA9IGhlYWRlci5mcmFtZUxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgbGV0IG5ld09mZnNldCA9IG9mZnNldCArIGZyYW1lTGVuZ3RoO1xuICAgICAgaWYgKG5ld09mZnNldCA9PT0gZGF0YS5sZW5ndGggfHwgKG5ld09mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiB0aGlzLmlzSGVhZGVyUGF0dGVybihkYXRhLCBuZXdPZmZzZXQpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBNcGVnQXVkaW87XG4iLCIvKipcbiAqIFNBTVBMRS1BRVMgZGVjcnlwdGVyXG4qL1xuXG5pbXBvcnQgRGVjcnlwdGVyIGZyb20gJy4uL2NyeXB0L2RlY3J5cHRlcic7XG5cbmNsYXNzIFNhbXBsZUFlc0RlY3J5cHRlciB7XG4gIGNvbnN0cnVjdG9yIChvYnNlcnZlciwgY29uZmlnLCBkZWNyeXB0ZGF0YSwgZGlzY2FyZEVQQikge1xuICAgIHRoaXMuZGVjcnlwdGRhdGEgPSBkZWNyeXB0ZGF0YTtcbiAgICB0aGlzLmRpc2NhcmRFUEIgPSBkaXNjYXJkRVBCO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcihvYnNlcnZlciwgY29uZmlnLCB7IHJlbW92ZVBLQ1M3UGFkZGluZzogZmFsc2UgfSk7XG4gIH1cblxuICBkZWNyeXB0QnVmZmVyIChlbmNyeXB0ZWREYXRhLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoZW5jcnlwdGVkRGF0YSwgdGhpcy5kZWNyeXB0ZGF0YS5rZXkuYnVmZmVyLCB0aGlzLmRlY3J5cHRkYXRhLml2LmJ1ZmZlciwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gQUFDIC0gZW5jcnlwdCBhbGwgZnVsbCAxNiBieXRlcyBibG9ja3Mgc3RhcnRpbmcgZnJvbSBvZmZzZXQgMTZcbiAgZGVjcnlwdEFhY1NhbXBsZSAoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrLCBzeW5jKSB7XG4gICAgbGV0IGN1clVuaXQgPSBzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0O1xuICAgIGxldCBlbmNyeXB0ZWREYXRhID0gY3VyVW5pdC5zdWJhcnJheSgxNiwgY3VyVW5pdC5sZW5ndGggLSBjdXJVbml0Lmxlbmd0aCAlIDE2KTtcbiAgICBsZXQgZW5jcnlwdGVkQnVmZmVyID0gZW5jcnlwdGVkRGF0YS5idWZmZXIuc2xpY2UoXG4gICAgICBlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQsXG4gICAgICBlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQgKyBlbmNyeXB0ZWREYXRhLmxlbmd0aCk7XG5cbiAgICBsZXQgbG9jYWx0aGlzID0gdGhpcztcbiAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkQnVmZmVyLCBmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgZGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xuICAgICAgY3VyVW5pdC5zZXQoZGVjcnlwdGVkRGF0YSwgMTYpO1xuXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgbG9jYWx0aGlzLmRlY3J5cHRBYWNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4ICsgMSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGVjcnlwdEFhY1NhbXBsZXMgKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaykge1xuICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKykge1xuICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXQubGVuZ3RoIDwgMzIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBzeW5jID0gdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCk7XG5cbiAgICAgIHRoaXMuZGVjcnlwdEFhY1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2ssIHN5bmMpO1xuXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEFWQyAtIGVuY3J5cHQgb25lIDE2IGJ5dGVzIGJsb2NrIG91dCBvZiB0ZW4sIHN0YXJ0aW5nIGZyb20gb2Zmc2V0IDMyXG4gIGdldEF2Y0VuY3J5cHRlZERhdGEgKGRlY29kZWREYXRhKSB7XG4gICAgbGV0IGVuY3J5cHRlZERhdGFMZW4gPSBNYXRoLmZsb29yKChkZWNvZGVkRGF0YS5sZW5ndGggLSA0OCkgLyAxNjApICogMTYgKyAxNjtcbiAgICBsZXQgZW5jcnlwdGVkRGF0YSA9IG5ldyBJbnQ4QXJyYXkoZW5jcnlwdGVkRGF0YUxlbik7XG4gICAgbGV0IG91dHB1dFBvcyA9IDA7XG4gICAgZm9yIChsZXQgaW5wdXRQb3MgPSAzMjsgaW5wdXRQb3MgPD0gZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7IGlucHV0UG9zICs9IDE2MCwgb3V0cHV0UG9zICs9IDE2KSB7XG4gICAgICBlbmNyeXB0ZWREYXRhLnNldChkZWNvZGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksIG91dHB1dFBvcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY3J5cHRlZERhdGE7XG4gIH1cblxuICBnZXRBdmNEZWNyeXB0ZWRVbml0IChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkRGF0YSkge1xuICAgIGRlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICBsZXQgaW5wdXRQb3MgPSAwO1xuICAgIGZvciAobGV0IG91dHB1dFBvcyA9IDMyOyBvdXRwdXRQb3MgPD0gZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7IG91dHB1dFBvcyArPSAxNjAsIGlucHV0UG9zICs9IDE2KSB7XG4gICAgICBkZWNvZGVkRGF0YS5zZXQoZGVjcnlwdGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksIG91dHB1dFBvcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY29kZWREYXRhO1xuICB9XG5cbiAgZGVjcnlwdEF2Y1NhbXBsZSAoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2ssIGN1clVuaXQsIHN5bmMpIHtcbiAgICBsZXQgZGVjb2RlZERhdGEgPSB0aGlzLmRpc2NhcmRFUEIoY3VyVW5pdC5kYXRhKTtcbiAgICBsZXQgZW5jcnlwdGVkRGF0YSA9IHRoaXMuZ2V0QXZjRW5jcnlwdGVkRGF0YShkZWNvZGVkRGF0YSk7XG4gICAgbGV0IGxvY2FsdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YS5idWZmZXIsIGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICBjdXJVbml0LmRhdGEgPSBsb2NhbHRoaXMuZ2V0QXZjRGVjcnlwdGVkVW5pdChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkRGF0YSk7XG5cbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBsb2NhbHRoaXMuZGVjcnlwdEF2Y1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRlY3J5cHRBdmNTYW1wbGVzIChzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaykge1xuICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKywgdW5pdEluZGV4ID0gMCkge1xuICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGN1clVuaXRzID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdHM7XG4gICAgICBmb3IgKDs7IHVuaXRJbmRleCsrKSB7XG4gICAgICAgIGlmICh1bml0SW5kZXggPj0gY3VyVW5pdHMubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY3VyVW5pdCA9IGN1clVuaXRzW3VuaXRJbmRleF07XG4gICAgICAgIGlmIChjdXJVbml0Lmxlbmd0aCA8PSA0OCB8fCAoY3VyVW5pdC50eXBlICE9PSAxICYmIGN1clVuaXQudHlwZSAhPT0gNSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzeW5jID0gdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCk7XG5cbiAgICAgICAgdGhpcy5kZWNyeXB0QXZjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0LCBzeW5jKTtcblxuICAgICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2FtcGxlQWVzRGVjcnlwdGVyO1xuIiwiLyoqXG4gKiBoaWdobHkgb3B0aW1pemVkIFRTIGRlbXV4ZXI6XG4gKiBwYXJzZSBQQVQsIFBNVFxuICogZXh0cmFjdCBQRVMgcGFja2V0IGZyb20gYXVkaW8gYW5kIHZpZGVvIFBJRHNcbiAqIGV4dHJhY3QgQVZDL0gyNjQgTkFMIHVuaXRzIGFuZCBBQUMvQURUUyBzYW1wbGVzIGZyb20gUEVTIHBhY2tldFxuICogdHJpZ2dlciB0aGUgcmVtdXhlciB1cG9uIHBhcnNpbmcgY29tcGxldGlvblxuICogaXQgYWxzbyB0cmllcyB0byB3b3JrYXJvdW5kIGFzIGJlc3QgYXMgaXQgY2FuIGF1ZGlvIGNvZGVjIHN3aXRjaCAoSEUtQUFDIHRvIEFBQyBhbmQgdmljZSB2ZXJzYSksIHdpdGhvdXQgaGF2aW5nIHRvIHJlc3RhcnQgdGhlIE1lZGlhU291cmNlLlxuICogaXQgYWxzbyBjb250cm9scyB0aGUgcmVtdXhpbmcgcHJvY2VzcyA6XG4gKiB1cG9uIGRpc2NvbnRpbnVpdHkgb3IgbGV2ZWwgc3dpdGNoIGRldGVjdGlvbiwgaXQgd2lsbCBhbHNvIG5vdGlmaWVzIHRoZSByZW11eGVyIHNvIHRoYXQgaXQgY2FuIHJlc2V0IGl0cyBzdGF0ZS5cbiovXG5cbmltcG9ydCAqIGFzIEFEVFMgZnJvbSAnLi9hZHRzJztcbmltcG9ydCBNcGVnQXVkaW8gZnJvbSAnLi9tcGVnYXVkaW8nO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXhwR29sb21iIGZyb20gJy4vZXhwLWdvbG9tYic7XG5pbXBvcnQgU2FtcGxlQWVzRGVjcnlwdGVyIGZyb20gJy4vc2FtcGxlLWFlcyc7XG4vLyBpbXBvcnQgSGV4IGZyb20gJy4uL3V0aWxzL2hleCc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcblxuLy8gV2UgYXJlIHVzaW5nIGZpeGVkIHRyYWNrIElEcyBmb3IgZHJpdmluZyB0aGUgTVA0IHJlbXV4ZXJcbi8vIGluc3RlYWQgb2YgZm9sbG93aW5nIHRoZSBUUyBQSURzLlxuLy8gVGhlcmUgaXMgbm8gcmVhc29uIG5vdCB0byBkbyB0aGlzIGFuZCBzb21lIGJyb3dzZXJzL1NvdXJjZUJ1ZmZlci1kZW11eGVyc1xuLy8gbWF5IG5vdCBsaWtlIGlmIHRoZXJlIGFyZSBUcmFja0lEIFwic3dpdGNoZXNcIlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8xMzMxXG4vLyBIZXJlIHdlIGFyZSBtYXBwaW5nIG91ciBpbnRlcm5hbCB0cmFjayB0eXBlcyB0byBjb25zdGFudCBNUDQgdHJhY2sgSURzXG4vLyBXaXRoIE1TRSBjdXJyZW50bHkgb25lIGNhbiBvbmx5IGhhdmUgb25lIHRyYWNrIG9mIGVhY2gsIGFuZCB3ZSBhcmUgbXV4aW5nXG4vLyB3aGF0ZXZlciB2aWRlby9hdWRpbyByZW5kaXRpb24gaW4gdGhlbS5cbmNvbnN0IFJlbXV4ZXJUcmFja0lkQ29uZmlnID0ge1xuICB2aWRlbzogMSxcbiAgYXVkaW86IDIsXG4gIGlkMzogMyxcbiAgdGV4dDogNFxufTtcblxuY2xhc3MgVFNEZW11eGVyIHtcbiAgY29uc3RydWN0b3IgKG9ic2VydmVyLCByZW11eGVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICB0aGlzLnJlbXV4ZXIgPSByZW11eGVyO1xuICAgIHRoaXMuc2FtcGxlQWVzID0gbnVsbDtcbiAgfVxuXG4gIHNldERlY3J5cHREYXRhIChkZWNyeXB0ZGF0YSkge1xuICAgIGlmICgoZGVjcnlwdGRhdGEgIT0gbnVsbCkgJiYgKGRlY3J5cHRkYXRhLmtleSAhPSBudWxsKSAmJiAoZGVjcnlwdGRhdGEubWV0aG9kID09PSAnU0FNUExFLUFFUycpKSB7XG4gICAgICB0aGlzLnNhbXBsZUFlcyA9IG5ldyBTYW1wbGVBZXNEZWNyeXB0ZXIodGhpcy5vYnNlcnZlciwgdGhpcy5jb25maWcsIGRlY3J5cHRkYXRhLCB0aGlzLmRpc2NhcmRFUEIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHByb2JlIChkYXRhKSB7XG4gICAgY29uc3Qgc3luY09mZnNldCA9IFRTRGVtdXhlci5fc3luY09mZnNldChkYXRhKTtcbiAgICBpZiAoc3luY09mZnNldCA8IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN5bmNPZmZzZXQpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYE1QRUcyLVRTIGRldGVjdGVkIGJ1dCBmaXJzdCBzeW5jIHdvcmQgZm91bmQgQCBvZmZzZXQgJHtzeW5jT2Zmc2V0fSwganVuayBhaGVhZCA/YCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBfc3luY09mZnNldCAoZGF0YSkge1xuICAgIC8vIHNjYW4gMTAwMCBmaXJzdCBieXRlc1xuICAgIGNvbnN0IHNjYW53aW5kb3cgPSBNYXRoLm1pbigxMDAwLCBkYXRhLmxlbmd0aCAtIDMgKiAxODgpO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHNjYW53aW5kb3cpIHtcbiAgICAgIC8vIGEgVFMgZnJhZ21lbnQgc2hvdWxkIGNvbnRhaW4gYXQgbGVhc3QgMyBUUyBwYWNrZXRzLCBhIFBBVCwgYSBQTVQsIGFuZCBvbmUgUElELCBlYWNoIHN0YXJ0aW5nIHdpdGggMHg0N1xuICAgICAgaWYgKGRhdGFbaV0gPT09IDB4NDcgJiYgZGF0YVtpICsgMTg4XSA9PT0gMHg0NyAmJiBkYXRhW2kgKyAyICogMTg4XSA9PT0gMHg0Nykge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0cmFjayBtb2RlbCBpbnRlcm5hbCB0byBkZW11eGVyIHVzZWQgdG8gZHJpdmUgcmVtdXhpbmcgaW5wdXRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgJ2F1ZGlvJyB8ICd2aWRlbycgfCAnaWQzJyB8ICd0ZXh0J1xuICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cbiAgICogQHJldHVybiB7b2JqZWN0fSBUU0RlbXV4ZXIncyBpbnRlcm5hbCB0cmFjayBtb2RlbFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVRyYWNrICh0eXBlLCBkdXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBjb250YWluZXI6IHR5cGUgPT09ICd2aWRlbycgfHwgdHlwZSA9PT0gJ2F1ZGlvJyA/ICd2aWRlby9tcDJ0JyA6IHVuZGVmaW5lZCxcbiAgICAgIHR5cGUsXG4gICAgICBpZDogUmVtdXhlclRyYWNrSWRDb25maWdbdHlwZV0sXG4gICAgICBwaWQ6IC0xLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIGxlbjogMCxcbiAgICAgIGRyb3BwZWQ6IHR5cGUgPT09ICd2aWRlbycgPyAwIDogdW5kZWZpbmVkLFxuICAgICAgaXNBQUM6IHR5cGUgPT09ICdhdWRpbycgPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgICAgZHVyYXRpb246IHR5cGUgPT09ICdhdWRpbycgPyBkdXJhdGlvbiA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5pdCBzZWdtZW50IG9uIHRoZSBkZW11eGVyL3JlbXV4ZXIgaW50ZXJmYWNlLiBOZWVkZWQgZm9yIGRpc2NvbnRpbnVpdGllcy90cmFjay1zd2l0Y2hlcyAob3IgYXQgc3RyZWFtIHN0YXJ0KVxuICAgKiBSZXNldHMgYWxsIGludGVybmFsIHRyYWNrIGluc3RhbmNlcyBvZiB0aGUgZGVtdXhlci5cbiAgICpcbiAgICogQG92ZXJyaWRlIEltcGxlbWVudHMgZ2VuZXJpYyBkZW11eGluZy9yZW11eGluZyBpbnRlcmZhY2UgKHNlZSBEZW11eGVySW5saW5lKVxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5pdFNlZ21lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF1ZGlvQ29kZWNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpZGVvQ29kZWNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIChpbiBUUyB0aW1lc2NhbGUgPSA5MGtIeilcbiAgICovXG4gIHJlc2V0SW5pdFNlZ21lbnQgKGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbikge1xuICAgIHRoaXMucG10UGFyc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcG10SWQgPSAtMTtcblxuICAgIHRoaXMuX2F2Y1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd2aWRlbycsIGR1cmF0aW9uKTtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCdhdWRpbycsIGR1cmF0aW9uKTtcbiAgICB0aGlzLl9pZDNUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygnaWQzJywgZHVyYXRpb24pO1xuICAgIHRoaXMuX3R4dFRyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd0ZXh0JywgZHVyYXRpb24pO1xuXG4gICAgLy8gZmx1c2ggYW55IHBhcnRpYWwgY29udGVudFxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIHRoaXMuYWFjTGFzdFBUUyA9IG51bGw7XG4gICAgdGhpcy5hdmNTYW1wbGUgPSBudWxsO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVzZXRUaW1lU3RhbXAgKCkge31cblxuICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gIGFwcGVuZCAoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgbGV0IHN0YXJ0LCBsZW4gPSBkYXRhLmxlbmd0aCwgc3R0LCBwaWQsIGF0Ziwgb2Zmc2V0LCBwZXMsXG4gICAgICB1bmtub3duUElEcyA9IGZhbHNlO1xuICAgIHRoaXMuY29udGlndW91cyA9IGNvbnRpZ3VvdXM7XG4gICAgbGV0IHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkLFxuICAgICAgYXZjVHJhY2sgPSB0aGlzLl9hdmNUcmFjayxcbiAgICAgIGF1ZGlvVHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrLFxuICAgICAgaWQzVHJhY2sgPSB0aGlzLl9pZDNUcmFjayxcbiAgICAgIGF2Y0lkID0gYXZjVHJhY2sucGlkLFxuICAgICAgYXVkaW9JZCA9IGF1ZGlvVHJhY2sucGlkLFxuICAgICAgaWQzSWQgPSBpZDNUcmFjay5waWQsXG4gICAgICBwbXRJZCA9IHRoaXMuX3BtdElkLFxuICAgICAgYXZjRGF0YSA9IGF2Y1RyYWNrLnBlc0RhdGEsXG4gICAgICBhdWRpb0RhdGEgPSBhdWRpb1RyYWNrLnBlc0RhdGEsXG4gICAgICBpZDNEYXRhID0gaWQzVHJhY2sucGVzRGF0YSxcbiAgICAgIHBhcnNlUEFUID0gdGhpcy5fcGFyc2VQQVQsXG4gICAgICBwYXJzZVBNVCA9IHRoaXMuX3BhcnNlUE1ULFxuICAgICAgcGFyc2VQRVMgPSB0aGlzLl9wYXJzZVBFUyxcbiAgICAgIHBhcnNlQVZDUEVTID0gdGhpcy5fcGFyc2VBVkNQRVMuYmluZCh0aGlzKSxcbiAgICAgIHBhcnNlQUFDUEVTID0gdGhpcy5fcGFyc2VBQUNQRVMuYmluZCh0aGlzKSxcbiAgICAgIHBhcnNlTVBFR1BFUyA9IHRoaXMuX3BhcnNlTVBFR1BFUy5iaW5kKHRoaXMpLFxuICAgICAgcGFyc2VJRDNQRVMgPSB0aGlzLl9wYXJzZUlEM1BFUy5iaW5kKHRoaXMpO1xuXG4gICAgY29uc3Qgc3luY09mZnNldCA9IFRTRGVtdXhlci5fc3luY09mZnNldChkYXRhKTtcblxuICAgIC8vIGRvbid0IHBhcnNlIGxhc3QgVFMgcGFja2V0IGlmIGluY29tcGxldGVcbiAgICBsZW4gLT0gKGxlbiArIHN5bmNPZmZzZXQpICUgMTg4O1xuXG4gICAgLy8gbG9vcCB0aHJvdWdoIFRTIHBhY2tldHNcbiAgICBmb3IgKHN0YXJ0ID0gc3luY09mZnNldDsgc3RhcnQgPCBsZW47IHN0YXJ0ICs9IDE4OCkge1xuICAgICAgaWYgKGRhdGFbc3RhcnRdID09PSAweDQ3KSB7XG4gICAgICAgIHN0dCA9ICEhKGRhdGFbc3RhcnQgKyAxXSAmIDB4NDApO1xuICAgICAgICAvLyBwaWQgaXMgYSAxMy1iaXQgZmllbGQgc3RhcnRpbmcgYXQgdGhlIGxhc3QgYml0IG9mIFRTWzFdXG4gICAgICAgIHBpZCA9ICgoZGF0YVtzdGFydCArIDFdICYgMHgxZikgPDwgOCkgKyBkYXRhW3N0YXJ0ICsgMl07XG4gICAgICAgIGF0ZiA9IChkYXRhW3N0YXJ0ICsgM10gJiAweDMwKSA+PiA0O1xuICAgICAgICAvLyBpZiBhbiBhZGFwdGlvbiBmaWVsZCBpcyBwcmVzZW50LCBpdHMgbGVuZ3RoIGlzIHNwZWNpZmllZCBieSB0aGUgZmlmdGggYnl0ZSBvZiB0aGUgVFMgcGFja2V0IGhlYWRlci5cbiAgICAgICAgaWYgKGF0ZiA+IDEpIHtcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDUgKyBkYXRhW3N0YXJ0ICsgNF07XG4gICAgICAgICAgLy8gY29udGludWUgaWYgdGhlcmUgaXMgb25seSBhZGFwdGF0aW9uIGZpZWxkXG4gICAgICAgICAgaWYgKG9mZnNldCA9PT0gKHN0YXJ0ICsgMTg4KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHBpZCkge1xuICAgICAgICBjYXNlIGF2Y0lkOlxuICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgIGlmIChhdmNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdmNEYXRhKSkgJiYgcGVzLnB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHBhcnNlQVZDUEVTKHBlcywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdmNEYXRhID0geyBkYXRhOiBbXSwgc2l6ZTogMCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXZjRGF0YSkge1xuICAgICAgICAgICAgYXZjRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICBhdmNEYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGF1ZGlvSWQ6XG4gICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkgJiYgcGVzLnB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VBQUNQRVMocGVzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZU1QRUdQRVMocGVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXVkaW9EYXRhID0geyBkYXRhOiBbXSwgc2l6ZTogMCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXVkaW9EYXRhKSB7XG4gICAgICAgICAgICBhdWRpb0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIDE4OCkpO1xuICAgICAgICAgICAgYXVkaW9EYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkM0lkOlxuICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkgJiYgcGVzLnB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHBhcnNlSUQzUEVTKHBlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlkM0RhdGEgPSB7IGRhdGE6IFtdLCBzaXplOiAwIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpZDNEYXRhKSB7XG4gICAgICAgICAgICBpZDNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcbiAgICAgICAgICAgIGlkM0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwbXRJZCA9IHRoaXMuX3BtdElkID0gcGFyc2VQQVQoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBwbXRJZDpcbiAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgcGFyc2VkUElEcyA9IHBhcnNlUE1UKGRhdGEsIG9mZnNldCwgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWcgPT09IHRydWUgfHwgdGhpcy50eXBlU3VwcG9ydGVkLm1wMyA9PT0gdHJ1ZSwgdGhpcy5zYW1wbGVBZXMgIT0gbnVsbCk7XG5cbiAgICAgICAgICAvLyBvbmx5IHVwZGF0ZSB0cmFjayBpZCBpZiB0cmFjayBQSUQgZm91bmQgd2hpbGUgcGFyc2luZyBQTVRcbiAgICAgICAgICAvLyB0aGlzIGlzIHRvIGF2b2lkIHJlc2V0dGluZyB0aGUgUElEIHRvIC0xIGluIGNhc2VcbiAgICAgICAgICAvLyB0cmFjayBQSUQgdHJhbnNpZW50bHkgZGlzYXBwZWFycyBmcm9tIHRoZSBzdHJlYW1cbiAgICAgICAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiBpbiBjYXNlIG9mIHRyYW5zaWVudCBtaXNzaW5nIGF1ZGlvIHNhbXBsZXMgZm9yIGV4YW1wbGVcbiAgICAgICAgICAvLyBOT1RFIHRoaXMgaXMgb25seSB0aGUgUElEIG9mIHRoZSB0cmFjayBhcyBmb3VuZCBpbiBUUyxcbiAgICAgICAgICAvLyBidXQgd2UgYXJlIG5vdCB1c2luZyB0aGlzIGZvciBNUDQgdHJhY2sgSURzLlxuICAgICAgICAgIGF2Y0lkID0gcGFyc2VkUElEcy5hdmM7XG4gICAgICAgICAgaWYgKGF2Y0lkID4gMCkge1xuICAgICAgICAgICAgYXZjVHJhY2sucGlkID0gYXZjSWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXVkaW9JZCA9IHBhcnNlZFBJRHMuYXVkaW87XG4gICAgICAgICAgaWYgKGF1ZGlvSWQgPiAwKSB7XG4gICAgICAgICAgICBhdWRpb1RyYWNrLnBpZCA9IGF1ZGlvSWQ7XG4gICAgICAgICAgICBhdWRpb1RyYWNrLmlzQUFDID0gcGFyc2VkUElEcy5pc0FBQztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWQzSWQgPSBwYXJzZWRQSURzLmlkMztcbiAgICAgICAgICBpZiAoaWQzSWQgPiAwKSB7XG4gICAgICAgICAgICBpZDNUcmFjay5waWQgPSBpZDNJZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodW5rbm93blBJRHMgJiYgIXBtdFBhcnNlZCkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygncmVwYXJzZSBmcm9tIGJlZ2lubmluZycpO1xuICAgICAgICAgICAgdW5rbm93blBJRHMgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHdlIHNldCBpdCB0byAtMTg4LCB0aGUgKz0gMTg4IGluIHRoZSBmb3IgbG9vcCB3aWxsIHJlc2V0IHN0YXJ0IHRvIDBcbiAgICAgICAgICAgIHN0YXJ0ID0gc3luY09mZnNldCAtIDE4ODtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE3OlxuICAgICAgICBjYXNlIDB4MWZmZjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB1bmtub3duUElEcyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogZmFsc2UsIHJlYXNvbjogJ1RTIHBhY2tldCBkaWQgbm90IHN0YXJ0IHdpdGggMHg0NycgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHRyeSB0byBwYXJzZSBsYXN0IFBFUyBwYWNrZXRzXG4gICAgaWYgKGF2Y0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF2Y0RhdGEpKSAmJiBwZXMucHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcnNlQVZDUEVTKHBlcywgdHJ1ZSk7XG4gICAgICBhdmNUcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWl0aGVyIGF2Y0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgYXZjVHJhY2sucGVzRGF0YSA9IGF2Y0RhdGE7XG4gICAgfVxuXG4gICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkgJiYgcGVzLnB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoYXVkaW9UcmFjay5pc0FBQykge1xuICAgICAgICBwYXJzZUFBQ1BFUyhwZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VNUEVHUEVTKHBlcyk7XG4gICAgICB9XG5cbiAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhdWRpb0RhdGEgJiYgYXVkaW9EYXRhLnNpemUpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnbGFzdCBBQUMgUEVTIHBhY2tldCB0cnVuY2F0ZWQsbWlnaHQgb3ZlcmxhcCBiZXR3ZWVuIGZyYWdtZW50cycpO1xuICAgICAgfVxuXG4gICAgICAvLyBlaXRoZXIgYXVkaW9EYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IGF1ZGlvRGF0YTtcbiAgICB9XG5cbiAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSkpICYmIHBlcy5wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyc2VJRDNQRVMocGVzKTtcbiAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlaXRoZXIgaWQzRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBpZDNUcmFjay5wZXNEYXRhID0gaWQzRGF0YTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zYW1wbGVBZXMgPT0gbnVsbCkge1xuICAgICAgdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIGF2Y1RyYWNrLCBpZDNUcmFjaywgdGhpcy5fdHh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVjcnlwdEFuZFJlbXV4KGF1ZGlvVHJhY2ssIGF2Y1RyYWNrLCBpZDNUcmFjaywgdGhpcy5fdHh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgfVxuICB9XG5cbiAgZGVjcnlwdEFuZFJlbXV4IChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICBpZiAoYXVkaW9UcmFjay5zYW1wbGVzICYmIGF1ZGlvVHJhY2suaXNBQUMpIHtcbiAgICAgIGxldCBsb2NhbHRoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5zYW1wbGVBZXMuZGVjcnlwdEFhY1NhbXBsZXMoYXVkaW9UcmFjay5zYW1wbGVzLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2FsdGhpcy5kZWNyeXB0QW5kUmVtdXhBdmMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlY3J5cHRBbmRSZW11eEF2YyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgIH1cbiAgfVxuXG4gIGRlY3J5cHRBbmRSZW11eEF2YyAoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcykge1xuICAgICAgbGV0IGxvY2FsdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLnNhbXBsZUFlcy5kZWNyeXB0QXZjU2FtcGxlcyh2aWRlb1RyYWNrLnNhbXBsZXMsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9jYWx0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLl9pbml0UFRTID0gdGhpcy5faW5pdERUUyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IDA7XG4gIH1cblxuICBfcGFyc2VQQVQgKGRhdGEsIG9mZnNldCkge1xuICAgIC8vIHNraXAgdGhlIFBTSSBoZWFkZXIgYW5kIHBhcnNlIHRoZSBmaXJzdCBQTVQgZW50cnlcbiAgICByZXR1cm4gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgxRikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xuICAgIC8vIGxvZ2dlci5sb2coJ1BNVCBQSUQ6JyAgKyB0aGlzLl9wbXRJZCk7XG4gIH1cblxuICBfcGFyc2VQTVQgKGRhdGEsIG9mZnNldCwgbXBlZ1N1cHBvcnRlZCwgaXNTYW1wbGVBZXMpIHtcbiAgICBsZXQgc2VjdGlvbkxlbmd0aCwgdGFibGVFbmQsIHByb2dyYW1JbmZvTGVuZ3RoLCBwaWQsIHJlc3VsdCA9IHsgYXVkaW86IC0xLCBhdmM6IC0xLCBpZDM6IC0xLCBpc0FBQzogdHJ1ZSB9O1xuICAgIHNlY3Rpb25MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDJdO1xuICAgIHRhYmxlRW5kID0gb2Zmc2V0ICsgMyArIHNlY3Rpb25MZW5ndGggLSA0O1xuICAgIC8vIHRvIGRldGVybWluZSB3aGVyZSB0aGUgdGFibGUgaXMsIHdlIGhhdmUgdG8gZmlndXJlIG91dCBob3dcbiAgICAvLyBsb25nIHRoZSBwcm9ncmFtIGluZm8gZGVzY3JpcHRvcnMgYXJlXG4gICAgcHJvZ3JhbUluZm9MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XG4gICAgLy8gYWR2YW5jZSB0aGUgb2Zmc2V0IHRvIHRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgbWFwcGluZyB0YWJsZVxuICAgIG9mZnNldCArPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xuICAgIHdoaWxlIChvZmZzZXQgPCB0YWJsZUVuZCkge1xuICAgICAgcGlkID0gKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDFGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAyXTtcbiAgICAgIHN3aXRjaCAoZGF0YVtvZmZzZXRdKSB7XG4gICAgICBjYXNlIDB4Y2Y6IC8vIFNBTVBMRS1BRVMgQUFDXG4gICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCd1bmtvd24gc3RyZWFtIHR5cGU6JyArIGRhdGFbb2Zmc2V0XSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuXG4gICAgICAgIC8vIElTTy9JRUMgMTM4MTgtNyBBRFRTIEFBQyAoTVBFRy0yIGxvd2VyIGJpdC1yYXRlIGF1ZGlvKVxuICAgICAgY2FzZSAweDBmOlxuICAgICAgICAvLyBsb2dnZXIubG9nKCdBQUMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuYXVkaW8gPSBwaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBQYWNrZXRpemVkIG1ldGFkYXRhIChJRDMpXG4gICAgICBjYXNlIDB4MTU6XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0lEMyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LmlkMyA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuaWQzID0gcGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMHhkYjogLy8gU0FNUExFLUFFUyBBVkNcbiAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3Vua293biBzdHJlYW0gdHlwZTonICsgZGF0YVtvZmZzZXRdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICAgICAgLy8gSVRVLVQgUmVjLiBILjI2NCBhbmQgSVNPL0lFQyAxNDQ5Ni0xMCAobG93ZXIgYml0LXJhdGUgdmlkZW8pXG4gICAgICBjYXNlIDB4MWI6XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0FWQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LmF2YyA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuYXZjID0gcGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gSVNPL0lFQyAxMTE3Mi0zIChNUEVHLTEgYXVkaW8pXG4gICAgICAgIC8vIG9yIElTTy9JRUMgMTM4MTgtMyAoTVBFRy0yIGhhbHZlZCBzYW1wbGUgcmF0ZSBhdWRpbylcbiAgICAgIGNhc2UgMHgwMzpcbiAgICAgIGNhc2UgMHgwNDpcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnTVBFRyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAoIW1wZWdTdXBwb3J0ZWQpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdNUEVHIGF1ZGlvIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlciBmb3Igbm93Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmF1ZGlvID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IHBpZDtcbiAgICAgICAgICByZXN1bHQuaXNBQUMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAweDI0OlxuICAgICAgICBsb2dnZXIud2FybignSEVWQyBzdHJlYW0gdHlwZSBmb3VuZCwgbm90IHN1cHBvcnRlZCBmb3Igbm93Jyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsb2dnZXIubG9nKCd1bmtvd24gc3RyZWFtIHR5cGU6JyArIGRhdGFbb2Zmc2V0XSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gbW92ZSB0byB0aGUgbmV4dCB0YWJsZSBlbnRyeVxuICAgICAgLy8gc2tpcCBwYXN0IHRoZSBlbGVtZW50YXJ5IHN0cmVhbSBkZXNjcmlwdG9ycywgaWYgcHJlc2VudFxuICAgICAgb2Zmc2V0ICs9ICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MEYpIDw8IDggfCBkYXRhW29mZnNldCArIDRdKSArIDU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfcGFyc2VQRVMgKHN0cmVhbSkge1xuICAgIGxldCBpID0gMCwgZnJhZywgcGVzRmxhZ3MsIHBlc1ByZWZpeCwgcGVzTGVuLCBwZXNIZHJMZW4sIHBlc0RhdGEsIHBlc1B0cywgcGVzRHRzLCBwYXlsb2FkU3RhcnRPZmZzZXQsIGRhdGEgPSBzdHJlYW0uZGF0YTtcbiAgICAvLyBzYWZldHkgY2hlY2tcbiAgICBpZiAoIXN0cmVhbSB8fCBzdHJlYW0uc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gd2UgbWlnaHQgbmVlZCB1cCB0byAxOSBieXRlcyB0byByZWFkIFBFUyBoZWFkZXJcbiAgICAvLyBpZiBmaXJzdCBjaHVuayBvZiBkYXRhIGlzIGxlc3MgdGhhbiAxOSBieXRlcywgbGV0J3MgbWVyZ2UgaXQgd2l0aCBmb2xsb3dpbmcgb25lcyB1bnRpbCB3ZSBnZXQgMTkgYnl0ZXNcbiAgICAvLyB1c3VhbGx5IG9ubHkgb25lIG1lcmdlIGlzIG5lZWRlZCAoYW5kIHRoaXMgaXMgcmFyZSAuLi4pXG4gICAgd2hpbGUgKGRhdGFbMF0ubGVuZ3RoIDwgMTkgJiYgZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICBsZXQgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGFbMF0ubGVuZ3RoICsgZGF0YVsxXS5sZW5ndGgpO1xuICAgICAgbmV3RGF0YS5zZXQoZGF0YVswXSk7XG4gICAgICBuZXdEYXRhLnNldChkYXRhWzFdLCBkYXRhWzBdLmxlbmd0aCk7XG4gICAgICBkYXRhWzBdID0gbmV3RGF0YTtcbiAgICAgIGRhdGEuc3BsaWNlKDEsIDEpO1xuICAgIH1cbiAgICAvLyByZXRyaWV2ZSBQVFMvRFRTIGZyb20gZmlyc3QgZnJhZ21lbnRcbiAgICBmcmFnID0gZGF0YVswXTtcbiAgICBwZXNQcmVmaXggPSAoZnJhZ1swXSA8PCAxNikgKyAoZnJhZ1sxXSA8PCA4KSArIGZyYWdbMl07XG4gICAgaWYgKHBlc1ByZWZpeCA9PT0gMSkge1xuICAgICAgcGVzTGVuID0gKGZyYWdbNF0gPDwgOCkgKyBmcmFnWzVdO1xuICAgICAgLy8gaWYgUEVTIHBhcnNlZCBsZW5ndGggaXMgbm90IHplcm8gYW5kIGdyZWF0ZXIgdGhhbiB0b3RhbCByZWNlaXZlZCBsZW5ndGgsIHN0b3AgcGFyc2luZy4gUEVTIG1pZ2h0IGJlIHRydW5jYXRlZFxuICAgICAgLy8gbWludXMgNiA6IFBFUyBoZWFkZXIgc2l6ZVxuICAgICAgaWYgKHBlc0xlbiAmJiBwZXNMZW4gPiBzdHJlYW0uc2l6ZSAtIDYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHBlc0ZsYWdzID0gZnJhZ1s3XTtcbiAgICAgIGlmIChwZXNGbGFncyAmIDB4QzApIHtcbiAgICAgICAgLyogUEVTIGhlYWRlciBkZXNjcmliZWQgaGVyZSA6IGh0dHA6Ly9kdmQuc291cmNlZm9yZ2UubmV0L2R2ZGluZm8vcGVzLWhkci5odG1sXG4gICAgICAgICAgICBhcyBQVFMgLyBEVFMgaXMgMzMgYml0IHdlIGNhbm5vdCB1c2UgYml0d2lzZSBvcGVyYXRvciBpbiBKUyxcbiAgICAgICAgICAgIGFzIEJpdHdpc2Ugb3BlcmF0b3JzIHRyZWF0IHRoZWlyIG9wZXJhbmRzIGFzIGEgc2VxdWVuY2Ugb2YgMzIgYml0cyAqL1xuICAgICAgICBwZXNQdHMgPSAoZnJhZ1s5XSAmIDB4MEUpICogNTM2ODcwOTEyICsvLyAxIDw8IDI5XG4gICAgICAgICAgKGZyYWdbMTBdICYgMHhGRikgKiA0MTk0MzA0ICsvLyAxIDw8IDIyXG4gICAgICAgICAgKGZyYWdbMTFdICYgMHhGRSkgKiAxNjM4NCArLy8gMSA8PCAxNFxuICAgICAgICAgIChmcmFnWzEyXSAmIDB4RkYpICogMTI4ICsvLyAxIDw8IDdcbiAgICAgICAgICAoZnJhZ1sxM10gJiAweEZFKSAvIDI7XG4gICAgICAgIC8vIGNoZWNrIGlmIGdyZWF0ZXIgdGhhbiAyXjMyIC0xXG4gICAgICAgIGlmIChwZXNQdHMgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgLy8gZGVjcmVtZW50IDJeMzNcbiAgICAgICAgICBwZXNQdHMgLT0gODU4OTkzNDU5MjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGVzRmxhZ3MgJiAweDQwKSB7XG4gICAgICAgICAgcGVzRHRzID0gKGZyYWdbMTRdICYgMHgwRSkgKiA1MzY4NzA5MTIgKy8vIDEgPDwgMjlcbiAgICAgICAgICAgIChmcmFnWzE1XSAmIDB4RkYpICogNDE5NDMwNCArLy8gMSA8PCAyMlxuICAgICAgICAgICAgKGZyYWdbMTZdICYgMHhGRSkgKiAxNjM4NCArLy8gMSA8PCAxNFxuICAgICAgICAgICAgKGZyYWdbMTddICYgMHhGRikgKiAxMjggKy8vIDEgPDwgN1xuICAgICAgICAgICAgKGZyYWdbMThdICYgMHhGRSkgLyAyO1xuICAgICAgICAgIC8vIGNoZWNrIGlmIGdyZWF0ZXIgdGhhbiAyXjMyIC0xXG4gICAgICAgICAgaWYgKHBlc0R0cyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgIC8vIGRlY3JlbWVudCAyXjMzXG4gICAgICAgICAgICBwZXNEdHMgLT0gODU4OTkzNDU5MjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBlc1B0cyAtIHBlc0R0cyA+IDYwICogOTAwMDApIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGAke01hdGgucm91bmQoKHBlc1B0cyAtIHBlc0R0cykgLyA5MDAwMCl9cyBkZWx0YSBiZXR3ZWVuIFBUUyBhbmQgRFRTLCBhbGlnbiB0aGVtYCk7XG4gICAgICAgICAgICBwZXNQdHMgPSBwZXNEdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlc0R0cyA9IHBlc1B0cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVzSGRyTGVuID0gZnJhZ1s4XTtcbiAgICAgIC8vIDkgYnl0ZXMgOiA2IGJ5dGVzIGZvciBQRVMgaGVhZGVyICsgMyBieXRlcyBmb3IgUEVTIGV4dGVuc2lvblxuICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gcGVzSGRyTGVuICsgOTtcblxuICAgICAgc3RyZWFtLnNpemUgLT0gcGF5bG9hZFN0YXJ0T2Zmc2V0O1xuICAgICAgLy8gcmVhc3NlbWJsZSBQRVMgcGFja2V0XG4gICAgICBwZXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtLnNpemUpO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGRhdGFMZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGRhdGFMZW47IGorKykge1xuICAgICAgICBmcmFnID0gZGF0YVtqXTtcbiAgICAgICAgbGV0IGxlbiA9IGZyYWcuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKHBheWxvYWRTdGFydE9mZnNldCkge1xuICAgICAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQgPiBsZW4pIHtcbiAgICAgICAgICAgIC8vIHRyaW0gZnVsbCBmcmFnIGlmIFBFUyBoZWFkZXIgYmlnZ2VyIHRoYW4gZnJhZ1xuICAgICAgICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0IC09IGxlbjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0cmltIHBhcnRpYWwgZnJhZyBpZiBQRVMgaGVhZGVyIHNtYWxsZXIgdGhhbiBmcmFnXG4gICAgICAgICAgICBmcmFnID0gZnJhZy5zdWJhcnJheShwYXlsb2FkU3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgbGVuIC09IHBheWxvYWRTdGFydE9mZnNldDtcbiAgICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBlc0RhdGEuc2V0KGZyYWcsIGkpO1xuICAgICAgICBpICs9IGxlbjtcbiAgICAgIH1cbiAgICAgIGlmIChwZXNMZW4pIHtcbiAgICAgICAgLy8gcGF5bG9hZCBzaXplIDogcmVtb3ZlIFBFUyBoZWFkZXIgKyBQRVMgZXh0ZW5zaW9uXG4gICAgICAgIHBlc0xlbiAtPSBwZXNIZHJMZW4gKyAzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0YTogcGVzRGF0YSwgcHRzOiBwZXNQdHMsIGR0czogcGVzRHRzLCBsZW46IHBlc0xlbiB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdXNoQWNjZXNVbml0IChhdmNTYW1wbGUsIGF2Y1RyYWNrKSB7XG4gICAgaWYgKGF2Y1NhbXBsZS51bml0cy5sZW5ndGggJiYgYXZjU2FtcGxlLmZyYW1lKSB7XG4gICAgICBjb25zdCBzYW1wbGVzID0gYXZjVHJhY2suc2FtcGxlcztcbiAgICAgIGNvbnN0IG5iU2FtcGxlcyA9IHNhbXBsZXMubGVuZ3RoO1xuICAgICAgLy8gb25seSBwdXNoIEFWQyBzYW1wbGUgaWYgc3RhcnRpbmcgd2l0aCBhIGtleWZyYW1lIGlzIG5vdCBtYW5kYXRvcnkgT1JcbiAgICAgIC8vICAgIGlmIGtleWZyYW1lIGFscmVhZHkgZm91bmQgaW4gdGhpcyBmcmFnbWVudCBPUlxuICAgICAgLy8gICAgICAga2V5ZnJhbWUgZm91bmQgaW4gbGFzdCBmcmFnbWVudCAodHJhY2suc3BzKSBBTkRcbiAgICAgIC8vICAgICAgICAgIHNhbXBsZXMgYWxyZWFkeSBhcHBlbmRlZCAod2UgYWxyZWFkeSBmb3VuZCBhIGtleWZyYW1lIGluIHRoaXMgZnJhZ21lbnQpIE9SIGZyYWdtZW50IGlzIGNvbnRpZ3VvdXNcbiAgICAgIGlmICghdGhpcy5jb25maWcuZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eSB8fFxuICAgICAgICAgIGF2Y1NhbXBsZS5rZXkgPT09IHRydWUgfHxcbiAgICAgICAgICAoYXZjVHJhY2suc3BzICYmIChuYlNhbXBsZXMgfHwgdGhpcy5jb250aWd1b3VzKSkpIHtcbiAgICAgICAgYXZjU2FtcGxlLmlkID0gbmJTYW1wbGVzO1xuICAgICAgICBzYW1wbGVzLnB1c2goYXZjU2FtcGxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRyb3BwZWQgc2FtcGxlcywgdHJhY2sgaXRcbiAgICAgICAgYXZjVHJhY2suZHJvcHBlZCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXZjU2FtcGxlLmRlYnVnLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLmxvZyhhdmNTYW1wbGUucHRzICsgJy8nICsgYXZjU2FtcGxlLmR0cyArICc6JyArIGF2Y1NhbXBsZS5kZWJ1Zyk7XG4gICAgfVxuICB9XG5cbiAgX3BhcnNlQVZDUEVTIChwZXMsIGxhc3QpIHtcbiAgICAvLyBsb2dnZXIubG9nKCdwYXJzZSBuZXcgUEVTJyk7XG4gICAgbGV0IHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssXG4gICAgICB1bml0cyA9IHRoaXMuX3BhcnNlQVZDTkFMdShwZXMuZGF0YSksXG4gICAgICBkZWJ1ZyA9IGZhbHNlLFxuICAgICAgZXhwR29sb21iRGVjb2RlcixcbiAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlLFxuICAgICAgcHVzaCxcbiAgICAgIHNwc2ZvdW5kID0gZmFsc2UsXG4gICAgICBpLFxuICAgICAgcHVzaEFjY2VzVW5pdCA9IHRoaXMucHVzaEFjY2VzVW5pdC5iaW5kKHRoaXMpLFxuICAgICAgY3JlYXRlQVZDU2FtcGxlID0gZnVuY3Rpb24gKGtleSwgcHRzLCBkdHMsIGRlYnVnKSB7XG4gICAgICAgIHJldHVybiB7IGtleToga2V5LCBwdHM6IHB0cywgZHRzOiBkdHMsIHVuaXRzOiBbXSwgZGVidWc6IGRlYnVnIH07XG4gICAgICB9O1xuICAgIC8vIGZyZWUgcGVzLmRhdGEgdG8gc2F2ZSB1cCBzb21lIG1lbW9yeVxuICAgIHBlcy5kYXRhID0gbnVsbDtcblxuICAgIC8vIGlmIG5ldyBOQUwgdW5pdHMgZm91bmQgYW5kIGxhc3Qgc2FtcGxlIHN0aWxsIHRoZXJlLCBsZXQncyBwdXNoIC4uLlxuICAgIC8vIHRoaXMgaGVscHMgcGFyc2luZyBzdHJlYW1zIHdpdGggbWlzc2luZyBBVUQgKG9ubHkgZG8gdGhpcyBpZiBBVUQgbmV2ZXIgZm91bmQpXG4gICAgaWYgKGF2Y1NhbXBsZSAmJiB1bml0cy5sZW5ndGggJiYgIXRyYWNrLmF1ZEZvdW5kKSB7XG4gICAgICBwdXNoQWNjZXNVbml0KGF2Y1NhbXBsZSwgdHJhY2spO1xuICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUgPSBjcmVhdGVBVkNTYW1wbGUoZmFsc2UsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICB9XG5cbiAgICB1bml0cy5mb3JFYWNoKHVuaXQgPT4ge1xuICAgICAgc3dpdGNoICh1bml0LnR5cGUpIHtcbiAgICAgIC8vIE5EUlxuICAgICAgY2FzZSAxOlxuICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFhdmNTYW1wbGUpIHtcbiAgICAgICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ05EUiAnO1xuICAgICAgICB9XG5cbiAgICAgICAgYXZjU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgbGV0IGRhdGEgPSB1bml0LmRhdGE7XG4gICAgICAgIC8vIG9ubHkgY2hlY2sgc2xpY2UgdHlwZSB0byBkZXRlY3QgS0YgaW4gY2FzZSBTUFMgZm91bmQgaW4gc2FtZSBwYWNrZXQgKGFueSBrZXlmcmFtZSBpcyBwcmVjZWRlZCBieSBTUFMgLi4uKVxuICAgICAgICBpZiAoc3BzZm91bmQgJiYgZGF0YS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgLy8gcmV0cmlldmUgc2xpY2UgdHlwZSBieSBwYXJzaW5nIGJlZ2lubmluZyBvZiBOQUwgdW5pdCAoZm9sbG93IEgyNjQgc3BlYywgc2xpY2VfaGVhZGVyIGRlZmluaXRpb24pIHRvIGRldGVjdCBrZXlmcmFtZSBlbWJlZGRlZCBpbiBORFJcbiAgICAgICAgICBsZXQgc2xpY2VUeXBlID0gbmV3IEV4cEdvbG9tYihkYXRhKS5yZWFkU2xpY2VUeXBlKCk7XG4gICAgICAgICAgLy8gMiA6IEkgc2xpY2UsIDQgOiBTSSBzbGljZSwgNyA6IEkgc2xpY2UsIDk6IFNJIHNsaWNlXG4gICAgICAgICAgLy8gU0kgc2xpY2UgOiBBIHNsaWNlIHRoYXQgaXMgY29kZWQgdXNpbmcgaW50cmEgcHJlZGljdGlvbiBvbmx5IGFuZCB1c2luZyBxdWFudGlzYXRpb24gb2YgdGhlIHByZWRpY3Rpb24gc2FtcGxlcy5cbiAgICAgICAgICAvLyBBbiBTSSBzbGljZSBjYW4gYmUgY29kZWQgc3VjaCB0aGF0IGl0cyBkZWNvZGVkIHNhbXBsZXMgY2FuIGJlIGNvbnN0cnVjdGVkIGlkZW50aWNhbGx5IHRvIGFuIFNQIHNsaWNlLlxuICAgICAgICAgIC8vIEkgc2xpY2U6IEEgc2xpY2UgdGhhdCBpcyBub3QgYW4gU0kgc2xpY2UgdGhhdCBpcyBkZWNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seS5cbiAgICAgICAgICAvLyBpZiAoc2xpY2VUeXBlID09PSAyIHx8IHNsaWNlVHlwZSA9PT0gNykge1xuICAgICAgICAgIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA0IHx8IHNsaWNlVHlwZSA9PT0gNyB8fCBzbGljZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5rZXkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgLy8gSURSXG4gICAgICBjYXNlIDU6XG4gICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAvLyBoYW5kbGUgUEVTIG5vdCBzdGFydGluZyB3aXRoIEFVRFxuICAgICAgICBpZiAoIWF2Y1NhbXBsZSkge1xuICAgICAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKHRydWUsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnSURSICc7XG4gICAgICAgIH1cblxuICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgYXZjU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFNFSVxuICAgICAgY2FzZSA2OlxuICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgaWYgKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnU0VJICc7XG4gICAgICAgIH1cblxuICAgICAgICBleHBHb2xvbWJEZWNvZGVyID0gbmV3IEV4cEdvbG9tYih0aGlzLmRpc2NhcmRFUEIodW5pdC5kYXRhKSk7XG5cbiAgICAgICAgLy8gc2tpcCBmcmFtZVR5cGVcbiAgICAgICAgZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcblxuICAgICAgICB2YXIgcGF5bG9hZFR5cGUgPSAwO1xuICAgICAgICB2YXIgcGF5bG9hZFNpemUgPSAwO1xuICAgICAgICB2YXIgZW5kT2ZDYXB0aW9ucyA9IGZhbHNlO1xuICAgICAgICB2YXIgYiA9IDA7XG5cbiAgICAgICAgd2hpbGUgKCFlbmRPZkNhcHRpb25zICYmIGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUgPiAxKSB7XG4gICAgICAgICAgcGF5bG9hZFR5cGUgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGIgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgcGF5bG9hZFR5cGUgKz0gYjtcbiAgICAgICAgICB9IHdoaWxlIChiID09PSAweEZGKTtcblxuICAgICAgICAgIC8vIFBhcnNlIHBheWxvYWQgc2l6ZS5cbiAgICAgICAgICBwYXlsb2FkU2l6ZSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgYiA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICBwYXlsb2FkU2l6ZSArPSBiO1xuICAgICAgICAgIH0gd2hpbGUgKGIgPT09IDB4RkYpO1xuXG4gICAgICAgICAgLy8gVE9ETzogdGhlcmUgY2FuIGJlIG1vcmUgdGhhbiBvbmUgcGF5bG9hZCBpbiBhbiBTRUkgcGFja2V0Li4uXG4gICAgICAgICAgLy8gVE9ETzogbmVlZCB0byByZWFkIHR5cGUgYW5kIHNpemUgaW4gYSB3aGlsZSBsb29wIHRvIGdldCB0aGVtIGFsbFxuICAgICAgICAgIGlmIChwYXlsb2FkVHlwZSA9PT0gNCAmJiBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlICE9PSAwKSB7XG4gICAgICAgICAgICBlbmRPZkNhcHRpb25zID0gdHJ1ZTtcblxuICAgICAgICAgICAgbGV0IGNvdW50cnlDb2RlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcblxuICAgICAgICAgICAgaWYgKGNvdW50cnlDb2RlID09PSAxODEpIHtcbiAgICAgICAgICAgICAgbGV0IHByb3ZpZGVyQ29kZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVTaG9ydCgpO1xuXG4gICAgICAgICAgICAgIGlmIChwcm92aWRlckNvZGUgPT09IDQ5KSB7XG4gICAgICAgICAgICAgICAgbGV0IHVzZXJTdHJ1Y3R1cmUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVSW50KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodXNlclN0cnVjdHVyZSA9PT0gMHg0NzQxMzkzNCkge1xuICAgICAgICAgICAgICAgICAgbGV0IHVzZXJEYXRhVHlwZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFJhdyBDRUEtNjA4IGJ5dGVzIHdyYXBwZWQgaW4gQ0VBLTcwOCBwYWNrZXRcbiAgICAgICAgICAgICAgICAgIGlmICh1c2VyRGF0YVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0Qnl0ZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWNvbmRCeXRlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgdG90YWxDQ3MgPSAzMSAmIGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJ5dGVBcnJheSA9IFtmaXJzdEJ5dGUsIHNlY29uZEJ5dGVdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENDczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gMyBieXRlcyBwZXIgQ0NcbiAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc2VydFNhbXBsZUluT3JkZXIodGhpcy5fdHh0VHJhY2suc2FtcGxlcywgeyB0eXBlOiAzLCBwdHM6IHBlcy5wdHMsIGJ5dGVzOiBieXRlQXJyYXkgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkU2l6ZSA8IGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXlsb2FkU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBTUFNcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgIHNwc2ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnU1BTICc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRyYWNrLnNwcykge1xuICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIgPSBuZXcgRXhwR29sb21iKHVuaXQuZGF0YSk7XG4gICAgICAgICAgbGV0IGNvbmZpZyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFNQUygpO1xuICAgICAgICAgIHRyYWNrLndpZHRoID0gY29uZmlnLndpZHRoO1xuICAgICAgICAgIHRyYWNrLmhlaWdodCA9IGNvbmZpZy5oZWlnaHQ7XG4gICAgICAgICAgdHJhY2sucGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvO1xuICAgICAgICAgIHRyYWNrLnNwcyA9IFt1bml0LmRhdGFdO1xuICAgICAgICAgIHRyYWNrLmR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgICAgICAgbGV0IGNvZGVjYXJyYXkgPSB1bml0LmRhdGEuc3ViYXJyYXkoMSwgNCk7XG4gICAgICAgICAgbGV0IGNvZGVjc3RyaW5nID0gJ2F2YzEuJztcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaCA9IGNvZGVjYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgaWYgKGgubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICBoID0gJzAnICsgaDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29kZWNzdHJpbmcgKz0gaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhY2suY29kZWMgPSBjb2RlY3N0cmluZztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgLy8gUFBTXG4gICAgICBjYXNlIDg6XG4gICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICBpZiAoZGVidWcgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdQUFMgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdHJhY2sucHBzKSB7XG4gICAgICAgICAgdHJhY2sucHBzID0gW3VuaXQuZGF0YV07XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgICAgLy8gQVVEXG4gICAgICBjYXNlIDk6XG4gICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgdHJhY2suYXVkRm91bmQgPSB0cnVlO1xuICAgICAgICBpZiAoYXZjU2FtcGxlKSB7XG4gICAgICAgICAgcHVzaEFjY2VzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCBkZWJ1ZyA/ICdBVUQgJyA6ICcnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEZpbGxlciBEYXRhXG4gICAgICBjYXNlIDEyOlxuICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICBpZiAoYXZjU2FtcGxlKSB7XG4gICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICd1bmtub3duIE5BTCAnICsgdW5pdC50eXBlICsgJyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoYXZjU2FtcGxlICYmIHB1c2gpIHtcbiAgICAgICAgbGV0IHVuaXRzID0gYXZjU2FtcGxlLnVuaXRzO1xuICAgICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGlmIGxhc3QgUEVTIHBhY2tldCwgcHVzaCBzYW1wbGVzXG4gICAgaWYgKGxhc3QgJiYgYXZjU2FtcGxlKSB7XG4gICAgICBwdXNoQWNjZXNVbml0KGF2Y1NhbXBsZSwgdHJhY2spO1xuICAgICAgdGhpcy5hdmNTYW1wbGUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIF9pbnNlcnRTYW1wbGVJbk9yZGVyIChhcnIsIGRhdGEpIHtcbiAgICBsZXQgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgaWYgKGRhdGEucHRzID49IGFycltsZW4gLSAxXS5wdHMpIHtcbiAgICAgICAgYXJyLnB1c2goZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBsZW4gLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgICBpZiAoZGF0YS5wdHMgPCBhcnJbcG9zXS5wdHMpIHtcbiAgICAgICAgICAgIGFyci5zcGxpY2UocG9zLCAwLCBkYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhcnIucHVzaChkYXRhKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0TGFzdE5hbFVuaXQgKCkge1xuICAgIGxldCBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSwgbGFzdFVuaXQ7XG4gICAgLy8gdHJ5IHRvIGZhbGxiYWNrIHRvIHByZXZpb3VzIHNhbXBsZSBpZiBjdXJyZW50IG9uZSBpcyBlbXB0eVxuICAgIGlmICghYXZjU2FtcGxlIHx8IGF2Y1NhbXBsZS51bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxldCB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrLCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICAgIGF2Y1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgbGV0IHVuaXRzID0gYXZjU2FtcGxlLnVuaXRzO1xuICAgICAgbGFzdFVuaXQgPSB1bml0c1t1bml0cy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIGxhc3RVbml0O1xuICB9XG5cbiAgX3BhcnNlQVZDTkFMdSAoYXJyYXkpIHtcbiAgICBsZXQgaSA9IDAsIGxlbiA9IGFycmF5LmJ5dGVMZW5ndGgsIHZhbHVlLCBvdmVyZmxvdywgdHJhY2sgPSB0aGlzLl9hdmNUcmFjaywgc3RhdGUgPSB0cmFjay5uYWx1U3RhdGUgfHwgMCwgbGFzdFN0YXRlID0gc3RhdGU7XG4gICAgbGV0IHVuaXRzID0gW10sIHVuaXQsIHVuaXRUeXBlLCBsYXN0VW5pdFN0YXJ0ID0gLTEsIGxhc3RVbml0VHlwZTtcbiAgICAvLyBsb2dnZXIubG9nKCdQRVM6JyArIEhleC5oZXhEdW1wKGFycmF5KSk7XG5cbiAgICBpZiAoc3RhdGUgPT09IC0xKSB7XG4gICAgLy8gc3BlY2lhbCB1c2UgY2FzZSB3aGVyZSB3ZSBmb3VuZCAzIG9yIDQtYnl0ZSBzdGFydCBjb2RlcyBleGFjdGx5IGF0IHRoZSBlbmQgb2YgcHJldmlvdXMgUEVTIHBhY2tldFxuICAgICAgbGFzdFVuaXRTdGFydCA9IDA7XG4gICAgICAvLyBOQUx1IHR5cGUgaXMgdmFsdWUgcmVhZCBmcm9tIG9mZnNldCAwXG4gICAgICBsYXN0VW5pdFR5cGUgPSBhcnJheVswXSAmIDB4MWY7XG4gICAgICBzdGF0ZSA9IDA7XG4gICAgICBpID0gMTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgdmFsdWUgPSBhcnJheVtpKytdO1xuICAgICAgLy8gb3B0aW1pemF0aW9uLiBzdGF0ZSAwIGFuZCAxIGFyZSB0aGUgcHJlZG9taW5hbnQgY2FzZS4gbGV0J3MgaGFuZGxlIHRoZW0gb3V0c2lkZSBvZiB0aGUgc3dpdGNoL2Nhc2VcbiAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgc3RhdGUgPSB2YWx1ZSA/IDAgOiAxO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZSA9PT0gMSkge1xuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gaGVyZSB3ZSBoYXZlIHN0YXRlIGVpdGhlciBlcXVhbCB0byAyIG9yIDNcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgc3RhdGUgPSAzO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICBpZiAobGFzdFVuaXRTdGFydCA+PSAwKSB7XG4gICAgICAgICAgdW5pdCA9IHsgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgaSAtIHN0YXRlIC0gMSksIHR5cGU6IGxhc3RVbml0VHlwZSB9O1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsYXN0VW5pdFN0YXJ0IGlzIHVuZGVmaW5lZCA9PiB0aGlzIGlzIHRoZSBmaXJzdCBzdGFydCBjb2RlIGZvdW5kIGluIHRoaXMgUEVTIHBhY2tldFxuICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIGlmIHN0YXJ0IGNvZGUgZGVsaW1pdGVyIGlzIG92ZXJsYXBwaW5nIGJldHdlZW4gMiBQRVMgcGFja2V0cyxcbiAgICAgICAgICAvLyBpZSBpdCBzdGFydGVkIGluIGxhc3QgcGFja2V0IChsYXN0U3RhdGUgbm90IHplcm8pXG4gICAgICAgICAgLy8gYW5kIGVuZGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBQRVMgcGFja2V0IChpIDw9IDQgLSBsYXN0U3RhdGUpXG4gICAgICAgICAgbGV0IGxhc3RVbml0ID0gdGhpcy5fZ2V0TGFzdE5hbFVuaXQoKTtcbiAgICAgICAgICBpZiAobGFzdFVuaXQpIHtcbiAgICAgICAgICAgIGlmIChsYXN0U3RhdGUgJiYgKGkgPD0gNCAtIGxhc3RTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgLy8gc3RhcnQgZGVsaW1pdGVyIG92ZXJsYXBwaW5nIGJldHdlZW4gUEVTIHBhY2tldHNcbiAgICAgICAgICAgICAgLy8gc3RyaXAgc3RhcnQgZGVsaW1pdGVyIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBsYXN0IE5BTCB1bml0XG4gICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGxhc3RVbml0IGhhZCBhIHN0YXRlIGRpZmZlcmVudCBmcm9tIHplcm9cbiAgICAgICAgICAgICAgaWYgKGxhc3RVbml0LnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgbGFzdCBieXRlc1xuICAgICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEgPSBsYXN0VW5pdC5kYXRhLnN1YmFycmF5KDAsIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCAtIGxhc3RTdGF0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIE5BTCB1bml0cyBhcmUgbm90IHN0YXJ0aW5nIHJpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYWNrZXQsIHB1c2ggcHJlY2VkaW5nIGRhdGEgaW50byBwcmV2aW91cyBOQUwgdW5pdC5cbiAgICAgICAgICAgIG92ZXJmbG93ID0gaSAtIHN0YXRlIC0gMTtcbiAgICAgICAgICAgIGlmIChvdmVyZmxvdyA+IDApIHtcbiAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmlyc3QgTkFMVSBmb3VuZCB3aXRoIG92ZXJmbG93OicgKyBvdmVyZmxvdyk7XG4gICAgICAgICAgICAgIGxldCB0bXAgPSBuZXcgVWludDhBcnJheShsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggKyBvdmVyZmxvdyk7XG4gICAgICAgICAgICAgIHRtcC5zZXQobGFzdFVuaXQuZGF0YSwgMCk7XG4gICAgICAgICAgICAgIHRtcC5zZXQoYXJyYXkuc3ViYXJyYXkoMCwgb3ZlcmZsb3cpLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gcmVhZCB1bml0IHR5cGVcbiAgICAgICAgaWYgKGkgPCBsZW4pIHtcbiAgICAgICAgICB1bml0VHlwZSA9IGFycmF5W2ldICYgMHgxZjtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaW5kIE5BTFUgQCBvZmZzZXQ6JyArIGkgKyAnLHR5cGU6JyArIHVuaXRUeXBlKTtcbiAgICAgICAgICBsYXN0VW5pdFN0YXJ0ID0gaTtcbiAgICAgICAgICBsYXN0VW5pdFR5cGUgPSB1bml0VHlwZTtcbiAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm90IGVub3VnaCBieXRlIHRvIHJlYWQgdW5pdCB0eXBlLiBsZXQncyByZWFkIGl0IG9uIG5leHQgUEVTIHBhcnNpbmdcbiAgICAgICAgICBzdGF0ZSA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49IDAgJiYgc3RhdGUgPj0gMCkge1xuICAgICAgdW5pdCA9IHsgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgbGVuKSwgdHlwZTogbGFzdFVuaXRUeXBlLCBzdGF0ZTogc3RhdGUgfTtcbiAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZS9zdGF0ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGggKyAnLycgKyBzdGF0ZSk7XG4gICAgfVxuICAgIC8vIG5vIE5BTHUgZm91bmRcbiAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBhcHBlbmQgcGVzLmRhdGEgdG8gcHJldmlvdXMgTkFMIHVuaXRcbiAgICAgIGxldCBsYXN0VW5pdCA9IHRoaXMuX2dldExhc3ROYWxVbml0KCk7XG4gICAgICBpZiAobGFzdFVuaXQpIHtcbiAgICAgICAgbGV0IHRtcCA9IG5ldyBVaW50OEFycmF5KGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIGFycmF5LmJ5dGVMZW5ndGgpO1xuICAgICAgICB0bXAuc2V0KGxhc3RVbml0LmRhdGEsIDApO1xuICAgICAgICB0bXAuc2V0KGFycmF5LCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICBsYXN0VW5pdC5kYXRhID0gdG1wO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmFjay5uYWx1U3RhdGUgPSBzdGF0ZTtcbiAgICByZXR1cm4gdW5pdHM7XG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlIEVtdWxhdGlvbiBQcmV2ZW50aW9uIGJ5dGVzIGZyb20gYSBSQlNQXG4gICAqL1xuICBkaXNjYXJkRVBCIChkYXRhKSB7XG4gICAgbGV0IGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCxcbiAgICAgIEVQQlBvc2l0aW9ucyA9IFtdLFxuICAgICAgaSA9IDEsXG4gICAgICBuZXdMZW5ndGgsIG5ld0RhdGE7XG5cbiAgICAvLyBGaW5kIGFsbCBgRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXNgXG4gICAgd2hpbGUgKGkgPCBsZW5ndGggLSAyKSB7XG4gICAgICBpZiAoZGF0YVtpXSA9PT0gMCAmJlxuICAgICAgICAgIGRhdGFbaSArIDFdID09PSAwICYmXG4gICAgICAgICAgZGF0YVtpICsgMl0gPT09IDB4MDMpIHtcbiAgICAgICAgRVBCUG9zaXRpb25zLnB1c2goaSArIDIpO1xuICAgICAgICBpICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXMgd2VyZSBmb3VuZCBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWxcbiAgICAvLyBhcnJheVxuICAgIGlmIChFUEJQb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gaG9sZCB0aGUgTkFMIHVuaXQgZGF0YVxuICAgIG5ld0xlbmd0aCA9IGxlbmd0aCAtIEVQQlBvc2l0aW9ucy5sZW5ndGg7XG4gICAgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG4gICAgbGV0IHNvdXJjZUluZGV4ID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuZXdMZW5ndGg7IHNvdXJjZUluZGV4KyssIGkrKykge1xuICAgICAgaWYgKHNvdXJjZUluZGV4ID09PSBFUEJQb3NpdGlvbnNbMF0pIHtcbiAgICAgICAgLy8gU2tpcCB0aGlzIGJ5dGVcbiAgICAgICAgc291cmNlSW5kZXgrKztcbiAgICAgICAgLy8gUmVtb3ZlIHRoaXMgcG9zaXRpb24gaW5kZXhcbiAgICAgICAgRVBCUG9zaXRpb25zLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICBuZXdEYXRhW2ldID0gZGF0YVtzb3VyY2VJbmRleF07XG4gICAgfVxuICAgIHJldHVybiBuZXdEYXRhO1xuICB9XG5cbiAgX3BhcnNlQUFDUEVTIChwZXMpIHtcbiAgICBsZXQgdHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrLFxuICAgICAgZGF0YSA9IHBlcy5kYXRhLFxuICAgICAgcHRzID0gcGVzLnB0cyxcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gMCxcbiAgICAgIGFhY092ZXJGbG93ID0gdGhpcy5hYWNPdmVyRmxvdyxcbiAgICAgIGFhY0xhc3RQVFMgPSB0aGlzLmFhY0xhc3RQVFMsXG4gICAgICBmcmFtZUR1cmF0aW9uLCBmcmFtZUluZGV4LCBvZmZzZXQsIHN0YW1wLCBsZW47XG4gICAgaWYgKGFhY092ZXJGbG93KSB7XG4gICAgICBsZXQgdG1wID0gbmV3IFVpbnQ4QXJyYXkoYWFjT3ZlckZsb3cuYnl0ZUxlbmd0aCArIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICB0bXAuc2V0KGFhY092ZXJGbG93LCAwKTtcbiAgICAgIHRtcC5zZXQoZGF0YSwgYWFjT3ZlckZsb3cuYnl0ZUxlbmd0aCk7XG4gICAgICAvLyBsb2dnZXIubG9nKGBBQUM6IGFwcGVuZCBvdmVyZmxvd2luZyAke2FhY092ZXJGbG93LmJ5dGVMZW5ndGh9IGJ5dGVzIHRvIGJlZ2lubmluZyBvZiBuZXcgUEVTYCk7XG4gICAgICBkYXRhID0gdG1wO1xuICAgIH1cbiAgICAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxuICAgIGZvciAob2Zmc2V0ID0gc3RhcnRPZmZzZXQsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgaWYgKEFEVFMuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgQURUUyBoZWFkZXIgZG9lcyBub3Qgc3RhcnQgc3RyYWlnaHQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGF5bG9hZCwgcmFpc2UgYW4gZXJyb3JcbiAgICBpZiAob2Zmc2V0KSB7XG4gICAgICBsZXQgcmVhc29uLCBmYXRhbDtcbiAgICAgIGlmIChvZmZzZXQgPCBsZW4gLSAxKSB7XG4gICAgICAgIHJlYXNvbiA9IGBBQUMgUEVTIGRpZCBub3Qgc3RhcnQgd2l0aCBBRFRTIGhlYWRlcixvZmZzZXQ6JHtvZmZzZXR9YDtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlYXNvbiA9ICdubyBBRFRTIGhlYWRlciBmb3VuZCBpbiBBQUMgUEVTJztcbiAgICAgICAgZmF0YWwgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLndhcm4oYHBhcnNpbmcgZXJyb3I6JHtyZWFzb259YCk7XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhdGFsLCByZWFzb246IHJlYXNvbiB9KTtcbiAgICAgIGlmIChmYXRhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgQURUUy5pbml0VHJhY2tDb25maWcodHJhY2ssIHRoaXMub2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgdGhpcy5hdWRpb0NvZGVjKTtcbiAgICBmcmFtZUluZGV4ID0gMDtcbiAgICBmcmFtZUR1cmF0aW9uID0gQURUUy5nZXRGcmFtZUR1cmF0aW9uKHRyYWNrLnNhbXBsZXJhdGUpO1xuXG4gICAgLy8gaWYgbGFzdCBBQUMgZnJhbWUgaXMgb3ZlcmZsb3dpbmcsIHdlIHNob3VsZCBlbnN1cmUgdGltZXN0YW1wcyBhcmUgY29udGlndW91czpcbiAgICAvLyBmaXJzdCBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBmcmFtZUR1cmF0aW9uXG4gICAgaWYgKGFhY092ZXJGbG93ICYmIGFhY0xhc3RQVFMpIHtcbiAgICAgIGxldCBuZXdQVFMgPSBhYWNMYXN0UFRTICsgZnJhbWVEdXJhdGlvbjtcbiAgICAgIGlmIChNYXRoLmFicyhuZXdQVFMgLSBwdHMpID4gMSkge1xuICAgICAgICBsb2dnZXIubG9nKGBBQUM6IGFsaWduIFBUUyBmb3Igb3ZlcmxhcHBpbmcgZnJhbWVzIGJ5ICR7TWF0aC5yb3VuZCgobmV3UFRTIC0gcHRzKSAvIDkwKX1gKTtcbiAgICAgICAgcHRzID0gbmV3UFRTO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNjYW4gZm9yIGFhYyBzYW1wbGVzXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbikge1xuICAgICAgaWYgKEFEVFMuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSAmJiAob2Zmc2V0ICsgNSkgPCBsZW4pIHtcbiAgICAgICAgbGV0IGZyYW1lID0gQURUUy5hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpO1xuICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKGAke01hdGgucm91bmQoZnJhbWUuc2FtcGxlLnB0cyl9IDogQUFDYCk7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICBzdGFtcCA9IGZyYW1lLnNhbXBsZS5wdHM7XG4gICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBBQUMgZnJhbWUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBmb3VuZCwga2VlcCBsb29raW5nXG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPCBsZW4pIHtcbiAgICAgIGFhY092ZXJGbG93ID0gZGF0YS5zdWJhcnJheShvZmZzZXQsIGxlbik7XG4gICAgICAvLyBsb2dnZXIubG9nKGBBQUM6IG92ZXJmbG93IGRldGVjdGVkOiR7bGVuLW9mZnNldH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBhYWNPdmVyRmxvdztcbiAgICB0aGlzLmFhY0xhc3RQVFMgPSBzdGFtcDtcbiAgfVxuXG4gIF9wYXJzZU1QRUdQRVMgKHBlcykge1xuICAgIGxldCBkYXRhID0gcGVzLmRhdGE7XG4gICAgbGV0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIGxldCBmcmFtZUluZGV4ID0gMDtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBsZXQgcHRzID0gcGVzLnB0cztcblxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgIGlmIChNcGVnQXVkaW8uaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBsZXQgZnJhbWUgPSBNcGVnQXVkaW8uYXBwZW5kRnJhbWUodGhpcy5fYXVkaW9UcmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpO1xuICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdVbmFibGUgdG8gcGFyc2UgTXBlZyBhdWRpbyBmcmFtZScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGZvdW5kLCBrZWVwIGxvb2tpbmdcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3BhcnNlSUQzUEVTIChwZXMpIHtcbiAgICB0aGlzLl9pZDNUcmFjay5zYW1wbGVzLnB1c2gocGVzKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUU0RlbXV4ZXI7XG4iLCJleHBvcnQgY29uc3QgRXJyb3JUeXBlcyA9IHtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBuZXR3b3JrIGVycm9yIChsb2FkaW5nIGVycm9yIC8gdGltZW91dCAuLi4pXG4gIE5FVFdPUktfRVJST1I6ICduZXR3b3JrRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1lZGlhIEVycm9yICh2aWRlby9wYXJzaW5nL21lZGlhc291cmNlIGVycm9yKVxuICBNRURJQV9FUlJPUjogJ21lZGlhRXJyb3InLFxuICAvLyBFTUUgKGVuY3J5cHRlZCBtZWRpYSBleHRlbnNpb25zKSBlcnJvcnNcbiAgS0VZX1NZU1RFTV9FUlJPUjogJ2tleVN5c3RlbUVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtdXggRXJyb3IgKGRlbXV4aW5nL3JlbXV4aW5nKVxuICBNVVhfRVJST1I6ICdtdXhFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFsbCBvdGhlciBlcnJvcnNcbiAgT1RIRVJfRVJST1I6ICdvdGhlckVycm9yJ1xufTtcblxuLyoqXG4gKiBAZW51bSB7RXJyb3JEZXRhaWxzfVxuICogQHR5cGVkZWYge3N0cmluZ30gRXJyb3JEZXRhaWxcbiAqL1xuZXhwb3J0IGNvbnN0IEVycm9yRGV0YWlscyA9IHtcbiAgS0VZX1NZU1RFTV9OT19LRVlTOiAna2V5U3lzdGVtTm9LZXlzJyxcbiAgS0VZX1NZU1RFTV9OT19BQ0NFU1M6ICdrZXlTeXN0ZW1Ob0FjY2VzcycsXG4gIEtFWV9TWVNURU1fTk9fU0VTU0lPTjogJ2tleVN5c3RlbU5vU2Vzc2lvbicsXG4gIEtFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRDogJ2tleVN5c3RlbUxpY2Vuc2VSZXF1ZXN0RmFpbGVkJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBNQU5JRkVTVF9MT0FEX0VSUk9SOiAnbWFuaWZlc3RMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTUFOSUZFU1RfTE9BRF9USU1FT1VUOiAnbWFuaWZlc3RMb2FkVGltZU91dCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgcGFyc2luZyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29ufVxuICBNQU5JRkVTVF9QQVJTSU5HX0VSUk9SOiAnbWFuaWZlc3RQYXJzaW5nRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IHdpdGggb25seSBpbmNvbXBhdGlibGUgY29kZWNzIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZWFzb24gOiBlcnJvciByZWFzb259XG4gIE1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1I6ICdtYW5pZmVzdEluY29tcGF0aWJsZUNvZGVjc0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBMRVZFTF9MT0FEX0VSUk9SOiAnbGV2ZWxMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTEVWRUxfTE9BRF9USU1FT1VUOiAnbGV2ZWxMb2FkVGltZU91dCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgc3dpdGNoIGVycm9yIC0gZGF0YTogeyBsZXZlbCA6IGZhdWx0eSBsZXZlbCBJZCwgZXZlbnQgOiBlcnJvciBkZXNjcmlwdGlvbn1cbiAgTEVWRUxfU1dJVENIX0VSUk9SOiAnbGV2ZWxTd2l0Y2hFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGF1ZGlvIHRyYWNrIGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEFVRElPX1RSQUNLX0xPQURfRVJST1I6ICdhdWRpb1RyYWNrTG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYW4gYXVkaW8gdHJhY2sgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBBVURJT19UUkFDS19MT0FEX1RJTUVPVVQ6ICdhdWRpb1RyYWNrTG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBGUkFHX0xPQURfRVJST1I6ICdmcmFnTG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCB0aW1lb3V0IGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0fVxuICBGUkFHX0xPQURfVElNRU9VVDogJ2ZyYWdMb2FkVGltZU91dCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgZnJhZ21lbnQgZGVjcnlwdGlvbiBlcnJvciBldmVudCAtIGRhdGE6IHtpZCA6IGRlbXV4ZXIgSWQsZnJhZzogZnJhZ21lbnQgb2JqZWN0LCByZWFzb24gOiBwYXJzaW5nIGVycm9yIGRlc2NyaXB0aW9uIH1cbiAgRlJBR19ERUNSWVBUX0VSUk9SOiAnZnJhZ0RlY3J5cHRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgZnJhZ21lbnQgcGFyc2luZyBlcnJvciBldmVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIElkLCByZWFzb24gOiBwYXJzaW5nIGVycm9yIGRlc2NyaXB0aW9uIH1cbiAgLy8gd2lsbCBiZSByZW5hbWVkIERFTVVYX1BBUlNJTkdfRVJST1IgYW5kIHN3aXRjaGVkIHRvIE1VWF9FUlJPUiBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG4gIEZSQUdfUEFSU0lOR19FUlJPUjogJ2ZyYWdQYXJzaW5nRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIHJlbXV4IGFsbG9jIGVycm9yIGV2ZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgSWQsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIGJ5dGVzIDogbmIgb2YgYnl0ZXMgb24gd2hpY2ggYWxsb2NhdGlvbiBmYWlsZWQgLCByZWFzb24gOiBlcnJvciB0ZXh0IH1cbiAgUkVNVVhfQUxMT0NfRVJST1I6ICdyZW11eEFsbG9jRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBkZWNyeXB0IGtleSBsb2FkIGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBLRVlfTE9BRF9FUlJPUjogJ2tleUxvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGRlY3J5cHQga2V5IGxvYWQgdGltZW91dCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgS0VZX0xPQURfVElNRU9VVDogJ2tleUxvYWRUaW1lT3V0JyxcbiAgLy8gVHJpZ2dlcmVkIHdoZW4gYW4gZXhjZXB0aW9uIG9jY3VycyB3aGlsZSBhZGRpbmcgYSBzb3VyY2VCdWZmZXIgdG8gTWVkaWFTb3VyY2UgLSBkYXRhIDogeyAgZXJyIDogZXhjZXB0aW9uICwgbWltZVR5cGUgOiBtaW1lVHlwZSB9XG4gIEJVRkZFUl9BRERfQ09ERUNfRVJST1I6ICdidWZmZXJBZGRDb2RlY0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgYXBwZW5kIGVycm9yIC0gZGF0YTogYXBwZW5kIGVycm9yIGRlc2NyaXB0aW9uXG4gIEJVRkZFUl9BUFBFTkRfRVJST1I6ICdidWZmZXJBcHBlbmRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGFwcGVuZGluZyBlcnJvciBldmVudCAtIGRhdGE6IGFwcGVuZGluZyBlcnJvciBkZXNjcmlwdGlvblxuICBCVUZGRVJfQVBQRU5ESU5HX0VSUk9SOiAnYnVmZmVyQXBwZW5kaW5nRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBzdGFsbGVkIGVycm9yIGV2ZW50XG4gIEJVRkZFUl9TVEFMTEVEX0VSUk9SOiAnYnVmZmVyU3RhbGxlZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgZnVsbCBldmVudFxuICBCVUZGRVJfRlVMTF9FUlJPUjogJ2J1ZmZlckZ1bGxFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIHNlZWsgb3ZlciBob2xlIGV2ZW50XG4gIEJVRkZFUl9TRUVLX09WRVJfSE9MRTogJ2J1ZmZlclNlZWtPdmVySG9sZScsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIG51ZGdlIG9uIHN0YWxsIChwbGF5YmFjayBpcyBzdHVjayBhbHRob3VnaCBjdXJyZW50VGltZSBpcyBpbiBhIGJ1ZmZlcmVkIGFyZWEpXG4gIEJVRkZFUl9OVURHRV9PTl9TVEFMTDogJ2J1ZmZlck51ZGdlT25TdGFsbCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGludGVybmFsIGV4Y2VwdGlvbiBoYXBwZW5pbmcgaW5zaWRlIGhscy5qcyB3aGlsZSBoYW5kbGluZyBhbiBldmVudFxuICBJTlRFUk5BTF9FWENFUFRJT046ICdpbnRlcm5hbEV4Y2VwdGlvbidcbn07XG4iLCIvKlxuKlxuKiBBbGwgb2JqZWN0cyBpbiB0aGUgZXZlbnQgaGFuZGxpbmcgY2hhaW4gc2hvdWxkIGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzXG4qXG4qL1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9ldmVudHMnO1xuXG5jb25zdCBGT1JCSURERU5fRVZFTlRfTkFNRVMgPSB7XG4gICdobHNFdmVudEdlbmVyaWMnOiB0cnVlLFxuICAnaGxzSGFuZGxlckRlc3Ryb3lpbmcnOiB0cnVlLFxuICAnaGxzSGFuZGxlckRlc3Ryb3llZCc6IHRydWVcbn07XG5cbmNsYXNzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMsIC4uLmV2ZW50cykge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMub25FdmVudCA9IHRoaXMub25FdmVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlZEV2ZW50cyA9IGV2ZW50cztcbiAgICB0aGlzLnVzZUdlbmVyaWNIYW5kbGVyID0gdHJ1ZTtcblxuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWluZygpO1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWVkKCk7XG4gIH1cblxuICBvbkhhbmRsZXJEZXN0cm95aW5nICgpIHt9XG4gIG9uSGFuZGxlckRlc3Ryb3llZCAoKSB7fVxuXG4gIGlzRXZlbnRIYW5kbGVyICgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuaGFuZGxlZEV2ZW50cyA9PT0gJ29iamVjdCcgJiYgdGhpcy5oYW5kbGVkRXZlbnRzLmxlbmd0aCAmJiB0eXBlb2YgdGhpcy5vbkV2ZW50ID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMgKCkge1xuICAgIGlmICh0aGlzLmlzRXZlbnRIYW5kbGVyKCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoRk9SQklEREVOX0VWRU5UX05BTUVTW2V2ZW50XSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9yYmlkZGVuIGV2ZW50LW5hbWU6ICcgKyBldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhscy5vbihldmVudCwgdGhpcy5vbkV2ZW50KTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMgKCkge1xuICAgIGlmICh0aGlzLmlzRXZlbnRIYW5kbGVyKCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmhscy5vZmYoZXZlbnQsIHRoaXMub25FdmVudCk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogYXJndW1lbnRzOiBldmVudCAoc3RyaW5nKSwgZGF0YSAoYW55KVxuICAgKi9cbiAgb25FdmVudCAoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm9uRXZlbnRHZW5lcmljKGV2ZW50LCBkYXRhKTtcbiAgfVxuXG4gIG9uRXZlbnRHZW5lcmljIChldmVudCwgZGF0YSkge1xuICAgIGxldCBldmVudFRvRnVuY3Rpb24gPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgICAgIGxldCBmdW5jTmFtZSA9ICdvbicgKyBldmVudC5yZXBsYWNlKCdobHMnLCAnJyk7XG4gICAgICBpZiAodHlwZW9mIHRoaXNbZnVuY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXZlbnQgJHtldmVudH0gaGFzIG5vIGdlbmVyaWMgaGFuZGxlciBpbiB0aGlzICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBjbGFzcyAodHJpZWQgJHtmdW5jTmFtZX0pYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzW2Z1bmNOYW1lXS5iaW5kKHRoaXMsIGRhdGEpO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGV2ZW50VG9GdW5jdGlvbi5jYWxsKHRoaXMsIGV2ZW50LCBkYXRhKS5jYWxsKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoYEFuIGludGVybmFsIGVycm9yIGhhcHBlbmVkIHdoaWxlIGhhbmRsaW5nIGV2ZW50ICR7ZXZlbnR9LiBFcnJvciBtZXNzYWdlOiBcIiR7ZXJyLm1lc3NhZ2V9XCIuIEhlcmUgaXMgYSBzdGFja3RyYWNlOmAsIGVycik7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sIGZhdGFsOiBmYWxzZSwgZXZlbnQ6IGV2ZW50LCBlcnI6IGVyciB9KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRIYW5kbGVyO1xuIiwiLyoqXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmNvbnN0IEhsc0V2ZW50cyA9IHtcbiAgLy8gZmlyZWQgYmVmb3JlIE1lZGlhU291cmNlIGlzIGF0dGFjaGluZyB0byBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyBtZWRpYSB9XG4gIE1FRElBX0FUVEFDSElORzogJ2hsc01lZGlhQXR0YWNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBNZWRpYVNvdXJjZSBoYXMgYmVlbiBzdWNjZXNmdWxseSBhdHRhY2hlZCB0byBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XG4gIE1FRElBX0FUVEFDSEVEOiAnaGxzTWVkaWFBdHRhY2hlZCcsXG4gIC8vIGZpcmVkIGJlZm9yZSBkZXRhY2hpbmcgTWVkaWFTb3VyY2UgZnJvbSBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XG4gIE1FRElBX0RFVEFDSElORzogJ2hsc01lZGlhRGV0YWNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBNZWRpYVNvdXJjZSBoYXMgYmVlbiBkZXRhY2hlZCBmcm9tIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IH1cbiAgTUVESUFfREVUQUNIRUQ6ICdobHNNZWRpYURldGFjaGVkJyxcbiAgLy8gZmlyZWQgd2hlbiB3ZSBidWZmZXIgaXMgZ29pbmcgdG8gYmUgcmVzZXQgLSBkYXRhOiB7IH1cbiAgQlVGRkVSX1JFU0VUOiAnaGxzQnVmZmVyUmVzZXQnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGtub3cgYWJvdXQgdGhlIGNvZGVjcyB0aGF0IHdlIG5lZWQgYnVmZmVycyBmb3IgdG8gcHVzaCBpbnRvIC0gZGF0YToge3RyYWNrcyA6IHsgY29udGFpbmVyLCBjb2RlYywgbGV2ZWxDb2RlYywgaW5pdFNlZ21lbnQsIG1ldGFkYXRhIH19XG4gIEJVRkZFUl9DT0RFQ1M6ICdobHNCdWZmZXJDb2RlY3MnLFxuICAvLyBmaXJlZCB3aGVuIHNvdXJjZWJ1ZmZlcnMgaGF2ZSBiZWVuIGNyZWF0ZWQgLSBkYXRhOiB7IHRyYWNrcyA6IHRyYWNrcyB9XG4gIEJVRkZFUl9DUkVBVEVEOiAnaGxzQnVmZmVyQ3JlYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gd2UgYXBwZW5kIGEgc2VnbWVudCB0byB0aGUgYnVmZmVyIC0gZGF0YTogeyBzZWdtZW50OiBzZWdtZW50IG9iamVjdCB9XG4gIEJVRkZFUl9BUFBFTkRJTkc6ICdobHNCdWZmZXJBcHBlbmRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGFyZSBkb25lIHdpdGggYXBwZW5kaW5nIGEgbWVkaWEgc2VnbWVudCB0byB0aGUgYnVmZmVyIC0gZGF0YSA6IHsgcGFyZW50IDogc2VnbWVudCBwYXJlbnQgdGhhdCB0cmlnZ2VyZWQgQlVGRkVSX0FQUEVORElORywgcGVuZGluZyA6IG5iIG9mIHNlZ21lbnRzIHdhaXRpbmcgZm9yIGFwcGVuZGluZyBmb3IgdGhpcyBzZWdtZW50IHBhcmVudH1cbiAgQlVGRkVSX0FQUEVOREVEOiAnaGxzQnVmZmVyQXBwZW5kZWQnLFxuICAvLyBmaXJlZCB3aGVuIHRoZSBzdHJlYW0gaXMgZmluaXNoZWQgYW5kIHdlIHdhbnQgdG8gbm90aWZ5IHRoZSBtZWRpYSBidWZmZXIgdGhhdCB0aGVyZSB3aWxsIGJlIG5vIG1vcmUgZGF0YSAtIGRhdGE6IHsgfVxuICBCVUZGRVJfRU9TOiAnaGxzQnVmZmVyRW9zJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgbWVkaWEgYnVmZmVyIHNob3VsZCBiZSBmbHVzaGVkIC0gZGF0YSB7IHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQgfVxuICBCVUZGRVJfRkxVU0hJTkc6ICdobHNCdWZmZXJGbHVzaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIG1lZGlhIGJ1ZmZlciBoYXMgYmVlbiBmbHVzaGVkIC0gZGF0YTogeyB9XG4gIEJVRkZFUl9GTFVTSEVEOiAnaGxzQnVmZmVyRmx1c2hlZCcsXG4gIC8vIGZpcmVkIHRvIHNpZ25hbCB0aGF0IGEgbWFuaWZlc3QgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IG1hbmlmZXN0VVJMfVxuICBNQU5JRkVTVF9MT0FESU5HOiAnaGxzTWFuaWZlc3RMb2FkaW5nJyxcbiAgLy8gZmlyZWQgYWZ0ZXIgbWFuaWZlc3QgaGFzIGJlZW4gbG9hZGVkIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSwgYXVkaW9UcmFja3MgOiBbIGF2YWlsYWJsZSBhdWRpbyB0cmFja3NdLCB1cmwgOiBtYW5pZmVzdFVSTCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX19XG4gIE1BTklGRVNUX0xPQURFRDogJ2hsc01hbmlmZXN0TG9hZGVkJyxcbiAgLy8gZmlyZWQgYWZ0ZXIgbWFuaWZlc3QgaGFzIGJlZW4gcGFyc2VkIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSwgZmlyc3RMZXZlbCA6IGluZGV4IG9mIGZpcnN0IHF1YWxpdHkgbGV2ZWwgYXBwZWFyaW5nIGluIE1hbmlmZXN0fVxuICBNQU5JRkVTVF9QQVJTRUQ6ICdobHNNYW5pZmVzdFBhcnNlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBzd2l0Y2ggaXMgcmVxdWVzdGVkIC0gZGF0YTogeyBsZXZlbCA6IGlkIG9mIG5ldyBsZXZlbCB9XG4gIExFVkVMX1NXSVRDSElORzogJ2hsc0xldmVsU3dpdGNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHN3aXRjaCBpcyBlZmZlY3RpdmUgLSBkYXRhOiB7IGxldmVsIDogaWQgb2YgbmV3IGxldmVsIH1cbiAgTEVWRUxfU1dJVENIRUQ6ICdobHNMZXZlbFN3aXRjaGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHBsYXlsaXN0IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBsZXZlbCBVUkwsIGxldmVsIDogaWQgb2YgbGV2ZWwgYmVpbmcgbG9hZGVkfVxuICBMRVZFTF9MT0FESU5HOiAnaGxzTGV2ZWxMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHBsYXlsaXN0IGxvYWRpbmcgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIGxvYWRlZCBsZXZlbCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX0gfVxuICBMRVZFTF9MT0FERUQ6ICdobHNMZXZlbExvYWRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCdzIGRldGFpbHMgaGF2ZSBiZWVuIHVwZGF0ZWQgYmFzZWQgb24gcHJldmlvdXMgZGV0YWlscywgYWZ0ZXIgaXQgaGFzIGJlZW4gbG9hZGVkIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiB1cGRhdGVkIGxldmVsIH1cbiAgTEVWRUxfVVBEQVRFRDogJ2hsc0xldmVsVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCdzIFBUUyBpbmZvcm1hdGlvbiBoYXMgYmVlbiB1cGRhdGVkIGFmdGVyIHBhcnNpbmcgYSBmcmFnbWVudCAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgdXBkYXRlZCBsZXZlbCwgZHJpZnQ6IFBUUyBkcmlmdCBvYnNlcnZlZCB3aGVuIHBhcnNpbmcgbGFzdCBmcmFnbWVudCB9XG4gIExFVkVMX1BUU19VUERBVEVEOiAnaGxzTGV2ZWxQdHNVcGRhdGVkJyxcbiAgLy8gZmlyZWQgdG8gbm90aWZ5IHRoYXQgYXVkaW8gdHJhY2sgbGlzdHMgaGFzIGJlZW4gdXBkYXRlZCAtIGRhdGE6IHsgYXVkaW9UcmFja3MgOiBhdWRpb1RyYWNrcyB9XG4gIEFVRElPX1RSQUNLU19VUERBVEVEOiAnaGxzQXVkaW9UcmFja3NVcGRhdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBzd2l0Y2hpbmcgaXMgcmVxdWVzdGVkIC0gZGF0YTogeyBpZCA6IGF1ZGlvIHRyYWNrIGlkIH1cbiAgQVVESU9fVFJBQ0tfU1dJVENISU5HOiAnaGxzQXVkaW9UcmFja1N3aXRjaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgc3dpdGNoIGFjdHVhbGx5IG9jY3VycyAtIGRhdGE6IHsgaWQgOiBhdWRpbyB0cmFjayBpZCB9XG4gIEFVRElPX1RSQUNLX1NXSVRDSEVEOiAnaGxzQXVkaW9UcmFja1N3aXRjaGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogYXVkaW8gdHJhY2sgVVJMLCBpZCA6IGF1ZGlvIHRyYWNrIGlkIH1cbiAgQVVESU9fVFJBQ0tfTE9BRElORzogJ2hsc0F1ZGlvVHJhY2tMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBsb2FkaW5nIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgaWQgOiBhdWRpbyB0cmFjayBpZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZSB9IH1cbiAgQVVESU9fVFJBQ0tfTE9BREVEOiAnaGxzQXVkaW9UcmFja0xvYWRlZCcsXG4gIC8vIGZpcmVkIHRvIG5vdGlmeSB0aGF0IHN1YnRpdGxlIHRyYWNrIGxpc3RzIGhhcyBiZWVuIHVwZGF0ZWQgLSBkYXRhOiB7IHN1YnRpdGxlVHJhY2tzIDogc3VidGl0bGVUcmFja3MgfVxuICBTVUJUSVRMRV9UUkFDS1NfVVBEQVRFRDogJ2hsc1N1YnRpdGxlVHJhY2tzVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYW4gc3VidGl0bGUgdHJhY2sgc3dpdGNoIG9jY3VycyAtIGRhdGE6IHsgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZCB9XG4gIFNVQlRJVExFX1RSQUNLX1NXSVRDSDogJ2hsc1N1YnRpdGxlVHJhY2tTd2l0Y2gnLFxuICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgdHJhY2sgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IHN1YnRpdGxlIHRyYWNrIFVSTCwgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZCB9XG4gIFNVQlRJVExFX1RSQUNLX0xPQURJTkc6ICdobHNTdWJ0aXRsZVRyYWNrTG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBzdWJ0aXRsZSB0cmFjayBsb2FkaW5nIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZSB9IH1cbiAgU1VCVElUTEVfVFJBQ0tfTE9BREVEOiAnaGxzU3VidGl0bGVUcmFja0xvYWRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBzdWJ0aXRsZSBmcmFnbWVudCBoYXMgYmVlbiBwcm9jZXNzZWQgLSBkYXRhOiB7IHN1Y2Nlc3MgOiBib29sZWFuLCBmcmFnIDogdGhlIHByb2Nlc3NlZCBmcmFnIH1cbiAgU1VCVElUTEVfRlJBR19QUk9DRVNTRUQ6ICdobHNTdWJ0aXRsZUZyYWdQcm9jZXNzZWQnLFxuICAvLyBmaXJlZCB3aGVuIHRoZSBmaXJzdCB0aW1lc3RhbXAgaXMgZm91bmQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgaW5pdFBUUzogaW5pdFBUUywgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gIElOSVRfUFRTX0ZPVU5EOiAnaGxzSW5pdFB0c0ZvdW5kJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgRlJBR19MT0FESU5HOiAnaGxzRnJhZ0xvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBpcyBwcm9ncmVzc2luZyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgeyB0cmVxdWVzdCwgdGZpcnN0LCBsb2FkZWQgfSB9XG4gIEZSQUdfTE9BRF9QUk9HUkVTUzogJ2hsc0ZyYWdMb2FkUHJvZ3Jlc3MnLFxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIGFib3J0aW5nIGZvciBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBGUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQ6ICdobHNGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHBheWxvYWQgOiBmcmFnbWVudCBwYXlsb2FkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIGxlbmd0aCB9IH1cbiAgRlJBR19MT0FERUQ6ICdobHNGcmFnTG9hZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGhhcyBmaW5pc2hlZCBkZWNyeXB0aW5nIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGZyYWdtZW50IHBheWxvYWQsIHN0YXRzIDogeyB0c3RhcnQsIHRkZWNyeXB0IH0gfVxuICBGUkFHX0RFQ1JZUFRFRDogJ2hsc0ZyYWdEZWNyeXB0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIEluaXQgU2VnbWVudCBoYXMgYmVlbiBleHRyYWN0ZWQgZnJvbSBmcmFnbWVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIG1vb3YgOiBtb292IE1QNCBib3gsIGNvZGVjcyA6IGNvZGVjcyBmb3VuZCB3aGlsZSBwYXJzaW5nIGZyYWdtZW50IH1cbiAgRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVDogJ2hsc0ZyYWdQYXJzaW5nSW5pdFNlZ21lbnQnLFxuICAvLyBmaXJlZCB3aGVuIHBhcnNpbmcgc2VpIHRleHQgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgc2FtcGxlcyA6IFsgc2VpIHNhbXBsZXMgcGVzIF0gfVxuICBGUkFHX1BBUlNJTkdfVVNFUkRBVEE6ICdobHNGcmFnUGFyc2luZ1VzZXJkYXRhJyxcbiAgLy8gZmlyZWQgd2hlbiBwYXJzaW5nIGlkMyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBzYW1wbGVzIDogWyBpZDMgc2FtcGxlcyBwZXMgXSB9XG4gIEZSQUdfUEFSU0lOR19NRVRBREFUQTogJ2hsc0ZyYWdQYXJzaW5nTWV0YWRhdGEnLFxuICAvLyBmaXJlZCB3aGVuIGRhdGEgaGF2ZSBiZWVuIGV4dHJhY3RlZCBmcm9tIGZyYWdtZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgZGF0YTEgOiBtb29mIE1QNCBib3ggb3IgVFMgZnJhZ21lbnRzLCBkYXRhMiA6IG1kYXQgTVA0IGJveCBvciBudWxsfVxuICBGUkFHX1BBUlNJTkdfREFUQTogJ2hsc0ZyYWdQYXJzaW5nRGF0YScsXG4gIC8vIGZpcmVkIHdoZW4gZnJhZ21lbnQgcGFyc2luZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0IH1cbiAgRlJBR19QQVJTRUQ6ICdobHNGcmFnUGFyc2VkJyxcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCByZW11eGVkIE1QNCBib3hlcyBoYXZlIGFsbCBiZWVuIGFwcGVuZGVkIGludG8gU291cmNlQnVmZmVyIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgdHBhcnNlZCwgdGJ1ZmZlcmVkLCBsZW5ndGgsIGJ3RXN0aW1hdGUgfSB9XG4gIEZSQUdfQlVGRkVSRUQ6ICdobHNGcmFnQnVmZmVyZWQnLFxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IG1hdGNoaW5nIHdpdGggY3VycmVudCBtZWRpYSBwb3NpdGlvbiBpcyBjaGFuZ2luZyAtIGRhdGEgOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gIEZSQUdfQ0hBTkdFRDogJ2hsc0ZyYWdDaGFuZ2VkJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBGUFMgZHJvcCBldmVudCAtIGRhdGE6IHsgY3VyZW50RHJvcHBlZCwgY3VycmVudERlY29kZWQsIHRvdGFsRHJvcHBlZEZyYW1lcyB9XG4gIEZQU19EUk9QOiAnaGxzRnBzRHJvcCcsXG4gIC8vIHRyaWdnZXJlZCB3aGVuIEZQUyBkcm9wIHRyaWdnZXJzIGF1dG8gbGV2ZWwgY2FwcGluZyAtIGRhdGE6IHsgbGV2ZWwsIGRyb3BwZWRsZXZlbCB9XG4gIEZQU19EUk9QX0xFVkVMX0NBUFBJTkc6ICdobHNGcHNEcm9wTGV2ZWxDYXBwaW5nJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYW4gZXJyb3IgZXZlbnQgLSBkYXRhOiB7IHR5cGUgOiBlcnJvciB0eXBlLCBkZXRhaWxzIDogZXJyb3IgZGV0YWlscywgZmF0YWwgOiBpZiB0cnVlLCBobHMuanMgY2Fubm90L3dpbGwgbm90IHRyeSB0byByZWNvdmVyLCBpZiBmYWxzZSwgaGxzLmpzIHdpbGwgdHJ5IHRvIHJlY292ZXIsb3RoZXIgZXJyb3Igc3BlY2lmaWMgZGF0YSB9XG4gIEVSUk9SOiAnaGxzRXJyb3InLFxuICAvLyBmaXJlZCB3aGVuIGhscy5qcyBpbnN0YW5jZSBzdGFydHMgZGVzdHJveWluZy4gRGlmZmVyZW50IGZyb20gTUVESUFfREVUQUNIRUQgYXMgb25lIGNvdWxkIHdhbnQgdG8gZGV0YWNoIGFuZCByZWF0dGFjaCBhIG1lZGlhIHRvIHRoZSBpbnN0YW5jZSBvZiBobHMuanMgdG8gaGFuZGxlIG1pZC1yb2xscyBmb3IgZXhhbXBsZSAtIGRhdGE6IHsgfVxuICBERVNUUk9ZSU5HOiAnaGxzRGVzdHJveWluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBkZWNyeXB0IGtleSBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gIEtFWV9MT0FESU5HOiAnaGxzS2V5TG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBkZWNyeXB0IGtleSBsb2FkaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGtleSBwYXlsb2FkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIGxlbmd0aCB9IH1cbiAgS0VZX0xPQURFRDogJ2hsc0tleUxvYWRlZCcsXG4gIC8vIGZpcmVkIHVwb24gc3RyZWFtIGNvbnRyb2xsZXIgc3RhdGUgdHJhbnNpdGlvbnMgLSBkYXRhOiB7IHByZXZpb3VzU3RhdGUsIG5leHRTdGF0ZSB9XG4gIFNUUkVBTV9TVEFURV9UUkFOU0lUSU9OOiAnaGxzU3RyZWFtU3RhdGVUcmFuc2l0aW9uJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSGxzRXZlbnRzO1xuIiwiaW1wb3J0ICogYXMgVVJMVG9vbGtpdCBmcm9tICd1cmwtdG9vbGtpdCc7XG5cbmltcG9ydCB7XG4gIEVycm9yVHlwZXMsXG4gIEVycm9yRGV0YWlsc1xufSBmcm9tICcuL2Vycm9ycyc7XG5cbmltcG9ydCBQbGF5bGlzdExvYWRlciBmcm9tICcuL2xvYWRlci9wbGF5bGlzdC1sb2FkZXInO1xuaW1wb3J0IEZyYWdtZW50TG9hZGVyIGZyb20gJy4vbG9hZGVyL2ZyYWdtZW50LWxvYWRlcic7XG5pbXBvcnQgS2V5TG9hZGVyIGZyb20gJy4vbG9hZGVyL2tleS1sb2FkZXInO1xuXG5pbXBvcnQgeyBGcmFnbWVudFRyYWNrZXIgfSBmcm9tICcuL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlcic7XG5pbXBvcnQgU3RyZWFtQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXInO1xuaW1wb3J0IExldmVsQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvbGV2ZWwtY29udHJvbGxlcic7XG5pbXBvcnQgSUQzVHJhY2tDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9pZDMtdHJhY2stY29udHJvbGxlcic7XG5cbmltcG9ydCB7IGlzU3VwcG9ydGVkIH0gZnJvbSAnLi9pcy1zdXBwb3J0ZWQnO1xuaW1wb3J0IHsgbG9nZ2VyLCBlbmFibGVMb2dzIH0gZnJvbSAnLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgaGxzRGVmYXVsdENvbmZpZyB9IGZyb20gJy4vY29uZmlnJztcblxuaW1wb3J0IEhsc0V2ZW50cyBmcm9tICcuL2V2ZW50cyc7XG5cbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAnLi9vYnNlcnZlcic7XG5cbi8qKlxuICogQG1vZHVsZSBIbHNcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhscyBleHRlbmRzIE9ic2VydmVyIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHZlcnNpb24gKCkge1xuICAgIHJldHVybiBfX1ZFUlNJT05fXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1N1cHBvcnRlZCAoKSB7XG4gICAgcmV0dXJuIGlzU3VwcG9ydGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0hsc0V2ZW50c31cbiAgICovXG4gIHN0YXRpYyBnZXQgRXZlbnRzICgpIHtcbiAgICByZXR1cm4gSGxzRXZlbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtIbHNFcnJvclR5cGVzfVxuICAgKi9cbiAgc3RhdGljIGdldCBFcnJvclR5cGVzICgpIHtcbiAgICByZXR1cm4gRXJyb3JUeXBlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7SGxzRXJyb3JEZXRhaWxzfVxuICAgKi9cbiAgc3RhdGljIGdldCBFcnJvckRldGFpbHMgKCkge1xuICAgIHJldHVybiBFcnJvckRldGFpbHM7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0hsc0NvbmZpZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgRGVmYXVsdENvbmZpZyAoKSB7XG4gICAgaWYgKCFIbHMuZGVmYXVsdENvbmZpZykge1xuICAgICAgcmV0dXJuIGhsc0RlZmF1bHRDb25maWc7XG4gICAgfVxuXG4gICAgcmV0dXJuIEhscy5kZWZhdWx0Q29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtIbHNDb25maWd9XG4gICAqL1xuICBzdGF0aWMgc2V0IERlZmF1bHRDb25maWcgKGRlZmF1bHRDb25maWcpIHtcbiAgICBIbHMuZGVmYXVsdENvbmZpZyA9IGRlZmF1bHRDb25maWc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhbiBITFMgY2xpZW50IHRoYXQgY2FuIGF0dGFjaCB0byBleGFjdGx5IG9uZSBgSFRNTE1lZGlhRWxlbWVudGAuXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RzIEhsc1xuICAgKiBAcGFyYW0ge0hsc0NvbmZpZ30gY29uZmlnXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IEhscy5EZWZhdWx0Q29uZmlnO1xuXG4gICAgaWYgKChjb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50IHx8IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQpICYmIChjb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBkb25cXCd0IG1peCB1cCBsaXZlU3luY0R1cmF0aW9uQ291bnQvbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IGFuZCBsaXZlU3luY0R1cmF0aW9uL2xpdmVNYXhMYXRlbmN5RHVyYXRpb24nKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBwcm9wIGluIGRlZmF1bHRDb25maWcpIHtcbiAgICAgIGlmIChwcm9wIGluIGNvbmZpZykgY29udGludWU7XG4gICAgICBjb25maWdbcHJvcF0gPSBkZWZhdWx0Q29uZmlnW3Byb3BdO1xuICAgIH1cblxuICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCA8PSBjb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnRcIiBtdXN0IGJlIGd0IFwibGl2ZVN5bmNEdXJhdGlvbkNvdW50XCInKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCAmJiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gPD0gY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25cIiBtdXN0IGJlIGd0IFwibGl2ZVN5bmNEdXJhdGlvblwiJyk7XG4gICAgfVxuXG4gICAgZW5hYmxlTG9ncyhjb25maWcuZGVidWcpO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcblxuICAgIC8vIGNvcmUgY29udHJvbGxlcnMgYW5kIG5ldHdvcmsgbG9hZGVyc1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7QWJyQ29udHJvbGxlcn0gYWJyQ29udHJvbGxlclxuICAgICAqL1xuICAgIGNvbnN0IGFickNvbnRyb2xsZXIgPSB0aGlzLmFickNvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmFickNvbnRyb2xsZXIodGhpcyk7XG5cbiAgICBjb25zdCBidWZmZXJDb250cm9sbGVyID0gbmV3IGNvbmZpZy5idWZmZXJDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IGNhcExldmVsQ29udHJvbGxlciA9IG5ldyBjb25maWcuY2FwTGV2ZWxDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IGZwc0NvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmZwc0NvbnRyb2xsZXIodGhpcyk7XG4gICAgY29uc3QgcGxheUxpc3RMb2FkZXIgPSBuZXcgUGxheWxpc3RMb2FkZXIodGhpcyk7XG4gICAgY29uc3QgZnJhZ21lbnRMb2FkZXIgPSBuZXcgRnJhZ21lbnRMb2FkZXIodGhpcyk7XG4gICAgY29uc3Qga2V5TG9hZGVyID0gbmV3IEtleUxvYWRlcih0aGlzKTtcbiAgICBjb25zdCBpZDNUcmFja0NvbnRyb2xsZXIgPSBuZXcgSUQzVHJhY2tDb250cm9sbGVyKHRoaXMpO1xuXG4gICAgLy8gbmV0d29yayBjb250cm9sbGVyc1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TGV2ZWxDb250cm9sbGVyfSBsZXZlbENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBjb25zdCBsZXZlbENvbnRyb2xsZXIgPSB0aGlzLmxldmVsQ29udHJvbGxlciA9IG5ldyBMZXZlbENvbnRyb2xsZXIodGhpcyk7XG5cbiAgICAvLyBGSVhNRTogRnJhZ21lbnRUcmFja2VyIG11c3QgYmUgZGVmaW5lZCBiZWZvcmUgU3RyZWFtQ29udHJvbGxlciBiZWNhdXNlIHRoZSBvcmRlciBvZiBldmVudCBoYW5kbGluZyBpcyBpbXBvcnRhbnRcbiAgICBjb25zdCBmcmFnbWVudFRyYWNrZXIgPSBuZXcgRnJhZ21lbnRUcmFja2VyKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyZWFtQ29udHJvbGxlcn0gc3RyZWFtQ29udHJvbGxlclxuICAgICAqL1xuICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBuZXcgU3RyZWFtQ29udHJvbGxlcih0aGlzLCBmcmFnbWVudFRyYWNrZXIpO1xuXG4gICAgbGV0IG5ldHdvcmtDb250cm9sbGVycyA9IFtsZXZlbENvbnRyb2xsZXIsIHN0cmVhbUNvbnRyb2xsZXJdO1xuXG4gICAgLy8gb3B0aW9uYWwgYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAvKipcbiAgICAgKiBAdmFyIHtJQ29yZUNvbXBvbmVudCB8IENvbnRyb2xsZXJ9XG4gICAgICovXG4gICAgbGV0IENvbnRyb2xsZXIgPSBjb25maWcuYXVkaW9TdHJlYW1Db250cm9sbGVyO1xuICAgIGlmIChDb250cm9sbGVyKSB7XG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChuZXcgQ29udHJvbGxlcih0aGlzLCBmcmFnbWVudFRyYWNrZXIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtJTmV0d29ya0NvbnRyb2xsZXJbXX0gbmV0d29ya0NvbnRyb2xsZXJzXG4gICAgICovXG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMgPSBuZXR3b3JrQ29udHJvbGxlcnM7XG5cbiAgICAvKipcbiAgICAgKiBAdmFyIHtJQ29yZUNvbXBvbmVudFtdfVxuICAgICAqL1xuICAgIGNvbnN0IGNvcmVDb21wb25lbnRzID0gW1xuICAgICAgcGxheUxpc3RMb2FkZXIsXG4gICAgICBmcmFnbWVudExvYWRlcixcbiAgICAgIGtleUxvYWRlcixcbiAgICAgIGFickNvbnRyb2xsZXIsXG4gICAgICBidWZmZXJDb250cm9sbGVyLFxuICAgICAgY2FwTGV2ZWxDb250cm9sbGVyLFxuICAgICAgZnBzQ29udHJvbGxlcixcbiAgICAgIGlkM1RyYWNrQ29udHJvbGxlcixcbiAgICAgIGZyYWdtZW50VHJhY2tlclxuICAgIF07XG5cbiAgICAvLyBvcHRpb25hbCBhdWRpbyB0cmFjayBhbmQgc3VidGl0bGUgY29udHJvbGxlclxuICAgIENvbnRyb2xsZXIgPSBjb25maWcuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIodGhpcyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7QXVkaW9UcmFja0NvbnRyb2xsZXJ9IGF1ZGlvVHJhY2tDb250cm9sbGVyXG4gICAgICAgKi9cbiAgICAgIHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIgPSBhdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICAgIGNvcmVDb21wb25lbnRzLnB1c2goYXVkaW9UcmFja0NvbnRyb2xsZXIpO1xuICAgIH1cblxuICAgIENvbnRyb2xsZXIgPSBjb25maWcuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIodGhpcyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7U3VidGl0bGVUcmFja0NvbnRyb2xsZXJ9IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyXG4gICAgICAgKi9cbiAgICAgIHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKTtcbiAgICB9XG5cbiAgICBDb250cm9sbGVyID0gY29uZmlnLmVtZUNvbnRyb2xsZXI7XG4gICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IGVtZUNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcih0aGlzKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtFTUVDb250cm9sbGVyfSBlbWVDb250cm9sbGVyXG4gICAgICAgKi9cbiAgICAgIHRoaXMuZW1lQ29udHJvbGxlciA9IGVtZUNvbnRyb2xsZXI7XG4gICAgICBjb3JlQ29tcG9uZW50cy5wdXNoKGVtZUNvbnRyb2xsZXIpO1xuICAgIH1cblxuICAgIC8vIG9wdGlvbmFsIHN1YnRpdGxlIGNvbnRyb2xsZXJzXG4gICAgQ29udHJvbGxlciA9IGNvbmZpZy5zdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKG5ldyBDb250cm9sbGVyKHRoaXMsIGZyYWdtZW50VHJhY2tlcikpO1xuICAgIH1cbiAgICBDb250cm9sbGVyID0gY29uZmlnLnRpbWVsaW5lQ29udHJvbGxlcjtcbiAgICBpZiAoQ29udHJvbGxlcikge1xuICAgICAgY29yZUNvbXBvbmVudHMucHVzaChuZXcgQ29udHJvbGxlcih0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7SUNvcmVDb21wb25lbnRbXX1cbiAgICAgKi9cbiAgICB0aGlzLmNvcmVDb21wb25lbnRzID0gY29yZUNvbXBvbmVudHM7XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZSBvZiB0aGUgaW5zdGFuY2VcbiAgICovXG4gIGRlc3Ryb3kgKCkge1xuICAgIGxvZ2dlci5sb2coJ2Rlc3Ryb3knKTtcbiAgICB0aGlzLnRyaWdnZXIoSGxzRXZlbnRzLkRFU1RST1lJTkcpO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzLmNvbmNhdCh0aGlzLm5ldHdvcmtDb250cm9sbGVycykuZm9yRWFjaChjb21wb25lbnQgPT4ge1xuICAgICAgY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICB0aGlzLnVybCA9IG51bGw7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIGEgbWVkaWEgZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR9IG1lZGlhXG4gICAqL1xuICBhdHRhY2hNZWRpYSAobWVkaWEpIHtcbiAgICBsb2dnZXIubG9nKCdhdHRhY2hNZWRpYScpO1xuICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICB0aGlzLnRyaWdnZXIoSGxzRXZlbnRzLk1FRElBX0FUVEFDSElORywgeyBtZWRpYTogbWVkaWEgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0YWNoIGZyb20gdGhlIG1lZGlhXG4gICAqL1xuICBkZXRhY2hNZWRpYSAoKSB7XG4gICAgbG9nZ2VyLmxvZygnZGV0YWNoTWVkaWEnKTtcbiAgICB0aGlzLnRyaWdnZXIoSGxzRXZlbnRzLk1FRElBX0RFVEFDSElORyk7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgVVJMLiBDYW4gYmUgcmVsYXRpdmUgb3IgYWJzb2x1dGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICovXG4gIGxvYWRTb3VyY2UgKHVybCkge1xuICAgIHVybCA9IFVSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZiwgdXJsLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgICBsb2dnZXIubG9nKGBsb2FkU291cmNlOiR7dXJsfWApO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIC8vIHdoZW4gYXR0YWNoaW5nIHRvIGEgc291cmNlIFVSTCwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWRcbiAgICB0aGlzLnRyaWdnZXIoSGxzRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHsgdXJsOiB1cmwgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgbG9hZGluZyBkYXRhIGZyb20gdGhlIHN0cmVhbSBzb3VyY2UuXG4gICAqIERlcGVuZGluZyBvbiBkZWZhdWx0IGNvbmZpZywgY2xpZW50IHN0YXJ0cyBsb2FkaW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBhIHNvdXJjZSBpcyBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFBvc2l0aW9uIFNldCB0aGUgc3RhcnQgcG9zaXRpb24gdG8gc3RyZWFtIGZyb21cbiAgICogQGRlZmF1bHQgLTEgTm9uZSAoZnJvbSBlYXJsaWVzdCBwb2ludClcbiAgICovXG4gIHN0YXJ0TG9hZCAoc3RhcnRQb3NpdGlvbiA9IC0xKSB7XG4gICAgbG9nZ2VyLmxvZyhgc3RhcnRMb2FkKCR7c3RhcnRQb3NpdGlvbn0pYCk7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChjb250cm9sbGVyID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgbG9hZGluZyBvZiBhbnkgc3RyZWFtIGRhdGEuXG4gICAqL1xuICBzdG9wTG9hZCAoKSB7XG4gICAgbG9nZ2VyLmxvZygnc3RvcExvYWQnKTtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGNvbnRyb2xsZXIgPT4ge1xuICAgICAgY29udHJvbGxlci5zdG9wTG9hZCgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN3YXAgdGhyb3VnaCBwb3NzaWJsZSBhdWRpbyBjb2RlY3MgaW4gdGhlIHN0cmVhbSAoZm9yIGV4YW1wbGUgdG8gc3dpdGNoIGZyb20gc3RlcmVvIHRvIDUuMSlcbiAgICovXG4gIHN3YXBBdWRpb0NvZGVjICgpIHtcbiAgICBsb2dnZXIubG9nKCdzd2FwQXVkaW9Db2RlYycpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zd2FwQXVkaW9Db2RlYygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIG1lZGlhLWVsZW1lbnQgZmFpbHMsIHRoaXMgYWxsb3dzIHRvIGRldGFjaCBhbmQgdGhlbiByZS1hdHRhY2ggaXRcbiAgICogYXMgb25lIGNhbGwgKGNvbnZlbmllbmNlIG1ldGhvZCkuXG4gICAqXG4gICAqIEF1dG9tYXRpYyByZWNvdmVyeSBvZiBtZWRpYS1lcnJvcnMgYnkgdGhpcyBwcm9jZXNzIGlzIGNvbmZpZ3VyYWJsZS5cbiAgICovXG4gIHJlY292ZXJNZWRpYUVycm9yICgpIHtcbiAgICBsb2dnZXIubG9nKCdyZWNvdmVyTWVkaWFFcnJvcicpO1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgIHRoaXMuYXR0YWNoTWVkaWEobWVkaWEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtRdWFsaXR5TGV2ZWxbXX1cbiAgICovXG4gIGdldCBsZXZlbHMgKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbHM7XG4gIH1cblxuICAvKipcbiAgICogSW5kZXggb2YgcXVhbGl0eSBsZXZlbCBjdXJyZW50bHkgcGxheWVkXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgY3VycmVudExldmVsICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBpbW1lZGlhdGVseSAuXG4gICAqIFRoaXMgd2lsbCBmbHVzaCB0aGUgY3VycmVudCBidWZmZXIgdG8gcmVwbGFjZSB0aGUgcXVhbGl0eSBhc2FwLlxuICAgKiBUaGF0IG1lYW5zIHBsYXliYWNrIHdpbGwgaW50ZXJydXB0IGF0IGxlYXN0IHNob3J0bHkgdG8gcmUtYnVmZmVyIGFuZCByZS1zeW5jIGV2ZW50dWFsbHkuXG4gICAqIEB0eXBlIHtudW1iZXJ9IC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uXG4gICAqL1xuICBzZXQgY3VycmVudExldmVsIChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBjdXJyZW50TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxvYWRMZXZlbCA9IG5ld0xldmVsO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIG5leHQgcXVhbGl0eSBsZXZlbCBsb2FkZWQgYXMgc2NoZWR1bGVkIGJ5IHN0cmVhbSBjb250cm9sbGVyLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG5leHRMZXZlbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEuXG4gICAqIFRoaXMgd2lsbCBzd2l0Y2ggdGhlIHZpZGVvIHF1YWxpdHkgYXNhcCwgd2l0aG91dCBpbnRlcnJ1cHRpbmcgcGxheWJhY2suXG4gICAqIE1heSBhYm9ydCBjdXJyZW50IGxvYWRpbmcgb2YgZGF0YSwgYW5kIGZsdXNoIHBhcnRzIG9mIGJ1ZmZlciAob3V0c2lkZSBjdXJyZW50bHkgcGxheWVkIGZyYWdtZW50IHJlZ2lvbikuXG4gICAqIEB0eXBlIHtudW1iZXJ9IC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uXG4gICAqL1xuICBzZXQgbmV4dExldmVsIChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBuZXh0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHF1YWxpdHkgbGV2ZWwgb2YgdGhlIGN1cnJlbnRseSBvciBsYXN0IChvZiBub25lIGlzIGxvYWRlZCBjdXJyZW50bHkpIHNlZ21lbnRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBsb2FkTGV2ZWwgKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YSBpbiBhIGNvbnNlcnZhdGl2ZSB3YXkuXG4gICAqIFRoaXMgd2lsbCBzd2l0Y2ggdGhlIHF1YWxpdHkgd2l0aG91dCBmbHVzaGluZywgYnV0IGludGVycnVwdCBjdXJyZW50IGxvYWRpbmcuXG4gICAqIFRodXMgdGhlIG1vbWVudCB3aGVuIHRoZSBxdWFsaXR5IHN3aXRjaCB3aWxsIGFwcGVhciBpbiBlZmZlY3Qgd2lsbCBvbmx5IGJlIGFmdGVyIHRoZSBhbHJlYWR5IGV4aXN0aW5nIGJ1ZmZlci5cbiAgICogQHR5cGUge251bWJlcn0gbmV3TGV2ZWwgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICovXG4gIHNldCBsb2FkTGV2ZWwgKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGxvYWRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IG5leHQgcXVhbGl0eSBsZXZlbCBsb2FkZWRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBuZXh0TG9hZExldmVsICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBvZiBuZXh0IGxvYWRlZCBzZWdtZW50IGluIGEgZnVsbHkgXCJub24tZGVzdHJ1Y3RpdmVcIiB3YXkuXG4gICAqIFNhbWUgYXMgYGxvYWRMZXZlbGAgYnV0IHdpbGwgd2FpdCBmb3IgbmV4dCBzd2l0Y2ggKHVudGlsIGN1cnJlbnQgbG9hZGluZyBpcyBkb25lKS5cbiAgICogQHR5cGUge251bWJlcn0gbGV2ZWxcbiAgICovXG4gIHNldCBuZXh0TG9hZExldmVsIChsZXZlbCkge1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gXCJmaXJzdCBsZXZlbFwiOiBsaWtlIGEgZGVmYXVsdCBsZXZlbCwgaWYgbm90IHNldCxcbiAgICogZmFsbHMgYmFjayB0byBpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZmlyc3RMZXZlbCAoKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWwsIHRoaXMubWluQXV0b0xldmVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIFwiZmlyc3QtbGV2ZWxcIiwgc2VlIGdldHRlci5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNldCBmaXJzdExldmVsIChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBmaXJzdExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBzdGFydCBsZXZlbCAobGV2ZWwgb2YgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIHBsYXllZCBiYWNrKVxuICAgKiBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcbiAgICogaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoXG4gICAqIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBzdGFydExldmVsICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXG4gICAqIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgKiBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGhcbiAgICogKGRldGVybWluZWQgZnJvbSBkb3dubG9hZCBvZiBmaXJzdCBzZWdtZW50KVxuICAgKiBAdHlwZSB7bnVtYmVyfSBuZXdMZXZlbFxuICAgKi9cbiAgc2V0IHN0YXJ0TGV2ZWwgKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IHN0YXJ0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICBjb25zdCBobHMgPSB0aGlzO1xuICAgIC8vIGlmIG5vdCBpbiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgZGV0ZWN0aW9uLCBlbnN1cmUgc3RhcnRMZXZlbCBpcyBncmVhdGVyIHRoYW4gbWluQXV0b0xldmVsXG4gICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1heChuZXdMZXZlbCwgaGxzLm1pbkF1dG9MZXZlbCk7XG4gICAgfVxuXG4gICAgaGxzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogQ2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAoYEFCUkNvbnRyb2xsZXJgKVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGF1dG9MZXZlbENhcHBpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNldCBhdXRvTGV2ZWxDYXBwaW5nIChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBhdXRvTGV2ZWxDYXBwaW5nOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRydWUgd2hlbiBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGVuYWJsZWRcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgYXV0b0xldmVsRW5hYmxlZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9PT0gLTEpO1xuICB9XG5cbiAgLyoqXG4gICAqIExldmVsIHNldCBtYW51YWxseSAoaWYgYW55KVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1hbnVhbExldmVsICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogbWluIGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBjb25maWcubWluQXV0b0JpdHJhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaW5BdXRvTGV2ZWwgKCkge1xuICAgIGxldCBobHMgPSB0aGlzLCBsZXZlbHMgPSBobHMubGV2ZWxzLCBtaW5BdXRvQml0cmF0ZSA9IGhscy5jb25maWcubWluQXV0b0JpdHJhdGUsIGxlbiA9IGxldmVscyA/IGxldmVscy5sZW5ndGggOiAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGxldmVsTmV4dEJpdHJhdGUgPSBsZXZlbHNbaV0ucmVhbEJpdHJhdGUgPyBNYXRoLm1heChsZXZlbHNbaV0ucmVhbEJpdHJhdGUsIGxldmVsc1tpXS5iaXRyYXRlKSA6IGxldmVsc1tpXS5iaXRyYXRlO1xuICAgICAgaWYgKGxldmVsTmV4dEJpdHJhdGUgPiBtaW5BdXRvQml0cmF0ZSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogbWF4IGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBhdXRvTGV2ZWxDYXBwaW5nXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWF4QXV0b0xldmVsICgpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzO1xuICAgIGNvbnN0IGxldmVscyA9IGhscy5sZXZlbHM7XG4gICAgY29uc3QgYXV0b0xldmVsQ2FwcGluZyA9IGhscy5hdXRvTGV2ZWxDYXBwaW5nO1xuICAgIGxldCBtYXhBdXRvTGV2ZWw7XG4gICAgaWYgKGF1dG9MZXZlbENhcHBpbmcgPT09IC0xICYmIGxldmVscyAmJiBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICBtYXhBdXRvTGV2ZWwgPSBsZXZlbHMubGVuZ3RoIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4QXV0b0xldmVsID0gYXV0b0xldmVsQ2FwcGluZztcbiAgICB9XG5cbiAgICByZXR1cm4gbWF4QXV0b0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIG5leHQgYXV0b21hdGljYWxseSBzZWxlY3RlZCBxdWFsaXR5IGxldmVsXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbmV4dEF1dG9MZXZlbCAoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcztcbiAgICAvLyBlbnN1cmUgbmV4dCBhdXRvIGxldmVsIGlzIGJldHdlZW4gIG1pbiBhbmQgbWF4IGF1dG8gbGV2ZWxcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoaGxzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCwgaGxzLm1pbkF1dG9MZXZlbCksIGhscy5tYXhBdXRvTGV2ZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIHRoaXMgc2V0dGVyIGlzIHVzZWQgdG8gZm9yY2UgbmV4dCBhdXRvIGxldmVsLlxuICAgKiB0aGlzIGlzIHVzZWZ1bCB0byBmb3JjZSBhIHN3aXRjaCBkb3duIGluIGF1dG8gbW9kZTpcbiAgICogaW4gY2FzZSBvZiBsb2FkIGVycm9yIG9uIGxldmVsIE4sIGhscy5qcyBjYW4gc2V0IG5leHRBdXRvTGV2ZWwgdG8gTi0xIGZvciBleGFtcGxlKVxuICAgKiBmb3JjZWQgdmFsdWUgaXMgdmFsaWQgZm9yIG9uZSBmcmFnbWVudC4gdXBvbiBzdWNjZXNmdWwgZnJhZyBsb2FkaW5nIGF0IGZvcmNlZCBsZXZlbCxcbiAgICogdGhpcyB2YWx1ZSB3aWxsIGJlIHJlc2V0dGVkIHRvIC0xIGJ5IEFCUiBjb250cm9sbGVyLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2V0IG5leHRBdXRvTGV2ZWwgKG5leHRMZXZlbCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXM7XG4gICAgaGxzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCA9IE1hdGgubWF4KGhscy5taW5BdXRvTGV2ZWwsIG5leHRMZXZlbCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0F1ZGlvVHJhY2tbXX1cbiAgICovXG4gIGdldCBhdWRpb1RyYWNrcyAoKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2tzIDogW107XG4gIH1cblxuICAvKipcbiAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIGF1ZGlvIHRyYWNrIChpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cylcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBhdWRpb1RyYWNrICgpIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjayA6IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIHNlbGVjdHMgYW4gYXVkaW8gdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0c1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2V0IGF1ZGlvVHJhY2sgKGF1ZGlvVHJhY2tJZCkge1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICBpZiAoYXVkaW9UcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgIGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgPSBhdWRpb1RyYWNrSWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTZWNvbmRzfVxuICAgKi9cbiAgZ2V0IGxpdmVTeW5jUG9zaXRpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubGl2ZVN5bmNQb3NpdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3RcbiAgICogQHR5cGUge1N1YnRpdGxlVHJhY2tbXX1cbiAgICovXG4gIGdldCBzdWJ0aXRsZVRyYWNrcyAoKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2tzIDogW107XG4gIH1cblxuICAvKipcbiAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIHN1YnRpdGxlIHRyYWNrIChpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cylcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBzdWJ0aXRsZVRyYWNrICgpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA6IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIHNlbGVjdCBhbiBzdWJ0aXRsZSB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzXG4gICAqIEB0eXBle251bWJlcn1cbiAgICovXG4gIHNldCBzdWJ0aXRsZVRyYWNrIChzdWJ0aXRsZVRyYWNrSWQpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrID0gc3VidGl0bGVUcmFja0lkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBzdWJ0aXRsZURpc3BsYXkgKCkge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZURpc3BsYXkgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUvZGlzYWJsZSBzdWJ0aXRsZSBkaXNwbGF5IHJlbmRlcmluZ1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHNldCBzdWJ0aXRsZURpc3BsYXkgKHZhbHVlKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcikge1xuICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVEaXNwbGF5ID0gdmFsdWU7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBnZXRNZWRpYVNvdXJjZSB9IGZyb20gJy4vdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3VwcG9ydGVkICgpIHtcbiAgY29uc3QgbWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSgpO1xuICBjb25zdCBzb3VyY2VCdWZmZXIgPSB3aW5kb3cuU291cmNlQnVmZmVyIHx8IHdpbmRvdy5XZWJLaXRTb3VyY2VCdWZmZXI7XG4gIGNvbnN0IGlzVHlwZVN1cHBvcnRlZCA9IG1lZGlhU291cmNlICYmXG4gICAgdHlwZW9mIG1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIG1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXA0OyBjb2RlY3M9XCJhdmMxLjQyRTAxRSxtcDRhLjQwLjJcIicpO1xuXG4gIC8vIGlmIFNvdXJjZUJ1ZmZlciBpcyBleHBvc2VkIGVuc3VyZSBpdHMgQVBJIGlzIHZhbGlkXG4gIC8vIHNhZmFyaSBhbmQgb2xkIHZlcnNpb24gb2YgQ2hyb21lIGRvZSBub3QgZXhwb3NlIFNvdXJjZUJ1ZmZlciBnbG9iYWxseSBzbyBjaGVja2luZyBTb3VyY2VCdWZmZXIucHJvdG90eXBlIGlzIGltcG9zc2libGVcbiAgY29uc3Qgc291cmNlQnVmZmVyVmFsaWRBUEkgPSAhc291cmNlQnVmZmVyIHx8XG4gICAgKHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUgJiZcbiAgICAgIHR5cGVvZiBzb3VyY2VCdWZmZXIucHJvdG90eXBlLmFwcGVuZEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUucmVtb3ZlID09PSAnZnVuY3Rpb24nKTtcbiAgcmV0dXJuICEhaXNUeXBlU3VwcG9ydGVkICYmICEhc291cmNlQnVmZmVyVmFsaWRBUEk7XG59XG4iLCIvKlxuICogRnJhZ21lbnQgTG9hZGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgRnJhZ21lbnRMb2FkZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCBFdmVudC5GUkFHX0xPQURJTkcpO1xuICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgbGV0IGxvYWRlcnMgPSB0aGlzLmxvYWRlcnM7XG4gICAgZm9yIChsZXQgbG9hZGVyTmFtZSBpbiBsb2FkZXJzKSB7XG4gICAgICBsZXQgbG9hZGVyID0gbG9hZGVyc1tsb2FkZXJOYW1lXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2FkZXJzID0ge307XG5cbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICBvbkZyYWdMb2FkaW5nIChkYXRhKSB7XG4gICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgIHR5cGUgPSBmcmFnLnR5cGUsXG4gICAgICBsb2FkZXJzID0gdGhpcy5sb2FkZXJzLFxuICAgICAgY29uZmlnID0gdGhpcy5obHMuY29uZmlnLFxuICAgICAgRnJhZ21lbnRJTG9hZGVyID0gY29uZmlnLmZMb2FkZXIsXG4gICAgICBEZWZhdWx0SUxvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG5cbiAgICAvLyByZXNldCBmcmFnbWVudCBzdGF0ZVxuICAgIGZyYWcubG9hZGVkID0gMDtcblxuICAgIGxldCBsb2FkZXIgPSBsb2FkZXJzW3R5cGVdO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvZ2dlci53YXJuKGBhYm9ydCBwcmV2aW91cyBmcmFnbWVudCBsb2FkZXIgZm9yIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIGxvYWRlciA9IGxvYWRlcnNbdHlwZV0gPSBmcmFnLmxvYWRlciA9XG4gICAgICBjb25maWcuZkxvYWRlciA/IG5ldyBGcmFnbWVudElMb2FkZXIoY29uZmlnKSA6IG5ldyBEZWZhdWx0SUxvYWRlcihjb25maWcpO1xuXG4gICAgbGV0IGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzO1xuXG4gICAgbG9hZGVyQ29udGV4dCA9IHsgdXJsOiBmcmFnLnVybCwgZnJhZzogZnJhZywgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLCBwcm9ncmVzc0RhdGE6IGZhbHNlIH07XG5cbiAgICBsZXQgc3RhcnQgPSBmcmFnLmJ5dGVSYW5nZVN0YXJ0T2Zmc2V0LFxuICAgICAgZW5kID0gZnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG5cbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHN0YXJ0KSAmJiBOdW1iZXIuaXNGaW5pdGUoZW5kKSkge1xuICAgICAgbG9hZGVyQ29udGV4dC5yYW5nZVN0YXJ0ID0gc3RhcnQ7XG4gICAgICBsb2FkZXJDb250ZXh0LnJhbmdlRW5kID0gZW5kO1xuICAgIH1cblxuICAgIGxvYWRlckNvbmZpZyA9IHtcbiAgICAgIHRpbWVvdXQ6IGNvbmZpZy5mcmFnTG9hZGluZ1RpbWVPdXQsXG4gICAgICBtYXhSZXRyeTogMCxcbiAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICBtYXhSZXRyeURlbGF5OiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXRcbiAgICB9O1xuXG4gICAgbG9hZGVyQ2FsbGJhY2tzID0ge1xuICAgICAgb25TdWNjZXNzOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLmxvYWRlcnJvci5iaW5kKHRoaXMpLFxuICAgICAgb25UaW1lb3V0OiB0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLmxvYWRwcm9ncmVzcy5iaW5kKHRoaXMpXG4gICAgfTtcblxuICAgIGxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgfVxuXG4gIGxvYWRzdWNjZXNzIChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzID0gbnVsbCkge1xuICAgIGxldCBwYXlsb2FkID0gcmVzcG9uc2UuZGF0YSwgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICAvLyBkZXRhY2ggZnJhZ21lbnQgbG9hZGVyIG9uIGxvYWQgc3VjY2Vzc1xuICAgIGZyYWcubG9hZGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubG9hZGVyc1tmcmFnLnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FERUQsIHsgcGF5bG9hZDogcGF5bG9hZCwgZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzLCBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMgfSk7XG4gIH1cblxuICBsb2FkZXJyb3IgKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyA9IG51bGwpIHtcbiAgICBjb25zdCBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgIGxldCBsb2FkZXIgPSBmcmFnLmxvYWRlcjtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUiwgZmF0YWw6IGZhbHNlLCBmcmFnOiBjb250ZXh0LmZyYWcsIHJlc3BvbnNlOiByZXNwb25zZSwgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzIH0pO1xuICB9XG5cbiAgbG9hZHRpbWVvdXQgKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyA9IG51bGwpIHtcbiAgICBjb25zdCBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgIGxldCBsb2FkZXIgPSBmcmFnLmxvYWRlcjtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VULCBmYXRhbDogZmFsc2UsIGZyYWc6IGNvbnRleHQuZnJhZywgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzIH0pO1xuICB9XG5cbiAgLy8gZGF0YSB3aWxsIGJlIHVzZWQgZm9yIHByb2dyZXNzaXZlIHBhcnNpbmdcbiAgbG9hZHByb2dyZXNzIChzdGF0cywgY29udGV4dCwgZGF0YSwgbmV0d29ya0RldGFpbHMgPSBudWxsKSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIGxldCBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgIGZyYWcubG9hZGVkID0gc3RhdHMubG9hZGVkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FEX1BST0dSRVNTLCB7IGZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0cywgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZyYWdtZW50TG9hZGVyO1xuIiwiXG5pbXBvcnQgKiBhcyBVUkxUb29sa2l0IGZyb20gJ3VybC10b29sa2l0JztcblxuaW1wb3J0IExldmVsS2V5IGZyb20gJy4vbGV2ZWwta2V5JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRnJhZ21lbnQge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5fdXJsID0gbnVsbDtcbiAgICB0aGlzLl9ieXRlUmFuZ2UgPSBudWxsO1xuICAgIHRoaXMuX2RlY3J5cHRkYXRhID0gbnVsbDtcbiAgICB0aGlzLnRhZ0xpc3QgPSBbXTtcbiAgICB0aGlzLnByb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgdGhpcy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuXG4gICAgLy8gSG9sZHMgdGhlIHR5cGVzIG9mIGRhdGEgdGhpcyBmcmFnbWVudCBzdXBwb3J0c1xuICAgIHRoaXMuX2VsZW1lbnRhcnlTdHJlYW1zID0ge1xuICAgICAgW0ZyYWdtZW50LkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT106IGZhbHNlLFxuICAgICAgW0ZyYWdtZW50LkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT106IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBgdHlwZWAgcHJvcGVydHkgZm9yIHRoaXMuX2VsZW1lbnRhcnlTdHJlYW1zXG4gICAqXG4gICAqIEBlbnVtXG4gICAqL1xuICBzdGF0aWMgZ2V0IEVsZW1lbnRhcnlTdHJlYW1UeXBlcyAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEFVRElPOiAnYXVkaW8nLFxuICAgICAgVklERU86ICd2aWRlbydcbiAgICB9O1xuICB9XG5cbiAgZ2V0IHVybCAoKSB7XG4gICAgaWYgKCF0aGlzLl91cmwgJiYgdGhpcy5yZWx1cmwpIHtcbiAgICAgIHRoaXMuX3VybCA9IFVSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVVSTCh0aGlzLmJhc2V1cmwsIHRoaXMucmVsdXJsLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdXJsO1xuICB9XG5cbiAgc2V0IHVybCAodmFsdWUpIHtcbiAgICB0aGlzLl91cmwgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBieXRlUmFuZ2UgKCkge1xuICAgIGlmICghdGhpcy5fYnl0ZVJhbmdlICYmICF0aGlzLnJhd0J5dGVSYW5nZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ieXRlUmFuZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ieXRlUmFuZ2U7XG4gICAgfVxuXG4gICAgbGV0IGJ5dGVSYW5nZSA9IFtdO1xuICAgIGlmICh0aGlzLnJhd0J5dGVSYW5nZSkge1xuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5yYXdCeXRlUmFuZ2Uuc3BsaXQoJ0AnLCAyKTtcbiAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgPSB0aGlzLmxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgIGJ5dGVSYW5nZVswXSA9IGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgfHwgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ5dGVSYW5nZVswXSA9IHBhcnNlSW50KHBhcmFtc1sxXSk7XG4gICAgICB9XG4gICAgICBieXRlUmFuZ2VbMV0gPSBwYXJzZUludChwYXJhbXNbMF0pICsgYnl0ZVJhbmdlWzBdO1xuICAgICAgdGhpcy5fYnl0ZVJhbmdlID0gYnl0ZVJhbmdlO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZVJhbmdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgYnl0ZVJhbmdlU3RhcnRPZmZzZXQgKCkge1xuICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVswXTtcbiAgfVxuXG4gIGdldCBieXRlUmFuZ2VFbmRPZmZzZXQgKCkge1xuICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVsxXTtcbiAgfVxuXG4gIGdldCBkZWNyeXB0ZGF0YSAoKSB7XG4gICAgaWYgKCF0aGlzLl9kZWNyeXB0ZGF0YSkge1xuICAgICAgdGhpcy5fZGVjcnlwdGRhdGEgPSB0aGlzLmZyYWdtZW50RGVjcnlwdGRhdGFGcm9tTGV2ZWxrZXkodGhpcy5sZXZlbGtleSwgdGhpcy5zbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhO1xuICB9XG5cbiAgZ2V0IGVuZFByb2dyYW1EYXRlVGltZSAoKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodGhpcy5wcm9ncmFtRGF0ZVRpbWUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgZHVyYXRpb24gPSAhTnVtYmVyLmlzRmluaXRlKHRoaXMuZHVyYXRpb24pID8gMCA6IHRoaXMuZHVyYXRpb247XG5cbiAgICByZXR1cm4gdGhpcy5wcm9ncmFtRGF0ZVRpbWUgKyAoZHVyYXRpb24gKiAxMDAwKTtcbiAgfVxuXG4gIGdldCBlbmNyeXB0ZWQgKCkge1xuICAgIHJldHVybiAhISgodGhpcy5kZWNyeXB0ZGF0YSAmJiB0aGlzLmRlY3J5cHRkYXRhLnVyaSAhPT0gbnVsbCkgJiYgKHRoaXMuZGVjcnlwdGRhdGEua2V5ID09PSBudWxsKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50YXJ5U3RyZWFtVHlwZX0gdHlwZVxuICAgKi9cbiAgYWRkRWxlbWVudGFyeVN0cmVhbSAodHlwZSkge1xuICAgIHRoaXMuX2VsZW1lbnRhcnlTdHJlYW1zW3R5cGVdID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnRhcnlTdHJlYW1UeXBlfSB0eXBlXG4gICAqL1xuICBoYXNFbGVtZW50YXJ5U3RyZWFtICh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRhcnlTdHJlYW1zW3R5cGVdID09PSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIGZvciBwYXJzZUxldmVsUGxheWxpc3QgdG8gY3JlYXRlIGFuIGluaXRpYWxpemF0aW9uIHZlY3RvciBmb3IgYSBnaXZlbiBzZWdtZW50XG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgKi9cbiAgY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3IgKHNlZ21lbnROdW1iZXIpIHtcbiAgICBsZXQgdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG4gICAgZm9yIChsZXQgaSA9IDEyOyBpIDwgMTY7IGkrKykge1xuICAgICAgdWludDhWaWV3W2ldID0gKHNlZ21lbnROdW1iZXIgPj4gOCAqICgxNSAtIGkpKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVpbnQ4VmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IG1ldGhvZCBmb3IgcGFyc2VMZXZlbFBsYXlsaXN0IHRvIGdldCBhIGZyYWdtZW50J3MgZGVjcnlwdGlvbiBkYXRhIGZyb20gdGhlIGN1cnJlbnRseSBwYXJzZWQgZW5jcnlwdGlvbiBrZXkgZGF0YVxuICAgKiBAcGFyYW0gbGV2ZWxrZXkgLSBhIHBsYXlsaXN0J3MgZW5jcnlwdGlvbiBpbmZvXG4gICAqIEBwYXJhbSBzZWdtZW50TnVtYmVyIC0gdGhlIGZyYWdtZW50J3Mgc2VnbWVudCBudW1iZXJcbiAgICogQHJldHVybnMgeyp9IC0gYW4gb2JqZWN0IHRvIGJlIGFwcGxpZWQgYXMgYSBmcmFnbWVudCdzIGRlY3J5cHRkYXRhXG4gICAqL1xuICBmcmFnbWVudERlY3J5cHRkYXRhRnJvbUxldmVsa2V5IChsZXZlbGtleSwgc2VnbWVudE51bWJlcikge1xuICAgIGxldCBkZWNyeXB0ZGF0YSA9IGxldmVsa2V5O1xuXG4gICAgaWYgKGxldmVsa2V5ICYmIGxldmVsa2V5Lm1ldGhvZCAmJiBsZXZlbGtleS51cmkgJiYgIWxldmVsa2V5Lml2KSB7XG4gICAgICBkZWNyeXB0ZGF0YSA9IG5ldyBMZXZlbEtleSgpO1xuICAgICAgZGVjcnlwdGRhdGEubWV0aG9kID0gbGV2ZWxrZXkubWV0aG9kO1xuICAgICAgZGVjcnlwdGRhdGEuYmFzZXVyaSA9IGxldmVsa2V5LmJhc2V1cmk7XG4gICAgICBkZWNyeXB0ZGF0YS5yZWx1cmkgPSBsZXZlbGtleS5yZWx1cmk7XG4gICAgICBkZWNyeXB0ZGF0YS5pdiA9IHRoaXMuY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3Ioc2VnbWVudE51bWJlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY3J5cHRkYXRhO1xuICB9XG59XG4iLCIvKlxuICogRGVjcnlwdCBrZXkgTG9hZGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgS2V5TG9hZGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuS0VZX0xPQURJTkcpO1xuICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICAgIHRoaXMuZGVjcnlwdGtleSA9IG51bGw7XG4gICAgdGhpcy5kZWNyeXB0dXJsID0gbnVsbDtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGZvciAobGV0IGxvYWRlck5hbWUgaW4gdGhpcy5sb2FkZXJzKSB7XG4gICAgICBsZXQgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2xvYWRlck5hbWVdO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIG9uS2V5TG9hZGluZyAoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgdHlwZSA9IGZyYWcudHlwZSxcbiAgICAgIGxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXSxcbiAgICAgIGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YSxcbiAgICAgIHVyaSA9IGRlY3J5cHRkYXRhLnVyaTtcbiAgICAvLyBpZiB1cmkgaXMgZGlmZmVyZW50IGZyb20gcHJldmlvdXMgb25lIG9yIGlmIGRlY3J5cHQga2V5IG5vdCByZXRyaWV2ZWQgeWV0XG4gICAgaWYgKHVyaSAhPT0gdGhpcy5kZWNyeXB0dXJsIHx8IHRoaXMuZGVjcnlwdGtleSA9PT0gbnVsbCkge1xuICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcblxuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2dnZXIud2FybihgYWJvcnQgcHJldmlvdXMga2V5IGxvYWRlciBmb3IgdHlwZToke3R5cGV9YCk7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgZnJhZy5sb2FkZXIgPSB0aGlzLmxvYWRlcnNbdHlwZV0gPSBuZXcgY29uZmlnLmxvYWRlcihjb25maWcpO1xuICAgICAgdGhpcy5kZWNyeXB0dXJsID0gdXJpO1xuICAgICAgdGhpcy5kZWNyeXB0a2V5ID0gbnVsbDtcblxuICAgICAgbGV0IGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzO1xuICAgICAgbG9hZGVyQ29udGV4dCA9IHsgdXJsOiB1cmksIGZyYWc6IGZyYWcsIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyB9O1xuICAgICAgLy8gbWF4UmV0cnkgaXMgMCBzbyB0aGF0IGluc3RlYWQgb2YgcmV0cnlpbmcgdGhlIHNhbWUga2V5IG9uIHRoZSBzYW1lIHZhcmlhbnQgbXVsdGlwbGUgdGltZXMsXG4gICAgICAvLyBrZXktbG9hZGVyIHdpbGwgdHJpZ2dlciBhbiBlcnJvciBhbmQgcmVseSBvbiBzdHJlYW0tY29udHJvbGxlciB0byBoYW5kbGUgcmV0cnkgbG9naWMuXG4gICAgICAvLyB0aGlzIHdpbGwgYWxzbyBhbGlnbiByZXRyeSBsb2dpYyB3aXRoIGZyYWdtZW50LWxvYWRlclxuICAgICAgbG9hZGVyQ29uZmlnID0geyB0aW1lb3V0OiBjb25maWcuZnJhZ0xvYWRpbmdUaW1lT3V0LCBtYXhSZXRyeTogMCwgcmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0IH07XG4gICAgICBsb2FkZXJDYWxsYmFja3MgPSB7IG9uU3VjY2VzczogdGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLCBvbkVycm9yOiB0aGlzLmxvYWRlcnJvci5iaW5kKHRoaXMpLCBvblRpbWVvdXQ6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSB9O1xuICAgICAgZnJhZy5sb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRlY3J5cHRrZXkpIHtcbiAgICAgIC8vIHdlIGFscmVhZHkgbG9hZGVkIHRoaXMga2V5LCByZXR1cm4gaXRcbiAgICAgIGRlY3J5cHRkYXRhLmtleSA9IHRoaXMuZGVjcnlwdGtleTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuS0VZX0xPQURFRCwgeyBmcmFnOiBmcmFnIH0pO1xuICAgIH1cbiAgfVxuXG4gIGxvYWRzdWNjZXNzIChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQpIHtcbiAgICBsZXQgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICB0aGlzLmRlY3J5cHRrZXkgPSBmcmFnLmRlY3J5cHRkYXRhLmtleSA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmRhdGEpO1xuICAgIC8vIGRldGFjaCBmcmFnbWVudCBsb2FkZXIgb24gbG9hZCBzdWNjZXNzXG4gICAgZnJhZy5sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5LRVlfTE9BREVELCB7IGZyYWc6IGZyYWcgfSk7XG4gIH1cblxuICBsb2FkZXJyb3IgKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgbGV0IGZyYWcgPSBjb250ZXh0LmZyYWcsXG4gICAgICBsb2FkZXIgPSBmcmFnLmxvYWRlcjtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBmYXRhbDogZmFsc2UsIGZyYWc6IGZyYWcsIHJlc3BvbnNlOiByZXNwb25zZSB9KTtcbiAgfVxuXG4gIGxvYWR0aW1lb3V0IChzdGF0cywgY29udGV4dCkge1xuICAgIGxldCBmcmFnID0gY29udGV4dC5mcmFnLFxuICAgICAgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VULCBmYXRhbDogZmFsc2UsIGZyYWc6IGZyYWcgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgS2V5TG9hZGVyO1xuIiwiaW1wb3J0ICogYXMgVVJMVG9vbGtpdCBmcm9tICd1cmwtdG9vbGtpdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExldmVsS2V5IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMubWV0aG9kID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgdGhpcy5pdiA9IG51bGw7XG4gICAgdGhpcy5fdXJpID0gbnVsbDtcbiAgfVxuXG4gIGdldCB1cmkgKCkge1xuICAgIGlmICghdGhpcy5fdXJpICYmIHRoaXMucmVsdXJpKSB7XG4gICAgICB0aGlzLl91cmkgPSBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVVUkwodGhpcy5iYXNldXJpLCB0aGlzLnJlbHVyaSwgeyBhbHdheXNOb3JtYWxpemU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3VyaTtcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGV2ZWwge1xuICBjb25zdHJ1Y3RvciAoYmFzZVVybCkge1xuICAgIC8vIFBsZWFzZSBrZWVwIHByb3BlcnRpZXMgaW4gYWxwaGFiZXRpY2FsIG9yZGVyXG4gICAgdGhpcy5lbmRDQyA9IDA7XG4gICAgdGhpcy5lbmRTTiA9IDA7XG4gICAgdGhpcy5mcmFnbWVudHMgPSBbXTtcbiAgICB0aGlzLmluaXRTZWdtZW50ID0gbnVsbDtcbiAgICB0aGlzLmxpdmUgPSB0cnVlO1xuICAgIHRoaXMubmVlZFNpZHhSYW5nZXMgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0Q0MgPSAwO1xuICAgIHRoaXMuc3RhcnRTTiA9IDA7XG4gICAgdGhpcy5zdGFydFRpbWVPZmZzZXQgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0ZHVyYXRpb24gPSAwO1xuICAgIHRoaXMudG90YWxkdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50eXBlID0gbnVsbDtcbiAgICB0aGlzLnVybCA9IGJhc2VVcmw7XG4gICAgdGhpcy52ZXJzaW9uID0gbnVsbDtcbiAgfVxuXG4gIGdldCBoYXNQcm9ncmFtRGF0ZVRpbWUgKCkge1xuICAgIHJldHVybiAhISh0aGlzLmZyYWdtZW50c1swXSAmJiBOdW1iZXIuaXNGaW5pdGUodGhpcy5mcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lKSk7XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIFVSTFRvb2xraXQgZnJvbSAndXJsLXRvb2xraXQnO1xuXG5pbXBvcnQgRnJhZ21lbnQgZnJvbSAnLi9mcmFnbWVudCc7XG5pbXBvcnQgTGV2ZWwgZnJvbSAnLi9sZXZlbCc7XG5pbXBvcnQgTGV2ZWxLZXkgZnJvbSAnLi9sZXZlbC1rZXknO1xuXG5pbXBvcnQgQXR0ckxpc3QgZnJvbSAnLi4vdXRpbHMvYXR0ci1saXN0JztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBpc0NvZGVjVHlwZSB9IGZyb20gJy4uL3V0aWxzL2NvZGVjcyc7XG5cbi8qKlxuICogTTNVOCBwYXJzZXJcbiAqIEBtb2R1bGVcbiAqL1xuXG4vLyBodHRwczovL3JlZ2V4MTAxLmNvbSBpcyB5b3VyIGZyaWVuZFxuY29uc3QgTUFTVEVSX1BMQVlMSVNUX1JFR0VYID0gLyNFWFQtWC1TVFJFQU0tSU5GOihbXlxcblxccl0qKVtcXHJcXG5dKyhbXlxcclxcbl0rKS9nO1xuY29uc3QgTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYID0gLyNFWFQtWC1NRURJQTooLiopL2c7XG5cbmNvbnN0IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QgPSBuZXcgUmVnRXhwKFtcbiAgLyNFWFRJTkY6XFxzKihcXGQqKD86XFwuXFxkKyk/KSg/OiwoLiopXFxzKyk/Ly5zb3VyY2UsIC8vIGR1cmF0aW9uICgjRVhUSU5GOjxkdXJhdGlvbj4sPHRpdGxlPiksIGdyb3VwIDEgPT4gZHVyYXRpb24sIGdyb3VwIDIgPT4gdGl0bGVcbiAgL3woPyEjKShbXFxTKyA/XSspLy5zb3VyY2UsIC8vIHNlZ21lbnQgVVJJLCBncm91cCAzID0+IHRoZSBVUkkgKG5vdGUgbmV3bGluZSBpcyBub3QgZWF0ZW4pXG4gIC98I0VYVC1YLUJZVEVSQU5HRToqKC4rKS8uc291cmNlLCAvLyBuZXh0IHNlZ21lbnQncyBieXRlcmFuZ2UsIGdyb3VwIDQgPT4gcmFuZ2Ugc3BlYyAoeEB5KVxuICAvfCNFWFQtWC1QUk9HUkFNLURBVEUtVElNRTooLispLy5zb3VyY2UsIC8vIG5leHQgc2VnbWVudCdzIHByb2dyYW0gZGF0ZS90aW1lIGdyb3VwIDUgPT4gdGhlIGRhdGV0aW1lIHNwZWNcbiAgL3wjLiovLnNvdXJjZSAvLyBBbGwgb3RoZXIgbm9uLXNlZ21lbnQgb3JpZW50ZWQgdGFncyB3aWxsIG1hdGNoIHdpdGggYWxsIGdyb3VwcyBlbXB0eVxuXS5qb2luKCcnKSwgJ2cnKTtcblxuY29uc3QgTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyA9IC8oPzooPzojKEVYVE0zVSkpfCg/OiNFWFQtWC0oUExBWUxJU1QtVFlQRSk6KC4rKSl8KD86I0VYVC1YLShNRURJQS1TRVFVRU5DRSk6ICooXFxkKykpfCg/OiNFWFQtWC0oVEFSR0VURFVSQVRJT04pOiAqKFxcZCspKXwoPzojRVhULVgtKEtFWSk6KC4rKSl8KD86I0VYVC1YLShTVEFSVCk6KC4rKSl8KD86I0VYVC1YLShFTkRMSVNUKSl8KD86I0VYVC1YLShESVNDT05USU5VSVRZLVNFUSlVRU5DRTooXFxkKykpfCg/OiNFWFQtWC0oRElTKUNPTlRJTlVJVFkpKXwoPzojRVhULVgtKFZFUlNJT04pOihcXGQrKSl8KD86I0VYVC1YLShNQVApOiguKykpfCg/OigjKShbXjpdKik6KC4qKSl8KD86KCMpKC4qKSkoPzouKilcXHI/XFxuPy87XG5cbmNvbnN0IE1QNF9SRUdFWF9TVUZGSVggPSAvXFwuKG1wNHxtNHN8bTR2fG00YSkkL2k7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE0zVThQYXJzZXIge1xuICBzdGF0aWMgZmluZEdyb3VwIChncm91cHMsIG1lZGlhR3JvdXBJZCkge1xuICAgIGlmICghZ3JvdXBzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgbWF0Y2hpbmdHcm91cCA9IG51bGw7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICBpZiAoZ3JvdXAuaWQgPT09IG1lZGlhR3JvdXBJZCkge1xuICAgICAgICBtYXRjaGluZ0dyb3VwID0gZ3JvdXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoaW5nR3JvdXA7XG4gIH1cblxuICBzdGF0aWMgY29udmVydEFWQzFUb0FWQ09USSAoY29kZWMpIHtcbiAgICBsZXQgcmVzdWx0LCBhdmNkYXRhID0gY29kZWMuc3BsaXQoJy4nKTtcbiAgICBpZiAoYXZjZGF0YS5sZW5ndGggPiAyKSB7XG4gICAgICByZXN1bHQgPSBhdmNkYXRhLnNoaWZ0KCkgKyAnLic7XG4gICAgICByZXN1bHQgKz0gcGFyc2VJbnQoYXZjZGF0YS5zaGlmdCgpKS50b1N0cmluZygxNik7XG4gICAgICByZXN1bHQgKz0gKCcwMDAnICsgcGFyc2VJbnQoYXZjZGF0YS5zaGlmdCgpKS50b1N0cmluZygxNikpLnN1YnN0cigtNCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGNvZGVjO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgc3RhdGljIHJlc29sdmUgKHVybCwgYmFzZVVybCkge1xuICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVVUkwoYmFzZVVybCwgdXJsLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZU1hc3RlclBsYXlsaXN0IChzdHJpbmcsIGJhc2V1cmwpIHtcbiAgICBsZXQgbGV2ZWxzID0gW10sIHJlc3VsdDtcbiAgICBNQVNURVJfUExBWUxJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcblxuICAgIGZ1bmN0aW9uIHNldENvZGVjcyAoY29kZWNzLCBsZXZlbCkge1xuICAgICAgWyd2aWRlbycsICdhdWRpbyddLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBjb2RlY3MuZmlsdGVyKChjb2RlYykgPT4gaXNDb2RlY1R5cGUoY29kZWMsIHR5cGUpKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHByZWZlcnJlZCA9IGZpbHRlcmVkLmZpbHRlcigoY29kZWMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlYy5sYXN0SW5kZXhPZignYXZjMScsIDApID09PSAwIHx8IGNvZGVjLmxhc3RJbmRleE9mKCdtcDRhJywgMCkgPT09IDA7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGV2ZWxbYCR7dHlwZX1Db2RlY2BdID0gcHJlZmVycmVkLmxlbmd0aCA+IDAgPyBwcmVmZXJyZWRbMF0gOiBmaWx0ZXJlZFswXTtcblxuICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIGxpc3RcbiAgICAgICAgICBjb2RlY3MgPSBjb2RlY3MuZmlsdGVyKChjb2RlYykgPT4gZmlsdGVyZWQuaW5kZXhPZihjb2RlYykgPT09IC0xKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGxldmVsLnVua25vd25Db2RlY3MgPSBjb2RlY3M7XG4gICAgfVxuXG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfUkVHRVguZXhlYyhzdHJpbmcpKSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBsZXZlbCA9IHt9O1xuXG4gICAgICBjb25zdCBhdHRycyA9IGxldmVsLmF0dHJzID0gbmV3IEF0dHJMaXN0KHJlc3VsdFsxXSk7XG4gICAgICBsZXZlbC51cmwgPSBNM1U4UGFyc2VyLnJlc29sdmUocmVzdWx0WzJdLCBiYXNldXJsKTtcblxuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IGF0dHJzLmRlY2ltYWxSZXNvbHV0aW9uKCdSRVNPTFVUSU9OJyk7XG4gICAgICBpZiAocmVzb2x1dGlvbikge1xuICAgICAgICBsZXZlbC53aWR0aCA9IHJlc29sdXRpb24ud2lkdGg7XG4gICAgICAgIGxldmVsLmhlaWdodCA9IHJlc29sdXRpb24uaGVpZ2h0O1xuICAgICAgfVxuICAgICAgbGV2ZWwuYml0cmF0ZSA9IGF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdBVkVSQUdFLUJBTkRXSURUSCcpIHx8IGF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdCQU5EV0lEVEgnKTtcbiAgICAgIGxldmVsLm5hbWUgPSBhdHRycy5OQU1FO1xuXG4gICAgICBzZXRDb2RlY3MoW10uY29uY2F0KChhdHRycy5DT0RFQ1MgfHwgJycpLnNwbGl0KC9bICxdKy8pKSwgbGV2ZWwpO1xuXG4gICAgICBpZiAobGV2ZWwudmlkZW9Db2RlYyAmJiBsZXZlbC52aWRlb0NvZGVjLmluZGV4T2YoJ2F2YzEnKSAhPT0gLTEpIHtcbiAgICAgICAgbGV2ZWwudmlkZW9Db2RlYyA9IE0zVThQYXJzZXIuY29udmVydEFWQzFUb0FWQ09USShsZXZlbC52aWRlb0NvZGVjKTtcbiAgICAgIH1cblxuICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWxzO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYSAoc3RyaW5nLCBiYXNldXJsLCB0eXBlLCBhdWRpb0dyb3VwcyA9IFtdKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgbWVkaWFzID0gW107XG4gICAgbGV0IGlkID0gMDtcbiAgICBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoKHJlc3VsdCA9IE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWC5leGVjKHN0cmluZykpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBtZWRpYSA9IHt9O1xuICAgICAgY29uc3QgYXR0cnMgPSBuZXcgQXR0ckxpc3QocmVzdWx0WzFdKTtcbiAgICAgIGlmIChhdHRycy5UWVBFID09PSB0eXBlKSB7XG4gICAgICAgIG1lZGlhLmdyb3VwSWQgPSBhdHRyc1snR1JPVVAtSUQnXTtcbiAgICAgICAgbWVkaWEubmFtZSA9IGF0dHJzLk5BTUU7XG4gICAgICAgIG1lZGlhLnR5cGUgPSB0eXBlO1xuICAgICAgICBtZWRpYS5kZWZhdWx0ID0gKGF0dHJzLkRFRkFVTFQgPT09ICdZRVMnKTtcbiAgICAgICAgbWVkaWEuYXV0b3NlbGVjdCA9IChhdHRycy5BVVRPU0VMRUNUID09PSAnWUVTJyk7XG4gICAgICAgIG1lZGlhLmZvcmNlZCA9IChhdHRycy5GT1JDRUQgPT09ICdZRVMnKTtcbiAgICAgICAgaWYgKGF0dHJzLlVSSSkge1xuICAgICAgICAgIG1lZGlhLnVybCA9IE0zVThQYXJzZXIucmVzb2x2ZShhdHRycy5VUkksIGJhc2V1cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVkaWEubGFuZyA9IGF0dHJzLkxBTkdVQUdFO1xuICAgICAgICBpZiAoIW1lZGlhLm5hbWUpIHtcbiAgICAgICAgICBtZWRpYS5uYW1lID0gbWVkaWEubGFuZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdWRpb0dyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBncm91cENvZGVjID0gTTNVOFBhcnNlci5maW5kR3JvdXAoYXVkaW9Hcm91cHMsIG1lZGlhLmdyb3VwSWQpO1xuICAgICAgICAgIG1lZGlhLmF1ZGlvQ29kZWMgPSBncm91cENvZGVjID8gZ3JvdXBDb2RlYy5jb2RlYyA6IGF1ZGlvR3JvdXBzWzBdLmNvZGVjO1xuICAgICAgICB9XG4gICAgICAgIG1lZGlhLmlkID0gaWQrKztcbiAgICAgICAgbWVkaWFzLnB1c2gobWVkaWEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVkaWFzO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlTGV2ZWxQbGF5bGlzdCAoc3RyaW5nLCBiYXNldXJsLCBpZCwgdHlwZSwgbGV2ZWxVcmxJZCkge1xuICAgIGxldCBjdXJyZW50U04gPSAwO1xuICAgIGxldCB0b3RhbGR1cmF0aW9uID0gMDtcbiAgICBsZXQgbGV2ZWwgPSBuZXcgTGV2ZWwoYmFzZXVybCk7XG4gICAgbGV0IGxldmVsa2V5ID0gbmV3IExldmVsS2V5KCk7XG4gICAgbGV0IGNjID0gMDtcbiAgICBsZXQgcHJldkZyYWcgPSBudWxsO1xuICAgIGxldCBmcmFnID0gbmV3IEZyYWdtZW50KCk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgaTtcblxuICAgIGxldCBmaXJzdFBkdEluZGV4ID0gbnVsbDtcblxuICAgIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QubGFzdEluZGV4ID0gMDtcblxuICAgIHdoaWxlICgocmVzdWx0ID0gTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVC5leGVjKHN0cmluZykpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHJlc3VsdFsxXTtcbiAgICAgIGlmIChkdXJhdGlvbikgeyAvLyBJTkZcbiAgICAgICAgZnJhZy5kdXJhdGlvbiA9IHBhcnNlRmxvYXQoZHVyYXRpb24pO1xuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGNvbnN0IHRpdGxlID0gKCcgJyArIHJlc3VsdFsyXSkuc2xpY2UoMSk7XG4gICAgICAgIGZyYWcudGl0bGUgPSB0aXRsZSB8fCBudWxsO1xuICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaCh0aXRsZSA/IFsgJ0lORicsIGR1cmF0aW9uLCB0aXRsZSBdIDogWyAnSU5GJywgZHVyYXRpb24gXSk7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFszXSkgeyAvLyB1cmxcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnLmR1cmF0aW9uKSkge1xuICAgICAgICAgIGNvbnN0IHNuID0gY3VycmVudFNOKys7XG4gICAgICAgICAgZnJhZy50eXBlID0gdHlwZTtcbiAgICAgICAgICBmcmFnLnN0YXJ0ID0gdG90YWxkdXJhdGlvbjtcbiAgICAgICAgICBmcmFnLmxldmVsa2V5ID0gbGV2ZWxrZXk7XG4gICAgICAgICAgZnJhZy5zbiA9IHNuO1xuICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgICBmcmFnLmNjID0gY2M7XG4gICAgICAgICAgZnJhZy51cmxJZCA9IGxldmVsVXJsSWQ7XG4gICAgICAgICAgZnJhZy5iYXNldXJsID0gYmFzZXVybDtcbiAgICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgICAgZnJhZy5yZWx1cmwgPSAoJyAnICsgcmVzdWx0WzNdKS5zbGljZSgxKTtcbiAgICAgICAgICBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcpO1xuXG4gICAgICAgICAgbGV2ZWwuZnJhZ21lbnRzLnB1c2goZnJhZyk7XG4gICAgICAgICAgcHJldkZyYWcgPSBmcmFnO1xuICAgICAgICAgIHRvdGFsZHVyYXRpb24gKz0gZnJhZy5kdXJhdGlvbjtcblxuICAgICAgICAgIGZyYWcgPSBuZXcgRnJhZ21lbnQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbNF0pIHsgLy8gWC1CWVRFUkFOR0VcbiAgICAgICAgZnJhZy5yYXdCeXRlUmFuZ2UgPSAoJyAnICsgcmVzdWx0WzRdKS5zbGljZSgxKTtcbiAgICAgICAgaWYgKHByZXZGcmFnKSB7XG4gICAgICAgICAgY29uc3QgbGFzdEJ5dGVSYW5nZUVuZE9mZnNldCA9IHByZXZGcmFnLmJ5dGVSYW5nZUVuZE9mZnNldDtcbiAgICAgICAgICBpZiAobGFzdEJ5dGVSYW5nZUVuZE9mZnNldCkge1xuICAgICAgICAgICAgZnJhZy5sYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0ID0gbGFzdEJ5dGVSYW5nZUVuZE9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzVdKSB7IC8vIFBST0dSQU0tREFURS1USU1FXG4gICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSAoJyAnICsgcmVzdWx0WzVdKS5zbGljZSgxKTtcbiAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydQUk9HUkFNLURBVEUtVElNRScsIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lXSk7XG4gICAgICAgIGlmIChmaXJzdFBkdEluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgZmlyc3RQZHRJbmRleCA9IGxldmVsLmZyYWdtZW50cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdFswXS5tYXRjaChMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChyZXN1bHRbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICBjb25zdCB2YWx1ZTEgPSAoJyAnICsgcmVzdWx0W2kgKyAxXSkuc2xpY2UoMSk7XG4gICAgICAgIGNvbnN0IHZhbHVlMiA9ICgnICcgKyByZXN1bHRbaSArIDJdKS5zbGljZSgxKTtcblxuICAgICAgICBzd2l0Y2ggKHJlc3VsdFtpXSkge1xuICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaCh2YWx1ZTIgPyBbIHZhbHVlMSwgdmFsdWUyIF0gOiBbIHZhbHVlMSBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUExBWUxJU1QtVFlQRSc6XG4gICAgICAgICAgbGV2ZWwudHlwZSA9IHZhbHVlMS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNRURJQS1TRVFVRU5DRSc6XG4gICAgICAgICAgY3VycmVudFNOID0gbGV2ZWwuc3RhcnRTTiA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1RBUkdFVERVUkFUSU9OJzpcbiAgICAgICAgICBsZXZlbC50YXJnZXRkdXJhdGlvbiA9IHBhcnNlRmxvYXQodmFsdWUxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVkVSU0lPTic6XG4gICAgICAgICAgbGV2ZWwudmVyc2lvbiA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0VYVE0zVSc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0VORExJU1QnOlxuICAgICAgICAgIGxldmVsLmxpdmUgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRElTJzpcbiAgICAgICAgICBjYysrO1xuICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnRElTJ10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdESVNDT05USU5VSVRZLVNFUSc6XG4gICAgICAgICAgY2MgPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdLRVknOlxuICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1wYW50b3MtaHR0cC1saXZlLXN0cmVhbWluZy0wOCNzZWN0aW9uLTMuNC40XG4gICAgICAgICAgdmFyIGRlY3J5cHRwYXJhbXMgPSB2YWx1ZTE7XG4gICAgICAgICAgdmFyIGtleUF0dHJzID0gbmV3IEF0dHJMaXN0KGRlY3J5cHRwYXJhbXMpO1xuICAgICAgICAgIHZhciBkZWNyeXB0bWV0aG9kID0ga2V5QXR0cnMuZW51bWVyYXRlZFN0cmluZygnTUVUSE9EJyksXG4gICAgICAgICAgICBkZWNyeXB0dXJpID0ga2V5QXR0cnMuVVJJLFxuICAgICAgICAgICAgZGVjcnlwdGl2ID0ga2V5QXR0cnMuaGV4YWRlY2ltYWxJbnRlZ2VyKCdJVicpO1xuICAgICAgICAgIGlmIChkZWNyeXB0bWV0aG9kKSB7XG4gICAgICAgICAgICBsZXZlbGtleSA9IG5ldyBMZXZlbEtleSgpO1xuICAgICAgICAgICAgaWYgKChkZWNyeXB0dXJpKSAmJiAoWydBRVMtMTI4JywgJ1NBTVBMRS1BRVMnLCAnU0FNUExFLUFFUy1DRU5DJ10uaW5kZXhPZihkZWNyeXB0bWV0aG9kKSA+PSAwKSkge1xuICAgICAgICAgICAgICBsZXZlbGtleS5tZXRob2QgPSBkZWNyeXB0bWV0aG9kO1xuICAgICAgICAgICAgICAvLyBVUkkgdG8gZ2V0IHRoZSBrZXlcbiAgICAgICAgICAgICAgbGV2ZWxrZXkuYmFzZXVyaSA9IGJhc2V1cmw7XG4gICAgICAgICAgICAgIGxldmVsa2V5LnJlbHVyaSA9IGRlY3J5cHR1cmk7XG4gICAgICAgICAgICAgIGxldmVsa2V5LmtleSA9IG51bGw7XG4gICAgICAgICAgICAgIC8vIEluaXRpYWxpemF0aW9uIFZlY3RvciAoSVYpXG4gICAgICAgICAgICAgIGxldmVsa2V5Lml2ID0gZGVjcnlwdGl2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnU1RBUlQnOlxuICAgICAgICAgIGxldCBzdGFydFBhcmFtcyA9IHZhbHVlMTtcbiAgICAgICAgICBsZXQgc3RhcnRBdHRycyA9IG5ldyBBdHRyTGlzdChzdGFydFBhcmFtcyk7XG4gICAgICAgICAgbGV0IHN0YXJ0VGltZU9mZnNldCA9IHN0YXJ0QXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1RJTUUtT0ZGU0VUJyk7XG4gICAgICAgICAgLy8gVElNRS1PRkZTRVQgY2FuIGJlIDBcbiAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgICAgIGxldmVsLnN0YXJ0VGltZU9mZnNldCA9IHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTUFQJzpcbiAgICAgICAgICBsZXQgbWFwQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICBmcmFnLnJlbHVybCA9IG1hcEF0dHJzLlVSSTtcbiAgICAgICAgICBmcmFnLnJhd0J5dGVSYW5nZSA9IG1hcEF0dHJzLkJZVEVSQU5HRTtcbiAgICAgICAgICBmcmFnLmJhc2V1cmwgPSBiYXNldXJsO1xuICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgICBmcmFnLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIGZyYWcuc24gPSAnaW5pdFNlZ21lbnQnO1xuICAgICAgICAgIGxldmVsLmluaXRTZWdtZW50ID0gZnJhZztcbiAgICAgICAgICBmcmFnID0gbmV3IEZyYWdtZW50KCk7XG4gICAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBsZXZlbC5pbml0U2VnbWVudC5yYXdQcm9ncmFtRGF0ZVRpbWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYGxpbmUgcGFyc2VkIGJ1dCBub3QgaGFuZGxlZDogJHtyZXN1bHR9YCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnJhZyA9IHByZXZGcmFnO1xuICAgIC8vIGxvZ2dlci5sb2coJ2ZvdW5kICcgKyBsZXZlbC5mcmFnbWVudHMubGVuZ3RoICsgJyBmcmFnbWVudHMnKTtcbiAgICBpZiAoZnJhZyAmJiAhZnJhZy5yZWx1cmwpIHtcbiAgICAgIGxldmVsLmZyYWdtZW50cy5wb3AoKTtcbiAgICAgIHRvdGFsZHVyYXRpb24gLT0gZnJhZy5kdXJhdGlvbjtcbiAgICB9XG4gICAgbGV2ZWwudG90YWxkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb247XG4gICAgbGV2ZWwuYXZlcmFnZXRhcmdldGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbiAvIGxldmVsLmZyYWdtZW50cy5sZW5ndGg7XG4gICAgbGV2ZWwuZW5kU04gPSBjdXJyZW50U04gLSAxO1xuICAgIGxldmVsLnN0YXJ0Q0MgPSBsZXZlbC5mcmFnbWVudHNbMF0gPyBsZXZlbC5mcmFnbWVudHNbMF0uY2MgOiAwO1xuICAgIGxldmVsLmVuZENDID0gY2M7XG5cbiAgICBpZiAoIWxldmVsLmluaXRTZWdtZW50ICYmIGxldmVsLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIHRoaXMgaXMgYSBiaXQgbHVya3kgYnV0IEhMUyByZWFsbHkgaGFzIG5vIG90aGVyIHdheSB0byB0ZWxsIHVzXG4gICAgICAvLyBpZiB0aGUgZnJhZ21lbnRzIGFyZSBUUyBvciBNUDQsIGV4Y2VwdCBpZiB3ZSBkb3dubG9hZCB0aGVtIDovXG4gICAgICAvLyBidXQgdGhpcyBpcyB0byBiZSBhYmxlIHRvIGhhbmRsZSBTSURYLlxuICAgICAgaWYgKGxldmVsLmZyYWdtZW50cy5ldmVyeSgoZnJhZykgPT4gTVA0X1JFR0VYX1NVRkZJWC50ZXN0KGZyYWcucmVsdXJsKSkpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ01QNCBmcmFnbWVudHMgZm91bmQgYnV0IG5vIGluaXQgc2VnbWVudCAocHJvYmFibHkgbm8gTUFQLCBpbmNvbXBsZXRlIE0zVTgpLCB0cnlpbmcgdG8gZmV0Y2ggU0lEWCcpO1xuXG4gICAgICAgIGZyYWcgPSBuZXcgRnJhZ21lbnQoKTtcbiAgICAgICAgZnJhZy5yZWx1cmwgPSBsZXZlbC5mcmFnbWVudHNbMF0ucmVsdXJsO1xuICAgICAgICBmcmFnLmJhc2V1cmwgPSBiYXNldXJsO1xuICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgIGZyYWcudHlwZSA9IHR5cGU7XG4gICAgICAgIGZyYWcuc24gPSAnaW5pdFNlZ21lbnQnO1xuXG4gICAgICAgIGxldmVsLmluaXRTZWdtZW50ID0gZnJhZztcbiAgICAgICAgbGV2ZWwubmVlZFNpZHhSYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJhY2tmaWxsIGFueSBtaXNzaW5nIFBEVCB2YWx1ZXNcbiAgICAgICBcIklmIHRoZSBmaXJzdCBFWFQtWC1QUk9HUkFNLURBVEUtVElNRSB0YWcgaW4gYSBQbGF5bGlzdCBhcHBlYXJzIGFmdGVyXG4gICAgICAgb25lIG9yIG1vcmUgTWVkaWEgU2VnbWVudCBVUklzLCB0aGUgY2xpZW50IFNIT1VMRCBleHRyYXBvbGF0ZVxuICAgICAgIGJhY2t3YXJkIGZyb20gdGhhdCB0YWcgKHVzaW5nIEVYVElORiBkdXJhdGlvbnMgYW5kL29yIG1lZGlhXG4gICAgICAgdGltZXN0YW1wcykgdG8gYXNzb2NpYXRlIGRhdGVzIHdpdGggdGhvc2Ugc2VnbWVudHMuXCJcbiAgICAgKiBXZSBoYXZlIGFscmVhZHkgZXh0cmFwb2xhdGVkIGZvcndhcmQsIGJ1dCBhbGwgZnJhZ21lbnRzIHVwIHRvIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBQRFQgZG8gbm90IGhhdmUgdGhlaXIgUERUc1xuICAgICAqIGNvbXB1dGVkLlxuICAgICAqL1xuICAgIGlmIChmaXJzdFBkdEluZGV4KSB7XG4gICAgICBiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMobGV2ZWwuZnJhZ21lbnRzLCBmaXJzdFBkdEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGV2ZWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmFja2ZpbGxQcm9ncmFtRGF0ZVRpbWVzIChmcmFnbWVudHMsIHN0YXJ0SW5kZXgpIHtcbiAgbGV0IGZyYWdQcmV2ID0gZnJhZ21lbnRzW3N0YXJ0SW5kZXhdO1xuICBmb3IgKGxldCBpID0gc3RhcnRJbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgZnJhZyA9IGZyYWdtZW50c1tpXTtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IGZyYWdQcmV2LnByb2dyYW1EYXRlVGltZSAtIChmcmFnLmR1cmF0aW9uICogMTAwMCk7XG4gICAgZnJhZ1ByZXYgPSBmcmFnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnblByb2dyYW1EYXRlVGltZSAoZnJhZywgcHJldkZyYWcpIHtcbiAgaWYgKGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBEYXRlLnBhcnNlKGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lKTtcbiAgfSBlbHNlIGlmIChwcmV2RnJhZyAmJiBwcmV2RnJhZy5wcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IHByZXZGcmFnLmVuZFByb2dyYW1EYXRlVGltZTtcbiAgfVxuXG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZyYWcucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gIH1cbn1cbiIsIi8qKlxuICogUGxheWxpc3RMb2FkZXIgLSBkZWxlZ2F0ZSBmb3IgbWVkaWEgbWFuaWZlc3QvcGxheWxpc3QgbG9hZGluZyB0YXNrcy4gVGFrZXMgY2FyZSBvZiBwYXJzaW5nIG1lZGlhIHRvIGludGVybmFsIGRhdGEtbW9kZWxzLlxuICpcbiAqIE9uY2UgbG9hZGVkLCBkaXNwYXRjaGVzIGV2ZW50cyB3aXRoIHBhcnNlZCBkYXRhLW1vZGVscyBvZiBtYW5pZmVzdC9sZXZlbHMvYXVkaW8vc3VidGl0bGUgdHJhY2tzLlxuICpcbiAqIFVzZXMgbG9hZGVyKHMpIHNldCBpbiBjb25maWcgdG8gZG8gYWN0dWFsIGludGVybmFsIGxvYWRpbmcgb2YgcmVzb3VyY2UgdGFza3MuXG4gKlxuICogQG1vZHVsZVxuICpcbiAqL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5pbXBvcnQgTVA0RGVtdXhlciBmcm9tICcuLi9kZW11eC9tcDRkZW11eGVyJztcbmltcG9ydCBNM1U4UGFyc2VyIGZyb20gJy4vbTN1OC1wYXJzZXInO1xuXG5jb25zdCB7IHBlcmZvcm1hbmNlIH0gPSB3aW5kb3c7XG5cbi8qKlxuICogYHR5cGVgIHByb3BlcnR5IHZhbHVlcyBmb3IgdGhpcyBsb2FkZXJzJyBjb250ZXh0IG9iamVjdFxuICogQGVudW1cbiAqXG4gKi9cbmNvbnN0IENvbnRleHRUeXBlID0ge1xuICBNQU5JRkVTVDogJ21hbmlmZXN0JyxcbiAgTEVWRUw6ICdsZXZlbHMuanMnLFxuICBBVURJT19UUkFDSzogJ2F1ZGlvVHJhY2snLFxuICBTVUJUSVRMRV9UUkFDSzogJ3N1YnRpdGxlVHJhY2snXG59O1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmNvbnN0IExldmVsVHlwZSA9IHtcbiAgTUFJTjogJ21haW4nLFxuICBBVURJTzogJ2F1ZGlvJyxcbiAgU1VCVElUTEU6ICdzdWJ0aXRsZSdcbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFBsYXlsaXN0TG9hZGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RzXG4gICAqIEBwYXJhbSB7SGxzfSBobHNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxuICAgICAgRXZlbnQuTEVWRUxfTE9BRElORyxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX0xPQURJTkcsXG4gICAgICBFdmVudC5TVUJUSVRMRV9UUkFDS19MT0FESU5HKTtcblxuICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICB9XG5cbiAgc3RhdGljIGdldCBDb250ZXh0VHlwZSAoKSB7XG4gICAgcmV0dXJuIENvbnRleHRUeXBlO1xuICB9XG5cbiAgc3RhdGljIGdldCBMZXZlbFR5cGUgKCkge1xuICAgIHJldHVybiBMZXZlbFR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZXh0VHlwZX0gdHlwZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBjYW5IYXZlUXVhbGl0eUxldmVscyAodHlwZSkge1xuICAgIHJldHVybiAodHlwZSAhPT0gQ29udGV4dFR5cGUuQVVESU9fVFJBQ0sgJiZcbiAgICAgIHR5cGUgIT09IENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXAgY29udGV4dC50eXBlIHRvIExldmVsVHlwZVxuICAgKiBAcGFyYW0ge3t0eXBlOiBDb250ZXh0VHlwZX19IGNvbnRleHRcbiAgICogQHJldHVybnMge0xldmVsVHlwZX1cbiAgICovXG4gIHN0YXRpYyBtYXBDb250ZXh0VG9MZXZlbFR5cGUgKGNvbnRleHQpIHtcbiAgICBjb25zdCB7IHR5cGUgfSA9IGNvbnRleHQ7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgcmV0dXJuIExldmVsVHlwZS5BVURJTztcbiAgICBjYXNlIENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgcmV0dXJuIExldmVsVHlwZS5TVUJUSVRMRTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIExldmVsVHlwZS5NQUlOO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXRSZXNwb25zZVVybCAocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgICBsZXQgdXJsID0gcmVzcG9uc2UudXJsO1xuICAgIC8vIHJlc3BvbnNlVVJMIG5vdCBzdXBwb3J0ZWQgb24gc29tZSBicm93c2VycyAoaXQgaXMgdXNlZCB0byBkZXRlY3QgVVJMIHJlZGlyZWN0aW9uKVxuICAgIC8vIGRhdGEtdXJpIG1vZGUgYWxzbyBub3Qgc3VwcG9ydGVkIChidXQgbm8gbmVlZCB0byBkZXRlY3QgcmVkaXJlY3Rpb24pXG4gICAgaWYgKHVybCA9PT0gdW5kZWZpbmVkIHx8IHVybC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICAvLyBmYWxsYmFjayB0byBpbml0aWFsIFVSTFxuICAgICAgdXJsID0gY29udGV4dC51cmw7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBkZWZhdWx0cyBvciBjb25maWd1cmVkIGxvYWRlci10eXBlIG92ZXJsb2FkcyAocExvYWRlciBhbmQgbG9hZGVyIGNvbmZpZyBwYXJhbXMpXG4gICAqIERlZmF1bHQgbG9hZGVyIGlzIFhIUkxvYWRlciAoc2VlIHV0aWxzKVxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJucyB7WEhSTG9hZGVyfSBvciBvdGhlciBjb21wYXRpYmxlIGNvbmZpZ3VyZWQgb3ZlcmxvYWRcbiAgICovXG4gIGNyZWF0ZUludGVybmFsTG9hZGVyIChjb250ZXh0KSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGNvbnN0IFBMb2FkZXIgPSBjb25maWcucExvYWRlcjtcbiAgICBjb25zdCBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGNvbnN0IEludGVybmFsTG9hZGVyID0gUExvYWRlciB8fCBMb2FkZXI7XG5cbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgSW50ZXJuYWxMb2FkZXIoY29uZmlnKTtcblxuICAgIGNvbnRleHQubG9hZGVyID0gbG9hZGVyO1xuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gbG9hZGVyO1xuXG4gICAgcmV0dXJuIGxvYWRlcjtcbiAgfVxuXG4gIGdldEludGVybmFsTG9hZGVyIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdO1xuICB9XG5cbiAgcmVzZXRJbnRlcm5hbExvYWRlciAoY29udGV4dFR5cGUpIHtcbiAgICBpZiAodGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXSkge1xuICAgICAgZGVsZXRlIHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgYGRlc3Ryb3lgIG9uIGFsbCBpbnRlcm5hbCBsb2FkZXIgaW5zdGFuY2VzIG1hcHBlZCAob25lIHBlciBjb250ZXh0IHR5cGUpXG4gICAqL1xuICBkZXN0cm95SW50ZXJuYWxMb2FkZXJzICgpIHtcbiAgICBmb3IgKGxldCBjb250ZXh0VHlwZSBpbiB0aGlzLmxvYWRlcnMpIHtcbiAgICAgIGxldCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dFR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuZGVzdHJveUludGVybmFsTG9hZGVycygpO1xuXG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgb25NYW5pZmVzdExvYWRpbmcgKGRhdGEpIHtcbiAgICB0aGlzLmxvYWQoZGF0YS51cmwsIHsgdHlwZTogQ29udGV4dFR5cGUuTUFOSUZFU1QsIGxldmVsOiAwLCBpZDogbnVsbCB9KTtcbiAgfVxuXG4gIG9uTGV2ZWxMb2FkaW5nIChkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGU6IENvbnRleHRUeXBlLkxFVkVMLCBsZXZlbDogZGF0YS5sZXZlbHMsIGlkOiBkYXRhLmlkIH0pO1xuICB9XG5cbiAgb25BdWRpb1RyYWNrTG9hZGluZyAoZGF0YSkge1xuICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlOiBDb250ZXh0VHlwZS5BVURJT19UUkFDSywgbGV2ZWw6IG51bGwsIGlkOiBkYXRhLmlkIH0pO1xuICB9XG5cbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGluZyAoZGF0YSkge1xuICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlOiBDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSywgbGV2ZWw6IG51bGwsIGlkOiBkYXRhLmlkIH0pO1xuICB9XG5cbiAgbG9hZCAodXJsLCBjb250ZXh0KSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuXG4gICAgbG9nZ2VyLmRlYnVnKGBMb2FkaW5nIHBsYXlsaXN0IG9mIHR5cGUgJHtjb250ZXh0LnR5cGV9LCBsZXZlbDogJHtjb250ZXh0LmxldmVsc30sIGlkOiAke2NvbnRleHQuaWR9YCk7XG5cbiAgICAvLyBDaGVjayBpZiBhIGxvYWRlciBmb3IgdGhpcyBjb250ZXh0IGFscmVhZHkgZXhpc3RzXG4gICAgbGV0IGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgY29uc3QgbG9hZGVyQ29udGV4dCA9IGxvYWRlci5jb250ZXh0O1xuICAgICAgaWYgKGxvYWRlckNvbnRleHQgJiYgbG9hZGVyQ29udGV4dC51cmwgPT09IHVybCkgeyAvLyBzYW1lIFVSTCBjYW4ndCBvdmVybGFwXG4gICAgICAgIGxvZ2dlci50cmFjZSgncGxheWxpc3QgcmVxdWVzdCBvbmdvaW5nJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBhYm9ydGluZyBwcmV2aW91cyBsb2FkZXIgZm9yIHR5cGU6ICR7Y29udGV4dC50eXBlfWApO1xuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbWF4UmV0cnksXG4gICAgICB0aW1lb3V0LFxuICAgICAgcmV0cnlEZWxheSxcbiAgICAgIG1heFJldHJ5RGVsYXk7XG5cbiAgICAvLyBhcHBseSBkaWZmZXJlbnQgY29uZmlncyBmb3IgcmV0cmllcyBkZXBlbmRpbmcgb25cbiAgICAvLyBjb250ZXh0IChtYW5pZmVzdCwgbGV2ZWwsIGF1ZGlvL3N1YnMgcGxheWxpc3QpXG4gICAgc3dpdGNoIChjb250ZXh0LnR5cGUpIHtcbiAgICBjYXNlIENvbnRleHRUeXBlLk1BTklGRVNUOlxuICAgICAgbWF4UmV0cnkgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk7XG4gICAgICB0aW1lb3V0ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ7XG4gICAgICByZXRyeURlbGF5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXk7XG4gICAgICBtYXhSZXRyeURlbGF5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ01heFJldHJ5VGltZW91dDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ29udGV4dFR5cGUuTEVWRUw6XG4gICAgICAvLyBEaXNhYmxlIGludGVybmFsIGxvYWRlciByZXRyeSBsb2dpYywgc2luY2Ugd2UgYXJlIG1hbmFnaW5nIHJldHJpZXMgaW4gTGV2ZWwgQ29udHJvbGxlclxuICAgICAgbWF4UmV0cnkgPSAwO1xuICAgICAgdGltZW91dCA9IGNvbmZpZy5sZXZlbExvYWRpbmdUaW1lT3V0O1xuICAgICAgLy8gVE9ETyBJbnRyb2R1Y2UgcmV0cnkgc2V0dGluZ3MgZm9yIGF1ZGlvLXRyYWNrIGFuZCBzdWJ0aXRsZS10cmFjaywgaXQgc2hvdWxkIG5vdCB1c2UgbGV2ZWwgcmV0cnkgY29uZmlnXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbWF4UmV0cnkgPSBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnk7XG4gICAgICB0aW1lb3V0ID0gY29uZmlnLmxldmVsTG9hZGluZ1RpbWVPdXQ7XG4gICAgICByZXRyeURlbGF5ID0gY29uZmlnLmxldmVsTG9hZGluZ1JldHJ5RGVsYXk7XG4gICAgICBtYXhSZXRyeURlbGF5ID0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGxvYWRlciA9IHRoaXMuY3JlYXRlSW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG5cbiAgICBjb250ZXh0LnVybCA9IHVybDtcbiAgICBjb250ZXh0LnJlc3BvbnNlVHlwZSA9IGNvbnRleHQucmVzcG9uc2VUeXBlIHx8ICcnOyAvLyBGSVhNRTogKHNob3VsZCBub3QgYmUgbmVjZXNzYXJ5IHRvIGRvIHRoaXMpXG5cbiAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICB0aW1lb3V0LFxuICAgICAgbWF4UmV0cnksXG4gICAgICByZXRyeURlbGF5LFxuICAgICAgbWF4UmV0cnlEZWxheVxuICAgIH07XG5cbiAgICBjb25zdCBsb2FkZXJDYWxsYmFja3MgPSB7XG4gICAgICBvblN1Y2Nlc3M6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSxcbiAgICAgIG9uRXJyb3I6IHRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblRpbWVvdXQ6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKVxuICAgIH07XG5cbiAgICBsb2dnZXIuZGVidWcoYENhbGxpbmcgaW50ZXJuYWwgbG9hZGVyIGRlbGVnYXRlIGZvciBVUkw6ICR7dXJsfWApO1xuXG4gICAgbG9hZGVyLmxvYWQoY29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBsb2Fkc3VjY2VzcyAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyA9IG51bGwpIHtcbiAgICBpZiAoY29udGV4dC5pc1NpZHhSZXF1ZXN0KSB7XG4gICAgICB0aGlzLl9oYW5kbGVTaWR4UmVxdWVzdChyZXNwb25zZSwgY29udGV4dCk7XG4gICAgICB0aGlzLl9oYW5kbGVQbGF5bGlzdExvYWRlZChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dC50eXBlKTtcblxuICAgIGNvbnN0IHN0cmluZyA9IHJlc3BvbnNlLmRhdGE7XG5cbiAgICBzdGF0cy50bG9hZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIC8vIHN0YXRzLm10aW1lID0gbmV3IERhdGUodGFyZ2V0LmdldFJlc3BvbnNlSGVhZGVyKCdMYXN0LU1vZGlmaWVkJykpO1xuXG4gICAgLy8gVmFsaWRhdGUgaWYgaXQgaXMgYW4gTTNVOCBhdCBhbGxcbiAgICBpZiAoc3RyaW5nLmluZGV4T2YoJyNFWFRNM1UnKSAhPT0gMCkge1xuICAgICAgdGhpcy5faGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsICdubyBFWFRNM1UgZGVsaW1pdGVyJywgbmV0d29ya0RldGFpbHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGNodW5rLWxpc3Qgb3IgbWFzdGVyLiBoYW5kbGUgZW1wdHkgY2h1bmsgbGlzdCBjYXNlIChmaXJzdCBFWFRJTkYgbm90IHNpZ25hbGVkLCBidXQgVEFSR0VURFVSQVRJT04gcHJlc2VudClcbiAgICBpZiAoc3RyaW5nLmluZGV4T2YoJyNFWFRJTkY6JykgPiAwIHx8IHN0cmluZy5pbmRleE9mKCcjRVhULVgtVEFSR0VURFVSQVRJT046JykgPiAwKSB7XG4gICAgICB0aGlzLl9oYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGFuZGxlTWFzdGVyUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgfVxuICB9XG5cbiAgbG9hZGVycm9yIChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMgPSBudWxsKSB7XG4gICAgdGhpcy5faGFuZGxlTmV0d29ya0Vycm9yKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBmYWxzZSwgcmVzcG9uc2UpO1xuICB9XG5cbiAgbG9hZHRpbWVvdXQgKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyA9IG51bGwpIHtcbiAgICB0aGlzLl9oYW5kbGVOZXR3b3JrRXJyb3IoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHRydWUpO1xuICB9XG5cbiAgX2hhbmRsZU1hc3RlclBsYXlsaXN0IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3Qgc3RyaW5nID0gcmVzcG9uc2UuZGF0YTtcblxuICAgIGNvbnN0IHVybCA9IFBsYXlsaXN0TG9hZGVyLmdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IGxldmVscyA9IE0zVThQYXJzZXIucGFyc2VNYXN0ZXJQbGF5bGlzdChzdHJpbmcsIHVybCk7XG4gICAgaWYgKCFsZXZlbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihyZXNwb25zZSwgY29udGV4dCwgJ25vIGxldmVsIGZvdW5kIGluIG1hbmlmZXN0JywgbmV0d29ya0RldGFpbHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG11bHRpIGxldmVsIHBsYXlsaXN0LCBwYXJzZSBsZXZlbCBpbmZvXG5cbiAgICBjb25zdCBhdWRpb0dyb3VwcyA9IGxldmVscy5tYXAobGV2ZWwgPT4gKHtcbiAgICAgIGlkOiBsZXZlbC5hdHRycy5BVURJTyxcbiAgICAgIGNvZGVjOiBsZXZlbC5hdWRpb0NvZGVjXG4gICAgfSkpO1xuXG4gICAgbGV0IGF1ZGlvVHJhY2tzID0gTTNVOFBhcnNlci5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCB1cmwsICdBVURJTycsIGF1ZGlvR3JvdXBzKTtcbiAgICBsZXQgc3VidGl0bGVzID0gTTNVOFBhcnNlci5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCB1cmwsICdTVUJUSVRMRVMnKTtcblxuICAgIGlmIChhdWRpb1RyYWNrcy5sZW5ndGgpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgZm91bmQgYW4gYXVkaW8gdHJhY2sgZW1iZWRkZWQgaW4gbWFpbiBwbGF5bGlzdCAoYXVkaW8gdHJhY2sgd2l0aG91dCBVUkkgYXR0cmlidXRlKVxuICAgICAgbGV0IGVtYmVkZGVkQXVkaW9Gb3VuZCA9IGZhbHNlO1xuICAgICAgYXVkaW9UcmFja3MuZm9yRWFjaChhdWRpb1RyYWNrID0+IHtcbiAgICAgICAgaWYgKCFhdWRpb1RyYWNrLnVybCkge1xuICAgICAgICAgIGVtYmVkZGVkQXVkaW9Gb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBpZiBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBkZWZpbmVkLCBidXQgYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCxcbiAgICAgIC8vIHdlIG5lZWQgdG8gc2lnbmFsIHRoaXMgbWFpbiBhdWRpbyB0cmFjayB0aGlzIGNvdWxkIGhhcHBlbiB3aXRoIHBsYXlsaXN0cyB3aXRoXG4gICAgICAvLyBhbHQgYXVkaW8gcmVuZGl0aW9uIGluIHdoaWNoIHF1YWxpdHkgbGV2ZWxzIChtYWluKVxuICAgICAgLy8gY29udGFpbnMgYm90aCBhdWRpbyt2aWRlby4gYnV0IHdpdGggbWl4ZWQgYXVkaW8gdHJhY2sgbm90IHNpZ25hbGVkXG4gICAgICBpZiAoZW1iZWRkZWRBdWRpb0ZvdW5kID09PSBmYWxzZSAmJiBsZXZlbHNbMF0uYXVkaW9Db2RlYyAmJiAhbGV2ZWxzWzBdLmF0dHJzLkFVRElPKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ2F1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsIGJ1dCBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBzaWduYWxlZCwgY3JlYXRlIG9uZScpO1xuICAgICAgICBhdWRpb1RyYWNrcy51bnNoaWZ0KHtcbiAgICAgICAgICB0eXBlOiAnbWFpbicsXG4gICAgICAgICAgbmFtZTogJ21haW4nXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhscy50cmlnZ2VyKEV2ZW50Lk1BTklGRVNUX0xPQURFRCwge1xuICAgICAgbGV2ZWxzLFxuICAgICAgYXVkaW9UcmFja3MsXG4gICAgICBzdWJ0aXRsZXMsXG4gICAgICB1cmwsXG4gICAgICBzdGF0cyxcbiAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgfSk7XG4gIH1cblxuICBfaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QgKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcblxuICAgIGNvbnN0IHsgaWQsIGxldmVsLCB0eXBlIH0gPSBjb250ZXh0O1xuXG4gICAgY29uc3QgdXJsID0gUGxheWxpc3RMb2FkZXIuZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpO1xuXG4gICAgY29uc3QgbGV2ZWxVcmxJZCA9IE51bWJlci5pc0Zpbml0ZShpZCkgPyBpZCA6IDA7XG4gICAgY29uc3QgbGV2ZWxJZCA9IE51bWJlci5pc0Zpbml0ZShsZXZlbCkgPyBsZXZlbCA6IGxldmVsVXJsSWQ7XG4gICAgY29uc3QgbGV2ZWxUeXBlID0gUGxheWxpc3RMb2FkZXIubWFwQ29udGV4dFRvTGV2ZWxUeXBlKGNvbnRleHQpO1xuXG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gTTNVOFBhcnNlci5wYXJzZUxldmVsUGxheWxpc3QocmVzcG9uc2UuZGF0YSwgdXJsLCBsZXZlbElkLCBsZXZlbFR5cGUsIGxldmVsVXJsSWQpO1xuXG4gICAgLy8gc2V0IHN0YXRzIG9uIGxldmVsIHN0cnVjdHVyZVxuICAgIGxldmVsRGV0YWlscy50bG9hZCA9IHN0YXRzLnRsb2FkO1xuXG4gICAgLy8gV2UgaGF2ZSBkb25lIG91ciBmaXJzdCByZXF1ZXN0IChNYW5pZmVzdC10eXBlKSBhbmQgcmVjZWl2ZVxuICAgIC8vIG5vdCBhIG1hc3RlciBwbGF5bGlzdCBidXQgYSBjaHVuay1saXN0ICh0cmFjay9sZXZlbClcbiAgICAvLyBXZSBmaXJlIHRoZSBtYW5pZmVzdC1sb2FkZWQgZXZlbnQgYW55d2F5IHdpdGggdGhlIHBhcnNlZCBsZXZlbC1kZXRhaWxzXG4gICAgLy8gYnkgY3JlYXRpbmcgYSBzaW5nbGUtbGV2ZWwgc3RydWN0dXJlIGZvciBpdC5cbiAgICBpZiAodHlwZSA9PT0gQ29udGV4dFR5cGUuTUFOSUZFU1QpIHtcbiAgICAgIGNvbnN0IHNpbmdsZUxldmVsID0ge1xuICAgICAgICB1cmwsXG4gICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlsc1xuICAgICAgfTtcblxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTUFOSUZFU1RfTE9BREVELCB7XG4gICAgICAgIGxldmVsczogW3NpbmdsZUxldmVsXSxcbiAgICAgICAgYXVkaW9UcmFja3M6IFtdLFxuICAgICAgICB1cmwsXG4gICAgICAgIHN0YXRzLFxuICAgICAgICBuZXR3b3JrRGV0YWlsc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc2F2ZSBwYXJzaW5nIHRpbWVcbiAgICBzdGF0cy50cGFyc2VkID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAvLyBpbiBjYXNlIHdlIG5lZWQgU0lEWCByYW5nZXNcbiAgICAvLyByZXR1cm4gZWFybHkgYWZ0ZXIgY2FsbGluZyBsb2FkIGZvclxuICAgIC8vIHRoZSBTSURYIGJveC5cbiAgICBpZiAobGV2ZWxEZXRhaWxzLm5lZWRTaWR4UmFuZ2VzKSB7XG4gICAgICBjb25zdCBzaWR4VXJsID0gbGV2ZWxEZXRhaWxzLmluaXRTZWdtZW50LnVybDtcbiAgICAgIHRoaXMubG9hZChzaWR4VXJsLCB7XG4gICAgICAgIGlzU2lkeFJlcXVlc3Q6IHRydWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGxldmVsLFxuICAgICAgICBsZXZlbERldGFpbHMsXG4gICAgICAgIGlkLFxuICAgICAgICByYW5nZVN0YXJ0OiAwLFxuICAgICAgICByYW5nZUVuZDogMjA0OCxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBleHRlbmQgdGhlIGNvbnRleHQgd2l0aCB0aGUgbmV3IGxldmVsRGV0YWlscyBwcm9wZXJ0eVxuICAgIGNvbnRleHQubGV2ZWxEZXRhaWxzID0gbGV2ZWxEZXRhaWxzO1xuXG4gICAgdGhpcy5faGFuZGxlUGxheWxpc3RMb2FkZWQocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gIH1cblxuICBfaGFuZGxlU2lkeFJlcXVlc3QgKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgY29uc3Qgc2lkeEluZm8gPSBNUDREZW11eGVyLnBhcnNlU2VnbWVudEluZGV4KG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmRhdGEpKTtcbiAgICAvLyBpZiBwcm92aWRlZCBmcmFnbWVudCBkb2VzIG5vdCBjb250YWluIHNpZHgsIGVhcmx5IHJldHVyblxuICAgIGlmICghc2lkeEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2lkeFJlZmVyZW5jZXMgPSBzaWR4SW5mby5yZWZlcmVuY2VzO1xuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGNvbnRleHQubGV2ZWxEZXRhaWxzO1xuICAgIHNpZHhSZWZlcmVuY2VzLmZvckVhY2goKHNlZ21lbnRSZWYsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzZWdSZWZJbmZvID0gc2VnbWVudFJlZi5pbmZvO1xuICAgICAgY29uc3QgZnJhZyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHNbaW5kZXhdO1xuXG4gICAgICBpZiAoZnJhZy5ieXRlUmFuZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZyYWcucmF3Qnl0ZVJhbmdlID0gU3RyaW5nKDEgKyBzZWdSZWZJbmZvLmVuZCAtIHNlZ1JlZkluZm8uc3RhcnQpICsgJ0AnICsgU3RyaW5nKHNlZ1JlZkluZm8uc3RhcnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldmVsRGV0YWlscy5pbml0U2VnbWVudC5yYXdCeXRlUmFuZ2UgPSBTdHJpbmcoc2lkeEluZm8ubW9vdkVuZE9mZnNldCkgKyAnQDAnO1xuICB9XG5cbiAgX2hhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yIChyZXNwb25zZSwgY29udGV4dCwgcmVhc29uLCBuZXR3b3JrRGV0YWlscykge1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SLFxuICAgICAgZmF0YWw6IHRydWUsXG4gICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgIHJlYXNvbixcbiAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgfSk7XG4gIH1cblxuICBfaGFuZGxlTmV0d29ya0Vycm9yIChjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgdGltZW91dCA9IGZhbHNlLCByZXNwb25zZSA9IG51bGwpIHtcbiAgICBsb2dnZXIuaW5mbyhgQSBuZXR3b3JrIGVycm9yIG9jY3VyZWQgd2hpbGUgbG9hZGluZyBhICR7Y29udGV4dC50eXBlfS10eXBlIHBsYXlsaXN0YCk7XG5cbiAgICBsZXQgZGV0YWlscztcbiAgICBsZXQgZmF0YWw7XG5cbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuXG4gICAgc3dpdGNoIChjb250ZXh0LnR5cGUpIHtcbiAgICBjYXNlIENvbnRleHRUeXBlLk1BTklGRVNUOlxuICAgICAgZGV0YWlscyA9ICh0aW1lb3V0ID8gRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfVElNRU9VVCA6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX0VSUk9SKTtcbiAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ29udGV4dFR5cGUuTEVWRUw6XG4gICAgICBkZXRhaWxzID0gKHRpbWVvdXQgPyBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUIDogRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1IpO1xuICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICBkZXRhaWxzID0gKHRpbWVvdXQgPyBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUIDogRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1IpO1xuICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBkZXRhaWxzID0gLi4uP1xuICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0LnR5cGUpO1xuICAgIH1cblxuICAgIGxldCBlcnJvckRhdGEgPSB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzLFxuICAgICAgZmF0YWwsXG4gICAgICB1cmw6IGxvYWRlci51cmwsXG4gICAgICBsb2FkZXIsXG4gICAgICBjb250ZXh0LFxuICAgICAgbmV0d29ya0RldGFpbHNcbiAgICB9O1xuXG4gICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICBlcnJvckRhdGEucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB9XG5cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCBlcnJvckRhdGEpO1xuICB9XG5cbiAgX2hhbmRsZVBsYXlsaXN0TG9hZGVkIChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgY29uc3QgeyB0eXBlLCBsZXZlbCwgaWQsIGxldmVsRGV0YWlscyB9ID0gY29udGV4dDtcblxuICAgIGlmICghbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSB7XG4gICAgICB0aGlzLl9oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihyZXNwb25zZSwgY29udGV4dCwgJ2ludmFsaWQgdGFyZ2V0IGR1cmF0aW9uJywgbmV0d29ya0RldGFpbHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbkhhdmVMZXZlbHMgPSBQbGF5bGlzdExvYWRlci5jYW5IYXZlUXVhbGl0eUxldmVscyhjb250ZXh0LnR5cGUpO1xuICAgIGlmIChjYW5IYXZlTGV2ZWxzKSB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX0xPQURFRCwge1xuICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgIGxldmVsOiBsZXZlbCB8fCAwLFxuICAgICAgICBpZDogaWQgfHwgMCxcbiAgICAgICAgc3RhdHMsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX0xPQURFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsc1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX1RSQUNLX0xPQURFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsc1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBsYXlsaXN0TG9hZGVyO1xuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5cbi8qKlxuICogQGNsYXNzXG4gKlxuICogU2ltcGxlIGFkYXB0ZXIgc3ViLWNsYXNzIG9mIE5vZGVqcy1saWtlIEV2ZW50RW1pdHRlci5cbiAqXG4gKiBXZSBzaW1wbHkgd2FudCB0byBwYXNzIGFsb25nIHRoZSBldmVudC1uYW1lIGl0c2VsZlxuICogaW4gZXZlcnkgY2FsbCB0byBhIGhhbmRsZXIsIHdoaWNoIGlzIHRoZSBwdXJwb3NlIG9mIG91ciBgdHJpZ2dlcmAgbWV0aG9kXG4gKiBleHRlbmRpbmcgdGhlIHN0YW5kYXJkIEFQSS5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBPYnNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHthbnl9IGRhdGFcbiAgICovXG4gIHRyaWdnZXIgKGV2ZW50LCAuLi5kYXRhKSB7XG4gICAgdGhpcy5lbWl0KGV2ZW50LCBldmVudCwgLi4uZGF0YSk7XG4gIH1cbn1cbiIsIi8qKlxuICogIEFBQyBoZWxwZXJcbiAqL1xuXG5jbGFzcyBBQUMge1xuICBzdGF0aWMgZ2V0U2lsZW50RnJhbWUgKGNvZGVjLCBjaGFubmVsQ291bnQpIHtcbiAgICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgY2FzZSAnbXA0YS40MC4yJzpcbiAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIzLCAweDgwXSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MjEsIDB4MDAsIDB4NDksIDB4OTAsIDB4MDIsIDB4MTksIDB4MDAsIDB4MjMsIDB4ODBdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4ZV0pO1xuICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgwLCAweDJjLCAweDgwLCAweDA4LCAweDAyLCAweDM4XSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MzhdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA2KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgwMCwgMHhiMiwgMHgwMCwgMHgyMCwgMHgwOCwgMHhlMF0pO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICAvLyBoYW5kbGUgSEUtQUFDIGJlbG93IChtcDRhLjQwLjUgLyBtcDRhLjQwLjI5KVxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XG4gICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDRlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MWMsIDB4NiwgMHhmMSwgMHhjMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDVlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHg5NSwgMHgwLCAweDYsIDB4ZjEsIDB4YTEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xuICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MHwwfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDVlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHg5NSwgMHgwLCAweDYsIDB4ZjEsIDB4YTEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFBQztcbiIsIi8qKlxuICogR2VuZXJhdGUgTVA0IEJveFxuKi9cblxuY29uc3QgVUlOVDMyX01BWCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5cbmNsYXNzIE1QNCB7XG4gIHN0YXRpYyBpbml0ICgpIHtcbiAgICBNUDQudHlwZXMgPSB7XG4gICAgICBhdmMxOiBbXSwgLy8gY29kaW5nbmFtZVxuICAgICAgYXZjQzogW10sXG4gICAgICBidHJ0OiBbXSxcbiAgICAgIGRpbmY6IFtdLFxuICAgICAgZHJlZjogW10sXG4gICAgICBlc2RzOiBbXSxcbiAgICAgIGZ0eXA6IFtdLFxuICAgICAgaGRscjogW10sXG4gICAgICBtZGF0OiBbXSxcbiAgICAgIG1kaGQ6IFtdLFxuICAgICAgbWRpYTogW10sXG4gICAgICBtZmhkOiBbXSxcbiAgICAgIG1pbmY6IFtdLFxuICAgICAgbW9vZjogW10sXG4gICAgICBtb292OiBbXSxcbiAgICAgIG1wNGE6IFtdLFxuICAgICAgJy5tcDMnOiBbXSxcbiAgICAgIG12ZXg6IFtdLFxuICAgICAgbXZoZDogW10sXG4gICAgICBwYXNwOiBbXSxcbiAgICAgIHNkdHA6IFtdLFxuICAgICAgc3RibDogW10sXG4gICAgICBzdGNvOiBbXSxcbiAgICAgIHN0c2M6IFtdLFxuICAgICAgc3RzZDogW10sXG4gICAgICBzdHN6OiBbXSxcbiAgICAgIHN0dHM6IFtdLFxuICAgICAgdGZkdDogW10sXG4gICAgICB0ZmhkOiBbXSxcbiAgICAgIHRyYWY6IFtdLFxuICAgICAgdHJhazogW10sXG4gICAgICB0cnVuOiBbXSxcbiAgICAgIHRyZXg6IFtdLFxuICAgICAgdGtoZDogW10sXG4gICAgICB2bWhkOiBbXSxcbiAgICAgIHNtaGQ6IFtdXG4gICAgfTtcblxuICAgIGxldCBpO1xuICAgIGZvciAoaSBpbiBNUDQudHlwZXMpIHtcbiAgICAgIGlmIChNUDQudHlwZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgTVA0LnR5cGVzW2ldID0gW1xuICAgICAgICAgIGkuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMSksXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDIpLFxuICAgICAgICAgIGkuY2hhckNvZGVBdCgzKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB2aWRlb0hkbHIgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHg3NiwgMHg2OSwgMHg2NCwgMHg2NSwgLy8gaGFuZGxlcl90eXBlOiAndmlkZSdcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4NTYsIDB4NjksIDB4NjQsIDB4NjUsXG4gICAgICAweDZmLCAweDQ4LCAweDYxLCAweDZlLFxuICAgICAgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnVmlkZW9IYW5kbGVyJ1xuICAgIF0pO1xuXG4gICAgbGV0IGF1ZGlvSGRsciA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDczLCAweDZmLCAweDc1LCAweDZlLCAvLyBoYW5kbGVyX3R5cGU6ICdzb3VuJ1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHg1MywgMHg2ZiwgMHg3NSwgMHg2ZSxcbiAgICAgIDB4NjQsIDB4NDgsIDB4NjEsIDB4NmUsXG4gICAgICAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdTb3VuZEhhbmRsZXInXG4gICAgXSk7XG5cbiAgICBNUDQuSERMUl9UWVBFUyA9IHtcbiAgICAgICd2aWRlbyc6IHZpZGVvSGRscixcbiAgICAgICdhdWRpbyc6IGF1ZGlvSGRsclxuICAgIH07XG5cbiAgICBsZXQgZHJlZiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGVudHJ5X2NvdW50XG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDBjLCAvLyBlbnRyeV9zaXplXG4gICAgICAweDc1LCAweDcyLCAweDZjLCAweDIwLCAvLyAndXJsJyB0eXBlXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDEgLy8gZW50cnlfZmxhZ3NcbiAgICBdKTtcblxuICAgIGxldCBzdGNvID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnRcbiAgICBdKTtcblxuICAgIE1QNC5TVFRTID0gTVA0LlNUU0MgPSBNUDQuU1RDTyA9IHN0Y287XG5cbiAgICBNUDQuU1RTWiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBzYW1wbGVfc2l6ZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBzYW1wbGVfY291bnRcbiAgICBdKTtcbiAgICBNUDQuVk1IRCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAvLyBncmFwaGljc21vZGVcbiAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCAvLyBvcGNvbG9yXG4gICAgXSk7XG4gICAgTVA0LlNNSEQgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgLy8gYmFsYW5jZVxuICAgICAgMHgwMCwgMHgwMCAvLyByZXNlcnZlZFxuICAgIF0pO1xuXG4gICAgTVA0LlNUU0QgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxXSk7Ly8gZW50cnlfY291bnRcblxuICAgIGxldCBtYWpvckJyYW5kID0gbmV3IFVpbnQ4QXJyYXkoWzEwNSwgMTE1LCAxMTEsIDEwOV0pOyAvLyBpc29tXG4gICAgbGV0IGF2YzFCcmFuZCA9IG5ldyBVaW50OEFycmF5KFs5NywgMTE4LCA5OSwgNDldKTsgLy8gYXZjMVxuICAgIGxldCBtaW5vclZlcnNpb24gPSBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMV0pO1xuXG4gICAgTVA0LkZUWVAgPSBNUDQuYm94KE1QNC50eXBlcy5mdHlwLCBtYWpvckJyYW5kLCBtaW5vclZlcnNpb24sIG1ham9yQnJhbmQsIGF2YzFCcmFuZCk7XG4gICAgTVA0LkRJTkYgPSBNUDQuYm94KE1QNC50eXBlcy5kaW5mLCBNUDQuYm94KE1QNC50eXBlcy5kcmVmLCBkcmVmKSk7XG4gIH1cblxuICBzdGF0aWMgYm94ICh0eXBlKSB7XG4gICAgbGV0XG4gICAgICBwYXlsb2FkID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgIHNpemUgPSA4LFxuICAgICAgaSA9IHBheWxvYWQubGVuZ3RoLFxuICAgICAgbGVuID0gaSxcbiAgICAgIHJlc3VsdDtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIHNpemUgd2UgbmVlZCB0byBhbGxvY2F0ZVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIHJlc3VsdFswXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgcmVzdWx0WzFdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICByZXN1bHRbMl0gPSAoc2l6ZSA+PiA4KSAmIDB4ZmY7XG4gICAgcmVzdWx0WzNdID0gc2l6ZSAmIDB4ZmY7XG4gICAgcmVzdWx0LnNldCh0eXBlLCA0KTtcbiAgICAvLyBjb3B5IHRoZSBwYXlsb2FkIGludG8gdGhlIHJlc3VsdFxuICAgIGZvciAoaSA9IDAsIHNpemUgPSA4OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIC8vIGNvcHkgcGF5bG9hZFtpXSBhcnJheSBAIG9mZnNldCBzaXplXG4gICAgICByZXN1bHQuc2V0KHBheWxvYWRbaV0sIHNpemUpO1xuICAgICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBzdGF0aWMgaGRsciAodHlwZSkge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5oZGxyLCBNUDQuSERMUl9UWVBFU1t0eXBlXSk7XG4gIH1cblxuICBzdGF0aWMgbWRhdCAoZGF0YSkge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGF0LCBkYXRhKTtcbiAgfVxuXG4gIHN0YXRpYyBtZGhkICh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xuICAgIGNvbnN0IHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGhkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAxLCAvLyB2ZXJzaW9uIDFcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLCAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgICAgKHRpbWVzY2FsZSA+PiAyNCkgJiAweEZGLFxuICAgICAgKHRpbWVzY2FsZSA+PiAxNikgJiAweEZGLFxuICAgICAgKHRpbWVzY2FsZSA+PiA4KSAmIDB4RkYsXG4gICAgICB0aW1lc2NhbGUgJiAweEZGLCAvLyB0aW1lc2NhbGVcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAyNCksXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiA4KSAmIDB4RkYsXG4gICAgICB1cHBlcldvcmREdXJhdGlvbiAmIDB4RkYsXG4gICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMjQpLFxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXG4gICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweEZGLFxuICAgICAgbG93ZXJXb3JkRHVyYXRpb24gJiAweEZGLFxuICAgICAgMHg1NSwgMHhjNCwgLy8gJ3VuZCcgbGFuZ3VhZ2UgKHVuZGV0ZXJtaW5lZClcbiAgICAgIDB4MDAsIDB4MDBcbiAgICBdKSk7XG4gIH1cblxuICBzdGF0aWMgbWRpYSAodHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRpYSwgTVA0Lm1kaGQodHJhY2sudGltZXNjYWxlLCB0cmFjay5kdXJhdGlvbiksIE1QNC5oZGxyKHRyYWNrLnR5cGUpLCBNUDQubWluZih0cmFjaykpO1xuICB9XG5cbiAgc3RhdGljIG1maGQgKHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1maGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgKHNlcXVlbmNlTnVtYmVyID4+IDI0KSxcbiAgICAgIChzZXF1ZW5jZU51bWJlciA+PiAxNikgJiAweEZGLFxuICAgICAgKHNlcXVlbmNlTnVtYmVyID4+IDgpICYgMHhGRixcbiAgICAgIHNlcXVlbmNlTnVtYmVyICYgMHhGRiAvLyBzZXF1ZW5jZV9udW1iZXJcbiAgICBdKSk7XG4gIH1cblxuICBzdGF0aWMgbWluZiAodHJhY2spIHtcbiAgICBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnNtaGQsIE1QNC5TTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5taW5mLCBNUDQuYm94KE1QNC50eXBlcy52bWhkLCBNUDQuVk1IRCksIE1QNC5ESU5GLCBNUDQuc3RibCh0cmFjaykpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBtb29mIChzbiwgYmFzZU1lZGlhRGVjb2RlVGltZSwgdHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubW9vZiwgTVA0Lm1maGQoc24pLCBNUDQudHJhZih0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSkpO1xuICB9XG4gIC8qKlxuICogQHBhcmFtIHRyYWNrcy4uLiAob3B0aW9uYWwpIHthcnJheX0gdGhlIHRyYWNrcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtb3ZpZVxuICovXG4gIHN0YXRpYyBtb292ICh0cmFja3MpIHtcbiAgICBsZXRcbiAgICAgIGkgPSB0cmFja3MubGVuZ3RoLFxuICAgICAgYm94ZXMgPSBbXTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGJveGVzW2ldID0gTVA0LnRyYWsodHJhY2tzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm1vb3YsIE1QNC5tdmhkKHRyYWNrc1swXS50aW1lc2NhbGUsIHRyYWNrc1swXS5kdXJhdGlvbildLmNvbmNhdChib3hlcykuY29uY2F0KE1QNC5tdmV4KHRyYWNrcykpKTtcbiAgfVxuXG4gIHN0YXRpYyBtdmV4ICh0cmFja3MpIHtcbiAgICBsZXRcbiAgICAgIGkgPSB0cmFja3MubGVuZ3RoLFxuICAgICAgYm94ZXMgPSBbXTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGJveGVzW2ldID0gTVA0LnRyZXgodHJhY2tzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm12ZXhdLmNvbmNhdChib3hlcykpO1xuICB9XG5cbiAgc3RhdGljIG12aGQgKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgY29uc3QgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgbGV0XG4gICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgICAgKHRpbWVzY2FsZSA+PiAyNCkgJiAweEZGLFxuICAgICAgICAodGltZXNjYWxlID4+IDE2KSAmIDB4RkYsXG4gICAgICAgICh0aW1lc2NhbGUgPj4gOCkgJiAweEZGLFxuICAgICAgICB0aW1lc2NhbGUgJiAweEZGLCAvLyB0aW1lc2NhbGVcbiAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDI0KSxcbiAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXG4gICAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiA4KSAmIDB4RkYsXG4gICAgICAgIHVwcGVyV29yZER1cmF0aW9uICYgMHhGRixcbiAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDI0KSxcbiAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXG4gICAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiA4KSAmIDB4RkYsXG4gICAgICAgIGxvd2VyV29yZER1cmF0aW9uICYgMHhGRixcbiAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgLy8gMS4wIHJhdGVcbiAgICAgICAgMHgwMSwgMHgwMCwgLy8gMS4wIHZvbHVtZVxuICAgICAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDQwLCAweDAwLCAweDAwLCAweDAwLCAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAgIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYgLy8gbmV4dF90cmFja19JRFxuICAgICAgXSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm12aGQsIGJ5dGVzKTtcbiAgfVxuXG4gIHN0YXRpYyBzZHRwICh0cmFjaykge1xuICAgIGxldFxuICAgICAgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW10sXG4gICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KDQgKyBzYW1wbGVzLmxlbmd0aCksXG4gICAgICBmbGFncyxcbiAgICAgIGk7XG4gICAgLy8gbGVhdmUgdGhlIGZ1bGwgYm94IGhlYWRlciAoNCBieXRlcykgYWxsIHplcm9cbiAgICAvLyB3cml0ZSB0aGUgc2FtcGxlIHRhYmxlXG4gICAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZsYWdzID0gc2FtcGxlc1tpXS5mbGFncztcbiAgICAgIGJ5dGVzW2kgKyA0XSA9IChmbGFncy5kZXBlbmRzT24gPDwgNCkgfFxuICAgICAgICAoZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDIpIHxcbiAgICAgICAgKGZsYWdzLmhhc1JlZHVuZGFuY3kpO1xuICAgIH1cblxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zZHRwLCBieXRlcyk7XG4gIH1cblxuICBzdGF0aWMgc3RibCAodHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RibCwgTVA0LnN0c2QodHJhY2spLCBNUDQuYm94KE1QNC50eXBlcy5zdHRzLCBNUDQuU1RUUyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c2MsIE1QNC5TVFNDKSwgTVA0LmJveChNUDQudHlwZXMuc3RzeiwgTVA0LlNUU1opLCBNUDQuYm94KE1QNC50eXBlcy5zdGNvLCBNUDQuU1RDTykpO1xuICB9XG5cbiAgc3RhdGljIGF2YzEgKHRyYWNrKSB7XG4gICAgbGV0IHNwcyA9IFtdLCBwcHMgPSBbXSwgaSwgZGF0YSwgbGVuO1xuICAgIC8vIGFzc2VtYmxlIHRoZSBTUFNzXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2suc3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhID0gdHJhY2suc3BzW2ldO1xuICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgc3BzLnB1c2goKGxlbiA+Pj4gOCkgJiAweEZGKTtcbiAgICAgIHNwcy5wdXNoKChsZW4gJiAweEZGKSk7XG5cbiAgICAgIC8vIFNQU1xuICAgICAgc3BzID0gc3BzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XG4gICAgfVxuXG4gICAgLy8gYXNzZW1ibGUgdGhlIFBQU3NcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2sucHBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhID0gdHJhY2sucHBzW2ldO1xuICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgcHBzLnB1c2goKGxlbiA+Pj4gOCkgJiAweEZGKTtcbiAgICAgIHBwcy5wdXNoKChsZW4gJiAweEZGKSk7XG5cbiAgICAgIHBwcyA9IHBwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xuICAgIH1cblxuICAgIGxldCBhdmNjID0gTVA0LmJveChNUDQudHlwZXMuYXZjQywgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDAxLCAvLyB2ZXJzaW9uXG4gICAgICAgIHNwc1szXSwgLy8gcHJvZmlsZVxuICAgICAgICBzcHNbNF0sIC8vIHByb2ZpbGUgY29tcGF0XG4gICAgICAgIHNwc1s1XSwgLy8gbGV2ZWxcbiAgICAgICAgMHhmYyB8IDMsIC8vIGxlbmd0aFNpemVNaW51c09uZSwgaGFyZC1jb2RlZCB0byA0IGJ5dGVzXG4gICAgICAgIDB4RTAgfCB0cmFjay5zcHMubGVuZ3RoIC8vIDNiaXQgcmVzZXJ2ZWQgKDExMSkgKyBudW1PZlNlcXVlbmNlUGFyYW1ldGVyU2V0c1xuICAgICAgXS5jb25jYXQoc3BzKS5jb25jYXQoW1xuICAgICAgICB0cmFjay5wcHMubGVuZ3RoIC8vIG51bU9mUGljdHVyZVBhcmFtZXRlclNldHNcbiAgICAgIF0pLmNvbmNhdChwcHMpKSksIC8vIFwiUFBTXCJcbiAgICAgIHdpZHRoID0gdHJhY2sud2lkdGgsXG4gICAgICBoZWlnaHQgPSB0cmFjay5oZWlnaHQsXG4gICAgICBoU3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMF0sXG4gICAgICB2U3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMV07XG5cbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuYXZjMSwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgICAgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAod2lkdGggPj4gOCkgJiAweEZGLFxuICAgICAgd2lkdGggJiAweGZmLCAvLyB3aWR0aFxuICAgICAgKGhlaWdodCA+PiA4KSAmIDB4RkYsXG4gICAgICBoZWlnaHQgJiAweGZmLCAvLyBoZWlnaHRcbiAgICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIGhvcml6cmVzb2x1dGlvblxuICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCwgLy8gdmVydHJlc29sdXRpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAvLyBmcmFtZV9jb3VudFxuICAgICAgMHgxMixcbiAgICAgIDB4NjQsIDB4NjEsIDB4NjksIDB4NkMsIC8vIGRhaWx5bW90aW9uL2hscy5qc1xuICAgICAgMHg3OSwgMHg2RCwgMHg2RiwgMHg3NCxcbiAgICAgIDB4NjksIDB4NkYsIDB4NkUsIDB4MkYsXG4gICAgICAweDY4LCAweDZDLCAweDczLCAweDJFLFxuICAgICAgMHg2QSwgMHg3MywgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gY29tcHJlc3Nvcm5hbWVcbiAgICAgIDB4MDAsIDB4MTgsIC8vIGRlcHRoID0gMjRcbiAgICAgIDB4MTEsIDB4MTFdKSwgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgIGF2Y2MsXG4gICAgTVA0LmJveChNUDQudHlwZXMuYnRydCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgMHgxYywgMHg5YywgMHg4MCwgLy8gYnVmZmVyU2l6ZURCXG4gICAgICAweDAwLCAweDJkLCAweGM2LCAweGMwLCAvLyBtYXhCaXRyYXRlXG4gICAgICAweDAwLCAweDJkLCAweGM2LCAweGMwXSkpLCAvLyBhdmdCaXRyYXRlXG4gICAgTVA0LmJveChNUDQudHlwZXMucGFzcCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgKGhTcGFjaW5nID4+IDI0KSwgLy8gaFNwYWNpbmdcbiAgICAgIChoU3BhY2luZyA+PiAxNikgJiAweEZGLFxuICAgICAgKGhTcGFjaW5nID4+IDgpICYgMHhGRixcbiAgICAgIGhTcGFjaW5nICYgMHhGRixcbiAgICAgICh2U3BhY2luZyA+PiAyNCksIC8vIHZTcGFjaW5nXG4gICAgICAodlNwYWNpbmcgPj4gMTYpICYgMHhGRixcbiAgICAgICh2U3BhY2luZyA+PiA4KSAmIDB4RkYsXG4gICAgICB2U3BhY2luZyAmIDB4RkZdKSlcbiAgICApO1xuICB9XG5cbiAgc3RhdGljIGVzZHMgKHRyYWNrKSB7XG4gICAgbGV0IGNvbmZpZ2xlbiA9IHRyYWNrLmNvbmZpZy5sZW5ndGg7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcblxuICAgICAgMHgwMywgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgICAweDE3ICsgY29uZmlnbGVuLCAvLyBsZW5ndGhcbiAgICAgIDB4MDAsIDB4MDEsIC8vIGVzX2lkXG4gICAgICAweDAwLCAvLyBzdHJlYW1fcHJpb3JpdHlcblxuICAgICAgMHgwNCwgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgICAweDBmICsgY29uZmlnbGVuLCAvLyBsZW5ndGhcbiAgICAgIDB4NDAsIC8vIGNvZGVjIDogbXBlZzRfYXVkaW9cbiAgICAgIDB4MTUsIC8vIHN0cmVhbV90eXBlXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBidWZmZXJfc2l6ZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gbWF4Qml0cmF0ZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gYXZnQml0cmF0ZVxuXG4gICAgICAweDA1IC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgIF0uY29uY2F0KFtjb25maWdsZW5dKS5jb25jYXQodHJhY2suY29uZmlnKS5jb25jYXQoWzB4MDYsIDB4MDEsIDB4MDJdKSk7IC8vIEdBU3BlY2lmaWNDb25maWcpKTsgLy8gbGVuZ3RoICsgYXVkaW8gY29uZmlnIGRlc2NyaXB0b3JcbiAgfVxuXG4gIHN0YXRpYyBtcDRhICh0cmFjaykge1xuICAgIGxldCBzYW1wbGVyYXRlID0gdHJhY2suc2FtcGxlcmF0ZTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXA0YSwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCB0cmFjay5jaGFubmVsQ291bnQsIC8vIGNoYW5uZWxjb3VudFxuICAgICAgMHgwMCwgMHgxMCwgLy8gc2FtcGxlU2l6ZToxNmJpdHNcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkMlxuICAgICAgKHNhbXBsZXJhdGUgPj4gOCkgJiAweEZGLFxuICAgICAgc2FtcGxlcmF0ZSAmIDB4ZmYsIC8vXG4gICAgICAweDAwLCAweDAwXSksXG4gICAgTVA0LmJveChNUDQudHlwZXMuZXNkcywgTVA0LmVzZHModHJhY2spKSk7XG4gIH1cblxuICBzdGF0aWMgbXAzICh0cmFjaykge1xuICAgIGxldCBzYW1wbGVyYXRlID0gdHJhY2suc2FtcGxlcmF0ZTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXNbJy5tcDMnXSwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCB0cmFjay5jaGFubmVsQ291bnQsIC8vIGNoYW5uZWxjb3VudFxuICAgICAgMHgwMCwgMHgxMCwgLy8gc2FtcGxlU2l6ZToxNmJpdHNcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkMlxuICAgICAgKHNhbXBsZXJhdGUgPj4gOCkgJiAweEZGLFxuICAgICAgc2FtcGxlcmF0ZSAmIDB4ZmYsIC8vXG4gICAgICAweDAwLCAweDAwXSkpO1xuICB9XG5cbiAgc3RhdGljIHN0c2QgKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIGlmICghdHJhY2suaXNBQUMgJiYgdHJhY2suY29kZWMgPT09ICdtcDMnKSB7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wMyh0cmFjaykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDRhKHRyYWNrKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0LmF2YzEodHJhY2spKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgdGtoZCAodHJhY2spIHtcbiAgICBsZXQgaWQgPSB0cmFjay5pZCxcbiAgICAgIGR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gKiB0cmFjay50aW1lc2NhbGUsXG4gICAgICB3aWR0aCA9IHRyYWNrLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0LFxuICAgICAgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSksXG4gICAgICBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudGtoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgICAweDAwLCAweDAwLCAweDA3LCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMiwgLy8gY3JlYXRpb25fdGltZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgIChpZCA+PiAyNCkgJiAweEZGLFxuICAgICAgKGlkID4+IDE2KSAmIDB4RkYsXG4gICAgICAoaWQgPj4gOCkgJiAweEZGLFxuICAgICAgaWQgJiAweEZGLCAvLyB0cmFja19JRFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAyNCksXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiA4KSAmIDB4RkYsXG4gICAgICB1cHBlcldvcmREdXJhdGlvbiAmIDB4RkYsXG4gICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMjQpLFxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXG4gICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweEZGLFxuICAgICAgbG93ZXJXb3JkRHVyYXRpb24gJiAweEZGLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAvLyBsYXllclxuICAgICAgMHgwMCwgMHgwMCwgLy8gYWx0ZXJuYXRlX2dyb3VwXG4gICAgICAweDAwLCAweDAwLCAvLyBub24tYXVkaW8gdHJhY2sgdm9sdW1lXG4gICAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDQwLCAweDAwLCAweDAwLCAweDAwLCAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgICAod2lkdGggPj4gOCkgJiAweEZGLFxuICAgICAgd2lkdGggJiAweEZGLFxuICAgICAgMHgwMCwgMHgwMCwgLy8gd2lkdGhcbiAgICAgIChoZWlnaHQgPj4gOCkgJiAweEZGLFxuICAgICAgaGVpZ2h0ICYgMHhGRixcbiAgICAgIDB4MDAsIDB4MDAgLy8gaGVpZ2h0XG4gICAgXSkpO1xuICB9XG5cbiAgc3RhdGljIHRyYWYgKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKSB7XG4gICAgbGV0IHNhbXBsZURlcGVuZGVuY3lUYWJsZSA9IE1QNC5zZHRwKHRyYWNrKSxcbiAgICAgIGlkID0gdHJhY2suaWQsXG4gICAgICB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lIC8gKFVJTlQzMl9NQVggKyAxKSksXG4gICAgICBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWYsXG4gICAgICBNUDQuYm94KE1QNC50eXBlcy50ZmhkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgICAoaWQgPj4gMjQpLFxuICAgICAgICAoaWQgPj4gMTYpICYgMFhGRixcbiAgICAgICAgKGlkID4+IDgpICYgMFhGRixcbiAgICAgICAgKGlkICYgMHhGRikgLy8gdHJhY2tfSURcbiAgICAgIF0pKSxcbiAgICAgIE1QNC5ib3goTVA0LnR5cGVzLnRmZHQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAgICh1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDI0KSxcbiAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYpICYgMFhGRixcbiAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gOCkgJiAwWEZGLFxuICAgICAgICAodXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4RkYpLFxuICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAyNCksXG4gICAgICAgIChsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDE2KSAmIDBYRkYsXG4gICAgICAgIChsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDgpICYgMFhGRixcbiAgICAgICAgKGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweEZGKVxuICAgICAgXSkpLFxuICAgICAgTVA0LnRydW4odHJhY2ssXG4gICAgICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICAgICAxNiArIC8vIHRmaGRcbiAgICAgICAgICAgICAgICAgICAgMjAgKyAvLyB0ZmR0XG4gICAgICAgICAgICAgICAgICAgIDggKyAvLyB0cmFmIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAxNiArIC8vIG1maGRcbiAgICAgICAgICAgICAgICAgICAgOCArIC8vIG1vb2YgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIDgpLCAvLyBtZGF0IGhlYWRlclxuICAgICAgc2FtcGxlRGVwZW5kZW5jeVRhYmxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYWNrIGJveC5cbiAgICogQHBhcmFtIHRyYWNrIHtvYmplY3R9IGEgdHJhY2sgZGVmaW5pdGlvblxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSB0aGUgdHJhY2sgYm94XG4gICAqL1xuICBzdGF0aWMgdHJhayAodHJhY2spIHtcbiAgICB0cmFjay5kdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uIHx8IDB4ZmZmZmZmZmY7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWssIE1QNC50a2hkKHRyYWNrKSwgTVA0Lm1kaWEodHJhY2spKTtcbiAgfVxuXG4gIHN0YXRpYyB0cmV4ICh0cmFjaykge1xuICAgIGxldCBpZCA9IHRyYWNrLmlkO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmV4LCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAoaWQgPj4gMjQpLFxuICAgICAgKGlkID4+IDE2KSAmIDBYRkYsXG4gICAgICAoaWQgPj4gOCkgJiAwWEZGLFxuICAgICAgKGlkICYgMHhGRiksIC8vIHRyYWNrX0lEXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyBkZWZhdWx0X3NhbXBsZV9kZXNjcmlwdGlvbl9pbmRleFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfZHVyYXRpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX3NpemVcbiAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDEgLy8gZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgICBdKSk7XG4gIH1cblxuICBzdGF0aWMgdHJ1biAodHJhY2ssIG9mZnNldCkge1xuICAgIGxldCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXSxcbiAgICAgIGxlbiA9IHNhbXBsZXMubGVuZ3RoLFxuICAgICAgYXJyYXlsZW4gPSAxMiArICgxNiAqIGxlbiksXG4gICAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5bGVuKSxcbiAgICAgIGksIHNhbXBsZSwgZHVyYXRpb24sIHNpemUsIGZsYWdzLCBjdHM7XG4gICAgb2Zmc2V0ICs9IDggKyBhcnJheWxlbjtcbiAgICBhcnJheS5zZXQoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDBmLCAweDAxLCAvLyBmbGFnc1xuICAgICAgKGxlbiA+Pj4gMjQpICYgMHhGRixcbiAgICAgIChsZW4gPj4+IDE2KSAmIDB4RkYsXG4gICAgICAobGVuID4+PiA4KSAmIDB4RkYsXG4gICAgICBsZW4gJiAweEZGLCAvLyBzYW1wbGVfY291bnRcbiAgICAgIChvZmZzZXQgPj4+IDI0KSAmIDB4RkYsXG4gICAgICAob2Zmc2V0ID4+PiAxNikgJiAweEZGLFxuICAgICAgKG9mZnNldCA+Pj4gOCkgJiAweEZGLFxuICAgICAgb2Zmc2V0ICYgMHhGRiAvLyBkYXRhX29mZnNldFxuICAgIF0sIDApO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2FtcGxlID0gc2FtcGxlc1tpXTtcbiAgICAgIGR1cmF0aW9uID0gc2FtcGxlLmR1cmF0aW9uO1xuICAgICAgc2l6ZSA9IHNhbXBsZS5zaXplO1xuICAgICAgZmxhZ3MgPSBzYW1wbGUuZmxhZ3M7XG4gICAgICBjdHMgPSBzYW1wbGUuY3RzO1xuICAgICAgYXJyYXkuc2V0KFtcbiAgICAgICAgKGR1cmF0aW9uID4+PiAyNCkgJiAweEZGLFxuICAgICAgICAoZHVyYXRpb24gPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgIChkdXJhdGlvbiA+Pj4gOCkgJiAweEZGLFxuICAgICAgICBkdXJhdGlvbiAmIDB4RkYsIC8vIHNhbXBsZV9kdXJhdGlvblxuICAgICAgICAoc2l6ZSA+Pj4gMjQpICYgMHhGRixcbiAgICAgICAgKHNpemUgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgIChzaXplID4+PiA4KSAmIDB4RkYsXG4gICAgICAgIHNpemUgJiAweEZGLCAvLyBzYW1wbGVfc2l6ZVxuICAgICAgICAoZmxhZ3MuaXNMZWFkaW5nIDw8IDIpIHwgZmxhZ3MuZGVwZW5kc09uLFxuICAgICAgICAoZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDYpIHxcbiAgICAgICAgICAoZmxhZ3MuaGFzUmVkdW5kYW5jeSA8PCA0KSB8XG4gICAgICAgICAgKGZsYWdzLnBhZGRpbmdWYWx1ZSA8PCAxKSB8XG4gICAgICAgICAgZmxhZ3MuaXNOb25TeW5jLFxuICAgICAgICBmbGFncy5kZWdyYWRQcmlvICYgMHhGMCA8PCA4LFxuICAgICAgICBmbGFncy5kZWdyYWRQcmlvICYgMHgwRiwgLy8gc2FtcGxlX2ZsYWdzXG4gICAgICAgIChjdHMgPj4+IDI0KSAmIDB4RkYsXG4gICAgICAgIChjdHMgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgIChjdHMgPj4+IDgpICYgMHhGRixcbiAgICAgICAgY3RzICYgMHhGRiAvLyBzYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXRcbiAgICAgIF0sIDEyICsgMTYgKiBpKTtcbiAgICB9XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRydW4sIGFycmF5KTtcbiAgfVxuXG4gIHN0YXRpYyBpbml0U2VnbWVudCAodHJhY2tzKSB7XG4gICAgaWYgKCFNUDQudHlwZXMpIHtcbiAgICAgIE1QNC5pbml0KCk7XG4gICAgfVxuXG4gICAgbGV0IG1vdmllID0gTVA0Lm1vb3YodHJhY2tzKSwgcmVzdWx0O1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KE1QNC5GVFlQLmJ5dGVMZW5ndGggKyBtb3ZpZS5ieXRlTGVuZ3RoKTtcbiAgICByZXN1bHQuc2V0KE1QNC5GVFlQKTtcbiAgICByZXN1bHQuc2V0KG1vdmllLCBNUDQuRlRZUC5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1QNDtcbiIsIi8qKlxuICogZk1QNCByZW11eGVyXG4qL1xuXG5pbXBvcnQgQUFDIGZyb20gJy4vYWFjLWhlbHBlcic7XG5pbXBvcnQgTVA0IGZyb20gJy4vbXA0LWdlbmVyYXRvcic7XG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuLy8gMTAgc2Vjb25kc1xuY29uc3QgTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiA9IDEwICogMTAwMDtcblxuY2xhc3MgTVA0UmVtdXhlciB7XG4gIGNvbnN0cnVjdG9yIChvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCB2ZW5kb3IpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICBjb25zdCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIHRoaXMuaXNTYWZhcmkgPSB2ZW5kb3IgJiYgdmVuZG9yLmluZGV4T2YoJ0FwcGxlJykgPiAtMSAmJiB1c2VyQWdlbnQgJiYgIXVzZXJBZ2VudC5tYXRjaCgnQ3JpT1MnKTtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgfVxuXG4gIHJlc2V0VGltZVN0YW1wIChkZWZhdWx0VGltZVN0YW1wKSB7XG4gICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSBkZWZhdWx0VGltZVN0YW1wO1xuICB9XG5cbiAgcmVzZXRJbml0U2VnbWVudCAoKSB7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgcmVtdXggKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIC8vIGdlbmVyYXRlIEluaXQgU2VnbWVudCBpZiBuZWVkZWRcbiAgICBpZiAoIXRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgY29uc3QgbmJBdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoO1xuICAgICAgY29uc3QgbmJWaWRlb1NhbXBsZXMgPSB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoO1xuICAgICAgbGV0IGF1ZGlvVGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG4gICAgICBsZXQgdmlkZW9UaW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICAgIGlmIChuYkF1ZGlvU2FtcGxlcyAmJiBuYlZpZGVvU2FtcGxlcykge1xuICAgICAgICAvLyB0aW1lT2Zmc2V0IGlzIGV4cGVjdGVkIHRvIGJlIHRoZSBvZmZzZXQgb2YgdGhlIGZpcnN0IHRpbWVzdGFtcCBvZiB0aGlzIGZyYWdtZW50IChmaXJzdCBEVFMpXG4gICAgICAgIC8vIGlmIGZpcnN0IGF1ZGlvIERUUyBpcyBub3QgYWxpZ25lZCB3aXRoIGZpcnN0IHZpZGVvIERUUyB0aGVuIHdlIG5lZWQgdG8gdGFrZSB0aGF0IGludG8gYWNjb3VudFxuICAgICAgICAvLyB3aGVuIHByb3ZpZGluZyB0aW1lT2Zmc2V0IHRvIHJlbXV4QXVkaW8gLyByZW11eFZpZGVvLiBpZiB3ZSBkb24ndCBkbyB0aGF0LCB0aGVyZSBtaWdodCBiZSBhIHBlcm1hbmVudCAvIHNtYWxsXG4gICAgICAgIC8vIGRyaWZ0IGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvIHN0cmVhbXNcbiAgICAgICAgbGV0IGF1ZGlvdmlkZW9EZWx0YUR0cyA9IChhdWRpb1RyYWNrLnNhbXBsZXNbMF0ucHRzIC0gdmlkZW9UcmFjay5zYW1wbGVzWzBdLnB0cykgLyB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICBhdWRpb1RpbWVPZmZzZXQgKz0gTWF0aC5tYXgoMCwgYXVkaW92aWRlb0RlbHRhRHRzKTtcbiAgICAgICAgdmlkZW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIC1hdWRpb3ZpZGVvRGVsdGFEdHMpO1xuICAgICAgfVxuICAgICAgLy8gUHVycG9zZWZ1bGx5IHJlbXV4aW5nIGF1ZGlvIGJlZm9yZSB2aWRlbywgc28gdGhhdCByZW11eFZpZGVvIGNhbiB1c2UgbmV4dEF1ZGlvUHRzLCB3aGljaCBpc1xuICAgICAgLy8gY2FsY3VsYXRlZCBpbiByZW11eEF1ZGlvLlxuICAgICAgLy8gbG9nZ2VyLmxvZygnbmIgQUFDIHNhbXBsZXM6JyArIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgaWYgKG5iQXVkaW9TYW1wbGVzKSB7XG4gICAgICAgIC8vIGlmIGluaXRTZWdtZW50IHdhcyBnZW5lcmF0ZWQgd2l0aG91dCB2aWRlbyBzYW1wbGVzLCByZWdlbmVyYXRlIGl0IGFnYWluXG4gICAgICAgIGlmICghYXVkaW9UcmFjay50aW1lc2NhbGUpIHtcbiAgICAgICAgICBsb2dnZXIud2FybigncmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyBhdWRpbyBkZXRlY3RlZCcpO1xuICAgICAgICAgIHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXVkaW9EYXRhID0gdGhpcy5yZW11eEF1ZGlvKGF1ZGlvVHJhY2ssIGF1ZGlvVGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnbmIgQVZDIHNhbXBsZXM6JyArIHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgICBpZiAobmJWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICBsZXQgYXVkaW9UcmFja0xlbmd0aDtcbiAgICAgICAgICBpZiAoYXVkaW9EYXRhKSB7XG4gICAgICAgICAgICBhdWRpb1RyYWNrTGVuZ3RoID0gYXVkaW9EYXRhLmVuZFBUUyAtIGF1ZGlvRGF0YS5zdGFydFBUUztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgdmlkZW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxuICAgICAgICAgIGlmICghdmlkZW9UcmFjay50aW1lc2NhbGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdyZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIHZpZGVvIGRldGVjdGVkJyk7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLCB2aWRlb1RpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGF1ZGlvVHJhY2tMZW5ndGgsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ25iIEFWQyBzYW1wbGVzOicgKyB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKG5iVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgbGV0IHZpZGVvRGF0YSA9IHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLCB2aWRlb1RpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIDAsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgaWYgKHZpZGVvRGF0YSAmJiBhdWRpb1RyYWNrLmNvZGVjKSB7XG4gICAgICAgICAgICB0aGlzLnJlbXV4RW1wdHlBdWRpbyhhdWRpb1RyYWNrLCBhdWRpb1RpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIHZpZGVvRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGxvZ2dlci5sb2coJ25iIElEMyBzYW1wbGVzOicgKyBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICBpZiAoaWQzVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmVtdXhJRDMoaWQzVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgIH1cblxuICAgIC8vIGxvZ2dlci5sb2coJ25iIElEMyBzYW1wbGVzOicgKyBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICBpZiAodGV4dFRyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJlbXV4VGV4dCh0ZXh0VHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgIH1cblxuICAgIC8vIG5vdGlmeSBlbmQgb2YgcGFyc2luZ1xuICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNFRCk7XG4gIH1cblxuICBnZW5lcmF0ZUlTIChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KSB7XG4gICAgbGV0IG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcixcbiAgICAgIGF1ZGlvU2FtcGxlcyA9IGF1ZGlvVHJhY2suc2FtcGxlcyxcbiAgICAgIHZpZGVvU2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcyxcbiAgICAgIHR5cGVTdXBwb3J0ZWQgPSB0aGlzLnR5cGVTdXBwb3J0ZWQsXG4gICAgICBjb250YWluZXIgPSAnYXVkaW8vbXA0JyxcbiAgICAgIHRyYWNrcyA9IHt9LFxuICAgICAgZGF0YSA9IHsgdHJhY2tzOiB0cmFja3MgfSxcbiAgICAgIGNvbXB1dGVQVFNEVFMgPSAodGhpcy5faW5pdFBUUyA9PT0gdW5kZWZpbmVkKSxcbiAgICAgIGluaXRQVFMsIGluaXREVFM7XG5cbiAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgaW5pdFBUUyA9IGluaXREVFMgPSBJbmZpbml0eTtcbiAgICB9XG5cbiAgICBpZiAoYXVkaW9UcmFjay5jb25maWcgJiYgYXVkaW9TYW1wbGVzLmxlbmd0aCkge1xuICAgICAgLy8gbGV0J3MgdXNlIGF1ZGlvIHNhbXBsaW5nIHJhdGUgYXMgTVA0IHRpbWUgc2NhbGUuXG4gICAgICAvLyByYXRpb25hbGUgaXMgdGhhdCB0aGVyZSBpcyBhIGludGVnZXIgbmIgb2YgYXVkaW8gZnJhbWVzIHBlciBhdWRpbyBzYW1wbGUgKDEwMjQgZm9yIEFBQylcbiAgICAgIC8vIHVzaW5nIGF1ZGlvIHNhbXBsaW5nIHJhdGUgaGVyZSBoZWxwcyBoYXZpbmcgYW4gaW50ZWdlciBNUDQgZnJhbWUgZHVyYXRpb25cbiAgICAgIC8vIHRoaXMgYXZvaWRzIHBvdGVudGlhbCByb3VuZGluZyBpc3N1ZSBhbmQgQVYgc3luYyBpc3N1ZVxuICAgICAgYXVkaW9UcmFjay50aW1lc2NhbGUgPSBhdWRpb1RyYWNrLnNhbXBsZXJhdGU7XG4gICAgICBsb2dnZXIubG9nKGBhdWRpbyBzYW1wbGluZyByYXRlIDogJHthdWRpb1RyYWNrLnNhbXBsZXJhdGV9YCk7XG4gICAgICBpZiAoIWF1ZGlvVHJhY2suaXNBQUMpIHtcbiAgICAgICAgaWYgKHR5cGVTdXBwb3J0ZWQubXBlZykgeyAvLyBDaHJvbWUgYW5kIFNhZmFyaVxuICAgICAgICAgIGNvbnRhaW5lciA9ICdhdWRpby9tcGVnJztcbiAgICAgICAgICBhdWRpb1RyYWNrLmNvZGVjID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZVN1cHBvcnRlZC5tcDMpIHsgLy8gRmlyZWZveFxuICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnbXAzJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJhY2tzLmF1ZGlvID0ge1xuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgY29kZWM6IGF1ZGlvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50OiAhYXVkaW9UcmFjay5pc0FBQyAmJiB0eXBlU3VwcG9ydGVkLm1wZWcgPyBuZXcgVWludDhBcnJheSgpIDogTVA0LmluaXRTZWdtZW50KFthdWRpb1RyYWNrXSksXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgY2hhbm5lbENvdW50OiBhdWRpb1RyYWNrLmNoYW5uZWxDb3VudFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIHRoaXMgZGVtdXhpbmcgY29udGV4dC4gZm9yIGF1ZGlvLCBQVFMgPSBEVFNcbiAgICAgICAgaW5pdFBUUyA9IGluaXREVFMgPSBhdWRpb1NhbXBsZXNbMF0ucHRzIC0gYXVkaW9UcmFjay5pbnB1dFRpbWVTY2FsZSAqIHRpbWVPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZpZGVvVHJhY2suc3BzICYmIHZpZGVvVHJhY2sucHBzICYmIHZpZGVvU2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIC8vIGxldCdzIHVzZSBpbnB1dCB0aW1lIHNjYWxlIGFzIE1QNCB2aWRlbyB0aW1lc2NhbGVcbiAgICAgIC8vIHdlIHVzZSBpbnB1dCB0aW1lIHNjYWxlIHN0cmFpZ2h0IGF3YXkgdG8gYXZvaWQgcm91bmRpbmcgaXNzdWVzIG9uIGZyYW1lIGR1cmF0aW9uIC8gY3RzIGNvbXB1dGF0aW9uXG4gICAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICB2aWRlb1RyYWNrLnRpbWVzY2FsZSA9IGlucHV0VGltZVNjYWxlO1xuICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICBjb2RlYzogdmlkZW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IE1QNC5pbml0U2VnbWVudChbdmlkZW9UcmFja10pLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHdpZHRoOiB2aWRlb1RyYWNrLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdmlkZW9UcmFjay5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIGluaXRQVFMgPSBNYXRoLm1pbihpbml0UFRTLCB2aWRlb1NhbXBsZXNbMF0ucHRzIC0gaW5wdXRUaW1lU2NhbGUgKiB0aW1lT2Zmc2V0KTtcbiAgICAgICAgaW5pdERUUyA9IE1hdGgubWluKGluaXREVFMsIHZpZGVvU2FtcGxlc1swXS5kdHMgLSBpbnB1dFRpbWVTY2FsZSAqIHRpbWVPZmZzZXQpO1xuICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuSU5JVF9QVFNfRk9VTkQsIHsgaW5pdFBUUzogaW5pdFBUUyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmtleXModHJhY2tzKS5sZW5ndGgpIHtcbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwgZGF0YSk7XG4gICAgICB0aGlzLklTR2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIHRoaXMuX2luaXRQVFMgPSBpbml0UFRTO1xuICAgICAgICB0aGlzLl9pbml0RFRTID0gaW5pdERUUztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogZmFsc2UsIHJlYXNvbjogJ25vIGF1ZGlvL3ZpZGVvIHNhbXBsZXMgZm91bmQnIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJlbXV4VmlkZW8gKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhdWRpb1RyYWNrTGVuZ3RoLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICBsZXQgb2Zmc2V0ID0gODtcbiAgICBsZXQgbXA0U2FtcGxlRHVyYXRpb247XG4gICAgbGV0IG1kYXQ7XG4gICAgbGV0IG1vb2Y7XG4gICAgbGV0IGZpcnN0UFRTO1xuICAgIGxldCBmaXJzdERUUztcbiAgICBsZXQgbGFzdFBUUztcbiAgICBsZXQgbGFzdERUUztcbiAgICBjb25zdCB0aW1lU2NhbGUgPSB0cmFjay50aW1lc2NhbGU7XG4gICAgY29uc3QgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICBjb25zdCBvdXRwdXRTYW1wbGVzID0gW107XG4gICAgY29uc3QgbmJTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmxlbmd0aDtcbiAgICBjb25zdCBwdHNOb3JtYWxpemUgPSB0aGlzLl9QVFNOb3JtYWxpemU7XG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG5cbiAgICAvLyBpZiBwYXJzZWQgZnJhZ21lbnQgaXMgY29udGlndW91cyB3aXRoIGxhc3Qgb25lLCBsZXQncyB1c2UgbGFzdCBEVFMgdmFsdWUgYXMgcmVmZXJlbmNlXG4gICAgbGV0IG5leHRBdmNEdHMgPSB0aGlzLm5leHRBdmNEdHM7XG5cbiAgICBjb25zdCBpc1NhZmFyaSA9IHRoaXMuaXNTYWZhcmk7XG5cbiAgICBpZiAobmJTYW1wbGVzID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2FmYXJpIGRvZXMgbm90IGxpa2Ugb3ZlcmxhcHBpbmcgRFRTIG9uIGNvbnNlY3V0aXZlIGZyYWdtZW50cy4gbGV0J3MgdXNlIG5leHRBdmNEdHMgdG8gb3ZlcmNvbWUgdGhpcyBpZiBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlXG4gICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICAvLyBhbHNvIGNvbnNpZGVyIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcyBiZWluZyBjb250aWd1b3VzIChldmVuIGlmIGEgbGV2ZWwgc3dpdGNoIG9jY3VycyksXG4gICAgICAvLyBmb3Igc2FrZSBvZiBjbGFyaXR5OlxuICAgICAgLy8gY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFyZSBmcmFncyB3aXRoXG4gICAgICAvLyAgLSBsZXNzIHRoYW4gMTAwbXMgZ2FwcyBiZXR3ZWVuIG5ldyB0aW1lIG9mZnNldCAoaWYgYWNjdXJhdGUpIGFuZCBuZXh0IGV4cGVjdGVkIFBUUyBPUlxuICAgICAgLy8gIC0gbGVzcyB0aGFuIDIwMCBtcyBQVFMgZ2FwcyAodGltZVNjYWxlLzUpXG4gICAgICBjb250aWd1b3VzIHw9IChpbnB1dFNhbXBsZXMubGVuZ3RoICYmIG5leHRBdmNEdHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICgoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmIE1hdGguYWJzKHRpbWVPZmZzZXQgLSBuZXh0QXZjRHRzIC8gdGltZVNjYWxlKSA8IDAuMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicygoaW5wdXRTYW1wbGVzWzBdLnB0cyAtIG5leHRBdmNEdHMgLSBpbml0UFRTKSkgPCB0aW1lU2NhbGUgLyA1KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbnRpZ3VvdXMpIHtcbiAgICAgIC8vIGlmIG5vdCBjb250aWd1b3VzLCBsZXQncyB1c2UgdGFyZ2V0IHRpbWVPZmZzZXRcbiAgICAgIG5leHRBdmNEdHMgPSB0aW1lT2Zmc2V0ICogdGltZVNjYWxlO1xuICAgIH1cblxuICAgIC8vIFBUUyBpcyBjb2RlZCBvbiAzM2JpdHMsIGFuZCBjYW4gbG9vcCBmcm9tIC0yXjMyIHRvIDJeMzJcbiAgICAvLyBwdHNOb3JtYWxpemUgd2lsbCBtYWtlIFBUUy9EVFMgdmFsdWUgbW9ub3RvbmljLCB3ZSB1c2UgbGFzdCBrbm93biBEVFMgdmFsdWUgYXMgcmVmZXJlbmNlIHZhbHVlXG4gICAgaW5wdXRTYW1wbGVzLmZvckVhY2goZnVuY3Rpb24gKHNhbXBsZSkge1xuICAgICAgc2FtcGxlLnB0cyA9IHB0c05vcm1hbGl6ZShzYW1wbGUucHRzIC0gaW5pdFBUUywgbmV4dEF2Y0R0cyk7XG4gICAgICBzYW1wbGUuZHRzID0gcHRzTm9ybWFsaXplKHNhbXBsZS5kdHMgLSBpbml0UFRTLCBuZXh0QXZjRHRzKTtcbiAgICB9KTtcblxuICAgIC8vIHNvcnQgdmlkZW8gc2FtcGxlcyBieSBEVFMgdGhlbiBQVFMgdGhlbiBkZW11eCBpZCBvcmRlclxuICAgIGlucHV0U2FtcGxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBjb25zdCBkZWx0YWR0cyA9IGEuZHRzIC0gYi5kdHM7XG4gICAgICBjb25zdCBkZWx0YXB0cyA9IGEucHRzIC0gYi5wdHM7XG4gICAgICByZXR1cm4gZGVsdGFkdHMgfHwgKGRlbHRhcHRzIHx8IChhLmlkIC0gYi5pZCkpO1xuICAgIH0pO1xuXG4gICAgLy8gaGFuZGxlIGJyb2tlbiBzdHJlYW1zIHdpdGggUFRTIDwgRFRTLCB0b2xlcmFuY2UgdXAgMjAwbXMgKDE4MDAwIGluIDkwa0h6IHRpbWVzY2FsZSlcbiAgICBsZXQgUFRTRFRTc2hpZnQgPSBpbnB1dFNhbXBsZXMucmVkdWNlKChwcmV2LCBjdXJyKSA9PiBNYXRoLm1heChNYXRoLm1pbihwcmV2LCBjdXJyLnB0cyAtIGN1cnIuZHRzKSwgLTE4MDAwKSwgMCk7XG4gICAgaWYgKFBUU0RUU3NoaWZ0IDwgMCkge1xuICAgICAgbG9nZ2VyLndhcm4oYFBUUyA8IERUUyBkZXRlY3RlZCBpbiB2aWRlbyBzYW1wbGVzLCBzaGlmdGluZyBEVFMgYnkgJHtNYXRoLnJvdW5kKFBUU0RUU3NoaWZ0IC8gOTApfSBtcyB0byBvdmVyY29tZSB0aGlzIGlzc3VlYCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0U2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnB1dFNhbXBsZXNbaV0uZHRzICs9IFBUU0RUU3NoaWZ0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgZmlyc3QgRFRTIGFuZCBsYXN0IERUUywgbm9ybWFsaXplIHRoZW0gYWdhaW5zdCByZWZlcmVuY2UgdmFsdWVcbiAgICBsZXQgc2FtcGxlID0gaW5wdXRTYW1wbGVzWzBdO1xuICAgIGZpcnN0RFRTID0gTWF0aC5tYXgoc2FtcGxlLmR0cywgMCk7XG4gICAgZmlyc3RQVFMgPSBNYXRoLm1heChzYW1wbGUucHRzLCAwKTtcblxuICAgIC8vIGNoZWNrIHRpbWVzdGFtcCBjb250aW51aXR5IGFjY3Jvc3MgY29uc2VjdXRpdmUgZnJhZ21lbnRzICh0aGlzIGlzIHRvIHJlbW92ZSBpbnRlci1mcmFnbWVudCBnYXAvaG9sZSlcbiAgICBsZXQgZGVsdGEgPSBNYXRoLnJvdW5kKChmaXJzdERUUyAtIG5leHRBdmNEdHMpIC8gOTApO1xuICAgIC8vIGlmIGZyYWdtZW50IGFyZSBjb250aWd1b3VzLCBkZXRlY3QgaG9sZS9vdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50c1xuICAgIGlmIChjb250aWd1b3VzKSB7XG4gICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgaWYgKGRlbHRhID4gMSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coYEFWQzoke2RlbHRhfSBtcyBob2xlIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkLGZpbGxpbmcgaXRgKTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWx0YSA8IC0xKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgQVZDOiR7KC1kZWx0YSl9IG1zIG92ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgaG9sZS9nYXAgOiBzZXQgRFRTIHRvIG5leHQgZXhwZWN0ZWQgRFRTXG4gICAgICAgIGZpcnN0RFRTID0gbmV4dEF2Y0R0cztcbiAgICAgICAgaW5wdXRTYW1wbGVzWzBdLmR0cyA9IGZpcnN0RFRTO1xuICAgICAgICAvLyBvZmZzZXQgUFRTIGFzIHdlbGwsIGVuc3VyZSB0aGF0IFBUUyBpcyBzbWFsbGVyIG9yIGVxdWFsIHRoYW4gbmV3IERUU1xuICAgICAgICBmaXJzdFBUUyA9IE1hdGgubWF4KGZpcnN0UFRTIC0gZGVsdGEsIG5leHRBdmNEdHMpO1xuICAgICAgICBpbnB1dFNhbXBsZXNbMF0ucHRzID0gZmlyc3RQVFM7XG4gICAgICAgIGxvZ2dlci5sb2coYFZpZGVvL1BUUy9EVFMgYWRqdXN0ZWQ6ICR7TWF0aC5yb3VuZChmaXJzdFBUUyAvIDkwKX0vJHtNYXRoLnJvdW5kKGZpcnN0RFRTIC8gOTApfSxkZWx0YToke2RlbHRhfSBtc2ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgbGFzdFBUUy9sYXN0RFRTXG4gICAgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2lucHV0U2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICBsYXN0RFRTID0gTWF0aC5tYXgoc2FtcGxlLmR0cywgMCk7XG4gICAgbGFzdFBUUyA9IE1hdGgubWF4KHNhbXBsZS5wdHMsIDAsIGxhc3REVFMpO1xuXG4gICAgLy8gb24gU2FmYXJpIGxldCdzIHNpZ25hbCB0aGUgc2FtZSBzYW1wbGUgZHVyYXRpb24gZm9yIGFsbCBzYW1wbGVzXG4gICAgLy8gc2FtcGxlIGR1cmF0aW9uIChhcyBleHBlY3RlZCBieSB0cnVuIE1QNCBib3hlcyksIHNob3VsZCBiZSB0aGUgZGVsdGEgYmV0d2VlbiBzYW1wbGUgRFRTXG4gICAgLy8gc2V0IHRoaXMgY29uc3RhbnQgZHVyYXRpb24gYXMgYmVpbmcgdGhlIGF2ZyBkZWx0YSBiZXR3ZWVuIGNvbnNlY3V0aXZlIERUUy5cbiAgICBpZiAoaXNTYWZhcmkpIHtcbiAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gTWF0aC5yb3VuZCgobGFzdERUUyAtIGZpcnN0RFRTKSAvIChpbnB1dFNhbXBsZXMubGVuZ3RoIC0gMSkpO1xuICAgIH1cblxuICAgIGxldCBuYk5hbHUgPSAwLCBuYWx1TGVuID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICAvLyBjb21wdXRlIHRvdGFsL2F2YyBzYW1wbGUgbGVuZ3RoIGFuZCBuYiBvZiBOQUwgdW5pdHNcbiAgICAgIGxldCBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV0sIHVuaXRzID0gc2FtcGxlLnVuaXRzLCBuYlVuaXRzID0gdW5pdHMubGVuZ3RoLCBzYW1wbGVMZW4gPSAwO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuYlVuaXRzOyBqKyspIHtcbiAgICAgICAgc2FtcGxlTGVuICs9IHVuaXRzW2pdLmRhdGEubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBuYWx1TGVuICs9IHNhbXBsZUxlbjtcbiAgICAgIG5iTmFsdSArPSBuYlVuaXRzO1xuICAgICAgc2FtcGxlLmxlbmd0aCA9IHNhbXBsZUxlbjtcblxuICAgICAgLy8gbm9ybWFsaXplIFBUUy9EVFNcbiAgICAgIGlmIChpc1NhZmFyaSkge1xuICAgICAgICAvLyBzYW1wbGUgRFRTIGlzIGNvbXB1dGVkIHVzaW5nIGEgY29uc3RhbnQgZGVjb2Rpbmcgb2Zmc2V0IChtcDRTYW1wbGVEdXJhdGlvbikgYmV0d2VlbiBzYW1wbGVzXG4gICAgICAgIHNhbXBsZS5kdHMgPSBmaXJzdERUUyArIGkgKiBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVuc3VyZSBzYW1wbGUgbW9ub3RvbmljIERUU1xuICAgICAgICBzYW1wbGUuZHRzID0gTWF0aC5tYXgoc2FtcGxlLmR0cywgZmlyc3REVFMpO1xuICAgICAgfVxuICAgICAgLy8gZW5zdXJlIHRoYXQgY29tcHV0ZWQgdmFsdWUgaXMgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHNhbXBsZSBEVFNcbiAgICAgIHNhbXBsZS5wdHMgPSBNYXRoLm1heChzYW1wbGUucHRzLCBzYW1wbGUuZHRzKTtcbiAgICB9XG5cbiAgICAvKiBjb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1wZGF0IHR5cGUpICovXG4gICAgbGV0IG1kYXRTaXplID0gbmFsdUxlbiArICg0ICogbmJOYWx1KSArIDg7XG4gICAgdHJ5IHtcbiAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheShtZGF0U2l6ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NVVhfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUiwgZmF0YWw6IGZhbHNlLCBieXRlczogbWRhdFNpemUsIHJlYXNvbjogYGZhaWwgYWxsb2NhdGluZyB2aWRlbyBtZGF0ICR7bWRhdFNpemV9YCB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgIHZpZXcuc2V0VWludDMyKDAsIG1kYXRTaXplKTtcbiAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICBsZXQgYXZjU2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldLFxuICAgICAgICBhdmNTYW1wbGVVbml0cyA9IGF2Y1NhbXBsZS51bml0cyxcbiAgICAgICAgbXA0U2FtcGxlTGVuZ3RoID0gMCxcbiAgICAgICAgY29tcG9zaXRpb25UaW1lT2Zmc2V0O1xuICAgICAgLy8gY29udmVydCBOQUxVIGJpdHN0cmVhbSB0byBNUDQgZm9ybWF0IChwcmVwZW5kIE5BTFUgd2l0aCBzaXplIGZpZWxkKVxuICAgICAgZm9yIChsZXQgaiA9IDAsIG5iVW5pdHMgPSBhdmNTYW1wbGVVbml0cy5sZW5ndGg7IGogPCBuYlVuaXRzOyBqKyspIHtcbiAgICAgICAgbGV0IHVuaXQgPSBhdmNTYW1wbGVVbml0c1tqXSxcbiAgICAgICAgICB1bml0RGF0YSA9IHVuaXQuZGF0YSxcbiAgICAgICAgICB1bml0RGF0YUxlbiA9IHVuaXQuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIHVuaXREYXRhTGVuKTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIG1kYXQuc2V0KHVuaXREYXRhLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gdW5pdERhdGFMZW47XG4gICAgICAgIG1wNFNhbXBsZUxlbmd0aCArPSA0ICsgdW5pdERhdGFMZW47XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNTYWZhcmkpIHtcbiAgICAgICAgLy8gZXhwZWN0ZWQgc2FtcGxlIGR1cmF0aW9uIGlzIHRoZSBEZWNvZGluZyBUaW1lc3RhbXAgZGlmZiBvZiBjb25zZWN1dGl2ZSBzYW1wbGVzXG4gICAgICAgIGlmIChpIDwgbmJTYW1wbGVzIC0gMSkge1xuICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gaW5wdXRTYW1wbGVzW2kgKyAxXS5kdHMgLSBhdmNTYW1wbGUuZHRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIGxhc3RGcmFtZUR1cmF0aW9uID0gYXZjU2FtcGxlLmR0cyAtIGlucHV0U2FtcGxlc1tpID4gMCA/IGkgLSAxIDogaV0uZHRzO1xuICAgICAgICAgIGlmIChjb25maWcuc3RyZXRjaFNob3J0VmlkZW9UcmFjaykge1xuICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcywgYSBzZWdtZW50J3MgYXVkaW8gdHJhY2sgZHVyYXRpb24gbWF5IGV4Y2VlZCB0aGUgdmlkZW8gdHJhY2sgZHVyYXRpb24uXG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSd2ZSBhbHJlYWR5IHJlbXV4ZWQgYXVkaW8sIGFuZCB3ZSBrbm93IGhvdyBsb25nIHRoZSBhdWRpbyB0cmFjayBpcywgd2UgbG9vayB0b1xuICAgICAgICAgICAgLy8gc2VlIGlmIHRoZSBkZWx0YSB0byB0aGUgbmV4dCBzZWdtZW50IGlzIGxvbmdlciB0aGFuIG1heEJ1ZmZlckhvbGUuXG4gICAgICAgICAgICAvLyBJZiBzbywgcGxheWJhY2sgd291bGQgcG90ZW50aWFsbHkgZ2V0IHN0dWNrLCBzbyB3ZSBhcnRpZmljaWFsbHkgaW5mbGF0ZVxuICAgICAgICAgICAgLy8gdGhlIGR1cmF0aW9uIG9mIHRoZSBsYXN0IGZyYW1lIHRvIG1pbmltaXplIGFueSBwb3RlbnRpYWwgZ2FwIGJldHdlZW4gc2VnbWVudHMuXG4gICAgICAgICAgICBsZXQgbWF4QnVmZmVySG9sZSA9IGNvbmZpZy5tYXhCdWZmZXJIb2xlLFxuICAgICAgICAgICAgICBnYXBUb2xlcmFuY2UgPSBNYXRoLmZsb29yKG1heEJ1ZmZlckhvbGUgKiB0aW1lU2NhbGUpLFxuICAgICAgICAgICAgICBkZWx0YVRvRnJhbWVFbmQgPSAoYXVkaW9UcmFja0xlbmd0aCA/IGZpcnN0UFRTICsgYXVkaW9UcmFja0xlbmd0aCAqIHRpbWVTY2FsZSA6IHRoaXMubmV4dEF1ZGlvUHRzKSAtIGF2Y1NhbXBsZS5wdHM7XG4gICAgICAgICAgICBpZiAoZGVsdGFUb0ZyYW1lRW5kID4gZ2FwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHN1YnRyYWN0IGxhc3RGcmFtZUR1cmF0aW9uIGZyb20gZGVsdGFUb0ZyYW1lRW5kIHRvIHRyeSB0byBwcmV2ZW50IGFueSB2aWRlb1xuICAgICAgICAgICAgICAvLyBmcmFtZSBvdmVybGFwLiBtYXhCdWZmZXJIb2xlIHNob3VsZCBiZSA+PiBsYXN0RnJhbWVEdXJhdGlvbiBhbnl3YXkuXG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gZGVsdGFUb0ZyYW1lRW5kIC0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICAgIGlmIChtcDRTYW1wbGVEdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgSXQgaXMgYXBwcm94aW1hdGVseSAke2RlbHRhVG9GcmFtZUVuZCAvIDkwfSBtcyB0byB0aGUgbmV4dCBzZWdtZW50OyB1c2luZyBkdXJhdGlvbiAke21wNFNhbXBsZUR1cmF0aW9uIC8gOTB9IG1zIGZvciB0aGUgbGFzdCB2aWRlbyBmcmFtZS5gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgucm91bmQoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gTWF0aC5tYXgoMCwgbXA0U2FtcGxlRHVyYXRpb24gKiBNYXRoLnJvdW5kKChhdmNTYW1wbGUucHRzIC0gYXZjU2FtcGxlLmR0cykgLyBtcDRTYW1wbGVEdXJhdGlvbikpO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25zb2xlLmxvZygnUFRTL0RUUy9pbml0RFRTL25vcm1QVFMvbm9ybURUUy9yZWxhdGl2ZSBQVFMgOiAke2F2Y1NhbXBsZS5wdHN9LyR7YXZjU2FtcGxlLmR0c30vJHtpbml0RFRTfS8ke3B0c25vcm19LyR7ZHRzbm9ybX0vJHsoYXZjU2FtcGxlLnB0cy80Mjk0OTY3Mjk2KS50b0ZpeGVkKDMpfScpO1xuICAgICAgLy8gY29uc29sZS5sb2coYGF2Y1NhbXBsZS5kdHM6ICR7YXZjU2FtcGxlLmR0cyAvIDkwfSwgYXZjU2FtcGxlLnB0czogJHthdmNTYW1wbGUucHRzIC8gOTB9LCBtcDRTYW1wbGVEdXJhdGlvbjogJHttcDRTYW1wbGVEdXJhdGlvbiAvIDkwfWAsIGF2Y1NhbXBsZSlcbiAgICAgIG91dHB1dFNhbXBsZXMucHVzaCh7XG4gICAgICAgIHNpemU6IG1wNFNhbXBsZUxlbmd0aCxcbiAgICAgICAgLy8gY29uc3RhbnQgZHVyYXRpb25cbiAgICAgICAgZHVyYXRpb246IG1wNFNhbXBsZUR1cmF0aW9uLFxuICAgICAgICBjdHM6IGNvbXBvc2l0aW9uVGltZU9mZnNldCxcbiAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICAgICAgZGVncmFkUHJpbzogMCxcbiAgICAgICAgICBkZXBlbmRzT246IGF2Y1NhbXBsZS5rZXkgPyAyIDogMSxcbiAgICAgICAgICBpc05vblN5bmM6IGF2Y1NhbXBsZS5rZXkgPyAwIDogMVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gbmV4dCBBVkMgc2FtcGxlIERUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgRFRTICsgbGFzdCBzYW1wbGUgZHVyYXRpb24gKGluIFBFUyB0aW1lc2NhbGUpXG4gICAgdGhpcy5uZXh0QXZjRHRzID0gbGFzdERUUyArIG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgIGxldCBkcm9wcGVkID0gdHJhY2suZHJvcHBlZDtcbiAgICB0cmFjay5sZW4gPSAwO1xuICAgIHRyYWNrLm5iTmFsdSA9IDA7XG4gICAgdHJhY2suZHJvcHBlZCA9IDA7XG4gICAgaWYgKG91dHB1dFNhbXBsZXMubGVuZ3RoICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjaHJvbWUnKSA+IC0xKSB7XG4gICAgICBsZXQgZmxhZ3MgPSBvdXRwdXRTYW1wbGVzWzBdLmZsYWdzO1xuICAgICAgLy8gY2hyb21lIHdvcmthcm91bmQsIG1hcmsgZmlyc3Qgc2FtcGxlIGFzIGJlaW5nIGEgUmFuZG9tIEFjY2VzcyBQb2ludCB0byBhdm9pZCBzb3VyY2VidWZmZXIgYXBwZW5kIGlzc3VlXG4gICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5NDEyXG4gICAgICBmbGFncy5kZXBlbmRzT24gPSAyO1xuICAgICAgZmxhZ3MuaXNOb25TeW5jID0gMDtcbiAgICB9XG4gICAgdHJhY2suc2FtcGxlcyA9IG91dHB1dFNhbXBsZXM7XG4gICAgbW9vZiA9IE1QNC5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0RFRTLCB0cmFjayk7XG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuXG4gICAgbGV0IGRhdGEgPSB7XG4gICAgICBkYXRhMTogbW9vZixcbiAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgc3RhcnRQVFM6IGZpcnN0UFRTIC8gdGltZVNjYWxlLFxuICAgICAgZW5kUFRTOiAobGFzdFBUUyArIG1wNFNhbXBsZUR1cmF0aW9uKSAvIHRpbWVTY2FsZSxcbiAgICAgIHN0YXJ0RFRTOiBmaXJzdERUUyAvIHRpbWVTY2FsZSxcbiAgICAgIGVuZERUUzogdGhpcy5uZXh0QXZjRHRzIC8gdGltZVNjYWxlLFxuICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgIGhhc0F1ZGlvOiBmYWxzZSxcbiAgICAgIGhhc1ZpZGVvOiB0cnVlLFxuICAgICAgbmI6IG91dHB1dFNhbXBsZXMubGVuZ3RoLFxuICAgICAgZHJvcHBlZDogZHJvcHBlZFxuICAgIH07XG4gICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCBkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHJlbXV4QXVkaW8gKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IG1wNHRpbWVTY2FsZSA9IHRyYWNrLnRpbWVzY2FsZTtcbiAgICBjb25zdCBzY2FsZUZhY3RvciA9IGlucHV0VGltZVNjYWxlIC8gbXA0dGltZVNjYWxlO1xuICAgIGNvbnN0IG1wNFNhbXBsZUR1cmF0aW9uID0gdHJhY2suaXNBQUMgPyAxMDI0IDogMTE1MjtcbiAgICBjb25zdCBpbnB1dFNhbXBsZUR1cmF0aW9uID0gbXA0U2FtcGxlRHVyYXRpb24gKiBzY2FsZUZhY3RvcjtcbiAgICBjb25zdCBwdHNOb3JtYWxpemUgPSB0aGlzLl9QVFNOb3JtYWxpemU7XG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgY29uc3QgcmF3TVBFRyA9ICF0cmFjay5pc0FBQyAmJiB0aGlzLnR5cGVTdXBwb3J0ZWQubXBlZztcblxuICAgIGxldCBvZmZzZXQsXG4gICAgICBtcDRTYW1wbGUsXG4gICAgICBmaWxsRnJhbWUsXG4gICAgICBtZGF0LCBtb29mLFxuICAgICAgZmlyc3RQVFMsIGxhc3RQVFMsXG4gICAgICBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzLFxuICAgICAgb3V0cHV0U2FtcGxlcyA9IFtdLFxuICAgICAgbmV4dEF1ZGlvUHRzID0gdGhpcy5uZXh0QXVkaW9QdHM7XG5cbiAgICAvLyBmb3IgYXVkaW8gc2FtcGxlcywgYWxzbyBjb25zaWRlciBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXMgYmVpbmcgY29udGlndW91cyAoZXZlbiBpZiBhIGxldmVsIHN3aXRjaCBvY2N1cnMpLFxuICAgIC8vIGZvciBzYWtlIG9mIGNsYXJpdHk6XG4gICAgLy8gY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFyZSBmcmFncyB3aXRoXG4gICAgLy8gIC0gbGVzcyB0aGFuIDEwMG1zIGdhcHMgYmV0d2VlbiBuZXcgdGltZSBvZmZzZXQgKGlmIGFjY3VyYXRlKSBhbmQgbmV4dCBleHBlY3RlZCBQVFMgT1JcbiAgICAvLyAgLSBsZXNzIHRoYW4gMjAgYXVkaW8gZnJhbWVzIGRpc3RhbmNlXG4gICAgLy8gY29udGlndW91cyBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBmcm9tIHNhbWUgcXVhbGl0eSBsZXZlbCAoc2FtZSBsZXZlbCwgbmV3IFNOID0gb2xkIFNOICsgMSlcbiAgICAvLyB0aGlzIGhlbHBzIGVuc3VyaW5nIGF1ZGlvIGNvbnRpbnVpdHlcbiAgICAvLyBhbmQgdGhpcyBhbHNvIGF2b2lkcyBhdWRpbyBnbGl0Y2hlcy9jdXQgd2hlbiBzd2l0Y2hpbmcgcXVhbGl0eSwgb3IgcmVwb3J0aW5nIHdyb25nIGR1cmF0aW9uIG9uIGZpcnN0IGF1ZGlvIGZyYW1lXG4gICAgY29udGlndW91cyB8PSAoaW5wdXRTYW1wbGVzLmxlbmd0aCAmJiBuZXh0QXVkaW9QdHMgJiZcbiAgICAgICAgICAgICAgICAgICAoKGFjY3VyYXRlVGltZU9mZnNldCAmJiBNYXRoLmFicyh0aW1lT2Zmc2V0IC0gbmV4dEF1ZGlvUHRzIC8gaW5wdXRUaW1lU2NhbGUpIDwgMC4xKSB8fFxuICAgICAgICAgICAgICAgICAgICBNYXRoLmFicygoaW5wdXRTYW1wbGVzWzBdLnB0cyAtIG5leHRBdWRpb1B0cyAtIGluaXRQVFMpKSA8IDIwICogaW5wdXRTYW1wbGVEdXJhdGlvbilcbiAgICApO1xuXG4gICAgLy8gY29tcHV0ZSBub3JtYWxpemVkIFBUU1xuICAgIGlucHV0U2FtcGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGUuZHRzID0gcHRzTm9ybWFsaXplKHNhbXBsZS5wdHMgLSBpbml0UFRTLCB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGUpO1xuICAgIH0pO1xuXG4gICAgLy8gZmlsdGVyIG91dCBzYW1wbGUgd2l0aCBuZWdhdGl2ZSBQVFMgdGhhdCBhcmUgbm90IHBsYXlhYmxlIGFueXdheVxuICAgIC8vIGlmIHdlIGRvbid0IHJlbW92ZSB0aGVzZSBuZWdhdGl2ZSBzYW1wbGVzLCB0aGV5IHdpbGwgc2hpZnQgYWxsIGF1ZGlvIHNhbXBsZXMgZm9yd2FyZC5cbiAgICAvLyBsZWFkaW5nIHRvIGF1ZGlvIG92ZXJsYXAgYmV0d2VlbiBjdXJyZW50IC8gbmV4dCBmcmFnbWVudFxuICAgIGlucHV0U2FtcGxlcyA9IGlucHV0U2FtcGxlcy5maWx0ZXIoZnVuY3Rpb24gKHNhbXBsZSkge1xuICAgICAgcmV0dXJuIHNhbXBsZS5wdHMgPj0gMDtcbiAgICB9KTtcblxuICAgIC8vIGluIGNhc2UgYWxsIHNhbXBsZXMgaGF2ZSBuZWdhdGl2ZSBQVFMsIGFuZCBoYXZlIGJlZW4gZmlsdGVyZWQgb3V0LCByZXR1cm4gbm93XG4gICAgaWYgKGlucHV0U2FtcGxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNvbnRpZ3VvdXMpIHtcbiAgICAgIGlmICghYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICAgIC8vIGlmIGZyYWcgYXJlIG1vdCBjb250aWd1b3VzIGFuZCBpZiB3ZSBjYW50IHRydXN0IHRpbWUgb2Zmc2V0LCBsZXQncyB1c2UgZmlyc3Qgc2FtcGxlIFBUUyBhcyBuZXh0IGF1ZGlvIFBUU1xuICAgICAgICBuZXh0QXVkaW9QdHMgPSBpbnB1dFNhbXBsZXNbMF0ucHRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgdGltZU9mZnNldCBpcyBhY2N1cmF0ZSwgbGV0J3MgdXNlIGl0IGFzIHByZWRpY3RlZCBuZXh0IGF1ZGlvIFBUU1xuICAgICAgICBuZXh0QXVkaW9QdHMgPSB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGF1ZGlvIHRyYWNrIGlzIG1pc3Npbmcgc2FtcGxlcywgdGhlIGZyYW1lcyBzZWVtIHRvIGdldCBcImxlZnQtc2hpZnRlZFwiIHdpdGhpbiB0aGVcbiAgICAvLyByZXN1bHRpbmcgbXA0IHNlZ21lbnQsIGNhdXNpbmcgc3luYyBpc3N1ZXMgYW5kIGxlYXZpbmcgZ2FwcyBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBzZWdtZW50LlxuICAgIC8vIEluIGFuIGVmZm9ydCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmcsIHdlIGluamVjdCBmcmFtZXMgaGVyZSB3aGVyZSB0aGVyZSBhcmUgZ2Fwcy5cbiAgICAvLyBXaGVuIHBvc3NpYmxlLCB3ZSBpbmplY3QgYSBzaWxlbnQgZnJhbWU7IHdoZW4gdGhhdCdzIG5vdCBwb3NzaWJsZSwgd2UgZHVwbGljYXRlIHRoZSBsYXN0XG4gICAgLy8gZnJhbWUuXG5cbiAgICBpZiAodHJhY2suaXNBQUMpIHtcbiAgICAgIGNvbnN0IG1heEF1ZGlvRnJhbWVzRHJpZnQgPSB0aGlzLmNvbmZpZy5tYXhBdWRpb0ZyYW1lc0RyaWZ0O1xuICAgICAgZm9yIChsZXQgaSA9IDAsIG5leHRQdHMgPSBuZXh0QXVkaW9QdHM7IGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOykge1xuICAgICAgICAvLyBGaXJzdCwgbGV0J3Mgc2VlIGhvdyBmYXIgb2ZmIHRoaXMgZnJhbWUgaXMgZnJvbSB3aGVyZSB3ZSBleHBlY3QgaXQgdG8gYmVcbiAgICAgICAgdmFyIHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXSwgZGVsdGE7XG4gICAgICAgIGxldCBwdHMgPSBzYW1wbGUucHRzO1xuICAgICAgICBkZWx0YSA9IHB0cyAtIG5leHRQdHM7XG5cbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBNYXRoLmFicygxMDAwICogZGVsdGEgLyBpbnB1dFRpbWVTY2FsZSk7XG5cbiAgICAgICAgLy8gSWYgd2UncmUgb3ZlcmxhcHBpbmcgYnkgbW9yZSB0aGFuIGEgZHVyYXRpb24sIGRyb3AgdGhpcyBzYW1wbGVcbiAgICAgICAgaWYgKGRlbHRhIDw9IC1tYXhBdWRpb0ZyYW1lc0RyaWZ0ICogaW5wdXRTYW1wbGVEdXJhdGlvbikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBEcm9wcGluZyAxIGF1ZGlvIGZyYW1lIEAgJHsobmV4dFB0cyAvIGlucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpfXMgZHVlIHRvICR7TWF0aC5yb3VuZChkdXJhdGlvbil9IG1zIG92ZXJsYXAuYCk7XG4gICAgICAgICAgaW5wdXRTYW1wbGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB0cmFjay5sZW4gLT0gc2FtcGxlLnVuaXQubGVuZ3RoO1xuICAgICAgICAgIC8vIERvbid0IHRvdWNoIG5leHRQdHNOb3JtIG9yIGlcbiAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJyYWNlLXN0eWxlXG5cbiAgICAgICAgLy8gSW5zZXJ0IG1pc3NpbmcgZnJhbWVzIGlmOlxuICAgICAgICAvLyAxOiBXZSdyZSBtb3JlIHRoYW4gbWF4QXVkaW9GcmFtZXNEcmlmdCBmcmFtZSBhd2F5XG4gICAgICAgIC8vIDI6IE5vdCBtb3JlIHRoYW4gTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiBhd2F5XG4gICAgICAgIC8vIDM6IGN1cnJlbnRUaW1lIChha2EgbmV4dFB0c05vcm0pIGlzIG5vdCAwXG4gICAgICAgIGVsc2UgaWYgKGRlbHRhID49IG1heEF1ZGlvRnJhbWVzRHJpZnQgKiBpbnB1dFNhbXBsZUR1cmF0aW9uICYmIGR1cmF0aW9uIDwgTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiAmJiBuZXh0UHRzKSB7XG4gICAgICAgICAgbGV0IG1pc3NpbmcgPSBNYXRoLnJvdW5kKGRlbHRhIC8gaW5wdXRTYW1wbGVEdXJhdGlvbik7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYEluamVjdGluZyAke21pc3Npbmd9IGF1ZGlvIGZyYW1lIEAgJHsobmV4dFB0cyAvIGlucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpfXMgZHVlIHRvICR7TWF0aC5yb3VuZCgxMDAwICogZGVsdGEgLyBpbnB1dFRpbWVTY2FsZSl9IG1zIGdhcC5gKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1pc3Npbmc7IGorKykge1xuICAgICAgICAgICAgbGV0IG5ld1N0YW1wID0gTWF0aC5tYXgobmV4dFB0cywgMCk7XG4gICAgICAgICAgICBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBnZXQgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYzsgZHVwbGljYXRpbmcgbGFzdCBmcmFtZSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBzYW1wbGUudW5pdC5zdWJhcnJheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRTYW1wbGVzLnNwbGljZShpLCAwLCB7IHVuaXQ6IGZpbGxGcmFtZSwgcHRzOiBuZXdTdGFtcCwgZHRzOiBuZXdTdGFtcCB9KTtcbiAgICAgICAgICAgIHRyYWNrLmxlbiArPSBmaWxsRnJhbWUubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFkanVzdCBzYW1wbGUgdG8gbmV4dCBleHBlY3RlZCBwdHNcbiAgICAgICAgICBzYW1wbGUucHRzID0gc2FtcGxlLmR0cyA9IG5leHRQdHM7XG4gICAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBqdXN0IGFkanVzdCBwdHNcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGEpID4gKDAuMSAqIGlucHV0U2FtcGxlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKGBJbnZhbGlkIGZyYW1lIGRlbHRhICR7TWF0aC5yb3VuZChkZWx0YSArIGlucHV0U2FtcGxlRHVyYXRpb24pfSBhdCBQVFMgJHtNYXRoLnJvdW5kKHB0cyAvIDkwKX0gKHNob3VsZCBiZSAke01hdGgucm91bmQoaW5wdXRTYW1wbGVEdXJhdGlvbil9KS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2FtcGxlLnB0cyA9IHNhbXBsZS5kdHMgPSBuZXh0UHRzO1xuICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBqID0gMCwgbmJTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmxlbmd0aDsgaiA8IG5iU2FtcGxlczsgaisrKSB7XG4gICAgICBsZXQgYXVkaW9TYW1wbGUgPSBpbnB1dFNhbXBsZXNbal07XG4gICAgICBsZXQgdW5pdCA9IGF1ZGlvU2FtcGxlLnVuaXQ7XG4gICAgICBsZXQgcHRzID0gYXVkaW9TYW1wbGUucHRzO1xuICAgICAgLy8gbG9nZ2VyLmxvZyhgQXVkaW8vUFRTOiR7TWF0aC5yb3VuZChwdHMvOTApfWApO1xuICAgICAgLy8gaWYgbm90IGZpcnN0IHNhbXBsZVxuICAgICAgaWYgKGxhc3RQVFMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtcDRTYW1wbGUuZHVyYXRpb24gPSBNYXRoLnJvdW5kKChwdHMgLSBsYXN0UFRTKSAvIHNjYWxlRmFjdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBkZWx0YSA9IE1hdGgucm91bmQoMTAwMCAqIChwdHMgLSBuZXh0QXVkaW9QdHMpIC8gaW5wdXRUaW1lU2NhbGUpLFxuICAgICAgICAgIG51bU1pc3NpbmdGcmFtZXMgPSAwO1xuICAgICAgICAvLyBpZiBmcmFnbWVudCBhcmUgY29udGlndW91cywgZGV0ZWN0IGhvbGUvb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHNcbiAgICAgICAgLy8gY29udGlndW91cyBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBmcm9tIHNhbWUgcXVhbGl0eSBsZXZlbCAoc2FtZSBsZXZlbCwgbmV3IFNOID0gb2xkIFNOICsgMSlcbiAgICAgICAgaWYgKGNvbnRpZ3VvdXMgJiYgdHJhY2suaXNBQUMpIHtcbiAgICAgICAgICAvLyBsb2cgZGVsdGFcbiAgICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDAgJiYgZGVsdGEgPCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OKSB7XG4gICAgICAgICAgICAgIG51bU1pc3NpbmdGcmFtZXMgPSBNYXRoLnJvdW5kKChwdHMgLSBuZXh0QXVkaW9QdHMpIC8gaW5wdXRTYW1wbGVEdXJhdGlvbik7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYCR7ZGVsdGF9IG1zIGhvbGUgYmV0d2VlbiBBQUMgc2FtcGxlcyBkZXRlY3RlZCxmaWxsaW5nIGl0YCk7XG4gICAgICAgICAgICAgIGlmIChudW1NaXNzaW5nRnJhbWVzID4gMCkge1xuICAgICAgICAgICAgICAgIGZpbGxGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLCB0cmFjay5jaGFubmVsQ291bnQpO1xuICAgICAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICBmaWxsRnJhbWUgPSB1bml0LnN1YmFycmF5KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJhY2subGVuICs9IG51bU1pc3NpbmdGcmFtZXMgKiBmaWxsRnJhbWUubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgZnJhbWUgb3ZlcmxhcCwgb3ZlcmxhcHBpbmcgZm9yIG1vcmUgdGhhbiBoYWxmIGEgZnJhbWUgZHVyYWlvblxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWx0YSA8IC0xMikge1xuICAgICAgICAgICAgICAvLyBkcm9wIG92ZXJsYXBwaW5nIGF1ZGlvIGZyYW1lcy4uLiBicm93c2VyIHdpbGwgZGVhbCB3aXRoIGl0XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYGRyb3Agb3ZlcmxhcHBpbmcgQUFDIHNhbXBsZSwgZXhwZWN0ZWQvcGFyc2VkL2RlbHRhOiR7KG5leHRBdWRpb1B0cyAvIGlucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpfXMvJHsocHRzIC8gaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoMyl9cy8keygtZGVsdGEpfW1zYCk7XG4gICAgICAgICAgICAgIHRyYWNrLmxlbiAtPSB1bml0LmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IFBUUy9EVFMgdG8gZXhwZWN0ZWQgUFRTL0RUU1xuICAgICAgICAgICAgcHRzID0gbmV4dEF1ZGlvUHRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZW1lbWJlciBmaXJzdCBQVFMgb2Ygb3VyIGF1ZGlvU2FtcGxlc1xuICAgICAgICBmaXJzdFBUUyA9IHB0cztcbiAgICAgICAgaWYgKHRyYWNrLmxlbiA+IDApIHtcbiAgICAgICAgICAvKiBjb25jYXRlbmF0ZSB0aGUgYXVkaW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAgICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1kYXQgdHlwZSkgKi9cbiAgICAgICAgICBsZXQgbWRhdFNpemUgPSByYXdNUEVHID8gdHJhY2subGVuIDogdHJhY2subGVuICsgODtcbiAgICAgICAgICBvZmZzZXQgPSByYXdNUEVHID8gMCA6IDg7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheShtZGF0U2l6ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NVVhfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUiwgZmF0YWw6IGZhbHNlLCBieXRlczogbWRhdFNpemUsIHJlYXNvbjogYGZhaWwgYWxsb2NhdGluZyBhdWRpbyBtZGF0ICR7bWRhdFNpemV9YCB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyYXdNUEVHKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDMyKDAsIG1kYXRTaXplKTtcbiAgICAgICAgICAgIG1kYXQuc2V0KE1QNC50eXBlcy5tZGF0LCA0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gYXVkaW8gc2FtcGxlc1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU1pc3NpbmdGcmFtZXM7IGkrKykge1xuICAgICAgICAgIGZpbGxGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLCB0cmFjay5jaGFubmVsQ291bnQpO1xuICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdVbmFibGUgdG8gZ2V0IHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWM7IGR1cGxpY2F0aW5nIHRoaXMgZnJhbWUgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIGZpbGxGcmFtZSA9IHVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWRhdC5zZXQoZmlsbEZyYW1lLCBvZmZzZXQpO1xuICAgICAgICAgIG9mZnNldCArPSBmaWxsRnJhbWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBtcDRTYW1wbGUgPSB7XG4gICAgICAgICAgICBzaXplOiBmaWxsRnJhbWUuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgIGN0czogMCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAxMDI0LFxuICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgICAgICAgICBpc0RlcGVuZGVkT246IDAsXG4gICAgICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICAgICAgICAgIGRlZ3JhZFByaW86IDAsXG4gICAgICAgICAgICAgIGRlcGVuZHNPbjogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG1wNFNhbXBsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1kYXQuc2V0KHVuaXQsIG9mZnNldCk7XG4gICAgICBsZXQgdW5pdExlbiA9IHVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgIG9mZnNldCArPSB1bml0TGVuO1xuICAgICAgLy8gY29uc29sZS5sb2coJ1BUUy9EVFMvaW5pdERUUy9ub3JtUFRTL25vcm1EVFMvcmVsYXRpdmUgUFRTIDogJHthdWRpb1NhbXBsZS5wdHN9LyR7YXVkaW9TYW1wbGUuZHRzfS8ke2luaXREVFN9LyR7cHRzbm9ybX0vJHtkdHNub3JtfS8keyhhdWRpb1NhbXBsZS5wdHMvNDI5NDk2NzI5NikudG9GaXhlZCgzKX0nKTtcbiAgICAgIG1wNFNhbXBsZSA9IHtcbiAgICAgICAgc2l6ZTogdW5pdExlbixcbiAgICAgICAgY3RzOiAwLFxuICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICAgICAgZGVncmFkUHJpbzogMCxcbiAgICAgICAgICBkZXBlbmRzT246IDFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIG91dHB1dFNhbXBsZXMucHVzaChtcDRTYW1wbGUpO1xuICAgICAgbGFzdFBUUyA9IHB0cztcbiAgICB9XG4gICAgbGV0IGxhc3RTYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgbGV0IG5iU2FtcGxlcyA9IG91dHB1dFNhbXBsZXMubGVuZ3RoO1xuICAgIC8vIHNldCBsYXN0IHNhbXBsZSBkdXJhdGlvbiBhcyBiZWluZyBpZGVudGljYWwgdG8gcHJldmlvdXMgc2FtcGxlXG4gICAgaWYgKG5iU2FtcGxlcyA+PSAyKSB7XG4gICAgICBsYXN0U2FtcGxlRHVyYXRpb24gPSBvdXRwdXRTYW1wbGVzW25iU2FtcGxlcyAtIDJdLmR1cmF0aW9uO1xuICAgICAgbXA0U2FtcGxlLmR1cmF0aW9uID0gbGFzdFNhbXBsZUR1cmF0aW9uO1xuICAgIH1cbiAgICBpZiAobmJTYW1wbGVzKSB7XG4gICAgICAvLyBuZXh0IGF1ZGlvIHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGR1cmF0aW9uXG4gICAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG5leHRBdWRpb1B0cyA9IGxhc3RQVFMgKyBzY2FsZUZhY3RvciAqIGxhc3RTYW1wbGVEdXJhdGlvbjtcbiAgICAgIC8vIGxvZ2dlci5sb2coJ0F1ZGlvL1BUUy9QVFNlbmQ6JyArIGF1ZGlvU2FtcGxlLnB0cy50b0ZpeGVkKDApICsgJy8nICsgdGhpcy5uZXh0QWFjRHRzLnRvRml4ZWQoMCkpO1xuICAgICAgdHJhY2subGVuID0gMDtcbiAgICAgIHRyYWNrLnNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzO1xuICAgICAgaWYgKHJhd01QRUcpIHtcbiAgICAgICAgbW9vZiA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb29mID0gTVA0Lm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3RQVFMgLyBzY2FsZUZhY3RvciwgdHJhY2spO1xuICAgICAgfVxuXG4gICAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgICBjb25zdCBzdGFydCA9IGZpcnN0UFRTIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgICBjb25zdCBlbmQgPSBuZXh0QXVkaW9QdHMgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICAgIGNvbnN0IGF1ZGlvRGF0YSA9IHtcbiAgICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgICBzdGFydFBUUzogc3RhcnQsXG4gICAgICAgIGVuZFBUUzogZW5kLFxuICAgICAgICBzdGFydERUUzogc3RhcnQsXG4gICAgICAgIGVuZERUUzogZW5kLFxuICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICBoYXNBdWRpbzogdHJ1ZSxcbiAgICAgICAgaGFzVmlkZW86IGZhbHNlLFxuICAgICAgICBuYjogbmJTYW1wbGVzXG4gICAgICB9O1xuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCBhdWRpb0RhdGEpO1xuICAgICAgcmV0dXJuIGF1ZGlvRGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZW11eEVtcHR5QXVkaW8gKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCB2aWRlb0RhdGEpIHtcbiAgICBsZXQgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZSxcbiAgICAgIG1wNHRpbWVTY2FsZSA9IHRyYWNrLnNhbXBsZXJhdGUgPyB0cmFjay5zYW1wbGVyYXRlIDogaW5wdXRUaW1lU2NhbGUsXG4gICAgICBzY2FsZUZhY3RvciA9IGlucHV0VGltZVNjYWxlIC8gbXA0dGltZVNjYWxlLFxuICAgICAgbmV4dEF1ZGlvUHRzID0gdGhpcy5uZXh0QXVkaW9QdHMsXG5cbiAgICAgIC8vIHN5bmMgd2l0aCB2aWRlbydzIHRpbWVzdGFtcFxuICAgICAgc3RhcnREVFMgPSAobmV4dEF1ZGlvUHRzICE9PSB1bmRlZmluZWQgPyBuZXh0QXVkaW9QdHMgOiB2aWRlb0RhdGEuc3RhcnREVFMgKiBpbnB1dFRpbWVTY2FsZSkgKyB0aGlzLl9pbml0RFRTLFxuICAgICAgZW5kRFRTID0gdmlkZW9EYXRhLmVuZERUUyAqIGlucHV0VGltZVNjYWxlICsgdGhpcy5faW5pdERUUyxcbiAgICAgIC8vIG9uZSBzYW1wbGUncyBkdXJhdGlvbiB2YWx1ZVxuICAgICAgc2FtcGxlRHVyYXRpb24gPSAxMDI0LFxuICAgICAgZnJhbWVEdXJhdGlvbiA9IHNjYWxlRmFjdG9yICogc2FtcGxlRHVyYXRpb24sXG5cbiAgICAgIC8vIHNhbXBsZXMgY291bnQgb2YgdGhpcyBzZWdtZW50J3MgZHVyYXRpb25cbiAgICAgIG5iU2FtcGxlcyA9IE1hdGguY2VpbCgoZW5kRFRTIC0gc3RhcnREVFMpIC8gZnJhbWVEdXJhdGlvbiksXG5cbiAgICAgIC8vIHNpbGVudCBmcmFtZVxuICAgICAgc2lsZW50RnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcblxuICAgIGxvZ2dlci53YXJuKCdyZW11eCBlbXB0eSBBdWRpbycpO1xuICAgIC8vIENhbid0IHJlbXV4IGlmIHdlIGNhbid0IGdlbmVyYXRlIGEgc2lsZW50IGZyYW1lLi4uXG4gICAgaWYgKCFzaWxlbnRGcmFtZSkge1xuICAgICAgbG9nZ2VyLnRyYWNlKCdVbmFibGUgdG8gcmVtdXhFbXB0eUF1ZGlvIHNpbmNlIHdlIHdlcmUgdW5hYmxlIHRvIGdldCBhIHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWMhJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHNhbXBsZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICBsZXQgc3RhbXAgPSBzdGFydERUUyArIGkgKiBmcmFtZUR1cmF0aW9uO1xuICAgICAgc2FtcGxlcy5wdXNoKHsgdW5pdDogc2lsZW50RnJhbWUsIHB0czogc3RhbXAsIGR0czogc3RhbXAgfSk7XG4gICAgICB0cmFjay5sZW4gKz0gc2lsZW50RnJhbWUubGVuZ3RoO1xuICAgIH1cbiAgICB0cmFjay5zYW1wbGVzID0gc2FtcGxlcztcblxuICAgIHRoaXMucmVtdXhBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cyk7XG4gIH1cblxuICByZW11eElEMyAodHJhY2spIHtcbiAgICBsZXQgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGgsIHNhbXBsZTtcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIGNvbnN0IGluaXREVFMgPSB0aGlzLl9pbml0RFRTO1xuICAgIC8vIGNvbnN1bWUgc2FtcGxlc1xuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XG4gICAgICAgIC8vIHNldHRpbmcgaWQzIHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAgICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuICAgICAgICBzYW1wbGUucHRzID0gKChzYW1wbGUucHRzIC0gaW5pdFBUUykgLyBpbnB1dFRpbWVTY2FsZSk7XG4gICAgICAgIHNhbXBsZS5kdHMgPSAoKHNhbXBsZS5kdHMgLSBpbml0RFRTKSAvIGlucHV0VGltZVNjYWxlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIHtcbiAgICAgICAgc2FtcGxlczogdHJhY2suc2FtcGxlc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICB9XG5cbiAgcmVtdXhUZXh0ICh0cmFjaykge1xuICAgIHRyYWNrLnNhbXBsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIChhLnB0cyAtIGIucHRzKTtcbiAgICB9KTtcblxuICAgIGxldCBsZW5ndGggPSB0cmFjay5zYW1wbGVzLmxlbmd0aCwgc2FtcGxlO1xuICAgIGNvbnN0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgLy8gY29uc3VtZSBzYW1wbGVzXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcbiAgICAgICAgLy8gc2V0dGluZyB0ZXh0IHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAgICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuICAgICAgICBzYW1wbGUucHRzID0gKChzYW1wbGUucHRzIC0gaW5pdFBUUykgLyBpbnB1dFRpbWVTY2FsZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCB7XG4gICAgICAgIHNhbXBsZXM6IHRyYWNrLnNhbXBsZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgfVxuXG4gIF9QVFNOb3JtYWxpemUgKHZhbHVlLCByZWZlcmVuY2UpIHtcbiAgICBsZXQgb2Zmc2V0O1xuICAgIGlmIChyZWZlcmVuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChyZWZlcmVuY2UgPCB2YWx1ZSkge1xuICAgICAgLy8gLSAyXjMzXG4gICAgICBvZmZzZXQgPSAtODU4OTkzNDU5MjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gKyAyXjMzXG4gICAgICBvZmZzZXQgPSA4NTg5OTM0NTkyO1xuICAgIH1cbiAgICAvKiBQVFMgaXMgMzNiaXQgKGZyb20gMCB0byAyXjMzIC0xKVxuICAgICAgaWYgZGlmZiBiZXR3ZWVuIHZhbHVlIGFuZCByZWZlcmVuY2UgaXMgYmlnZ2VyIHRoYW4gaGFsZiBvZiB0aGUgYW1wbGl0dWRlICgyXjMyKSB0aGVuIGl0IG1lYW5zIHRoYXRcbiAgICAgIFBUUyBsb29waW5nIG9jY3VyZWQuIGZpbGwgdGhlIGdhcCAqL1xuICAgIHdoaWxlIChNYXRoLmFicyh2YWx1ZSAtIHJlZmVyZW5jZSkgPiA0Mjk0OTY3Mjk2KSB7XG4gICAgICB2YWx1ZSArPSBvZmZzZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1QNFJlbXV4ZXI7XG4iLCIvKipcbiAqIHBhc3N0aHJvdWdoIHJlbXV4ZXJcbiovXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcblxuY2xhc3MgUGFzc1Rocm91Z2hSZW11eGVyIHtcbiAgY29uc3RydWN0b3IgKG9ic2VydmVyKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gIH1cblxuICByZXNldFRpbWVTdGFtcCAoKSB7XG4gIH1cblxuICByZXNldEluaXRTZWdtZW50ICgpIHtcbiAgfVxuXG4gIHJlbXV4IChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHJhd0RhdGEpIHtcbiAgICBsZXQgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgIGxldCBzdHJlYW1UeXBlID0gJyc7XG4gICAgaWYgKGF1ZGlvVHJhY2spIHtcbiAgICAgIHN0cmVhbVR5cGUgKz0gJ2F1ZGlvJztcbiAgICB9XG5cbiAgICBpZiAodmlkZW9UcmFjaykge1xuICAgICAgc3RyZWFtVHlwZSArPSAndmlkZW8nO1xuICAgIH1cblxuICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIHtcbiAgICAgIGRhdGExOiByYXdEYXRhLFxuICAgICAgc3RhcnRQVFM6IHRpbWVPZmZzZXQsXG4gICAgICBzdGFydERUUzogdGltZU9mZnNldCxcbiAgICAgIHR5cGU6IHN0cmVhbVR5cGUsXG4gICAgICBoYXNBdWRpbzogISFhdWRpb1RyYWNrLFxuICAgICAgaGFzVmlkZW86ICEhdmlkZW9UcmFjayxcbiAgICAgIG5iOiAxLFxuICAgICAgZHJvcHBlZDogMFxuICAgIH0pO1xuICAgIC8vIG5vdGlmeSBlbmQgb2YgcGFyc2luZ1xuICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTRUQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhc3NUaHJvdWdoUmVtdXhlcjtcbiIsImltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi9ldmVudC1oYW5kbGVyJztcblxuLyoqXG4gKiBTdWItY2xhc3Mgc3BlY2lhbGl6YXRpb24gb2YgRXZlbnRIYW5kbGVyIGJhc2UgY2xhc3MuXG4gKlxuICogVGFza0xvb3AgYWxsb3dzIHRvIHNjaGVkdWxlIGEgdGFzayBmdW5jdGlvbiBiZWluZyBjYWxsZWQgKG9wdGlvbm5hbHkgcmVwZWF0ZWRseSkgb24gdGhlIG1haW4gbG9vcCxcbiAqIHNjaGVkdWxlZCBhc3luY2hyb25lb3VzbHksIGF2b2lkaW5nIHJlY3Vyc2l2ZSBjYWxscyBpbiB0aGUgc2FtZSB0aWNrLlxuICpcbiAqIFRoZSB0YXNrIGl0c2VsZiBpcyBpbXBsZW1lbnRlZCBpbiBgZG9UaWNrYC4gSXQgY2FuIGJlIHJlcXVlc3RlZCBhbmQgY2FsbGVkIGZvciBzaW5nbGUgZXhlY3V0aW9uXG4gKiB1c2luZyB0aGUgYHRpY2tgIG1ldGhvZC5cbiAqXG4gKiBJdCB3aWxsIGJlIGFzc3VyZWQgdGhhdCB0aGUgdGFzayBleGVjdXRpb24gbWV0aG9kIChgdGlja2ApIG9ubHkgZ2V0cyBjYWxsZWQgb25jZSBwZXIgbWFpbiBsb29wIFwidGlja1wiLFxuICogbm8gbWF0dGVyIGhvdyBvZnRlbiBpdCBnZXRzIHJlcXVlc3RlZCBmb3IgZXhlY3V0aW9uLiBFeGVjdXRpb24gaW4gZnVydGhlciB0aWNrcyB3aWxsIGJlIHNjaGVkdWxlZCBhY2NvcmRpbmdseS5cbiAqXG4gKiBJZiBmdXJ0aGVyIGV4ZWN1dGlvbiByZXF1ZXN0cyBoYXZlIGFscmVhZHkgYmVlbiBzY2hlZHVsZWQgb24gdGhlIG5leHQgdGljaywgaXQgY2FuIGJlIGNoZWNrZWQgd2l0aCBgaGFzTmV4dFRpY2tgLFxuICogYW5kIGNhbmNlbGxlZCB3aXRoIGBjbGVhck5leHRUaWNrYC5cbiAqXG4gKiBUaGUgdGFzayBjYW4gYmUgc2NoZWR1bGVkIGFzIGFuIGludGVydmFsIHJlcGVhdGVkbHkgd2l0aCBhIHBlcmlvZCBhcyBwYXJhbWV0ZXIgKHNlZSBgc2V0SW50ZXJ2YWxgLCBgY2xlYXJJbnRlcnZhbGApLlxuICpcbiAqIFN1Yi1jbGFzc2VzIG5lZWQgdG8gaW1wbGVtZW50IHRoZSBgZG9UaWNrYCBtZXRob2Qgd2hpY2ggd2lsbCBlZmZlY3RpdmVseSBoYXZlIHRoZSB0YXNrIGV4ZWN1dGlvbiByb3V0aW5lLlxuICpcbiAqIEZ1cnRoZXIgZXhwbGFuYXRpb25zOlxuICpcbiAqIFRoZSBiYXNlY2xhc3MgaGFzIGEgYHRpY2tgIG1ldGhvZCB0aGF0IHdpbGwgc2NoZWR1bGUgdGhlIGRvVGljayBjYWxsLiBJdCBtYXkgYmUgY2FsbGVkIHN5bmNocm9uZW91c2x5XG4gKiBvbmx5IGZvciBhIHN0YWNrLWRlcHRoIG9mIG9uZS4gT24gcmUtZW50cmFudCBjYWxscywgc3ViLXNlcXVlbnQgY2FsbHMgYXJlIHNjaGVkdWxlZCBmb3IgbmV4dCBtYWluIGxvb3AgdGlja3MuXG4gKlxuICogV2hlbiB0aGUgdGFzayBleGVjdXRpb24gKGB0aWNrYCBtZXRob2QpIGlzIGNhbGxlZCBpbiByZS1lbnRyYW50IHdheSB0aGlzIGlzIGRldGVjdGVkIGFuZFxuICogd2UgYXJlIGxpbWl0aW5nIHRoZSB0YXNrIGV4ZWN1dGlvbiBwZXIgY2FsbCBzdGFjayB0byBleGFjdGx5IG9uZSwgYnV0IHNjaGVkdWxpbmcvcG9zdC1wb25pbmcgZnVydGhlclxuICogdGFzayBwcm9jZXNzaW5nIG9uIHRoZSBuZXh0IG1haW4gbG9vcCBpdGVyYXRpb24gKGFsc28ga25vd24gYXMgXCJuZXh0IHRpY2tcIiBpbiB0aGUgTm9kZS9KUyBydW50aW1lIGxpbmdvKS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYXNrTG9vcCBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMsIC4uLmV2ZW50cykge1xuICAgIHN1cGVyKGhscywgLi4uZXZlbnRzKTtcblxuICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgdGhpcy5fdGlja1RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl90aWNrQ2FsbENvdW50ID0gMDtcbiAgICB0aGlzLl9ib3VuZFRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcgKCkge1xuICAgIC8vIGNsZWFyIGFsbCB0aW1lcnMgYmVmb3JlIHVucmVnaXN0ZXJpbmcgZnJvbSBldmVudCBidXNcbiAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0ludGVydmFsICgpIHtcbiAgICByZXR1cm4gISF0aGlzLl90aWNrSW50ZXJ2YWw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBoYXNOZXh0VGljayAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fdGlja1RpbWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaWxsaXMgSW50ZXJ2YWwgdGltZSAobXMpXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHdoZW4gaW50ZXJ2YWwgaGFzIGJlZW4gc2NoZWR1bGVkLCBmYWxzZSB3aGVuIGFscmVhZHkgc2NoZWR1bGVkIChubyBlZmZlY3QpXG4gICAqL1xuICBzZXRJbnRlcnZhbCAobWlsbGlzKSB7XG4gICAgaWYgKCF0aGlzLl90aWNrSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IHNldEludGVydmFsKHRoaXMuX2JvdW5kVGljaywgbWlsbGlzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgd2hlbiBpbnRlcnZhbCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcbiAgICovXG4gIGNsZWFySW50ZXJ2YWwgKCkge1xuICAgIGlmICh0aGlzLl90aWNrSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fdGlja0ludGVydmFsKTtcbiAgICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHdoZW4gdGltZW91dCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcbiAgICovXG4gIGNsZWFyTmV4dFRpY2sgKCkge1xuICAgIGlmICh0aGlzLl90aWNrVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aWNrVGltZXIpO1xuICAgICAgdGhpcy5fdGlja1RpbWVyID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCBjYWxsIHRoZSBzdWJjbGFzcyBkb1RpY2sgaW1wbGVtZW50YXRpb24gaW4gdGhpcyBtYWluIGxvb3AgdGlja1xuICAgKiBvciBpbiB0aGUgbmV4dCBvbmUgKHZpYSBzZXRUaW1lb3V0KCwwKSkgaW4gY2FzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFxuICAgKiBpbiB0aGlzIHRpY2sgKGluIGNhc2UgdGhpcyBpcyBhIHJlLWVudHJhbnQgY2FsbCkuXG4gICAqL1xuICB0aWNrICgpIHtcbiAgICB0aGlzLl90aWNrQ2FsbENvdW50Kys7XG4gICAgaWYgKHRoaXMuX3RpY2tDYWxsQ291bnQgPT09IDEpIHtcbiAgICAgIHRoaXMuZG9UaWNrKCk7XG4gICAgICAvLyByZS1lbnRyYW50IGNhbGwgdG8gdGljayBmcm9tIHByZXZpb3VzIGRvVGljayBjYWxsIHN0YWNrXG4gICAgICAvLyAtPiBzY2hlZHVsZSBhIGNhbGwgb24gdGhlIG5leHQgbWFpbiBsb29wIGl0ZXJhdGlvbiB0byBwcm9jZXNzIHRoaXMgdGFzayBwcm9jZXNzaW5nIHJlcXVlc3RcbiAgICAgIGlmICh0aGlzLl90aWNrQ2FsbENvdW50ID4gMSkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgb25seSBvbmUgdGltZXIgZXhpc3RzIGF0IGFueSB0aW1lIGF0IG1heFxuICAgICAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICAgICAgdGhpcy5fdGlja1RpbWVyID0gc2V0VGltZW91dCh0aGlzLl9ib3VuZFRpY2ssIDApO1xuICAgICAgfVxuICAgICAgdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvciBzdWJjbGFzcyB0byBpbXBsZW1lbnQgdGFzayBsb2dpY1xuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGRvVGljayAoKSB7fVxufVxuIiwiY29uc3QgREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYID0gL14oXFxkKyl4KFxcZCspJC87IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbmNvbnN0IEFUVFJfTElTVF9SRUdFWCA9IC9cXHMqKC4rPylcXHMqPSgoPzpcXFwiLio/XFxcIil8Lio/KSg/Oix8JCkvZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2thbm9uZ2lsL25vZGUtbTN1OHBhcnNlL2Jsb2IvbWFzdGVyL2F0dHJsaXN0LmpzXG5jbGFzcyBBdHRyTGlzdCB7XG4gIGNvbnN0cnVjdG9yIChhdHRycykge1xuICAgIGlmICh0eXBlb2YgYXR0cnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhdHRycyA9IEF0dHJMaXN0LnBhcnNlQXR0ckxpc3QoYXR0cnMpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICB0aGlzW2F0dHJdID0gYXR0cnNbYXR0cl07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVjaW1hbEludGVnZXIgKGF0dHJOYW1lKSB7XG4gICAgY29uc3QgaW50VmFsdWUgPSBwYXJzZUludCh0aGlzW2F0dHJOYW1lXSwgMTApO1xuICAgIGlmIChpbnRWYWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludFZhbHVlO1xuICB9XG5cbiAgaGV4YWRlY2ltYWxJbnRlZ2VyIChhdHRyTmFtZSkge1xuICAgIGlmICh0aGlzW2F0dHJOYW1lXSkge1xuICAgICAgbGV0IHN0cmluZ1ZhbHVlID0gKHRoaXNbYXR0ck5hbWVdIHx8ICcweCcpLnNsaWNlKDIpO1xuICAgICAgc3RyaW5nVmFsdWUgPSAoKHN0cmluZ1ZhbHVlLmxlbmd0aCAmIDEpID8gJzAnIDogJycpICsgc3RyaW5nVmFsdWU7XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoc3RyaW5nVmFsdWUubGVuZ3RoIC8gMik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YWx1ZVtpXSA9IHBhcnNlSW50KHN0cmluZ1ZhbHVlLnNsaWNlKGkgKiAyLCBpICogMiArIDIpLCAxNik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgaGV4YWRlY2ltYWxJbnRlZ2VyQXNOdW1iZXIgKGF0dHJOYW1lKSB7XG4gICAgY29uc3QgaW50VmFsdWUgPSBwYXJzZUludCh0aGlzW2F0dHJOYW1lXSwgMTYpO1xuICAgIGlmIChpbnRWYWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludFZhbHVlO1xuICB9XG5cbiAgZGVjaW1hbEZsb2F0aW5nUG9pbnQgKGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpc1thdHRyTmFtZV0pO1xuICB9XG5cbiAgZW51bWVyYXRlZFN0cmluZyAoYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gdGhpc1thdHRyTmFtZV07XG4gIH1cblxuICBkZWNpbWFsUmVzb2x1dGlvbiAoYXR0ck5hbWUpIHtcbiAgICBjb25zdCByZXMgPSBERUNJTUFMX1JFU09MVVRJT05fUkVHRVguZXhlYyh0aGlzW2F0dHJOYW1lXSk7XG4gICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHBhcnNlSW50KHJlc1sxXSwgMTApLFxuICAgICAgaGVpZ2h0OiBwYXJzZUludChyZXNbMl0sIDEwKVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgcGFyc2VBdHRyTGlzdCAoaW5wdXQpIHtcbiAgICBsZXQgbWF0Y2gsIGF0dHJzID0ge307XG4gICAgQVRUUl9MSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChtYXRjaCA9IEFUVFJfTElTVF9SRUdFWC5leGVjKGlucHV0KSkgIT09IG51bGwpIHtcbiAgICAgIGxldCB2YWx1ZSA9IG1hdGNoWzJdLCBxdW90ZSA9ICdcIic7XG5cbiAgICAgIGlmICh2YWx1ZS5pbmRleE9mKHF1b3RlKSA9PT0gMCAmJlxuICAgICAgICAgIHZhbHVlLmxhc3RJbmRleE9mKHF1b3RlKSA9PT0gKHZhbHVlLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgICAgfVxuXG4gICAgICBhdHRyc1ttYXRjaFsxXV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEF0dHJMaXN0O1xuIiwibGV0IEJpbmFyeVNlYXJjaCA9IHtcbiAgLyoqXG4gICAgICogU2VhcmNoZXMgZm9yIGFuIGl0ZW0gaW4gYW4gYXJyYXkgd2hpY2ggbWF0Y2hlcyBhIGNlcnRhaW4gY29uZGl0aW9uLlxuICAgICAqIFRoaXMgcmVxdWlyZXMgdGhlIGNvbmRpdGlvbiB0byBvbmx5IG1hdGNoIG9uZSBpdGVtIGluIHRoZSBhcnJheSxcbiAgICAgKiBhbmQgZm9yIHRoZSBhcnJheSB0byBiZSBvcmRlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmlzb25GdW5jdGlvblxuICAgICAqICAgICAgQ2FsbGVkIGFuZCBwcm92aWRlZCBhIGNhbmRpZGF0ZSBpdGVtIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICAgKiAgICAgIFNob3VsZCByZXR1cm46XG4gICAgICogICAgICAgICAgPiAtMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGxvd2VyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAgICogICAgICAgICAgPiAxIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgaGlnaGVyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAgICogICAgICAgICAgPiAwIGlmIHRoZSBpdGVtIGlzIHRoZSBpdGVtIHlvdSdyZSBsb29raW5nIGZvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyp9IFRoZSBvYmplY3QgaWYgaXQgaXMgZm91bmQgb3IgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gIHNlYXJjaDogZnVuY3Rpb24gKGxpc3QsIGNvbXBhcmlzb25GdW5jdGlvbikge1xuICAgIGxldCBtaW5JbmRleCA9IDA7XG4gICAgbGV0IG1heEluZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgIGxldCBjdXJyZW50SW5kZXggPSBudWxsO1xuICAgIGxldCBjdXJyZW50RWxlbWVudCA9IG51bGw7XG5cbiAgICB3aGlsZSAobWluSW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgIGN1cnJlbnRJbmRleCA9IChtaW5JbmRleCArIG1heEluZGV4KSAvIDIgfCAwO1xuICAgICAgY3VycmVudEVsZW1lbnQgPSBsaXN0W2N1cnJlbnRJbmRleF07XG5cbiAgICAgIGxldCBjb21wYXJpc29uUmVzdWx0ID0gY29tcGFyaXNvbkZ1bmN0aW9uKGN1cnJlbnRFbGVtZW50KTtcbiAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xuICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICB9IGVsc2UgaWYgKGNvbXBhcmlzb25SZXN1bHQgPCAwKSB7XG4gICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQmluYXJ5U2VhcmNoO1xuIiwiLyoqXG4gKiBAbW9kdWxlIEJ1ZmZlckhlbHBlclxuICpcbiAqIFByb3ZpZGluZyBtZXRob2RzIGRlYWxpbmcgd2l0aCBidWZmZXIgbGVuZ3RoIHJldHJpZXZhbCBmb3IgZXhhbXBsZS5cbiAqXG4gKiBJbiBnZW5lcmFsLCBhIGhlbHBlciBhcm91bmQgSFRNTDUgTWVkaWFFbGVtZW50IFRpbWVSYW5nZXMgZ2F0aGVyZWQgZnJvbSBgYnVmZmVyZWRgIHByb3BlcnR5LlxuICpcbiAqIEFsc28gQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9idWZmZXJlZFxuKi9cblxuZXhwb3J0IGNsYXNzIEJ1ZmZlckhlbHBlciB7XG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBgbWVkaWFgJ3MgYnVmZmVyZWQgaW5jbHVkZSBgcG9zaXRpb25gXG4gICAqIEBwYXJhbSB7SFRNTE1lZGlhRWxlbWVudHxTb3VyY2VCdWZmZXJ9IG1lZGlhXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0J1ZmZlcmVkIChtZWRpYSwgcG9zaXRpb24pIHtcbiAgICB0cnkge1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGxldCBidWZmZXJlZCA9IG1lZGlhLmJ1ZmZlcmVkO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBvc2l0aW9uID49IGJ1ZmZlcmVkLnN0YXJ0KGkpICYmIHBvc2l0aW9uIDw9IGJ1ZmZlcmVkLmVuZChpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHRoaXMgaXMgdG8gY2F0Y2hcbiAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxuICAgICAgLy8gVGhpcyBTb3VyY2VCdWZmZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgbWVkaWEgc291cmNlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBidWZmZXJJbmZvIChtZWRpYSwgcG9zLCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICB0cnkge1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGxldCB2YnVmZmVyZWQgPSBtZWRpYS5idWZmZXJlZCwgYnVmZmVyZWQgPSBbXSwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlcmVkLnB1c2goeyBzdGFydDogdmJ1ZmZlcmVkLnN0YXJ0KGkpLCBlbmQ6IHZidWZmZXJlZC5lbmQoaSkgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJlZEluZm8oYnVmZmVyZWQsIHBvcywgbWF4SG9sZUR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gdGhpcyBpcyB0byBjYXRjaFxuICAgICAgLy8gSW52YWxpZFN0YXRlRXJyb3I6IEZhaWxlZCB0byByZWFkIHRoZSAnYnVmZmVyZWQnIHByb3BlcnR5IGZyb20gJ1NvdXJjZUJ1ZmZlcic6XG4gICAgICAvLyBUaGlzIFNvdXJjZUJ1ZmZlciBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhcmVudCBtZWRpYSBzb3VyY2VcbiAgICB9XG4gICAgcmV0dXJuIHsgbGVuOiAwLCBzdGFydDogcG9zLCBlbmQ6IHBvcywgbmV4dFN0YXJ0OiB1bmRlZmluZWQgfTtcbiAgfVxuXG4gIHN0YXRpYyBidWZmZXJlZEluZm8gKGJ1ZmZlcmVkLCBwb3MsIG1heEhvbGVEdXJhdGlvbikge1xuICAgIGxldCBidWZmZXJlZDIgPSBbXSxcbiAgICAgIC8vIGJ1ZmZlclN0YXJ0IGFuZCBidWZmZXJFbmQgYXJlIGJ1ZmZlciBib3VuZGFyaWVzIGFyb3VuZCBjdXJyZW50IHZpZGVvIHBvc2l0aW9uXG4gICAgICBidWZmZXJMZW4sIGJ1ZmZlclN0YXJ0LCBidWZmZXJFbmQsIGJ1ZmZlclN0YXJ0TmV4dCwgaTtcbiAgICAvLyBzb3J0IG9uIGJ1ZmZlci5zdGFydC9zbWFsbGVyIGVuZCAoSUUgZG9lcyBub3QgYWx3YXlzIHJldHVybiBzb3J0ZWQgYnVmZmVyZWQgcmFuZ2UpXG4gICAgYnVmZmVyZWQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgbGV0IGRpZmYgPSBhLnN0YXJ0IC0gYi5zdGFydDtcbiAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGIuZW5kIC0gYS5lbmQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gdGhlcmUgbWlnaHQgYmUgc29tZSBzbWFsbCBob2xlcyBiZXR3ZWVuIGJ1ZmZlciB0aW1lIHJhbmdlXG4gICAgLy8gY29uc2lkZXIgdGhhdCBob2xlcyBzbWFsbGVyIHRoYW4gbWF4SG9sZUR1cmF0aW9uIGFyZSBpcnJlbGV2YW50IGFuZCBidWlsZCBhbm90aGVyXG4gICAgLy8gYnVmZmVyIHRpbWUgcmFuZ2UgcmVwcmVzZW50YXRpb25zIHRoYXQgZGlzY2FyZHMgdGhvc2UgaG9sZXNcbiAgICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBidWYybGVuID0gYnVmZmVyZWQyLmxlbmd0aDtcbiAgICAgIGlmIChidWYybGVuKSB7XG4gICAgICAgIGxldCBidWYyZW5kID0gYnVmZmVyZWQyW2J1ZjJsZW4gLSAxXS5lbmQ7XG4gICAgICAgIC8vIGlmIHNtYWxsIGhvbGUgKHZhbHVlIGJldHdlZW4gMCBvciBtYXhIb2xlRHVyYXRpb24gKSBvciBvdmVybGFwcGluZyAobmVnYXRpdmUpXG4gICAgICAgIGlmICgoYnVmZmVyZWRbaV0uc3RhcnQgLSBidWYyZW5kKSA8IG1heEhvbGVEdXJhdGlvbikge1xuICAgICAgICAgIC8vIG1lcmdlIG92ZXJsYXBwaW5nIHRpbWUgcmFuZ2VzXG4gICAgICAgICAgLy8gdXBkYXRlIGxhc3RSYW5nZS5lbmQgb25seSBpZiBzbWFsbGVyIHRoYW4gaXRlbS5lbmRcbiAgICAgICAgICAvLyBlLmcuICBbIDEsIDE1XSB3aXRoICBbIDIsOF0gPT4gWyAxLDE1XSAobm8gbmVlZCB0byBtb2RpZnkgbGFzdFJhbmdlLmVuZClcbiAgICAgICAgICAvLyB3aGVyZWFzIFsgMSwgOF0gd2l0aCAgWyAyLDE1XSA9PiBbIDEsMTVdICggbGFzdFJhbmdlIHNob3VsZCBzd2l0Y2ggZnJvbSBbMSw4XSB0byBbMSwxNV0pXG4gICAgICAgICAgaWYgKGJ1ZmZlcmVkW2ldLmVuZCA+IGJ1ZjJlbmQpIHtcbiAgICAgICAgICAgIGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kID0gYnVmZmVyZWRbaV0uZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBiaWcgaG9sZVxuICAgICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmlyc3QgdmFsdWVcbiAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBidWZmZXJMZW4gPSAwLCBidWZmZXJTdGFydCA9IGJ1ZmZlckVuZCA9IHBvczsgaSA8IGJ1ZmZlcmVkMi5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHN0YXJ0ID0gYnVmZmVyZWQyW2ldLnN0YXJ0LFxuICAgICAgICBlbmQgPSBidWZmZXJlZDJbaV0uZW5kO1xuICAgICAgLy8gbG9nZ2VyLmxvZygnYnVmIHN0YXJ0L2VuZDonICsgYnVmZmVyZWQuc3RhcnQoaSkgKyAnLycgKyBidWZmZXJlZC5lbmQoaSkpO1xuICAgICAgaWYgKChwb3MgKyBtYXhIb2xlRHVyYXRpb24pID49IHN0YXJ0ICYmIHBvcyA8IGVuZCkge1xuICAgICAgICAvLyBwbGF5IHBvc2l0aW9uIGlzIGluc2lkZSB0aGlzIGJ1ZmZlciBUaW1lUmFuZ2UsIHJldHJpZXZlIGVuZCBvZiBidWZmZXIgcG9zaXRpb24gYW5kIGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgYnVmZmVyU3RhcnQgPSBzdGFydDtcbiAgICAgICAgYnVmZmVyRW5kID0gZW5kO1xuICAgICAgICBidWZmZXJMZW4gPSBidWZmZXJFbmQgLSBwb3M7XG4gICAgICB9IGVsc2UgaWYgKChwb3MgKyBtYXhIb2xlRHVyYXRpb24pIDwgc3RhcnQpIHtcbiAgICAgICAgYnVmZmVyU3RhcnROZXh0ID0gc3RhcnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBsZW46IGJ1ZmZlckxlbiwgc3RhcnQ6IGJ1ZmZlclN0YXJ0LCBlbmQ6IGJ1ZmZlckVuZCwgbmV4dFN0YXJ0OiBidWZmZXJTdGFydE5leHQgfTtcbiAgfVxufVxuIiwiLyoqXG4gKlxuICogVGhpcyBjb2RlIHdhcyBwb3J0ZWQgZnJvbSB0aGUgZGFzaC5qcyBwcm9qZWN0IGF0OlxuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2Jsb2IvZGV2ZWxvcG1lbnQvZXh0ZXJuYWxzL2NlYTYwOC1wYXJzZXIuanNcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vZGFzaC5qcy9jb21taXQvODI2OWIyNmE3NjFlMDg1M2JiMjFkNzg3ODBlZDk0NTE0NGVjZGQ0ZCNkaWZmLTcxYmMyOTVhMmQ2YjZiNzA5M2ExZDMyOTBkNTNhNGIyXG4gKlxuICogVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBhcHBlYXJzIGJlbG93OlxuICpcbiAqIFRoZSBjb3B5cmlnaHQgaW4gdGhpcyBzb2Z0d2FyZSBpcyBiZWluZyBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgQlNEIExpY2Vuc2UsXG4gKiBpbmNsdWRlZCBiZWxvdy4gVGhpcyBzb2Z0d2FyZSBtYXkgYmUgc3ViamVjdCB0byBvdGhlciB0aGlyZCBwYXJ0eSBhbmQgY29udHJpYnV0b3JcbiAqIHJpZ2h0cywgaW5jbHVkaW5nIHBhdGVudCByaWdodHMsIGFuZCBubyBzdWNoIHJpZ2h0cyBhcmUgZ3JhbnRlZCB1bmRlciB0aGlzIGxpY2Vuc2UuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYsIERBU0ggSW5kdXN0cnkgRm9ydW0uXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKiAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gKiAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3JcbiAqICBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogIDIuIE5laXRoZXIgdGhlIG5hbWUgb2YgRGFzaCBJbmR1c3RyeSBGb3J1bSBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAqICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBBUyBJUyBBTkQgQU5ZXG4gKiAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC5cbiAqICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULFxuICogIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVRcbiAqICBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gKiAgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbi8qKlxuICAgICAqICBFeGNlcHRpb25zIGZyb20gcmVndWxhciBBU0NJSS4gQ29kZVBvaW50cyBhcmUgbWFwcGVkIHRvIFVURi0xNiBjb2Rlc1xuICAgICAqL1xuXG5sZXQgc3BlY2lhbENlYTYwOENoYXJzQ29kZXMgPSB7XG4gIDB4MmE6IDB4ZTEsIC8vIGxvd2VyY2FzZSBhLCBhY3V0ZSBhY2NlbnRcbiAgMHg1YzogMHhlOSwgLy8gbG93ZXJjYXNlIGUsIGFjdXRlIGFjY2VudFxuICAweDVlOiAweGVkLCAvLyBsb3dlcmNhc2UgaSwgYWN1dGUgYWNjZW50XG4gIDB4NWY6IDB4ZjMsIC8vIGxvd2VyY2FzZSBvLCBhY3V0ZSBhY2NlbnRcbiAgMHg2MDogMHhmYSwgLy8gbG93ZXJjYXNlIHUsIGFjdXRlIGFjY2VudFxuICAweDdiOiAweGU3LCAvLyBsb3dlcmNhc2UgYyB3aXRoIGNlZGlsbGFcbiAgMHg3YzogMHhmNywgLy8gZGl2aXNpb24gc3ltYm9sXG4gIDB4N2Q6IDB4ZDEsIC8vIHVwcGVyY2FzZSBOIHRpbGRlXG4gIDB4N2U6IDB4ZjEsIC8vIGxvd2VyY2FzZSBuIHRpbGRlXG4gIDB4N2Y6IDB4MjU4OCwgLy8gRnVsbCBibG9ja1xuICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAxNiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAvLyBUSEFUIENPTUUgRlJPTSBISSBCWVRFPTB4MTEgQU5EIExPVyBCRVRXRUVOIDB4MzAgQU5EIDB4M0ZcbiAgLy8gVEhJUyBNRUFOUyBUSEFUIFxceDUwIE1VU1QgQkUgQURERUQgVE8gVEhFIFZBTFVFU1xuICAweDgwOiAweGFlLCAvLyBSZWdpc3RlcmVkIHN5bWJvbCAoUilcbiAgMHg4MTogMHhiMCwgLy8gZGVncmVlIHNpZ25cbiAgMHg4MjogMHhiZCwgLy8gMS8yIHN5bWJvbFxuICAweDgzOiAweGJmLCAvLyBJbnZlcnRlZCAob3BlbikgcXVlc3Rpb24gbWFya1xuICAweDg0OiAweDIxMjIsIC8vIFRyYWRlbWFyayBzeW1ib2wgKFRNKVxuICAweDg1OiAweGEyLCAvLyBDZW50cyBzeW1ib2xcbiAgMHg4NjogMHhhMywgLy8gUG91bmRzIHN0ZXJsaW5nXG4gIDB4ODc6IDB4MjY2YSwgLy8gTXVzaWMgOCd0aCBub3RlXG4gIDB4ODg6IDB4ZTAsIC8vIGxvd2VyY2FzZSBhLCBncmF2ZSBhY2NlbnRcbiAgMHg4OTogMHgyMCwgLy8gdHJhbnNwYXJlbnQgc3BhY2UgKHJlZ3VsYXIpXG4gIDB4OGE6IDB4ZTgsIC8vIGxvd2VyY2FzZSBlLCBncmF2ZSBhY2NlbnRcbiAgMHg4YjogMHhlMiwgLy8gbG93ZXJjYXNlIGEsIGNpcmN1bWZsZXggYWNjZW50XG4gIDB4OGM6IDB4ZWEsIC8vIGxvd2VyY2FzZSBlLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhkOiAweGVlLCAvLyBsb3dlcmNhc2UgaSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4ZTogMHhmNCwgLy8gbG93ZXJjYXNlIG8sIGNpcmN1bWZsZXggYWNjZW50XG4gIDB4OGY6IDB4ZmIsIC8vIGxvd2VyY2FzZSB1LCBjaXJjdW1mbGV4IGFjY2VudFxuICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAvLyBUSEFUIENPTUUgRlJPTSBISSBCWVRFPTB4MTIgQU5EIExPVyBCRVRXRUVOIDB4MjAgQU5EIDB4M0ZcbiAgMHg5MDogMHhjMSwgLy8gY2FwaXRhbCBsZXR0ZXIgQSB3aXRoIGFjdXRlXG4gIDB4OTE6IDB4YzksIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBhY3V0ZVxuICAweDkyOiAweGQzLCAvLyBjYXBpdGFsIGxldHRlciBPIHdpdGggYWN1dGVcbiAgMHg5MzogMHhkYSwgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGFjdXRlXG4gIDB4OTQ6IDB4ZGMsIC8vIGNhcGl0YWwgbGV0dGVyIFUgd2l0aCBkaWFyZXNpc1xuICAweDk1OiAweGZjLCAvLyBsb3dlcmNhc2UgbGV0dGVyIFUgd2l0aCBkaWFlcmVzaXNcbiAgMHg5NjogMHgyMDE4LCAvLyBvcGVuaW5nIHNpbmdsZSBxdW90ZVxuICAweDk3OiAweGExLCAvLyBpbnZlcnRlZCBleGNsYW1hdGlvbiBtYXJrXG4gIDB4OTg6IDB4MmEsIC8vIGFzdGVyaXNrXG4gIDB4OTk6IDB4MjAxOSwgLy8gY2xvc2luZyBzaW5nbGUgcXVvdGVcbiAgMHg5YTogMHgyNTAxLCAvLyBib3ggZHJhd2luZ3MgaGVhdnkgaG9yaXpvbnRhbFxuICAweDliOiAweGE5LCAvLyBjb3B5cmlnaHQgc2lnblxuICAweDljOiAweDIxMjAsIC8vIFNlcnZpY2UgbWFya1xuICAweDlkOiAweDIwMjIsIC8vIChyb3VuZCkgYnVsbGV0XG4gIDB4OWU6IDB4MjAxYywgLy8gTGVmdCBkb3VibGUgcXVvdGF0aW9uIG1hcmtcbiAgMHg5ZjogMHgyMDFkLCAvLyBSaWdodCBkb3VibGUgcXVvdGF0aW9uIG1hcmtcbiAgMHhhMDogMHhjMCwgLy8gdXBwZXJjYXNlIEEsIGdyYXZlIGFjY2VudFxuICAweGExOiAweGMyLCAvLyB1cHBlcmNhc2UgQSwgY2lyY3VtZmxleFxuICAweGEyOiAweGM3LCAvLyB1cHBlcmNhc2UgQyB3aXRoIGNlZGlsbGFcbiAgMHhhMzogMHhjOCwgLy8gdXBwZXJjYXNlIEUsIGdyYXZlIGFjY2VudFxuICAweGE0OiAweGNhLCAvLyB1cHBlcmNhc2UgRSwgY2lyY3VtZmxleFxuICAweGE1OiAweGNiLCAvLyBjYXBpdGFsIGxldHRlciBFIHdpdGggZGlhcmVzaXNcbiAgMHhhNjogMHhlYiwgLy8gbG93ZXJjYXNlIGxldHRlciBlIHdpdGggZGlhcmVzaXNcbiAgMHhhNzogMHhjZSwgLy8gdXBwZXJjYXNlIEksIGNpcmN1bWZsZXhcbiAgMHhhODogMHhjZiwgLy8gdXBwZXJjYXNlIEksIHdpdGggZGlhcmVzaXNcbiAgMHhhOTogMHhlZiwgLy8gbG93ZXJjYXNlIGksIHdpdGggZGlhcmVzaXNcbiAgMHhhYTogMHhkNCwgLy8gdXBwZXJjYXNlIE8sIGNpcmN1bWZsZXhcbiAgMHhhYjogMHhkOSwgLy8gdXBwZXJjYXNlIFUsIGdyYXZlIGFjY2VudFxuICAweGFjOiAweGY5LCAvLyBsb3dlcmNhc2UgdSwgZ3JhdmUgYWNjZW50XG4gIDB4YWQ6IDB4ZGIsIC8vIHVwcGVyY2FzZSBVLCBjaXJjdW1mbGV4XG4gIDB4YWU6IDB4YWIsIC8vIGxlZnQtcG9pbnRpbmcgZG91YmxlIGFuZ2xlIHF1b3RhdGlvbiBtYXJrXG4gIDB4YWY6IDB4YmIsIC8vIHJpZ2h0LXBvaW50aW5nIGRvdWJsZSBhbmdsZSBxdW90YXRpb24gbWFya1xuICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAvLyBUSEFUIENPTUUgRlJPTSBISSBCWVRFPTB4MTMgQU5EIExPVyBCRVRXRUVOIDB4MjAgQU5EIDB4M0ZcbiAgMHhiMDogMHhjMywgLy8gVXBwZXJjYXNlIEEsIHRpbGRlXG4gIDB4YjE6IDB4ZTMsIC8vIExvd2VyY2FzZSBhLCB0aWxkZVxuICAweGIyOiAweGNkLCAvLyBVcHBlcmNhc2UgSSwgYWN1dGUgYWNjZW50XG4gIDB4YjM6IDB4Y2MsIC8vIFVwcGVyY2FzZSBJLCBncmF2ZSBhY2NlbnRcbiAgMHhiNDogMHhlYywgLy8gTG93ZXJjYXNlIGksIGdyYXZlIGFjY2VudFxuICAweGI1OiAweGQyLCAvLyBVcHBlcmNhc2UgTywgZ3JhdmUgYWNjZW50XG4gIDB4YjY6IDB4ZjIsIC8vIExvd2VyY2FzZSBvLCBncmF2ZSBhY2NlbnRcbiAgMHhiNzogMHhkNSwgLy8gVXBwZXJjYXNlIE8sIHRpbGRlXG4gIDB4Yjg6IDB4ZjUsIC8vIExvd2VyY2FzZSBvLCB0aWxkZVxuICAweGI5OiAweDdiLCAvLyBPcGVuIGN1cmx5IGJyYWNlXG4gIDB4YmE6IDB4N2QsIC8vIENsb3NpbmcgY3VybHkgYnJhY2VcbiAgMHhiYjogMHg1YywgLy8gQmFja3NsYXNoXG4gIDB4YmM6IDB4NWUsIC8vIENhcmV0XG4gIDB4YmQ6IDB4NWYsIC8vIFVuZGVyc2NvcmVcbiAgMHhiZTogMHg3YywgLy8gUGlwZSAodmVydGljYWwgbGluZSlcbiAgMHhiZjogMHgyMjNjLCAvLyBUaWxkZSBvcGVyYXRvclxuICAweGMwOiAweGM0LCAvLyBVcHBlcmNhc2UgQSwgdW1sYXV0XG4gIDB4YzE6IDB4ZTQsIC8vIExvd2VyY2FzZSBBLCB1bWxhdXRcbiAgMHhjMjogMHhkNiwgLy8gVXBwZXJjYXNlIE8sIHVtbGF1dFxuICAweGMzOiAweGY2LCAvLyBMb3dlcmNhc2UgbywgdW1sYXV0XG4gIDB4YzQ6IDB4ZGYsIC8vIEVzc3pldHQgKHNoYXJwIFMpXG4gIDB4YzU6IDB4YTUsIC8vIFllbiBzeW1ib2xcbiAgMHhjNjogMHhhNCwgLy8gR2VuZXJpYyBjdXJyZW5jeSBzaWduXG4gIDB4Yzc6IDB4MjUwMywgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHZlcnRpY2FsXG4gIDB4Yzg6IDB4YzUsIC8vIFVwcGVyY2FzZSBBLCByaW5nXG4gIDB4Yzk6IDB4ZTUsIC8vIExvd2VyY2FzZSBBLCByaW5nXG4gIDB4Y2E6IDB4ZDgsIC8vIFVwcGVyY2FzZSBPLCBzdHJva2VcbiAgMHhjYjogMHhmOCwgLy8gTG93ZXJjYXNlIG8sIHN0cm9rXG4gIDB4Y2M6IDB4MjUwZiwgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IGRvd24gYW5kIHJpZ2h0XG4gIDB4Y2Q6IDB4MjUxMywgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IGRvd24gYW5kIGxlZnRcbiAgMHhjZTogMHgyNTE3LCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdXAgYW5kIHJpZ2h0XG4gIDB4Y2Y6IDB4MjUxYiAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdXAgYW5kIGxlZnRcbn07XG5cbi8qKlxuICogVXRpbHNcbiAqL1xubGV0IGdldENoYXJGb3JCeXRlID0gZnVuY3Rpb24gKGJ5dGUpIHtcbiAgbGV0IGNoYXJDb2RlID0gYnl0ZTtcbiAgaWYgKHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzLmhhc093blByb3BlcnR5KGJ5dGUpKSB7XG4gICAgY2hhckNvZGUgPSBzcGVjaWFsQ2VhNjA4Q2hhcnNDb2Rlc1tieXRlXTtcbiAgfVxuXG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn07XG5cbmxldCBOUl9ST1dTID0gMTUsXG4gIE5SX0NPTFMgPSAxMDA7XG4vLyBUYWJsZXMgdG8gbG9vayB1cCByb3cgZnJvbSBQQUMgZGF0YVxubGV0IHJvd3NMb3dDaDEgPSB7IDB4MTE6IDEsIDB4MTI6IDMsIDB4MTU6IDUsIDB4MTY6IDcsIDB4MTc6IDksIDB4MTA6IDExLCAweDEzOiAxMiwgMHgxNDogMTQgfTtcbmxldCByb3dzSGlnaENoMSA9IHsgMHgxMTogMiwgMHgxMjogNCwgMHgxNTogNiwgMHgxNjogOCwgMHgxNzogMTAsIDB4MTM6IDEzLCAweDE0OiAxNSB9O1xubGV0IHJvd3NMb3dDaDIgPSB7IDB4MTk6IDEsIDB4MUE6IDMsIDB4MUQ6IDUsIDB4MUU6IDcsIDB4MUY6IDksIDB4MTg6IDExLCAweDFCOiAxMiwgMHgxQzogMTQgfTtcbmxldCByb3dzSGlnaENoMiA9IHsgMHgxOTogMiwgMHgxQTogNCwgMHgxRDogNiwgMHgxRTogOCwgMHgxRjogMTAsIDB4MUI6IDEzLCAweDFDOiAxNSB9O1xuXG5sZXQgYmFja2dyb3VuZENvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YScsICdibGFjaycsICd0cmFuc3BhcmVudCddO1xuXG4vKipcbiAqIFNpbXBsZSBsb2dnZXIgY2xhc3MgdG8gYmUgYWJsZSB0byB3cml0ZSB3aXRoIHRpbWUtc3RhbXBzIGFuZCBmaWx0ZXIgb24gbGV2ZWwuXG4gKi9cbmxldCBsb2dnZXIgPSB7XG4gIHZlcmJvc2VGaWx0ZXI6IHsgJ0RBVEEnOiAzLCAnREVCVUcnOiAzLCAnSU5GTyc6IDIsICdXQVJOSU5HJzogMiwgJ1RFWFQnOiAxLCAnRVJST1InOiAwIH0sXG4gIHRpbWU6IG51bGwsXG4gIHZlcmJvc2VMZXZlbDogMCwgLy8gT25seSB3cml0ZSBlcnJvcnNcbiAgc2V0VGltZTogZnVuY3Rpb24gKG5ld1RpbWUpIHtcbiAgICB0aGlzLnRpbWUgPSBuZXdUaW1lO1xuICB9LFxuICBsb2c6IGZ1bmN0aW9uIChzZXZlcml0eSwgbXNnKSB7XG4gICAgbGV0IG1pbkxldmVsID0gdGhpcy52ZXJib3NlRmlsdGVyW3NldmVyaXR5XTtcbiAgICBpZiAodGhpcy52ZXJib3NlTGV2ZWwgPj0gbWluTGV2ZWwpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMudGltZSArICcgWycgKyBzZXZlcml0eSArICddICcgKyBtc2cpO1xuICAgIH1cbiAgfVxufTtcblxubGV0IG51bUFycmF5VG9IZXhBcnJheSA9IGZ1bmN0aW9uIChudW1BcnJheSkge1xuICBsZXQgaGV4QXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1BcnJheS5sZW5ndGg7IGorKykge1xuICAgIGhleEFycmF5LnB1c2gobnVtQXJyYXlbal0udG9TdHJpbmcoMTYpKTtcbiAgfVxuXG4gIHJldHVybiBoZXhBcnJheTtcbn07XG5cbmNsYXNzIFBlblN0YXRlIHtcbiAgY29uc3RydWN0b3IgKGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpIHtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kIHx8ICd3aGl0ZSc7XG4gICAgdGhpcy51bmRlcmxpbmUgPSB1bmRlcmxpbmUgfHwgZmFsc2U7XG4gICAgdGhpcy5pdGFsaWNzID0gaXRhbGljcyB8fCBmYWxzZTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kIHx8ICdibGFjayc7XG4gICAgdGhpcy5mbGFzaCA9IGZsYXNoIHx8IGZhbHNlO1xuICB9XG5cbiAgcmVzZXQgKCkge1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgdGhpcy51bmRlcmxpbmUgPSBmYWxzZTtcbiAgICB0aGlzLml0YWxpY3MgPSBmYWxzZTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSAnYmxhY2snO1xuICAgIHRoaXMuZmxhc2ggPSBmYWxzZTtcbiAgfVxuXG4gIHNldFN0eWxlcyAoc3R5bGVzKSB7XG4gICAgbGV0IGF0dHJpYnMgPSBbJ2ZvcmVncm91bmQnLCAndW5kZXJsaW5lJywgJ2l0YWxpY3MnLCAnYmFja2dyb3VuZCcsICdmbGFzaCddO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHN0eWxlID0gYXR0cmlic1tpXTtcbiAgICAgIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgIHRoaXNbc3R5bGVdID0gc3R5bGVzW3N0eWxlXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc0RlZmF1bHQgKCkge1xuICAgIHJldHVybiAodGhpcy5mb3JlZ3JvdW5kID09PSAnd2hpdGUnICYmICF0aGlzLnVuZGVybGluZSAmJiAhdGhpcy5pdGFsaWNzICYmXG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID09PSAnYmxhY2snICYmICF0aGlzLmZsYXNoKTtcbiAgfVxuXG4gIGVxdWFscyAob3RoZXIpIHtcbiAgICByZXR1cm4gKCh0aGlzLmZvcmVncm91bmQgPT09IG90aGVyLmZvcmVncm91bmQpICYmXG4gICAgICAgICAgICAgICAgICh0aGlzLnVuZGVybGluZSA9PT0gb3RoZXIudW5kZXJsaW5lKSAmJlxuICAgICAgICAgICAgICAgICAodGhpcy5pdGFsaWNzID09PSBvdGhlci5pdGFsaWNzKSAmJlxuICAgICAgICAgICAgICAgICAodGhpcy5iYWNrZ3JvdW5kID09PSBvdGhlci5iYWNrZ3JvdW5kKSAmJlxuICAgICAgICAgICAgICAgICAodGhpcy5mbGFzaCA9PT0gb3RoZXIuZmxhc2gpKTtcbiAgfVxuXG4gIGNvcHkgKG5ld1BlblN0YXRlKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gbmV3UGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICB0aGlzLnVuZGVybGluZSA9IG5ld1BlblN0YXRlLnVuZGVybGluZTtcbiAgICB0aGlzLml0YWxpY3MgPSBuZXdQZW5TdGF0ZS5pdGFsaWNzO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ld1BlblN0YXRlLmJhY2tncm91bmQ7XG4gICAgdGhpcy5mbGFzaCA9IG5ld1BlblN0YXRlLmZsYXNoO1xuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiAoJ2NvbG9yPScgKyB0aGlzLmZvcmVncm91bmQgKyAnLCB1bmRlcmxpbmU9JyArIHRoaXMudW5kZXJsaW5lICsgJywgaXRhbGljcz0nICsgdGhpcy5pdGFsaWNzICtcbiAgICAgICAgICAgICcsIGJhY2tncm91bmQ9JyArIHRoaXMuYmFja2dyb3VuZCArICcsIGZsYXNoPScgKyB0aGlzLmZsYXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggc3R5bGluZyBhbmQgYmFja2dyb3VuZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBTdHlsZWRVbmljb2RlQ2hhciB7XG4gIGNvbnN0cnVjdG9yICh1Y2hhciwgZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCkge1xuICAgIHRoaXMudWNoYXIgPSB1Y2hhciB8fCAnICc7IC8vIHVuaWNvZGUgY2hhcmFjdGVyXG4gICAgdGhpcy5wZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZShmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKTtcbiAgfVxuXG4gIHJlc2V0ICgpIHtcbiAgICB0aGlzLnVjaGFyID0gJyAnO1xuICAgIHRoaXMucGVuU3RhdGUucmVzZXQoKTtcbiAgfVxuXG4gIHNldENoYXIgKHVjaGFyLCBuZXdQZW5TdGF0ZSkge1xuICAgIHRoaXMudWNoYXIgPSB1Y2hhcjtcbiAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3UGVuU3RhdGUpO1xuICB9XG5cbiAgc2V0UGVuU3RhdGUgKG5ld1BlblN0YXRlKSB7XG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgfVxuXG4gIGVxdWFscyAob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gb3RoZXIudWNoYXIgJiYgdGhpcy5wZW5TdGF0ZS5lcXVhbHMob3RoZXIucGVuU3RhdGUpO1xuICB9XG5cbiAgY29weSAobmV3Q2hhcikge1xuICAgIHRoaXMudWNoYXIgPSBuZXdDaGFyLnVjaGFyO1xuICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdDaGFyLnBlblN0YXRlKTtcbiAgfVxuXG4gIGlzRW1wdHkgKCkge1xuICAgIHJldHVybiB0aGlzLnVjaGFyID09PSAnICcgJiYgdGhpcy5wZW5TdGF0ZS5pc0RlZmF1bHQoKTtcbiAgfVxufVxuXG4vKipcbiAqIENFQS02MDggcm93IGNvbnNpc3Rpbmcgb2YgTlJfQ09MUyBpbnN0YW5jZXMgb2YgU3R5bGVkVW5pY29kZUNoYXIuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgUm93IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuY2hhcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgdGhpcy5jaGFycy5wdXNoKG5ldyBTdHlsZWRVbmljb2RlQ2hhcigpKTtcbiAgICB9XG5cbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5jdXJyUGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoKTtcbiAgfVxuXG4gIGVxdWFscyAob3RoZXIpIHtcbiAgICBsZXQgZXF1YWwgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uZXF1YWxzKG90aGVyLmNoYXJzW2ldKSkge1xuICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVxdWFsO1xuICB9XG5cbiAgY29weSAob3RoZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgdGhpcy5jaGFyc1tpXS5jb3B5KG90aGVyLmNoYXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICBpc0VtcHR5ICgpIHtcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uaXNFbXB0eSgpKSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cblxuICAvKipcbiAgICAgKiAgU2V0IHRoZSBjdXJzb3IgdG8gYSB2YWxpZCBjb2x1bW4uXG4gICAgICovXG4gIHNldEN1cnNvciAoYWJzUG9zKSB7XG4gICAgaWYgKHRoaXMucG9zICE9PSBhYnNQb3MpIHtcbiAgICAgIHRoaXMucG9zID0gYWJzUG9zO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBvcyA8IDApIHtcbiAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ05lZ2F0aXZlIGN1cnNvciBwb3NpdGlvbiAnICsgdGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wb3MgPiBOUl9DT0xTKSB7XG4gICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdUb28gbGFyZ2UgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcyA9IE5SX0NPTFM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAgICogTW92ZSB0aGUgY3Vyc29yIHJlbGF0aXZlIHRvIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICovXG4gIG1vdmVDdXJzb3IgKHJlbFBvcykge1xuICAgIGxldCBuZXdQb3MgPSB0aGlzLnBvcyArIHJlbFBvcztcbiAgICBpZiAocmVsUG9zID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMucG9zICsgMTsgaSA8IG5ld1BvcyArIDE7IGkrKykge1xuICAgICAgICB0aGlzLmNoYXJzW2ldLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZXRDdXJzb3IobmV3UG9zKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIEJhY2tzcGFjZSwgbW92ZSBvbmUgc3RlcCBiYWNrIGFuZCBjbGVhciBjaGFyYWN0ZXIuXG4gICAgICovXG4gIGJhY2tTcGFjZSAoKSB7XG4gICAgdGhpcy5tb3ZlQ3Vyc29yKC0xKTtcbiAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKCcgJywgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICB9XG5cbiAgaW5zZXJ0Q2hhciAoYnl0ZSkge1xuICAgIGlmIChieXRlID49IDB4OTApIHsgLy8gRXh0ZW5kZWQgY2hhclxuICAgICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICB9XG4gICAgbGV0IGNoYXIgPSBnZXRDaGFyRm9yQnl0ZShieXRlKTtcbiAgICBpZiAodGhpcy5wb3MgPj0gTlJfQ09MUykge1xuICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnQ2Fubm90IGluc2VydCAnICsgYnl0ZS50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAoJyArIGNoYXIgKyAnKSBhdCBwb3NpdGlvbiAnICsgdGhpcy5wb3MgKyAnLiBTa2lwcGluZyBpdCEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcihjaGFyLCB0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgdGhpcy5tb3ZlQ3Vyc29yKDEpO1xuICB9XG5cbiAgY2xlYXJGcm9tUG9zIChzdGFydFBvcykge1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IHN0YXJ0UG9zOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICB0aGlzLmNoYXJzW2ldLnJlc2V0KCk7XG4gICAgfVxuICB9XG5cbiAgY2xlYXIgKCkge1xuICAgIHRoaXMuY2xlYXJGcm9tUG9zKDApO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmN1cnJQZW5TdGF0ZS5yZXNldCgpO1xuICB9XG5cbiAgY2xlYXJUb0VuZE9mUm93ICgpIHtcbiAgICB0aGlzLmNsZWFyRnJvbVBvcyh0aGlzLnBvcyk7XG4gIH1cblxuICBnZXRUZXh0U3RyaW5nICgpIHtcbiAgICBsZXQgY2hhcnMgPSBbXTtcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICBsZXQgY2hhciA9IHRoaXMuY2hhcnNbaV0udWNoYXI7XG4gICAgICBpZiAoY2hhciAhPT0gJyAnKSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNoYXJzLnB1c2goY2hhcik7XG4gICAgfVxuICAgIGlmIChlbXB0eSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgfVxuICB9XG5cbiAgc2V0UGVuU3R5bGVzIChzdHlsZXMpIHtcbiAgICB0aGlzLmN1cnJQZW5TdGF0ZS5zZXRTdHlsZXMoc3R5bGVzKTtcbiAgICBsZXQgY3VyckNoYXIgPSB0aGlzLmNoYXJzW3RoaXMucG9zXTtcbiAgICBjdXJyQ2hhci5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBLZWVwIGEgQ0VBLTYwOCBzY3JlZW4gb2YgMzJ4MTUgc3R5bGVkIGNoYXJhY3RlcnNcbiAqIEBjb25zdHJ1Y3RvclxuKi9cbmNsYXNzIENhcHRpb25TY3JlZW4ge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5yb3dzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHRoaXMucm93cy5wdXNoKG5ldyBSb3coKSk7XG4gICAgfSAvLyBOb3RlIHRoYXQgd2UgdXNlIHplcm8tYmFzZWQgbnVtYmVyaW5nICgwLTE0KVxuXG4gICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gICAgdGhpcy5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG4gIHJlc2V0ICgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gIH1cblxuICBlcXVhbHMgKG90aGVyKSB7XG4gICAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uZXF1YWxzKG90aGVyLnJvd3NbaV0pKSB7XG4gICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXF1YWw7XG4gIH1cblxuICBjb3B5IChvdGhlcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICB0aGlzLnJvd3NbaV0uY29weShvdGhlci5yb3dzW2ldKTtcbiAgICB9XG4gIH1cblxuICBpc0VtcHR5ICgpIHtcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMucm93c1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbXB0eTtcbiAgfVxuXG4gIGJhY2tTcGFjZSAoKSB7XG4gICAgbGV0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5iYWNrU3BhY2UoKTtcbiAgfVxuXG4gIGNsZWFyVG9FbmRPZlJvdyAoKSB7XG4gICAgbGV0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5jbGVhclRvRW5kT2ZSb3coKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIEluc2VydCBhIGNoYXJhY3RlciAod2l0aG91dCBzdHlsaW5nKSBpbiB0aGUgY3VycmVudCByb3cuXG4gICAgICovXG4gIGluc2VydENoYXIgKGNoYXIpIHtcbiAgICBsZXQgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93Lmluc2VydENoYXIoY2hhcik7XG4gIH1cblxuICBzZXRQZW4gKHN0eWxlcykge1xuICAgIGxldCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuc2V0UGVuU3R5bGVzKHN0eWxlcyk7XG4gIH1cblxuICBtb3ZlQ3Vyc29yIChyZWxQb3MpIHtcbiAgICBsZXQgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93Lm1vdmVDdXJzb3IocmVsUG9zKTtcbiAgfVxuXG4gIHNldEN1cnNvciAoYWJzUG9zKSB7XG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdzZXRDdXJzb3I6ICcgKyBhYnNQb3MpO1xuICAgIGxldCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuc2V0Q3Vyc29yKGFic1Bvcyk7XG4gIH1cblxuICBzZXRQQUMgKHBhY0RhdGEpIHtcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ3BhY0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkocGFjRGF0YSkpO1xuICAgIGxldCBuZXdSb3cgPSBwYWNEYXRhLnJvdyAtIDE7XG4gICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzICYmIG5ld1JvdyA8IHRoaXMubnJSb2xsVXBSb3dzIC0gMSkge1xuICAgICAgbmV3Um93ID0gdGhpcy5uclJvbGxVcFJvd3MgLSAxO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGlzIG9ubHkgYWZmZWN0cyBSb2xsLXVwIENhcHRpb25zIGJ5IGNoZWNraW5nIHRoaXMubnJSb2xsVXBSb3dzXG4gICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzICYmIHRoaXMuY3VyclJvdyAhPT0gbmV3Um93KSB7XG4gICAgICAvLyBjbGVhciBhbGwgcm93cyBmaXJzdFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvcHkgdGhpcy5uclJvbGxVcFJvd3Mgcm93cyBmcm9tIGxhc3RPdXRwdXRTY3JlZW4gYW5kIHBsYWNlIGl0IGluIHRoZSBuZXdSb3cgbG9jYXRpb25cbiAgICAgIC8vIHRvcFJvd0luZGV4IC0gdGhlIHN0YXJ0IG9mIHJvd3MgdG8gY29weSAoaW5jbHVzaXZlIGluZGV4KVxuICAgICAgbGV0IHRvcFJvd0luZGV4ID0gdGhpcy5jdXJyUm93ICsgMSAtICh0aGlzLm5yUm9sbFVwUm93cyk7XG4gICAgICAvLyBXZSBvbmx5IGNvcHkgaWYgdGhlIGxhc3QgcG9zaXRpb24gd2FzIGFscmVhZHkgc2hvd24uXG4gICAgICAvLyBXZSB1c2UgdGhlIGN1ZVN0YXJ0VGltZSB2YWx1ZSB0byBjaGVjayB0aGlzLlxuICAgICAgY29uc3QgbGFzdE91dHB1dFNjcmVlbiA9IHRoaXMubGFzdE91dHB1dFNjcmVlbjtcbiAgICAgIGlmIChsYXN0T3V0cHV0U2NyZWVuKSB7XG4gICAgICAgIGxldCBwcmV2TGluZVRpbWUgPSBsYXN0T3V0cHV0U2NyZWVuLnJvd3NbdG9wUm93SW5kZXhdLmN1ZVN0YXJ0VGltZTtcbiAgICAgICAgaWYgKHByZXZMaW5lVGltZSAmJiBwcmV2TGluZVRpbWUgPCBsb2dnZXIudGltZSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uclJvbGxVcFJvd3M7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yb3dzW25ld1JvdyAtIHRoaXMubnJSb2xsVXBSb3dzICsgaSArIDFdLmNvcHkobGFzdE91dHB1dFNjcmVlbi5yb3dzW3RvcFJvd0luZGV4ICsgaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY3VyclJvdyA9IG5ld1JvdztcbiAgICBsZXQgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgaWYgKHBhY0RhdGEuaW5kZW50ICE9PSBudWxsKSB7XG4gICAgICBsZXQgaW5kZW50ID0gcGFjRGF0YS5pbmRlbnQ7XG4gICAgICBsZXQgcHJldlBvcyA9IE1hdGgubWF4KGluZGVudCAtIDEsIDApO1xuICAgICAgcm93LnNldEN1cnNvcihwYWNEYXRhLmluZGVudCk7XG4gICAgICBwYWNEYXRhLmNvbG9yID0gcm93LmNoYXJzW3ByZXZQb3NdLnBlblN0YXRlLmZvcmVncm91bmQ7XG4gICAgfVxuICAgIGxldCBzdHlsZXMgPSB7IGZvcmVncm91bmQ6IHBhY0RhdGEuY29sb3IsIHVuZGVybGluZTogcGFjRGF0YS51bmRlcmxpbmUsIGl0YWxpY3M6IHBhY0RhdGEuaXRhbGljcywgYmFja2dyb3VuZDogJ2JsYWNrJywgZmxhc2g6IGZhbHNlIH07XG4gICAgdGhpcy5zZXRQZW4oc3R5bGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFNldCBiYWNrZ3JvdW5kL2V4dHJhIGZvcmVncm91bmQsIGJ1dCBmaXJzdCBkbyBiYWNrX3NwYWNlLCBhbmQgdGhlbiBpbnNlcnQgc3BhY2UgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KS5cbiAgICAgKi9cbiAgc2V0QmtnRGF0YSAoYmtnRGF0YSkge1xuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnYmtnRGF0YSA9ICcgKyBKU09OLnN0cmluZ2lmeShia2dEYXRhKSk7XG4gICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICB0aGlzLnNldFBlbihia2dEYXRhKTtcbiAgICB0aGlzLmluc2VydENoYXIoMHgyMCk7IC8vIFNwYWNlXG4gIH1cblxuICBzZXRSb2xsVXBSb3dzIChuclJvd3MpIHtcbiAgICB0aGlzLm5yUm9sbFVwUm93cyA9IG5yUm93cztcbiAgfVxuXG4gIHJvbGxVcCAoKSB7XG4gICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzID09PSBudWxsKSB7XG4gICAgICBsb2dnZXIubG9nKCdERUJVRycsICdyb2xsX3VwIGJ1dCBuclJvbGxVcFJvd3Mgbm90IHNldCB5ZXQnKTtcbiAgICAgIHJldHVybjsgLy8gTm90IHByb3Blcmx5IHNldHVwXG4gICAgfVxuICAgIGxvZ2dlci5sb2coJ1RFWFQnLCB0aGlzLmdldERpc3BsYXlUZXh0KCkpO1xuICAgIGxldCB0b3BSb3dJbmRleCA9IHRoaXMuY3VyclJvdyArIDEgLSB0aGlzLm5yUm9sbFVwUm93cztcbiAgICBsZXQgdG9wUm93ID0gdGhpcy5yb3dzLnNwbGljZSh0b3BSb3dJbmRleCwgMSlbMF07XG4gICAgdG9wUm93LmNsZWFyKCk7XG4gICAgdGhpcy5yb3dzLnNwbGljZSh0aGlzLmN1cnJSb3csIDAsIHRvcFJvdyk7XG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdSb2xsaW5nIHVwJyk7XG4gICAgLy8gbG9nZ2VyLmxvZygnVEVYVCcsIHRoaXMuZ2V0X2Rpc3BsYXlfdGV4dCgpKVxuICB9XG5cbiAgLyoqXG4gICAgKiBHZXQgYWxsIG5vbi1lbXB0eSByb3dzIHdpdGggYXMgdW5pY29kZSB0ZXh0LlxuICAgICovXG4gIGdldERpc3BsYXlUZXh0IChhc09uZVJvdykge1xuICAgIGFzT25lUm93ID0gYXNPbmVSb3cgfHwgZmFsc2U7XG4gICAgbGV0IGRpc3BsYXlUZXh0ID0gW107XG4gICAgbGV0IHRleHQgPSAnJztcbiAgICBsZXQgcm93TnIgPSAtMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgbGV0IHJvd1RleHQgPSB0aGlzLnJvd3NbaV0uZ2V0VGV4dFN0cmluZygpO1xuICAgICAgaWYgKHJvd1RleHQpIHtcbiAgICAgICAgcm93TnIgPSBpICsgMTtcbiAgICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgICAgZGlzcGxheVRleHQucHVzaCgnUm93ICcgKyByb3dOciArICc6IFxcJycgKyByb3dUZXh0ICsgJ1xcJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpc3BsYXlUZXh0LnB1c2gocm93VGV4dC50cmltKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkaXNwbGF5VGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoYXNPbmVSb3cpIHtcbiAgICAgICAgdGV4dCA9ICdbJyArIGRpc3BsYXlUZXh0LmpvaW4oJyB8ICcpICsgJ10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGRpc3BsYXlUZXh0LmpvaW4oJ1xcbicpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIGdldFRleHRBbmRGb3JtYXQgKCkge1xuICAgIHJldHVybiB0aGlzLnJvd3M7XG4gIH1cbn1cblxuLy8gdmFyIG1vZGVzID0gWydNT0RFX1JPTEwtVVAnLCAnTU9ERV9QT1AtT04nLCAnTU9ERV9QQUlOVC1PTicsICdNT0RFX1RFWFQnXTtcblxuY2xhc3MgQ2VhNjA4Q2hhbm5lbCB7XG4gIGNvbnN0cnVjdG9yIChjaGFubmVsTnVtYmVyLCBvdXRwdXRGaWx0ZXIpIHtcbiAgICB0aGlzLmNoTnIgPSBjaGFubmVsTnVtYmVyO1xuICAgIHRoaXMub3V0cHV0RmlsdGVyID0gb3V0cHV0RmlsdGVyO1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy52ZXJib3NlID0gMDtcbiAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKCk7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IG5ldyBDYXB0aW9uU2NyZWVuKCk7XG4gICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsOyAvLyBLZWVwcyB0cmFjayBvZiB3aGVyZSBhIGN1ZSBzdGFydGVkLlxuICB9XG5cbiAgcmVzZXQgKCkge1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5yZXNldCgpO1xuICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LnJvd3NbTlJfUk9XUyAtIDFdO1xuICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gbnVsbDtcbiAgICB0aGlzLmxhc3RDdWVFbmRUaW1lID0gbnVsbDtcbiAgfVxuXG4gIGdldEhhbmRsZXIgKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dEZpbHRlcjtcbiAgfVxuXG4gIHNldEhhbmRsZXIgKG5ld0hhbmRsZXIpIHtcbiAgICB0aGlzLm91dHB1dEZpbHRlciA9IG5ld0hhbmRsZXI7XG4gIH1cblxuICBzZXRQQUMgKHBhY0RhdGEpIHtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBBQyhwYWNEYXRhKTtcbiAgfVxuXG4gIHNldEJrZ0RhdGEgKGJrZ0RhdGEpIHtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldEJrZ0RhdGEoYmtnRGF0YSk7XG4gIH1cblxuICBzZXRNb2RlIChuZXdNb2RlKSB7XG4gICAgaWYgKG5ld01vZGUgPT09IHRoaXMubW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdNT0RFPScgKyBuZXdNb2RlKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4ucmVzZXQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9kZSAhPT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICB9XG5cbiAgaW5zZXJ0Q2hhcnMgKGNoYXJzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53cml0ZVNjcmVlbi5pbnNlcnRDaGFyKGNoYXJzW2ldKTtcbiAgICB9XG5cbiAgICBsZXQgc2NyZWVuID0gdGhpcy53cml0ZVNjcmVlbiA9PT0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPyAnRElTUCcgOiAnTk9OX0RJU1AnO1xuICAgIGxvZ2dlci5sb2coJ0lORk8nLCBzY3JlZW4gKyAnOiAnICsgdGhpcy53cml0ZVNjcmVlbi5nZXREaXNwbGF5VGV4dCh0cnVlKSk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUEFJTlQtT04nIHx8IHRoaXMubW9kZSA9PT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCAnRElTUExBWUVEOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xuICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgY2NSQ0wgKCkgeyAvLyBSZXN1bWUgQ2FwdGlvbiBMb2FkaW5nIChzd2l0Y2ggbW9kZSB0byBQb3AgT24pXG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdSQ0wgLSBSZXN1bWUgQ2FwdGlvbiBMb2FkaW5nJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BPUC1PTicpO1xuICB9XG5cbiAgY2NCUyAoKSB7IC8vIEJhY2tTcGFjZVxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnQlMgLSBCYWNrU3BhY2UnKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9URVhUJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMud3JpdGVTY3JlZW4uYmFja1NwYWNlKCk7XG4gICAgaWYgKHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5KSB7XG4gICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBjY0FPRiAoKSB7IC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPZmYpXG5cbiAgfVxuXG4gIGNjQU9OICgpIHsgLy8gUmVzZXJ2ZWQgKGZvcm1lcmx5IEFsYXJtIE9uKVxuXG4gIH1cblxuICBjY0RFUiAoKSB7IC8vIERlbGV0ZSB0byBFbmQgb2YgUm93XG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdERVItIERlbGV0ZSB0byBFbmQgb2YgUm93Jyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5jbGVhclRvRW5kT2ZSb3coKTtcbiAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgfVxuXG4gIGNjUlUgKG5yUm93cykgeyAvLyBSb2xsLVVwIENhcHRpb25zLTIsMyxvciA0IFJvd3NcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JVKCcgKyBuclJvd3MgKyAnKSAtIFJvbGwgVXAnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1JPTEwtVVAnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFJvbGxVcFJvd3MobnJSb3dzKTtcbiAgfVxuXG4gIGNjRk9OICgpIHsgLy8gRmxhc2ggT25cbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0ZPTiAtIEZsYXNoIE9uJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQZW4oeyBmbGFzaDogdHJ1ZSB9KTtcbiAgfVxuXG4gIGNjUkRDICgpIHsgLy8gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nIChzd2l0Y2ggbW9kZSB0byBQYWludE9uKVxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUkRDIC0gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BBSU5ULU9OJyk7XG4gIH1cblxuICBjY1RSICgpIHsgLy8gVGV4dCBSZXN0YXJ0IGluIHRleHQgbW9kZSAobm90IHN1cHBvcnRlZCwgaG93ZXZlcilcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1RSJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcbiAgfVxuXG4gIGNjUlREICgpIHsgLy8gUmVzdW1lIFRleHQgRGlzcGxheSBpbiBUZXh0IG1vZGUgKG5vdCBzdXBwb3J0ZWQsIGhvd2V2ZXIpXG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdSVEQnKTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICB9XG5cbiAgY2NFRE0gKCkgeyAvLyBFcmFzZSBEaXNwbGF5ZWQgTWVtb3J5XG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdFRE0gLSBFcmFzZSBEaXNwbGF5ZWQgTWVtb3J5Jyk7XG4gICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUodHJ1ZSk7XG4gIH1cblxuICBjY0NSICgpIHsgLy8gQ2FycmlhZ2UgUmV0dXJuXG4gICAgbG9nZ2VyLmxvZygnQ1IgLSBDYXJyaWFnZSBSZXR1cm4nKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnJvbGxVcCgpO1xuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgfVxuXG4gIGNjRU5NICgpIHsgLy8gRXJhc2UgTm9uLURpc3BsYXllZCBNZW1vcnlcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0VOTSAtIEVyYXNlIE5vbi1kaXNwbGF5ZWQgTWVtb3J5Jyk7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgfVxuXG4gIGNjRU9DICgpIHsgLy8gRW5kIG9mIENhcHRpb24gKEZsaXAgTWVtb3JpZXMpXG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdFT0MgLSBFbmQgT2YgQ2FwdGlvbicpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgIGxldCB0bXAgPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IHRtcDtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCAnRElTUDogJyArIHRoaXMuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KCkpO1xuICAgIH1cbiAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUodHJ1ZSk7XG4gIH1cblxuICBjY1RPIChuckNvbHMpIHsgLy8gVGFiIE9mZnNldCAxLDIsIG9yIDMgY29sdW1uc1xuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnVE8oJyArIG5yQ29scyArICcpIC0gVGFiIE9mZnNldCcpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4ubW92ZUN1cnNvcihuckNvbHMpO1xuICB9XG5cbiAgY2NNSURST1cgKHNlY29uZEJ5dGUpIHsgLy8gUGFyc2UgTUlEUk9XIGNvbW1hbmRcbiAgICBsZXQgc3R5bGVzID0geyBmbGFzaDogZmFsc2UgfTtcbiAgICBzdHlsZXMudW5kZXJsaW5lID0gc2Vjb25kQnl0ZSAlIDIgPT09IDE7XG4gICAgc3R5bGVzLml0YWxpY3MgPSBzZWNvbmRCeXRlID49IDB4MmU7XG4gICAgaWYgKCFzdHlsZXMuaXRhbGljcykge1xuICAgICAgbGV0IGNvbG9ySW5kZXggPSBNYXRoLmZsb29yKHNlY29uZEJ5dGUgLyAyKSAtIDB4MTA7XG4gICAgICBsZXQgY29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJ107XG4gICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9IGNvbG9yc1tjb2xvckluZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xuICAgIH1cbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ01JRFJPVzogJyArIEpTT04uc3RyaW5naWZ5KHN0eWxlcykpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHN0eWxlcyk7XG4gIH1cblxuICBvdXRwdXREYXRhVXBkYXRlIChkaXNwYXRjaCA9IGZhbHNlKSB7XG4gICAgbGV0IHQgPSBsb2dnZXIudGltZTtcbiAgICBpZiAodCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgaWYgKHRoaXMuY3VlU3RhcnRUaW1lID09PSBudWxsICYmICF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHsgLy8gU3RhcnQgb2YgYSBuZXcgY3VlXG4gICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZXF1YWxzKHRoaXMubGFzdE91dHB1dFNjcmVlbikpIHtcbiAgICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHQsIHRoaXMubGFzdE91dHB1dFNjcmVlbik7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2ggPT09IHRydWUgJiYgdGhpcy5vdXRwdXRGaWx0ZXIuZGlzcGF0Y2hDdWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIuZGlzcGF0Y2hDdWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkgPyBudWxsIDogdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuLmNvcHkodGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xuICAgIH1cbiAgfVxuXG4gIGN1ZVNwbGl0QXRUaW1lICh0KSB7XG4gICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyKSB7XG4gICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkge1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XG4gICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0LCB0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIENlYTYwOFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yIChmaWVsZCwgb3V0MSwgb3V0Mikge1xuICAgIHRoaXMuZmllbGQgPSBmaWVsZCB8fCAxO1xuICAgIHRoaXMub3V0cHV0cyA9IFtvdXQxLCBvdXQyXTtcbiAgICB0aGlzLmNoYW5uZWxzID0gW25ldyBDZWE2MDhDaGFubmVsKDEsIG91dDEpLCBuZXcgQ2VhNjA4Q2hhbm5lbCgyLCBvdXQyKV07XG4gICAgdGhpcy5jdXJyQ2hOciA9IC0xOyAvLyBXaWxsIGJlIDEgb3IgMlxuICAgIHRoaXMubGFzdENtZEEgPSBudWxsOyAvLyBGaXJzdCBieXRlIG9mIGxhc3QgY29tbWFuZFxuICAgIHRoaXMubGFzdENtZEIgPSBudWxsOyAvLyBTZWNvbmQgYnl0ZSBvZiBsYXN0IGNvbW1hbmRcbiAgICB0aGlzLmJ1ZmZlcmVkRGF0YSA9IFtdO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUaW1lID0gbnVsbDtcbiAgICB0aGlzLmRhdGFDb3VudGVycyA9IHsgJ3BhZGRpbmcnOiAwLCAnY2hhcic6IDAsICdjbWQnOiAwLCAnb3RoZXInOiAwIH07XG4gIH1cblxuICBnZXRIYW5kbGVyIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWxzW2luZGV4XS5nZXRIYW5kbGVyKCk7XG4gIH1cblxuICBzZXRIYW5kbGVyIChpbmRleCwgbmV3SGFuZGxlcikge1xuICAgIHRoaXMuY2hhbm5lbHNbaW5kZXhdLnNldEhhbmRsZXIobmV3SGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICAgKiBBZGQgZGF0YSBmb3IgdGltZSB0IGluIGZvcm1zIG9mIGxpc3Qgb2YgYnl0ZXMgKHVuc2lnbmVkIGludHMpLiBUaGUgYnl0ZXMgYXJlIHRyZWF0ZWQgYXMgcGFpcnMuXG4gICAgICovXG4gIGFkZERhdGEgKHQsIGJ5dGVMaXN0KSB7XG4gICAgbGV0IGNtZEZvdW5kLCBhLCBiLFxuICAgICAgY2hhcnNGb3VuZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5sYXN0VGltZSA9IHQ7XG4gICAgbG9nZ2VyLnNldFRpbWUodCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVMaXN0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBhID0gYnl0ZUxpc3RbaV0gJiAweDdmO1xuICAgICAgYiA9IGJ5dGVMaXN0W2kgKyAxXSAmIDB4N2Y7XG4gICAgICBpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XG4gICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLnBhZGRpbmcgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIubG9nKCdEQVRBJywgJ1snICsgbnVtQXJyYXlUb0hleEFycmF5KFtieXRlTGlzdFtpXSwgYnl0ZUxpc3RbaSArIDFdXSkgKyAnXSAtPiAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyknKTtcbiAgICAgIH1cbiAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZUNtZChhLCBiKTtcbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlTWlkcm93KGEsIGIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZVBBQyhhLCBiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyhhLCBiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICBjaGFyc0ZvdW5kID0gdGhpcy5wYXJzZUNoYXJzKGEsIGIpO1xuICAgICAgICBpZiAoY2hhcnNGb3VuZCkge1xuICAgICAgICAgIGlmICh0aGlzLmN1cnJDaE5yICYmIHRoaXMuY3VyckNoTnIgPj0gMCkge1xuICAgICAgICAgICAgbGV0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW3RoaXMuY3VyckNoTnIgLSAxXTtcbiAgICAgICAgICAgIGNoYW5uZWwuaW5zZXJ0Q2hhcnMoY2hhcnNGb3VuZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1dBUk5JTkcnLCAnTm8gY2hhbm5lbCBmb3VuZCB5ZXQuIFRFWFQtTU9ERT8nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjbWRGb3VuZCkge1xuICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5jbWQgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoY2hhcnNGb3VuZCkge1xuICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5jaGFyICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5vdGhlciArPSAyO1xuICAgICAgICBsb2dnZXIubG9nKCdXQVJOSU5HJywgJ0NvdWxkblxcJ3QgcGFyc2UgY2xlYW5lZCBkYXRhICcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBvcmlnOiAnICsgbnVtQXJyYXlUb0hleEFycmF5KFtieXRlTGlzdFtpXSwgYnl0ZUxpc3RbaSArIDFdXSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgICAqIFBhcnNlIENvbW1hbmQuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIGEgY29tbWFuZCB3YXMgZm91bmRcbiAgICAgKi9cbiAgcGFyc2VDbWQgKGEsIGIpIHtcbiAgICBsZXQgY2hOciA9IG51bGw7XG5cbiAgICBsZXQgY29uZDEgPSAoYSA9PT0gMHgxNCB8fCBhID09PSAweDFDKSAmJiAoYiA+PSAweDIwICYmIGIgPD0gMHgyRik7XG4gICAgbGV0IGNvbmQyID0gKGEgPT09IDB4MTcgfHwgYSA9PT0gMHgxRikgJiYgKGIgPj0gMHgyMSAmJiBiIDw9IDB4MjMpO1xuICAgIGlmICghKGNvbmQxIHx8IGNvbmQyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChhID09PSB0aGlzLmxhc3RDbWRBICYmIGIgPT09IHRoaXMubGFzdENtZEIpIHtcbiAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7IC8vIFJlcGVhdGVkIGNvbW1hbmRzIGFyZSBkcm9wcGVkIChvbmNlKVxuICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAnUmVwZWF0ZWQgY29tbWFuZCAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJykgaXMgZHJvcHBlZCcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxNykge1xuICAgICAgY2hOciA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoTnIgPSAyO1xuICAgIH0gLy8gKGEgPT09IDB4MUMgfHwgYT09PSAweDFmKVxuXG4gICAgbGV0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnIgLSAxXTtcblxuICAgIGlmIChhID09PSAweDE0IHx8IGEgPT09IDB4MUMpIHtcbiAgICAgIGlmIChiID09PSAweDIwKSB7XG4gICAgICAgIGNoYW5uZWwuY2NSQ0woKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMSkge1xuICAgICAgICBjaGFubmVsLmNjQlMoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMikge1xuICAgICAgICBjaGFubmVsLmNjQU9GKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjMpIHtcbiAgICAgICAgY2hhbm5lbC5jY0FPTigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI0KSB7XG4gICAgICAgIGNoYW5uZWwuY2NERVIoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNSkge1xuICAgICAgICBjaGFubmVsLmNjUlUoMik7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjYpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JVKDMpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI3KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVSg0KTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOCkge1xuICAgICAgICBjaGFubmVsLmNjRk9OKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjkpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JEQygpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJBKSB7XG4gICAgICAgIGNoYW5uZWwuY2NUUigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJCKSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVEQoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyQykge1xuICAgICAgICBjaGFubmVsLmNjRURNKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkQpIHtcbiAgICAgICAgY2hhbm5lbC5jY0NSKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkUpIHtcbiAgICAgICAgY2hhbm5lbC5jY0VOTSgpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJGKSB7XG4gICAgICAgIGNoYW5uZWwuY2NFT0MoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBhID09IDB4MTcgfHwgYSA9PSAweDFGXG4gICAgICBjaGFubmVsLmNjVE8oYiAtIDB4MjApO1xuICAgIH1cbiAgICB0aGlzLmxhc3RDbWRBID0gYTtcbiAgICB0aGlzLmxhc3RDbWRCID0gYjtcbiAgICB0aGlzLmN1cnJDaE5yID0gY2hOcjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFBhcnNlIG1pZHJvdyBzdHlsaW5nIGNvbW1hbmRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgcGFyc2VNaWRyb3cgKGEsIGIpIHtcbiAgICBsZXQgY2hOciA9IG51bGw7XG5cbiAgICBpZiAoKChhID09PSAweDExKSB8fCAoYSA9PT0gMHgxOSkpICYmIGIgPj0gMHgyMCAmJiBiIDw9IDB4MmYpIHtcbiAgICAgIGlmIChhID09PSAweDExKSB7XG4gICAgICAgIGNoTnIgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hOciA9IDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaE5yICE9PSB0aGlzLmN1cnJDaE5yKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ01pc21hdGNoIGNoYW5uZWwgaW4gbWlkcm93IHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbGV0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnIgLSAxXTtcbiAgICAgIGNoYW5uZWwuY2NNSURST1coYik7XG4gICAgICBsb2dnZXIubG9nKCdERUJVRycsICdNSURST1cgKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgICAqIFBhcnNlIFByZWFibGUgQWNjZXNzIENvZGVzIChUYWJsZSA1MykuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIFBBQyBmb3VuZFxuICAgICAqL1xuICBwYXJzZVBBQyAoYSwgYikge1xuICAgIGxldCBjaE5yID0gbnVsbDtcbiAgICBsZXQgcm93ID0gbnVsbDtcblxuICAgIGxldCBjYXNlMSA9ICgoYSA+PSAweDExICYmIGEgPD0gMHgxNykgfHwgKGEgPj0gMHgxOSAmJiBhIDw9IDB4MUYpKSAmJiAoYiA+PSAweDQwICYmIGIgPD0gMHg3Rik7XG4gICAgbGV0IGNhc2UyID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgKGIgPj0gMHg0MCAmJiBiIDw9IDB4NUYpO1xuICAgIGlmICghKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChhID09PSB0aGlzLmxhc3RDbWRBICYmIGIgPT09IHRoaXMubGFzdENtZEIpIHtcbiAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gUmVwZWF0ZWQgY29tbWFuZHMgYXJlIGRyb3BwZWQgKG9uY2UpXG4gICAgfVxuXG4gICAgY2hOciA9IChhIDw9IDB4MTcpID8gMSA6IDI7XG5cbiAgICBpZiAoYiA+PSAweDQwICYmIGIgPD0gMHg1Rikge1xuICAgICAgcm93ID0gKGNoTnIgPT09IDEpID8gcm93c0xvd0NoMVthXSA6IHJvd3NMb3dDaDJbYV07XG4gICAgfSBlbHNlIHsgLy8gMHg2MCA8PSBiIDw9IDB4N0ZcbiAgICAgIHJvdyA9IChjaE5yID09PSAxKSA/IHJvd3NIaWdoQ2gxW2FdIDogcm93c0hpZ2hDaDJbYV07XG4gICAgfVxuICAgIGxldCBwYWNEYXRhID0gdGhpcy5pbnRlcnByZXRQQUMocm93LCBiKTtcbiAgICBsZXQgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOciAtIDFdO1xuICAgIGNoYW5uZWwuc2V0UEFDKHBhY0RhdGEpO1xuICAgIHRoaXMubGFzdENtZEEgPSBhO1xuICAgIHRoaXMubGFzdENtZEIgPSBiO1xuICAgIHRoaXMuY3VyckNoTnIgPSBjaE5yO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAgICogSW50ZXJwcmV0IHRoZSBzZWNvbmQgYnl0ZSBvZiB0aGUgcGFjLCBhbmQgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBwYWNEYXRhIHdpdGggc3R5bGUgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgaW50ZXJwcmV0UEFDIChyb3csIGJ5dGUpIHtcbiAgICBsZXQgcGFjSW5kZXggPSBieXRlO1xuICAgIGxldCBwYWNEYXRhID0geyBjb2xvcjogbnVsbCwgaXRhbGljczogZmFsc2UsIGluZGVudDogbnVsbCwgdW5kZXJsaW5lOiBmYWxzZSwgcm93OiByb3cgfTtcblxuICAgIGlmIChieXRlID4gMHg1Rikge1xuICAgICAgcGFjSW5kZXggPSBieXRlIC0gMHg2MDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFjSW5kZXggPSBieXRlIC0gMHg0MDtcbiAgICB9XG5cbiAgICBwYWNEYXRhLnVuZGVybGluZSA9IChwYWNJbmRleCAmIDEpID09PSAxO1xuICAgIGlmIChwYWNJbmRleCA8PSAweGQpIHtcbiAgICAgIHBhY0RhdGEuY29sb3IgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnLCAnd2hpdGUnXVtNYXRoLmZsb29yKHBhY0luZGV4IC8gMildO1xuICAgIH0gZWxzZSBpZiAocGFjSW5kZXggPD0gMHhmKSB7XG4gICAgICBwYWNEYXRhLml0YWxpY3MgPSB0cnVlO1xuICAgICAgcGFjRGF0YS5jb2xvciA9ICd3aGl0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY0RhdGEuaW5kZW50ID0gKE1hdGguZmxvb3IoKHBhY0luZGV4IC0gMHgxMCkgLyAyKSkgKiA0O1xuICAgIH1cbiAgICByZXR1cm4gcGFjRGF0YTsgLy8gTm90ZSB0aGF0IHJvdyBoYXMgemVybyBvZmZzZXQuIFRoZSBzcGVjIHVzZXMgMS5cbiAgfVxuXG4gIC8qKlxuICAgICAqIFBhcnNlIGNoYXJhY3RlcnMuXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCAxIHRvIDIgY29kZXMgY29ycmVzcG9uZGluZyB0byBjaGFycywgaWYgZm91bmQuIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICBwYXJzZUNoYXJzIChhLCBiKSB7XG4gICAgbGV0IGNoYW5uZWxOciA9IG51bGwsXG4gICAgICBjaGFyQ29kZXMgPSBudWxsLFxuICAgICAgY2hhckNvZGUxID0gbnVsbDtcblxuICAgIGlmIChhID49IDB4MTkpIHtcbiAgICAgIGNoYW5uZWxOciA9IDI7XG4gICAgICBjaGFyQ29kZTEgPSBhIC0gODtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbm5lbE5yID0gMTtcbiAgICAgIGNoYXJDb2RlMSA9IGE7XG4gICAgfVxuICAgIGlmIChjaGFyQ29kZTEgPj0gMHgxMSAmJiBjaGFyQ29kZTEgPD0gMHgxMykge1xuICAgICAgLy8gU3BlY2lhbCBjaGFyYWN0ZXJcbiAgICAgIGxldCBvbmVDb2RlID0gYjtcbiAgICAgIGlmIChjaGFyQ29kZTEgPT09IDB4MTEpIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDUwO1xuICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZTEgPT09IDB4MTIpIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDcwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDkwO1xuICAgICAgfVxuXG4gICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1NwZWNpYWwgY2hhciBcXCcnICsgZ2V0Q2hhckZvckJ5dGUob25lQ29kZSkgKyAnXFwnIGluIGNoYW5uZWwgJyArIGNoYW5uZWxOcik7XG4gICAgICBjaGFyQ29kZXMgPSBbb25lQ29kZV07XG4gICAgfSBlbHNlIGlmIChhID49IDB4MjAgJiYgYSA8PSAweDdmKSB7XG4gICAgICBjaGFyQ29kZXMgPSAoYiA9PT0gMCkgPyBbYV0gOiBbYSwgYl07XG4gICAgfVxuICAgIGlmIChjaGFyQ29kZXMpIHtcbiAgICAgIGxldCBoZXhDb2RlcyA9IG51bUFycmF5VG9IZXhBcnJheShjaGFyQ29kZXMpO1xuICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAnQ2hhciBjb2RlcyA9ICAnICsgaGV4Q29kZXMuam9pbignLCcpKTtcbiAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjaGFyQ29kZXM7XG4gIH1cblxuICAvKipcbiAgICAqIFBhcnNlIGV4dGVuZGVkIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcyB3ZWxsIGFzIG5ldyBmb3JlZ3JvdW5kIGNvbG9yIGJsYWNrLlxuICAgICogQHJldHVybnN7Qm9vbGVhbn0gVGVsbHMgaWYgYmFja2dyb3VuZCBhdHRyaWJ1dGVzIGFyZSBmb3VuZFxuICAgICovXG4gIHBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMgKGEsIGIpIHtcbiAgICBsZXQgYmtnRGF0YSxcbiAgICAgIGluZGV4LFxuICAgICAgY2hOcixcbiAgICAgIGNoYW5uZWw7XG5cbiAgICBsZXQgY2FzZTEgPSAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSAmJiAoYiA+PSAweDIwICYmIGIgPD0gMHgyZik7XG4gICAgbGV0IGNhc2UyID0gKGEgPT09IDB4MTcgfHwgYSA9PT0gMHgxZikgJiYgKGIgPj0gMHgyZCAmJiBiIDw9IDB4MmYpO1xuICAgIGlmICghKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGJrZ0RhdGEgPSB7fTtcbiAgICBpZiAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSB7XG4gICAgICBpbmRleCA9IE1hdGguZmxvb3IoKGIgLSAweDIwKSAvIDIpO1xuICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZENvbG9yc1tpbmRleF07XG4gICAgICBpZiAoYiAlIDIgPT09IDEpIHtcbiAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmtnRGF0YS5iYWNrZ3JvdW5kICsgJ19zZW1pJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJrZ0RhdGEuZm9yZWdyb3VuZCA9ICdibGFjayc7XG4gICAgICBpZiAoYiA9PT0gMHgyZikge1xuICAgICAgICBia2dEYXRhLnVuZGVybGluZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNoTnIgPSAoYSA8IDB4MTgpID8gMSA6IDI7XG4gICAgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOciAtIDFdO1xuICAgIGNoYW5uZWwuc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFJlc2V0IHN0YXRlIG9mIHBhcnNlciBhbmQgaXRzIGNoYW5uZWxzLlxuICAgICAqL1xuICByZXNldCAoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5jaGFubmVsc1tpXSkge1xuICAgICAgICB0aGlzLmNoYW5uZWxzW2ldLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAgICogVHJpZ2dlciB0aGUgZ2VuZXJhdGlvbiBvZiBhIGN1ZSwgYW5kIHRoZSBzdGFydCBvZiBhIG5ldyBvbmUgaWYgZGlzcGxheVNjcmVlbnMgYXJlIG5vdCBlbXB0eS5cbiAgICAgKi9cbiAgY3VlU3BsaXRBdFRpbWUgKHQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNoYW5uZWxzW2ldKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbHNbaV0uY3VlU3BsaXRBdFRpbWUodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENlYTYwOFBhcnNlcjtcbiIsIi8vIGZyb20gaHR0cDovL21wNHJhLm9yZy9jb2RlY3MuaHRtbFxuY29uc3Qgc2FtcGxlRW50cnlDb2Rlc0lTTyA9IHtcbiAgYXVkaW86IHtcbiAgICAnYTNkcyc6IHRydWUsXG4gICAgJ2FjLTMnOiB0cnVlLFxuICAgICdhYy00JzogdHJ1ZSxcbiAgICAnYWxhYyc6IHRydWUsXG4gICAgJ2FsYXcnOiB0cnVlLFxuICAgICdkcmExJzogdHJ1ZSxcbiAgICAnZHRzKyc6IHRydWUsXG4gICAgJ2R0cy0nOiB0cnVlLFxuICAgICdkdHNjJzogdHJ1ZSxcbiAgICAnZHRzZSc6IHRydWUsXG4gICAgJ2R0c2gnOiB0cnVlLFxuICAgICdlYy0zJzogdHJ1ZSxcbiAgICAnZW5jYSc6IHRydWUsXG4gICAgJ2c3MTknOiB0cnVlLFxuICAgICdnNzI2JzogdHJ1ZSxcbiAgICAnbTRhZSc6IHRydWUsXG4gICAgJ21oYTEnOiB0cnVlLFxuICAgICdtaGEyJzogdHJ1ZSxcbiAgICAnbWhtMSc6IHRydWUsXG4gICAgJ21obTInOiB0cnVlLFxuICAgICdtbHBhJzogdHJ1ZSxcbiAgICAnbXA0YSc6IHRydWUsXG4gICAgJ3JhdyAnOiB0cnVlLFxuICAgICdPcHVzJzogdHJ1ZSxcbiAgICAnc2Ftcic6IHRydWUsXG4gICAgJ3Nhd2InOiB0cnVlLFxuICAgICdzYXdwJzogdHJ1ZSxcbiAgICAnc2V2Yyc6IHRydWUsXG4gICAgJ3NxY3AnOiB0cnVlLFxuICAgICdzc212JzogdHJ1ZSxcbiAgICAndHdvcyc6IHRydWUsXG4gICAgJ3VsYXcnOiB0cnVlXG4gIH0sXG4gIHZpZGVvOiB7XG4gICAgJ2F2YzEnOiB0cnVlLFxuICAgICdhdmMyJzogdHJ1ZSxcbiAgICAnYXZjMyc6IHRydWUsXG4gICAgJ2F2YzQnOiB0cnVlLFxuICAgICdhdmNwJzogdHJ1ZSxcbiAgICAnZHJhYyc6IHRydWUsXG4gICAgJ2R2YXYnOiB0cnVlLFxuICAgICdkdmhlJzogdHJ1ZSxcbiAgICAnZW5jdic6IHRydWUsXG4gICAgJ2hldjEnOiB0cnVlLFxuICAgICdodmMxJzogdHJ1ZSxcbiAgICAnbWpwMic6IHRydWUsXG4gICAgJ21wNHYnOiB0cnVlLFxuICAgICdtdmMxJzogdHJ1ZSxcbiAgICAnbXZjMic6IHRydWUsXG4gICAgJ212YzMnOiB0cnVlLFxuICAgICdtdmM0JzogdHJ1ZSxcbiAgICAncmVzdic6IHRydWUsXG4gICAgJ3J2NjAnOiB0cnVlLFxuICAgICdzMjYzJzogdHJ1ZSxcbiAgICAnc3ZjMSc6IHRydWUsXG4gICAgJ3N2YzInOiB0cnVlLFxuICAgICd2Yy0xJzogdHJ1ZSxcbiAgICAndnAwOCc6IHRydWUsXG4gICAgJ3ZwMDknOiB0cnVlXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzQ29kZWNUeXBlIChjb2RlYywgdHlwZSkge1xuICBjb25zdCB0eXBlQ29kZXMgPSBzYW1wbGVFbnRyeUNvZGVzSVNPW3R5cGVdO1xuICByZXR1cm4gISF0eXBlQ29kZXMgJiYgdHlwZUNvZGVzW2NvZGVjLnNsaWNlKDAsIDQpXSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNDb2RlY1N1cHBvcnRlZEluTXA0IChjb2RlYywgdHlwZSkge1xuICByZXR1cm4gd2luZG93Lk1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZChgJHt0eXBlIHx8ICd2aWRlbyd9L21wNDtjb2RlY3M9XCIke2NvZGVjfVwiYCk7XG59XG5cbmV4cG9ydCB7IGlzQ29kZWNUeXBlLCBpc0NvZGVjU3VwcG9ydGVkSW5NcDQgfTtcbiIsImltcG9ydCB7IGZpeExpbmVCcmVha3MgfSBmcm9tICcuL3Z0dHBhcnNlcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXdDdWUgKHRyYWNrLCBzdGFydFRpbWUsIGVuZFRpbWUsIGNhcHRpb25TY3JlZW4pIHtcbiAgbGV0IHJvdztcbiAgbGV0IGN1ZTtcbiAgbGV0IGluZGVudGluZztcbiAgbGV0IGluZGVudDtcbiAgbGV0IHRleHQ7XG4gIGxldCBWVFRDdWUgPSB3aW5kb3cuVlRUQ3VlIHx8IHdpbmRvdy5UZXh0VHJhY2tDdWU7XG5cbiAgZm9yIChsZXQgciA9IDA7IHIgPCBjYXB0aW9uU2NyZWVuLnJvd3MubGVuZ3RoOyByKyspIHtcbiAgICByb3cgPSBjYXB0aW9uU2NyZWVuLnJvd3Nbcl07XG4gICAgaW5kZW50aW5nID0gdHJ1ZTtcbiAgICBpbmRlbnQgPSAwO1xuICAgIHRleHQgPSAnJztcblxuICAgIGlmICghcm93LmlzRW1wdHkoKSkge1xuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCByb3cuY2hhcnMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgaWYgKHJvdy5jaGFyc1tjXS51Y2hhci5tYXRjaCgvXFxzLykgJiYgaW5kZW50aW5nKSB7XG4gICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCArPSByb3cuY2hhcnNbY10udWNoYXI7XG4gICAgICAgICAgaW5kZW50aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFRvIGJlIHVzZWQgZm9yIGNsZWFuaW5nLXVwIG9ycGhhbmVkIHJvbGwtdXAgY2FwdGlvbnNcbiAgICAgIHJvdy5jdWVTdGFydFRpbWUgPSBzdGFydFRpbWU7XG5cbiAgICAgIC8vIEdpdmUgYSBzbGlnaHQgYnVtcCB0byB0aGUgZW5kVGltZSBpZiBpdCdzIGVxdWFsIHRvIHN0YXJ0VGltZSB0byBhdm9pZCBhIFN5bnRheEVycm9yIGluIElFXG4gICAgICBpZiAoc3RhcnRUaW1lID09PSBlbmRUaW1lKSB7XG4gICAgICAgIGVuZFRpbWUgKz0gMC4wMDAxO1xuICAgICAgfVxuXG4gICAgICBjdWUgPSBuZXcgVlRUQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgZml4TGluZUJyZWFrcyh0ZXh0LnRyaW0oKSkpO1xuXG4gICAgICBpZiAoaW5kZW50ID49IDE2KSB7XG4gICAgICAgIGluZGVudC0tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZW50Kys7XG4gICAgICB9XG5cbiAgICAgIC8vIFZUVEN1ZS5saW5lIGdldCdzIGZsYWtleSB3aGVuIHVzaW5nIGNvbnRyb2xzLCBzbyBsZXQncyBub3cgaW5jbHVkZSBsaW5lIDEzJjE0XG4gICAgICAvLyBhbHNvLCBkcm9wIGxpbmUgMSBzaW5jZSBpdCdzIHRvIGNsb3NlIHRvIHRoZSB0b3BcbiAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvLykpIHtcbiAgICAgICAgY3VlLmxpbmUgPSByICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1ZS5saW5lID0gKHIgPiA3ID8gciAtIDIgOiByICsgMSk7XG4gICAgICB9XG5cbiAgICAgIGN1ZS5hbGlnbiA9ICdsZWZ0JztcbiAgICAgIC8vIENsYW1wIHRoZSBwb3NpdGlvbiBiZXR3ZWVuIDAgYW5kIDEwMCAtIGlmIG91dCBvZiB0aGVzZSBib3VuZHMsIEZpcmVmb3ggdGhyb3dzIGFuIGV4Y2VwdGlvbiBhbmQgY2FwdGlvbnMgYnJlYWtcbiAgICAgIGN1ZS5wb3NpdGlvbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgMTAwICogKGluZGVudCAvIDMyKSArIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvLykgPyA1MCA6IDApKSk7XG4gICAgICB0cmFjay5hZGRDdWUoY3VlKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBCaW5hcnlTZWFyY2ggZnJvbSAnLi9iaW5hcnktc2VhcmNoJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRmlyc3RGcmFnV2l0aENDIChmcmFnbWVudHMsIGNjKSB7XG4gIGxldCBmaXJzdEZyYWcgPSBudWxsO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgY3VycmVudEZyYWcgPSBmcmFnbWVudHNbaV07XG4gICAgaWYgKGN1cnJlbnRGcmFnICYmIGN1cnJlbnRGcmFnLmNjID09PSBjYykge1xuICAgICAgZmlyc3RGcmFnID0gY3VycmVudEZyYWc7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmlyc3RGcmFnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZEZyYWdXaXRoQ0MgKGZyYWdtZW50cywgQ0MpIHtcbiAgcmV0dXJuIEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCAoY2FuZGlkYXRlKSA9PiB7XG4gICAgaWYgKGNhbmRpZGF0ZS5jYyA8IENDKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5jYyA+IENDKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzIChsYXN0RnJhZywgbGFzdExldmVsLCBkZXRhaWxzKSB7XG4gIGxldCBzaG91bGRBbGlnbiA9IGZhbHNlO1xuICBpZiAobGFzdExldmVsICYmIGxhc3RMZXZlbC5kZXRhaWxzICYmIGRldGFpbHMpIHtcbiAgICBpZiAoZGV0YWlscy5lbmRDQyA+IGRldGFpbHMuc3RhcnRDQyB8fCAobGFzdEZyYWcgJiYgbGFzdEZyYWcuY2MgPCBkZXRhaWxzLnN0YXJ0Q0MpKSB7XG4gICAgICBzaG91bGRBbGlnbiA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBzaG91bGRBbGlnbjtcbn1cblxuLy8gRmluZCB0aGUgZmlyc3QgZnJhZyBpbiB0aGUgcHJldmlvdXMgbGV2ZWwgd2hpY2ggbWF0Y2hlcyB0aGUgQ0Mgb2YgdGhlIGZpcnN0IGZyYWcgb2YgdGhlIG5ldyBsZXZlbFxuZXhwb3J0IGZ1bmN0aW9uIGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyAocHJldkRldGFpbHMsIGN1ckRldGFpbHMpIHtcbiAgY29uc3QgcHJldkZyYWdzID0gcHJldkRldGFpbHMuZnJhZ21lbnRzO1xuICBjb25zdCBjdXJGcmFncyA9IGN1ckRldGFpbHMuZnJhZ21lbnRzO1xuXG4gIGlmICghY3VyRnJhZ3MubGVuZ3RoIHx8ICFwcmV2RnJhZ3MubGVuZ3RoKSB7XG4gICAgbG9nZ2VyLmxvZygnTm8gZnJhZ21lbnRzIHRvIGFsaWduJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcHJldlN0YXJ0RnJhZyA9IGZpbmRGaXJzdEZyYWdXaXRoQ0MocHJldkZyYWdzLCBjdXJGcmFnc1swXS5jYyk7XG5cbiAgaWYgKCFwcmV2U3RhcnRGcmFnIHx8IChwcmV2U3RhcnRGcmFnICYmICFwcmV2U3RhcnRGcmFnLnN0YXJ0UFRTKSkge1xuICAgIGxvZ2dlci5sb2coJ05vIGZyYWcgaW4gcHJldmlvdXMgbGV2ZWwgdG8gYWxpZ24gb24nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gcHJldlN0YXJ0RnJhZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdFB0cyAoc2xpZGluZywgZGV0YWlscykge1xuICBkZXRhaWxzLmZyYWdtZW50cy5mb3JFYWNoKChmcmFnKSA9PiB7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIGxldCBzdGFydCA9IGZyYWcuc3RhcnQgKyBzbGlkaW5nO1xuICAgICAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydDtcbiAgICAgIGZyYWcuZW5kUFRTID0gc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgIH1cbiAgfSk7XG4gIGRldGFpbHMuUFRTS25vd24gPSB0cnVlO1xufVxuXG4vKipcbiAqIFVzaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBsYXN0IGxldmVsLCB0aGlzIGZ1bmN0aW9uIGNvbXB1dGVzIFBUUycgb2YgdGhlIG5ldyBmcmFnbWVudHMgc28gdGhhdCB0aGV5IGZvcm0gYVxuICogY29udGlndW91cyBzdHJlYW0gd2l0aCB0aGUgbGFzdCBmcmFnbWVudHMuXG4gKiBUaGUgUFRTIG9mIGEgZnJhZ21lbnQgbGV0cyBIbHMuanMga25vdyB3aGVyZSBpdCBmaXRzIGludG8gYSBzdHJlYW0gLSBieSBrbm93aW5nIGV2ZXJ5IFBUUywgd2Uga25vdyB3aGljaCBmcmFnbWVudCB0b1xuICogZG93bmxvYWQgYXQgYW55IGdpdmVuIHRpbWUuIFBUUyBpcyBub3JtYWxseSBjb21wdXRlZCB3aGVuIHRoZSBmcmFnbWVudCBpcyBkZW11eGVkLCBzbyB0YWtpbmcgdGhpcyBzdGVwIHNhdmVzIHVzIHRpbWVcbiAqIGFuZCBhbiBleHRyYSBkb3dubG9hZC5cbiAqIEBwYXJhbSBsYXN0RnJhZ1xuICogQHBhcmFtIGxhc3RMZXZlbFxuICogQHBhcmFtIGRldGFpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFsaWduU3RyZWFtIChsYXN0RnJhZywgbGFzdExldmVsLCBkZXRhaWxzKSB7XG4gIGFsaWduRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBkZXRhaWxzLCBsYXN0TGV2ZWwpO1xuICBpZiAoIWRldGFpbHMuUFRTS25vd24gJiYgbGFzdExldmVsKSB7XG4gICAgLy8gSWYgdGhlIFBUUyB3YXNuJ3QgZmlndXJlZCBvdXQgdmlhIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgdGhhdCBtZWFucyB0aGVyZSB3YXMgbm8gQ0MgaW5jcmVhc2Ugd2l0aGluIHRoZSBsZXZlbC5cbiAgICAvLyBBbGlnbmluZyB2aWEgUHJvZ3JhbSBEYXRlIFRpbWUgc2hvdWxkIHRoZXJlZm9yZSBiZSByZWxpYWJsZSwgc2luY2UgUERUIHNob3VsZCBiZSB0aGUgc2FtZSB3aXRoaW4gdGhlIHNhbWVcbiAgICAvLyBkaXNjb250aW51aXR5IHNlcXVlbmNlLlxuICAgIGFsaWduUERUKGRldGFpbHMsIGxhc3RMZXZlbC5kZXRhaWxzKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBQVFMgaWYgYSBuZXcgbGV2ZWwncyBmcmFnbWVudHMgdXNpbmcgdGhlIFBUUyBvZiBhIGZyYWdtZW50IGluIHRoZSBsYXN0IGxldmVsIHdoaWNoIHNoYXJlcyB0aGUgc2FtZVxuICogZGlzY29udGludWl0eSBzZXF1ZW5jZS5cbiAqIEBwYXJhbSBsYXN0TGV2ZWwgLSBUaGUgZGV0YWlscyBvZiB0aGUgbGFzdCBsb2FkZWQgbGV2ZWxcbiAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIG5ldyBsZXZlbFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWxpZ25EaXNjb250aW51aXRpZXMgKGxhc3RGcmFnLCBkZXRhaWxzLCBsYXN0TGV2ZWwpIHtcbiAgaWYgKHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMobGFzdEZyYWcsIGxhc3RMZXZlbCwgZGV0YWlscykpIHtcbiAgICBjb25zdCByZWZlcmVuY2VGcmFnID0gZmluZERpc2NvbnRpbnVvdXNSZWZlcmVuY2VGcmFnKGxhc3RMZXZlbC5kZXRhaWxzLCBkZXRhaWxzKTtcbiAgICBpZiAocmVmZXJlbmNlRnJhZykge1xuICAgICAgbG9nZ2VyLmxvZygnQWRqdXN0aW5nIFBUUyB1c2luZyBsYXN0IGxldmVsIGR1ZSB0byBDQyBpbmNyZWFzZSB3aXRoaW4gY3VycmVudCBsZXZlbCcpO1xuICAgICAgYWRqdXN0UHRzKHJlZmVyZW5jZUZyYWcuc3RhcnQsIGRldGFpbHMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBQVFMgb2YgYSBuZXcgbGV2ZWwncyBmcmFnbWVudHMgdXNpbmcgdGhlIGRpZmZlcmVuY2UgaW4gUHJvZ3JhbSBEYXRlIFRpbWUgZnJvbSB0aGUgbGFzdCBsZXZlbC5cbiAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIG5ldyBsZXZlbFxuICogQHBhcmFtIGxhc3REZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGlnblBEVCAoZGV0YWlscywgbGFzdERldGFpbHMpIHtcbiAgaWYgKGxhc3REZXRhaWxzICYmIGxhc3REZXRhaWxzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICBpZiAoIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICFsYXN0RGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gaWYgbGFzdCBsZXZlbCBzbGlkaW5nIGlzIDEwMDAgYW5kIGl0cyBmaXJzdCBmcmFnIFBST0dSQU0tREFURS1USU1FIGlzIDIwMTctMDgtMjAgMToxMDowMCBBTVxuICAgIC8vIGFuZCBpZiBuZXcgZGV0YWlscyBmaXJzdCBmcmFnIFBST0dSQU0gREFURS1USU1FIGlzIDIwMTctMDgtMjAgMToxMDowOCBBTVxuICAgIC8vIHRoZW4gd2UgY2FuIGRlZHVjZSB0aGF0IHBsYXlsaXN0IEIgc2xpZGluZyBpcyAxMDAwKzggPSAxMDA4c1xuICAgIGxldCBsYXN0UERUID0gbGFzdERldGFpbHMuZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZTtcbiAgICBsZXQgbmV3UERUID0gZGV0YWlscy5mcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lO1xuICAgIC8vIGRhdGUgZGlmZiBpcyBpbiBtcy4gZnJhZy5zdGFydCBpcyBpbiBzZWNvbmRzXG4gICAgbGV0IHNsaWRpbmcgPSAobmV3UERUIC0gbGFzdFBEVCkgLyAxMDAwICsgbGFzdERldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc2xpZGluZykpIHtcbiAgICAgIGxvZ2dlci5sb2coYGFkanVzdGluZyBQVFMgdXNpbmcgcHJvZ3JhbURhdGVUaW1lIGRlbHRhLCBzbGlkaW5nOiR7c2xpZGluZy50b0ZpeGVkKDMpfWApO1xuICAgICAgYWRqdXN0UHRzKHNsaWRpbmcsIGRldGFpbHMpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIEVXTUEgQmFuZHdpZHRoIEVzdGltYXRvclxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICogVHJhY2tzIGJhbmR3aWR0aCBzYW1wbGVzIGFuZCBlc3RpbWF0ZXMgYXZhaWxhYmxlIGJhbmR3aWR0aC5cbiAqIEJhc2VkIG9uIHRoZSBtaW5pbXVtIG9mIHR3byBleHBvbmVudGlhbGx5LXdlaWdodGVkIG1vdmluZyBhdmVyYWdlcyB3aXRoXG4gKiBkaWZmZXJlbnQgaGFsZi1saXZlcy5cbiAqL1xuXG5pbXBvcnQgRVdNQSBmcm9tICcuLi91dGlscy9ld21hJztcblxuY2xhc3MgRXdtYUJhbmRXaWR0aEVzdGltYXRvciB7XG4gIGNvbnN0cnVjdG9yIChobHMsIHNsb3csIGZhc3QsIGRlZmF1bHRFc3RpbWF0ZSkge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuZGVmYXVsdEVzdGltYXRlXyA9IGRlZmF1bHRFc3RpbWF0ZTtcbiAgICB0aGlzLm1pbldlaWdodF8gPSAwLjAwMTtcbiAgICB0aGlzLm1pbkRlbGF5TXNfID0gNTA7XG4gICAgdGhpcy5zbG93XyA9IG5ldyBFV01BKHNsb3cpO1xuICAgIHRoaXMuZmFzdF8gPSBuZXcgRVdNQShmYXN0KTtcbiAgfVxuXG4gIHNhbXBsZSAoZHVyYXRpb25NcywgbnVtQnl0ZXMpIHtcbiAgICBkdXJhdGlvbk1zID0gTWF0aC5tYXgoZHVyYXRpb25NcywgdGhpcy5taW5EZWxheU1zXyk7XG4gICAgbGV0IGJhbmR3aWR0aCA9IDgwMDAgKiBudW1CeXRlcyAvIGR1cmF0aW9uTXMsXG4gICAgICAvLyBjb25zb2xlLmxvZygnaW5zdGFudCBidzonKyBNYXRoLnJvdW5kKGJhbmR3aWR0aCkpO1xuICAgICAgLy8gd2Ugd2VpZ2h0IHNhbXBsZSB1c2luZyBsb2FkaW5nIGR1cmF0aW9uLi4uLlxuICAgICAgd2VpZ2h0ID0gZHVyYXRpb25NcyAvIDEwMDA7XG4gICAgdGhpcy5mYXN0Xy5zYW1wbGUod2VpZ2h0LCBiYW5kd2lkdGgpO1xuICAgIHRoaXMuc2xvd18uc2FtcGxlKHdlaWdodCwgYmFuZHdpZHRoKTtcbiAgfVxuXG4gIGNhbkVzdGltYXRlICgpIHtcbiAgICBsZXQgZmFzdCA9IHRoaXMuZmFzdF87XG4gICAgcmV0dXJuIChmYXN0ICYmIGZhc3QuZ2V0VG90YWxXZWlnaHQoKSA+PSB0aGlzLm1pbldlaWdodF8pO1xuICB9XG5cbiAgZ2V0RXN0aW1hdGUgKCkge1xuICAgIGlmICh0aGlzLmNhbkVzdGltYXRlKCkpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdzbG93IGVzdGltYXRlOicrIE1hdGgucm91bmQodGhpcy5zbG93Xy5nZXRFc3RpbWF0ZSgpKSk7XG4gICAgICAvLyBjb25zb2xlLmxvZygnZmFzdCBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgLy8gVGFrZSB0aGUgbWluaW11bSBvZiB0aGVzZSB0d28gZXN0aW1hdGVzLiAgVGhpcyBzaG91bGQgaGF2ZSB0aGUgZWZmZWN0IG9mXG4gICAgICAvLyBhZGFwdGluZyBkb3duIHF1aWNrbHksIGJ1dCB1cCBtb3JlIHNsb3dseS5cbiAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmZhc3RfLmdldEVzdGltYXRlKCksIHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRFc3RpbWF0ZV87XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3I7XG4iLCIvKlxuICogY29tcHV0ZSBhbiBFeHBvbmVudGlhbCBXZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZVxuICogLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb3ZpbmdfYXZlcmFnZSNFeHBvbmVudGlhbF9tb3ZpbmdfYXZlcmFnZVxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICovXG5cbmNsYXNzIEVXTUEge1xuICAvLyAgQWJvdXQgaGFsZiBvZiB0aGUgZXN0aW1hdGVkIHZhbHVlIHdpbGwgYmUgZnJvbSB0aGUgbGFzdCB8aGFsZkxpZmV8IHNhbXBsZXMgYnkgd2VpZ2h0LlxuICBjb25zdHJ1Y3RvciAoaGFsZkxpZmUpIHtcbiAgICAvLyBMYXJnZXIgdmFsdWVzIG9mIGFscGhhIGV4cGlyZSBoaXN0b3JpY2FsIGRhdGEgbW9yZSBzbG93bHkuXG4gICAgdGhpcy5hbHBoYV8gPSBoYWxmTGlmZSA/IE1hdGguZXhwKE1hdGgubG9nKDAuNSkgLyBoYWxmTGlmZSkgOiAwO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gMDtcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyA9IDA7XG4gIH1cblxuICBzYW1wbGUgKHdlaWdodCwgdmFsdWUpIHtcbiAgICBsZXQgYWRqQWxwaGEgPSBNYXRoLnBvdyh0aGlzLmFscGhhXywgd2VpZ2h0KTtcbiAgICB0aGlzLmVzdGltYXRlXyA9IHZhbHVlICogKDEgLSBhZGpBbHBoYSkgKyBhZGpBbHBoYSAqIHRoaXMuZXN0aW1hdGVfO1xuICAgIHRoaXMudG90YWxXZWlnaHRfICs9IHdlaWdodDtcbiAgfVxuXG4gIGdldFRvdGFsV2VpZ2h0ICgpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFdlaWdodF87XG4gIH1cblxuICBnZXRFc3RpbWF0ZSAoKSB7XG4gICAgaWYgKHRoaXMuYWxwaGFfKSB7XG4gICAgICBsZXQgemVyb0ZhY3RvciA9IDEgLSBNYXRoLnBvdyh0aGlzLmFscGhhXywgdGhpcy50b3RhbFdlaWdodF8pO1xuICAgICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfIC8gemVyb0ZhY3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFV01BO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGZTY29wZSAoKSB7XG4gIC8vIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTEyMzcyNTkvNTg5NDkzXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZiAqL1xuICAgIHJldHVybiBzZWxmO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cbn1cbiIsImltcG9ydCB7IGdldFNlbGZTY29wZSB9IGZyb20gJy4vZ2V0LXNlbGYtc2NvcGUnO1xuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmNvbnN0IGZha2VMb2dnZXIgPSB7XG4gIHRyYWNlOiBub29wLFxuICBkZWJ1Zzogbm9vcCxcbiAgbG9nOiBub29wLFxuICB3YXJuOiBub29wLFxuICBpbmZvOiBub29wLFxuICBlcnJvcjogbm9vcFxufTtcblxubGV0IGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcblxuLy8gbGV0IGxhc3RDYWxsVGltZTtcbi8vIGZ1bmN0aW9uIGZvcm1hdE1zZ1dpdGhUaW1lSW5mbyh0eXBlLCBtc2cpIHtcbi8vICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbi8vICAgY29uc3QgZGlmZiA9IGxhc3RDYWxsVGltZSA/ICcrJyArIChub3cgLSBsYXN0Q2FsbFRpbWUpIDogJzAnO1xuLy8gICBsYXN0Q2FsbFRpbWUgPSBub3c7XG4vLyAgIG1zZyA9IChuZXcgRGF0ZShub3cpKS50b0lTT1N0cmluZygpICsgJyB8IFsnICsgIHR5cGUgKyAnXSA+ICcgKyBtc2cgKyAnICggJyArIGRpZmYgKyAnIG1zICknO1xuLy8gICByZXR1cm4gbXNnO1xuLy8gfVxuXG5mdW5jdGlvbiBmb3JtYXRNc2cgKHR5cGUsIG1zZykge1xuICBtc2cgPSAnWycgKyB0eXBlICsgJ10gPiAnICsgbXNnO1xuICByZXR1cm4gbXNnO1xufVxuXG5jb25zdCBnbG9iYWwgPSBnZXRTZWxmU2NvcGUoKTtcblxuZnVuY3Rpb24gY29uc29sZVByaW50Rm4gKHR5cGUpIHtcbiAgY29uc3QgZnVuYyA9IGdsb2JhbC5jb25zb2xlW3R5cGVdO1xuICBpZiAoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgaWYgKGFyZ3NbMF0pIHtcbiAgICAgICAgYXJnc1swXSA9IGZvcm1hdE1zZyh0eXBlLCBhcmdzWzBdKTtcbiAgICAgIH1cblxuICAgICAgZnVuYy5hcHBseShnbG9iYWwuY29uc29sZSwgYXJncyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gbm9vcDtcbn1cblxuZnVuY3Rpb24gZXhwb3J0TG9nZ2VyRnVuY3Rpb25zIChkZWJ1Z0NvbmZpZywgLi4uZnVuY3Rpb25zKSB7XG4gIGZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgZXhwb3J0ZWRMb2dnZXJbdHlwZV0gPSBkZWJ1Z0NvbmZpZ1t0eXBlXSA/IGRlYnVnQ29uZmlnW3R5cGVdLmJpbmQoZGVidWdDb25maWcpIDogY29uc29sZVByaW50Rm4odHlwZSk7XG4gIH0pO1xufVxuXG5leHBvcnQgdmFyIGVuYWJsZUxvZ3MgPSBmdW5jdGlvbiAoZGVidWdDb25maWcpIHtcbiAgaWYgKGRlYnVnQ29uZmlnID09PSB0cnVlIHx8IHR5cGVvZiBkZWJ1Z0NvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICBleHBvcnRMb2dnZXJGdW5jdGlvbnMoZGVidWdDb25maWcsXG4gICAgICAvLyBSZW1vdmUgb3V0IGZyb20gbGlzdCBoZXJlIHRvIGhhcmQtZGlzYWJsZSBhIGxvZy1sZXZlbFxuICAgICAgLy8gJ3RyYWNlJyxcbiAgICAgICdkZWJ1ZycsXG4gICAgICAnbG9nJyxcbiAgICAgICdpbmZvJyxcbiAgICAgICd3YXJuJyxcbiAgICAgICdlcnJvcidcbiAgICApO1xuICAgIC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3QgYWxsb3cgdG8gdXNlIGJpbmQgb24gY29uc29sZSBvYmplY3QgYW55d2F5XG4gICAgLy8gZmFsbGJhY2sgdG8gZGVmYXVsdCBpZiBuZWVkZWRcbiAgICB0cnkge1xuICAgICAgZXhwb3J0ZWRMb2dnZXIubG9nKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG4gIH1cbn07XG5cbmV4cG9ydCB2YXIgbG9nZ2VyID0gZXhwb3J0ZWRMb2dnZXI7XG4iLCJjb25zdCByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgPSAoZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzcykge1xuICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzcy5iaW5kKHdpbmRvdy5uYXZpZ2F0b3IpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59KSgpO1xuXG5leHBvcnQge1xuICByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3Ncbn07XG4iLCIvKipcbiAqIE1lZGlhU291cmNlIGhlbHBlclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZWRpYVNvdXJjZSAoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB3aW5kb3cuTWVkaWFTb3VyY2UgfHwgd2luZG93LldlYktpdE1lZGlhU291cmNlO1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBPdXRwdXRGaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAodGltZWxpbmVDb250cm9sbGVyLCB0cmFja05hbWUpIHtcbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlciA9IHRpbWVsaW5lQ29udHJvbGxlcjtcbiAgICB0aGlzLnRyYWNrTmFtZSA9IHRyYWNrTmFtZTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy5lbmRUaW1lID0gbnVsbDtcbiAgICB0aGlzLnNjcmVlbiA9IG51bGw7XG4gIH1cblxuICBkaXNwYXRjaEN1ZSAoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRUaW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIuYWRkQ3Vlcyh0aGlzLnRyYWNrTmFtZSwgdGhpcy5zdGFydFRpbWUsIHRoaXMuZW5kVGltZSwgdGhpcy5zY3JlZW4pO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgfVxuXG4gIG5ld0N1ZSAoc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pIHtcbiAgICBpZiAodGhpcy5zdGFydFRpbWUgPT09IG51bGwgfHwgdGhpcy5zdGFydFRpbWUgPiBzdGFydFRpbWUpIHtcbiAgICAgIHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgIH1cblxuICAgIHRoaXMuZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgdGhpcy5zY3JlZW4gPSBzY3JlZW47XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIuY3JlYXRlQ2FwdGlvbnNUcmFjayh0aGlzLnRyYWNrTmFtZSk7XG4gIH1cbn1cbiIsIlxuZXhwb3J0IGZ1bmN0aW9uIHNlbmRBZGRUcmFja0V2ZW50ICh0cmFjaywgdmlkZW9FbCkge1xuICBsZXQgZXZlbnQgPSBudWxsO1xuICB0cnkge1xuICAgIGV2ZW50ID0gbmV3IHdpbmRvdy5FdmVudCgnYWRkdHJhY2snKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gZm9yIElFMTFcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmluaXRFdmVudCgnYWRkdHJhY2snLCBmYWxzZSwgZmFsc2UpO1xuICB9XG4gIGV2ZW50LnRyYWNrID0gdHJhY2s7XG4gIHZpZGVvRWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckN1cnJlbnRDdWVzICh0cmFjaykge1xuICBpZiAodHJhY2sgJiYgdHJhY2suY3Vlcykge1xuICAgIHdoaWxlICh0cmFjay5jdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRyYWNrLnJlbW92ZUN1ZSh0cmFjay5jdWVzWzBdKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogIFRpbWVSYW5nZXMgdG8gc3RyaW5nIGhlbHBlclxuICovXG5cbmNvbnN0IFRpbWVSYW5nZXMgPSB7XG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAocikge1xuICAgIGxldCBsb2cgPSAnJywgbGVuID0gci5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgbG9nICs9ICdbJyArIHIuc3RhcnQoaSkudG9GaXhlZCgzKSArICcsJyArIHIuZW5kKGkpLnRvRml4ZWQoMykgKyAnXSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvZztcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgVGltZVJhbmdlcztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WVFRDdWUpIHtcbiAgICByZXR1cm4gd2luZG93LlZUVEN1ZTtcbiAgfVxuXG4gIGxldCBhdXRvS2V5d29yZCA9ICdhdXRvJztcbiAgbGV0IGRpcmVjdGlvblNldHRpbmcgPSB7XG4gICAgJyc6IHRydWUsXG4gICAgbHI6IHRydWUsXG4gICAgcmw6IHRydWVcbiAgfTtcbiAgbGV0IGFsaWduU2V0dGluZyA9IHtcbiAgICBzdGFydDogdHJ1ZSxcbiAgICBtaWRkbGU6IHRydWUsXG4gICAgZW5kOiB0cnVlLFxuICAgIGxlZnQ6IHRydWUsXG4gICAgcmlnaHQ6IHRydWVcbiAgfTtcblxuICBmdW5jdGlvbiBmaW5kRGlyZWN0aW9uU2V0dGluZyAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBkaXIgPSBkaXJlY3Rpb25TZXR0aW5nW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xuICAgIHJldHVybiBkaXIgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQWxpZ25TZXR0aW5nICh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGFsaWduID0gYWxpZ25TZXR0aW5nW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xuICAgIHJldHVybiBhbGlnbiA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZCAob2JqKSB7XG4gICAgbGV0IGkgPSAxO1xuICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgY29iaiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAobGV0IHAgaW4gY29iaikge1xuICAgICAgICBvYmpbcF0gPSBjb2JqW3BdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBWVFRDdWUgKHN0YXJ0VGltZSwgZW5kVGltZSwgdGV4dCkge1xuICAgIGxldCBjdWUgPSB0aGlzO1xuICAgIGxldCBpc0lFOCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKC9NU0lFXFxzOFxcLjAvKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH0pKCk7XG4gICAgbGV0IGJhc2VPYmogPSB7fTtcblxuICAgIGlmIChpc0lFOCkge1xuICAgICAgY3VlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2VPYmouZW51bWVyYWJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hpbSBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyBwcm9wZXJ0aWVzLiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgaW5cbiAgICAgKiB0aGUgc3BlYy5cbiAgICAgKi9cblxuICAgIC8vIExldHMgdXMga25vdyB3aGVuIHRoZSBWVFRDdWUncyBkYXRhIGhhcyBjaGFuZ2VkIGluIHN1Y2ggYSB3YXkgdGhhdCB3ZSBuZWVkXG4gICAgLy8gdG8gcmVjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlLiBUaGlzIGxldHMgdXMgY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZVxuICAgIC8vIGxhemlseS5cbiAgICBjdWUuaGFzQmVlblJlc2V0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBWVFRDdWUgYW5kIFRleHRUcmFja0N1ZSBwcm9wZXJ0aWVzXG4gICAgICogaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2VidnR0LyN2dHRjdWUtaW50ZXJmYWNlXG4gICAgICovXG5cbiAgICBsZXQgX2lkID0gJyc7XG4gICAgbGV0IF9wYXVzZU9uRXhpdCA9IGZhbHNlO1xuICAgIGxldCBfc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgIGxldCBfZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgbGV0IF90ZXh0ID0gdGV4dDtcbiAgICBsZXQgX3JlZ2lvbiA9IG51bGw7XG4gICAgbGV0IF92ZXJ0aWNhbCA9ICcnO1xuICAgIGxldCBfc25hcFRvTGluZXMgPSB0cnVlO1xuICAgIGxldCBfbGluZSA9ICdhdXRvJztcbiAgICBsZXQgX2xpbmVBbGlnbiA9ICdzdGFydCc7XG4gICAgbGV0IF9wb3NpdGlvbiA9IDUwO1xuICAgIGxldCBfcG9zaXRpb25BbGlnbiA9ICdtaWRkbGUnO1xuICAgIGxldCBfc2l6ZSA9IDUwO1xuICAgIGxldCBfYWxpZ24gPSAnbWlkZGxlJztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdpZCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfaWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX2lkID0gJycgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncGF1c2VPbkV4aXQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3BhdXNlT25FeGl0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF9wYXVzZU9uRXhpdCA9ICEhdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3N0YXJ0VGltZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc3RhcnRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RhcnQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zdGFydFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdlbmRUaW1lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9lbmRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5kIHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfZW5kVGltZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3RleHQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RleHQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3RleHQgPSAnJyArIHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3JlZ2lvbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcmVnaW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF9yZWdpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICd2ZXJ0aWNhbCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdmVydGljYWw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgbGV0IHNldHRpbmcgPSBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGZhbHNlIGJlY2F1c2UgdGhlIHNldHRpbmcgYW4gYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICBpZiAoc2V0dGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF92ZXJ0aWNhbCA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc25hcFRvTGluZXMnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3NuYXBUb0xpbmVzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF9zbmFwVG9MaW5lcyA9ICEhdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnbGluZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfbGluZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gYXV0b0tleXdvcmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgbnVtYmVyIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfbGluZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2xpbmVBbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfbGluZUFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGxldCBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2xpbmVBbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncG9zaXRpb24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2l0aW9uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfcG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwb3NpdGlvbkFsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbkFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGxldCBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3Bvc2l0aW9uQWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NpemUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2l6ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3NpemUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdhbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfYWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgbGV0IHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfYWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogT3RoZXIgPHRyYWNrPiBzcGVjIGRlZmluZWQgcHJvcGVydGllc1xuICAgICAqL1xuXG4gICAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLXZpZGVvLWVsZW1lbnQuaHRtbCN0ZXh0LXRyYWNrLWN1ZS1kaXNwbGF5LXN0YXRlXG4gICAgY3VlLmRpc3BsYXlTdGF0ZSA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChpc0lFOCkge1xuICAgICAgcmV0dXJuIGN1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVlRUQ3VlIG1ldGhvZHNcbiAgICovXG5cbiAgVlRUQ3VlLnByb3RvdHlwZS5nZXRDdWVBc0hUTUwgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQXNzdW1lIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlIGlzIG9uIHRoZSBnbG9iYWwuXG4gICAgbGV0IFdlYlZUVCA9IHdpbmRvdy5XZWJWVFQ7XG4gICAgcmV0dXJuIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlKHdpbmRvdywgdGhpcy50ZXh0KTtcbiAgfTtcblxuICByZXR1cm4gVlRUQ3VlO1xufSkoKTtcbiIsIi8qXG4gKiBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3Z0dC5qcy9ibG9iL21hc3Rlci9kaXN0L3Z0dC5qcyNMMTcxNlxuICovXG5cbmltcG9ydCBWVFRDdWUgZnJvbSAnLi92dHRjdWUnO1xuXG5jb25zdCBTdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24gU3RyaW5nRGVjb2RlciAoKSB7XG4gIHJldHVybiB7XG4gICAgZGVjb2RlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIC0gZXhwZWN0ZWQgc3RyaW5nIGRhdGEuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpKTtcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBWVFRQYXJzZXIgKCkge1xuICB0aGlzLndpbmRvdyA9IHdpbmRvdztcbiAgdGhpcy5zdGF0ZSA9ICdJTklUSUFMJztcbiAgdGhpcy5idWZmZXIgPSAnJztcbiAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoKTtcbiAgdGhpcy5yZWdpb25MaXN0ID0gW107XG59XG5cbi8vIFRyeSB0byBwYXJzZSBpbnB1dCBhcyBhIHRpbWUgc3RhbXAuXG5mdW5jdGlvbiBwYXJzZVRpbWVTdGFtcCAoaW5wdXQpIHtcbiAgZnVuY3Rpb24gY29tcHV0ZVNlY29uZHMgKGgsIG0sIHMsIGYpIHtcbiAgICByZXR1cm4gKGggfCAwKSAqIDM2MDAgKyAobSB8IDApICogNjAgKyAocyB8IDApICsgKGYgfCAwKSAvIDEwMDA7XG4gIH1cblxuICBsZXQgbSA9IGlucHV0Lm1hdGNoKC9eKFxcZCspOihcXGR7Mn0pKDpcXGR7Mn0pP1xcLihcXGR7M30pLyk7XG4gIGlmICghbSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKG1bM10pIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzXTpbbWludXRlc106W3NlY29uZHNdLlttaWxsaXNlY29uZHNdXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIG1bM10ucmVwbGFjZSgnOicsICcnKSwgbVs0XSk7XG4gIH0gZWxzZSBpZiAobVsxXSA+IDU5KSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdLlttaWxsaXNlY29uZHNdXG4gICAgLy8gRmlyc3QgcG9zaXRpb24gaXMgaG91cnMgYXMgaXQncyBvdmVyIDU5LlxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCAwLCBtWzRdKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcygwLCBtWzFdLCBtWzJdLCBtWzRdKTtcbiAgfVxufVxuXG4vLyBBIHNldHRpbmdzIG9iamVjdCBob2xkcyBrZXkvdmFsdWUgcGFpcnMgYW5kIHdpbGwgaWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3Rcbi8vIGFzc2lnbm1lbnQgdG8gYSBzcGVjaWZpYyBrZXkuXG5mdW5jdGlvbiBTZXR0aW5ncyAoKSB7XG4gIHRoaXMudmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuU2V0dGluZ3MucHJvdG90eXBlID0ge1xuICAvLyBPbmx5IGFjY2VwdCB0aGUgZmlyc3QgYXNzaWdubWVudCB0byBhbnkga2V5LlxuICBzZXQ6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKCF0aGlzLmdldChrKSAmJiB2ICE9PSAnJykge1xuICAgICAgdGhpcy52YWx1ZXNba10gPSB2O1xuICAgIH1cbiAgfSxcbiAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBmb3IgYSBrZXksIG9yIGEgZGVmYXVsdCB2YWx1ZS5cbiAgLy8gSWYgJ2RlZmF1bHRLZXknIGlzIHBhc3NlZCB0aGVuICdkZmx0JyBpcyBhc3N1bWVkIHRvIGJlIGFuIG9iamVjdCB3aXRoXG4gIC8vIGEgbnVtYmVyIG9mIHBvc3NpYmxlIGRlZmF1bHQgdmFsdWVzIGFzIHByb3BlcnRpZXMgd2hlcmUgJ2RlZmF1bHRLZXknIGlzXG4gIC8vIHRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBjaG9zZW47IG90aGVyd2lzZSBpdCdzIGFzc3VtZWQgdG8gYmVcbiAgLy8gYSBzaW5nbGUgdmFsdWUuXG4gIGdldDogZnVuY3Rpb24gKGssIGRmbHQsIGRlZmF1bHRLZXkpIHtcbiAgICBpZiAoZGVmYXVsdEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0W2RlZmF1bHRLZXldO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdDtcbiAgfSxcbiAgLy8gQ2hlY2sgd2hldGhlciB3ZSBoYXZlIGEgdmFsdWUgZm9yIGEga2V5LlxuICBoYXM6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgaW4gdGhpcy52YWx1ZXM7XG4gIH0sXG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIG9uZSBvZiB0aGUgZ2l2ZW4gYWx0ZXJuYXRpdmVzLlxuICBhbHQ6IGZ1bmN0aW9uIChrLCB2LCBhKSB7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBhLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAodiA9PT0gYVtuXSkge1xuICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIChzaWduZWQpIGludGVnZXIuXG4gIGludGVnZXI6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKC9eLT9cXGQrJC8udGVzdCh2KSkgeyAvLyBpbnRlZ2VyXG4gICAgICB0aGlzLnNldChrLCBwYXJzZUludCh2LCAxMCkpO1xuICAgIH1cbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCBwZXJjZW50YWdlLlxuICBwZXJjZW50OiBmdW5jdGlvbiAoaywgdikge1xuICAgIGxldCBtO1xuICAgIGlmICgobSA9IHYubWF0Y2goL14oW1xcZF17MSwzfSkoXFwuW1xcZF0qKT8lJC8pKSkge1xuICAgICAgdiA9IHBhcnNlRmxvYXQodik7XG4gICAgICBpZiAodiA+PSAwICYmIHYgPD0gMTAwKSB7XG4gICAgICAgIHRoaXMuc2V0KGssIHYpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gcGFyc2UgaW5wdXQgaW50byBncm91cHMgc2VwYXJhdGVkIGJ5ICdncm91cERlbGltJywgYW5kXG4vLyBpbnRlcnByZXRlIGVhY2ggZ3JvdXAgYXMgYSBrZXkvdmFsdWUgcGFpciBzZXBhcmF0ZWQgYnkgJ2tleVZhbHVlRGVsaW0nLlxuZnVuY3Rpb24gcGFyc2VPcHRpb25zIChpbnB1dCwgY2FsbGJhY2ssIGtleVZhbHVlRGVsaW0sIGdyb3VwRGVsaW0pIHtcbiAgbGV0IGdyb3VwcyA9IGdyb3VwRGVsaW0gPyBpbnB1dC5zcGxpdChncm91cERlbGltKSA6IFtpbnB1dF07XG4gIGZvciAobGV0IGkgaW4gZ3JvdXBzKSB7XG4gICAgaWYgKHR5cGVvZiBncm91cHNbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBsZXQga3YgPSBncm91cHNbaV0uc3BsaXQoa2V5VmFsdWVEZWxpbSk7XG4gICAgaWYgKGt2Lmxlbmd0aCAhPT0gMikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbGV0IGsgPSBrdlswXTtcbiAgICBsZXQgdiA9IGt2WzFdO1xuICAgIGNhbGxiYWNrKGssIHYpO1xuICB9XG59XG5cbmxldCBkZWZhdWx0cyA9IG5ldyBWVFRDdWUoMCwgMCwgMCk7XG4vLyAnbWlkZGxlJyB3YXMgY2hhbmdlZCB0byAnY2VudGVyJyBpbiB0aGUgc3BlYzogaHR0cHM6Ly9naXRodWIuY29tL3czYy93ZWJ2dHQvcHVsbC8yNDRcbi8vICBTYWZhcmkgZG9lc24ndCB5ZXQgc3VwcG9ydCB0aGlzIGNoYW5nZSwgYnV0IEZGIGFuZCBDaHJvbWUgZG8uXG5sZXQgY2VudGVyID0gZGVmYXVsdHMuYWxpZ24gPT09ICdtaWRkbGUnID8gJ21pZGRsZScgOiAnY2VudGVyJztcblxuZnVuY3Rpb24gcGFyc2VDdWUgKGlucHV0LCBjdWUsIHJlZ2lvbkxpc3QpIHtcbiAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIGlucHV0IGlmIHdlIG5lZWQgdG8gdGhyb3cgYW4gZXJyb3IuXG4gIGxldCBvSW5wdXQgPSBpbnB1dDtcbiAgLy8gNC4xIFdlYlZUVCB0aW1lc3RhbXBcbiAgZnVuY3Rpb24gY29uc3VtZVRpbWVTdGFtcCAoKSB7XG4gICAgbGV0IHRzID0gcGFyc2VUaW1lU3RhbXAoaW5wdXQpO1xuICAgIGlmICh0cyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgdGltZXN0YW1wOiAnICsgb0lucHV0KTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdGltZSBzdGFtcCBmcm9tIGlucHV0LlxuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXlteXFxzYS16QS1aLV0rLywgJycpO1xuICAgIHJldHVybiB0cztcbiAgfVxuXG4gIC8vIDQuNC4yIFdlYlZUVCBjdWUgc2V0dGluZ3NcbiAgZnVuY3Rpb24gY29uc3VtZUN1ZVNldHRpbmdzIChpbnB1dCwgY3VlKSB7XG4gICAgbGV0IHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG5cbiAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICBzd2l0Y2ggKGspIHtcbiAgICAgIGNhc2UgJ3JlZ2lvbic6XG4gICAgICAgIC8vIEZpbmQgdGhlIGxhc3QgcmVnaW9uIHdlIHBhcnNlZCB3aXRoIHRoZSBzYW1lIHJlZ2lvbiBpZC5cbiAgICAgICAgZm9yIChsZXQgaSA9IHJlZ2lvbkxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAocmVnaW9uTGlzdFtpXS5pZCA9PT0gdikge1xuICAgICAgICAgICAgc2V0dGluZ3Muc2V0KGssIHJlZ2lvbkxpc3RbaV0ucmVnaW9uKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsncmwnLCAnbHInXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGluZSc6XG4gICAgICAgIHZhciB2YWxzID0gdi5zcGxpdCgnLCcpLFxuICAgICAgICAgIHZhbHMwID0gdmFsc1swXTtcbiAgICAgICAgc2V0dGluZ3MuaW50ZWdlcihrLCB2YWxzMCk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5wZXJjZW50KGssIHZhbHMwKSkge1xuICAgICAgICAgIHNldHRpbmdzLnNldCgnc25hcFRvTGluZXMnLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0aW5ncy5hbHQoaywgdmFsczAsIFsnYXV0byddKTtcbiAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KCdsaW5lQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJ10pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgIHZhbHMgPSB2LnNwbGl0KCcsJyk7XG4gICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdmFsc1swXSk7XG4gICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHNldHRpbmdzLmFsdCgncG9zaXRpb25BbGlnbicsIHZhbHNbMV0sIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnLCAnbGluZS1sZWZ0JywgJ2xpbmUtcmlnaHQnLCAnYXV0byddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2l6ZSc6XG4gICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYWxpZ24nOlxuICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCcsICdsZWZ0JywgJ3JpZ2h0J10pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LCAvOi8sIC9cXHMvKTtcblxuICAgIC8vIEFwcGx5IGRlZmF1bHQgdmFsdWVzIGZvciBhbnkgbWlzc2luZyBmaWVsZHMuXG4gICAgY3VlLnJlZ2lvbiA9IHNldHRpbmdzLmdldCgncmVnaW9uJywgbnVsbCk7XG4gICAgY3VlLnZlcnRpY2FsID0gc2V0dGluZ3MuZ2V0KCd2ZXJ0aWNhbCcsICcnKTtcbiAgICBsZXQgbGluZSA9IHNldHRpbmdzLmdldCgnbGluZScsICdhdXRvJyk7XG4gICAgaWYgKGxpbmUgPT09ICdhdXRvJyAmJiBkZWZhdWx0cy5saW5lID09PSAtMSkge1xuICAgICAgLy8gc2V0IG51bWVyaWMgbGluZSBudW1iZXIgZm9yIFNhZmFyaVxuICAgICAgbGluZSA9IC0xO1xuICAgIH1cbiAgICBjdWUubGluZSA9IGxpbmU7XG4gICAgY3VlLmxpbmVBbGlnbiA9IHNldHRpbmdzLmdldCgnbGluZUFsaWduJywgJ3N0YXJ0Jyk7XG4gICAgY3VlLnNuYXBUb0xpbmVzID0gc2V0dGluZ3MuZ2V0KCdzbmFwVG9MaW5lcycsIHRydWUpO1xuICAgIGN1ZS5zaXplID0gc2V0dGluZ3MuZ2V0KCdzaXplJywgMTAwKTtcbiAgICBjdWUuYWxpZ24gPSBzZXR0aW5ncy5nZXQoJ2FsaWduJywgY2VudGVyKTtcbiAgICBsZXQgcG9zaXRpb24gPSBzZXR0aW5ncy5nZXQoJ3Bvc2l0aW9uJywgJ2F1dG8nKTtcbiAgICBpZiAocG9zaXRpb24gPT09ICdhdXRvJyAmJiBkZWZhdWx0cy5wb3NpdGlvbiA9PT0gNTApIHtcbiAgICAgIC8vIHNldCBudW1lcmljIHBvc2l0aW9uIGZvciBTYWZhcmlcbiAgICAgIHBvc2l0aW9uID0gY3VlLmFsaWduID09PSAnc3RhcnQnIHx8IGN1ZS5hbGlnbiA9PT0gJ2xlZnQnID8gMCA6IGN1ZS5hbGlnbiA9PT0gJ2VuZCcgfHwgY3VlLmFsaWduID09PSAncmlnaHQnID8gMTAwIDogNTA7XG4gICAgfVxuICAgIGN1ZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UgKCkge1xuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXlxccysvLCAnJyk7XG4gIH1cblxuICAvLyA0LjEgV2ViVlRUIGN1ZSB0aW1pbmdzLlxuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuc3RhcnRUaW1lID0gY29uc3VtZVRpbWVTdGFtcCgpOyAvLyAoMSkgY29sbGVjdCBjdWUgc3RhcnQgdGltZVxuICBza2lwV2hpdGVzcGFjZSgpO1xuICBpZiAoaW5wdXQuc3Vic3RyKDAsIDMpICE9PSAnLS0+JykgeyAvLyAoMykgbmV4dCBjaGFyYWN0ZXJzIG11c3QgbWF0Y2ggJy0tPidcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCB0aW1lIHN0YW1wICh0aW1lIHN0YW1wcyBtdXN0IGJlIHNlcGFyYXRlZCBieSBcXCctLT5cXCcpOiAnICtcbiAgICAgIG9JbnB1dCk7XG4gIH1cbiAgaW5wdXQgPSBpbnB1dC5zdWJzdHIoMyk7XG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGN1ZS5lbmRUaW1lID0gY29uc3VtZVRpbWVTdGFtcCgpOyAvLyAoNSkgY29sbGVjdCBjdWUgZW5kIHRpbWVcblxuICAvLyA0LjEgV2ViVlRUIGN1ZSBzZXR0aW5ncyBsaXN0LlxuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjb25zdW1lQ3VlU2V0dGluZ3MoaW5wdXQsIGN1ZSk7XG59XG5cbmZ1bmN0aW9uIGZpeExpbmVCcmVha3MgKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5yZXBsYWNlKC88YnIoPzogXFwvKT8+L2dpLCAnXFxuJyk7XG59XG5cblZUVFBhcnNlci5wcm90b3R5cGUgPSB7XG4gIHBhcnNlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGxldCBzZWxmID0gdGhpcztcblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgdGhlbiB3ZSB3b24ndCBkZWNvZGUgaXQsIGJ1dCB3aWxsIGp1c3QgdHJ5IHRvIHBhcnNlXG4gICAgLy8gd2hhdGV2ZXIgaXMgaW4gYnVmZmVyIGFscmVhZHkuIFRoaXMgbWF5IG9jY3VyIGluIGNpcmN1bXN0YW5jZXMsIGZvclxuICAgIC8vIGV4YW1wbGUgd2hlbiBmbHVzaCgpIGlzIGNhbGxlZC5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgLy8gVHJ5IHRvIGRlY29kZSB0aGUgZGF0YSB0aGF0IHdlIHJlY2VpdmVkLlxuICAgICAgc2VsZi5idWZmZXIgKz0gc2VsZi5kZWNvZGVyLmRlY29kZShkYXRhLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0TmV4dExpbmUgKCkge1xuICAgICAgbGV0IGJ1ZmZlciA9IHNlbGYuYnVmZmVyO1xuICAgICAgbGV0IHBvcyA9IDA7XG5cbiAgICAgIGJ1ZmZlciA9IGZpeExpbmVCcmVha3MoYnVmZmVyKTtcblxuICAgICAgd2hpbGUgKHBvcyA8IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyW3Bvc10gIT09ICdcXHInICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cblxuICAgICAgbGV0IGxpbmUgPSBidWZmZXIuc3Vic3RyKDAsIHBvcyk7XG4gICAgICAvLyBBZHZhbmNlIHRoZSBidWZmZXIgZWFybHkgaW4gY2FzZSB3ZSBmYWlsIGJlbG93LlxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxyJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cblxuICAgICAgc2VsZi5idWZmZXIgPSBidWZmZXIuc3Vic3RyKHBvcyk7XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9XG5cbiAgICAvLyAzLjIgV2ViVlRUIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcbiAgICBmdW5jdGlvbiBwYXJzZUhlYWRlciAoaW5wdXQpIHtcbiAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgIGNhc2UgJ1JlZ2lvbic6XG4gICAgICAgICAgLy8gMy4zIFdlYlZUVCByZWdpb24gbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdwYXJzZSByZWdpb24nLCB2KTtcbiAgICAgICAgICAvLyBwYXJzZVJlZ2lvbih2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSwgLzovKTtcbiAgICB9XG5cbiAgICAvLyA1LjEgV2ViVlRUIGZpbGUgcGFyc2luZy5cbiAgICB0cnkge1xuICAgICAgbGV0IGxpbmU7XG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gJ0lOSVRJQUwnKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHN0YXJ0IHBhcnNpbmcgdW50aWwgd2UgaGF2ZSB0aGUgZmlyc3QgbGluZS5cbiAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChzZWxmLmJ1ZmZlcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcbiAgICAgICAgLy8gc3RyaXAgb2YgVVRGLTggQk9NIGlmIGFueVxuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CeXRlX29yZGVyX21hcmsjVVRGLThcbiAgICAgICAgbGV0IG0gPSBsaW5lLm1hdGNoKC9eKMOvwrvCvyk/V0VCVlRUKFsgXFx0XS4qKT8kLyk7XG4gICAgICAgIGlmICghbSB8fCAhbVswXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFdlYlZUVCBzaWduYXR1cmUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnN0YXRlID0gJ0hFQURFUic7XG4gICAgICB9XG5cbiAgICAgIGxldCBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xuICAgICAgd2hpbGUgKHNlbGYuYnVmZmVyKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHBhcnNlIGEgbGluZSB1bnRpbCB3ZSBoYXZlIHRoZSBmdWxsIGxpbmUuXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3Qoc2VsZi5idWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFscmVhZHlDb2xsZWN0ZWRMaW5lKSB7XG4gICAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHNlbGYuc3RhdGUpIHtcbiAgICAgICAgY2FzZSAnSEVBREVSJzpcbiAgICAgICAgICAvLyAxMy0xOCAtIEFsbG93IGEgaGVhZGVyIChtZXRhZGF0YSkgdW5kZXIgdGhlIFdFQlZUVCBsaW5lLlxuICAgICAgICAgIGlmICgvOi8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgcGFyc2VIZWFkZXIobGluZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICghbGluZSkge1xuICAgICAgICAgICAgLy8gQW4gZW1wdHkgbGluZSB0ZXJtaW5hdGVzIHRoZSBoZWFkZXIgYW5kIHN0YXJ0cyB0aGUgYm9keSAoY3VlcykuXG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgJ05PVEUnOlxuICAgICAgICAgIC8vIElnbm9yZSBOT1RFIGJsb2Nrcy5cbiAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlICdJRCc6XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzdGFydCBvZiBOT1RFIGJsb2Nrcy5cbiAgICAgICAgICBpZiAoL15OT1RFKCR8WyBcXHRdKS8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdOT1RFJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyAxOS0yOSAtIEFsbG93IGFueSBudW1iZXIgb2YgbGluZSB0ZXJtaW5hdG9ycywgdGhlbiBpbml0aWFsaXplIG5ldyBjdWUgdmFsdWVzLlxuICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5jdWUgPSBuZXcgVlRUQ3VlKDAsIDAsICcnKTtcbiAgICAgICAgICBzZWxmLnN0YXRlID0gJ0NVRSc7XG4gICAgICAgICAgLy8gMzAtMzkgLSBDaGVjayBpZiBzZWxmIGxpbmUgY29udGFpbnMgYW4gb3B0aW9uYWwgaWRlbnRpZmllciBvciB0aW1pbmcgZGF0YS5cbiAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCctLT4nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHNlbGYuY3VlLmlkID0gbGluZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQcm9jZXNzIGxpbmUgYXMgc3RhcnQgb2YgYSBjdWUuXG4gICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdDVUUnOlxuICAgICAgICAgIC8vIDQwIC0gQ29sbGVjdCBjdWUgdGltaW5ncyBhbmQgc2V0dGluZ3MuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhcnNlQ3VlKGxpbmUsIHNlbGYuY3VlLCBzZWxmLnJlZ2lvbkxpc3QpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgYW4gZXJyb3IgaWdub3JlIHJlc3Qgb2YgdGhlIGN1ZS5cbiAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnQkFEQ1VFJztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLnN0YXRlID0gJ0NVRVRFWFQnO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlICdDVUVURVhUJzpcbiAgICAgICAgICB2YXIgaGFzU3Vic3RyaW5nID0gbGluZS5pbmRleE9mKCctLT4nKSAhPT0gLTE7XG4gICAgICAgICAgLy8gMzQgLSBJZiB3ZSBoYXZlIGFuIGVtcHR5IGxpbmUgdGhlbiByZXBvcnQgdGhlIGN1ZS5cbiAgICAgICAgICAvLyAzNSAtIElmIHdlIGhhdmUgdGhlIHNwZWNpYWwgc3Vic3RyaW5nICctLT4nIHRoZW4gcmVwb3J0IHRoZSBjdWUsXG4gICAgICAgICAgLy8gYnV0IGRvIG5vdCBjb2xsZWN0IHRoZSBsaW5lIGFzIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGUgY3VycmVudFxuICAgICAgICAgIC8vIG9uZSBhcyBhIG5ldyBjdWUuXG4gICAgICAgICAgaWYgKCFsaW5lIHx8IGhhc1N1YnN0cmluZyAmJiAoYWxyZWFkeUNvbGxlY3RlZExpbmUgPSB0cnVlKSkge1xuICAgICAgICAgICAgLy8gV2UgYXJlIGRvbmUgcGFyc2luZyBzZWxmIGN1ZS5cbiAgICAgICAgICAgIGlmIChzZWxmLm9uY3VlKSB7XG4gICAgICAgICAgICAgIHNlbGYub25jdWUoc2VsZi5jdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmN1ZSA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VsZi5jdWUudGV4dCkge1xuICAgICAgICAgICAgc2VsZi5jdWUudGV4dCArPSAnXFxuJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLmN1ZS50ZXh0ICs9IGxpbmU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgJ0JBRENVRSc6IC8vIEJBRENVRVxuICAgICAgICAgIC8vIDU0LTYyIC0gQ29sbGVjdCBhbmQgZGlzY2FyZCB0aGUgcmVtYWluaW5nIGN1ZS5cbiAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBwYXJzaW5nIGEgY3VlLCByZXBvcnQgd2hhdCB3ZSBoYXZlLlxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdDVUVURVhUJyAmJiBzZWxmLmN1ZSAmJiBzZWxmLm9uY3VlKSB7XG4gICAgICAgIHNlbGYub25jdWUoc2VsZi5jdWUpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmN1ZSA9IG51bGw7XG4gICAgICAvLyBFbnRlciBCQURXRUJWVFQgc3RhdGUgaWYgaGVhZGVyIHdhcyBub3QgcGFyc2VkIGNvcnJlY3RseSBvdGhlcndpc2VcbiAgICAgIC8vIGFub3RoZXIgZXhjZXB0aW9uIG9jY3VycmVkIHNvIGVudGVyIEJBRENVRSBzdGF0ZS5cbiAgICAgIHNlbGYuc3RhdGUgPSBzZWxmLnN0YXRlID09PSAnSU5JVElBTCcgPyAnQkFEV0VCVlRUJyA6ICdCQURDVUUnO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpbmlzaCBkZWNvZGluZyB0aGUgc3RyZWFtLlxuICAgICAgc2VsZi5idWZmZXIgKz0gc2VsZi5kZWNvZGVyLmRlY29kZSgpO1xuICAgICAgLy8gU3ludGhlc2l6ZSB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGN1ZSBvciByZWdpb24uXG4gICAgICBpZiAoc2VsZi5jdWUgfHwgc2VsZi5zdGF0ZSA9PT0gJ0hFQURFUicpIHtcbiAgICAgICAgc2VsZi5idWZmZXIgKz0gJ1xcblxcbic7XG4gICAgICAgIHNlbGYucGFyc2UoKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlJ3ZlIGZsdXNoZWQsIHBhcnNlZCwgYW5kIHdlJ3JlIHN0aWxsIG9uIHRoZSBJTklUSUFMIHN0YXRlIHRoZW5cbiAgICAgIC8vIHRoYXQgbWVhbnMgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggb2YgdGhlIHN0cmVhbSB0byBwYXJzZSB0aGUgZmlyc3RcbiAgICAgIC8vIGxpbmUuXG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gJ0lOSVRJQUwnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFdlYlZUVCBzaWduYXR1cmUuJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgaWYgKHNlbGYub25mbHVzaCkge1xuICAgICAgc2VsZi5vbmZsdXNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGZpeExpbmVCcmVha3MgfTtcblxuZXhwb3J0IGRlZmF1bHQgVlRUUGFyc2VyO1xuIiwiaW1wb3J0IFZUVFBhcnNlciBmcm9tICcuL3Z0dHBhcnNlcic7XG5pbXBvcnQgeyB1dGY4QXJyYXlUb1N0ciB9IGZyb20gJy4uL2RlbXV4L2lkMyc7XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCBpcyBub3Qgc3VwcG9ydGVkIGluIElFMTFcbmNvbnN0IHN0YXJ0c1dpdGggPSBmdW5jdGlvbiAoaW5wdXRTdHJpbmcsIHNlYXJjaFN0cmluZywgcG9zaXRpb24pIHtcbiAgcmV0dXJuIGlucHV0U3RyaW5nLnN1YnN0cihwb3NpdGlvbiB8fCAwLCBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nO1xufTtcblxuY29uc3QgY3VlU3RyaW5nMm1pbGxpcyA9IGZ1bmN0aW9uICh0aW1lU3RyaW5nKSB7XG4gIGxldCB0cyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKC0zKSk7XG4gIGxldCBzZWNzID0gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoLTYsIDIpKTtcbiAgbGV0IG1pbnMgPSBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigtOSwgMikpO1xuICBsZXQgaG91cnMgPSB0aW1lU3RyaW5nLmxlbmd0aCA+IDkgPyBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigwLCB0aW1lU3RyaW5nLmluZGV4T2YoJzonKSkpIDogMDtcblxuICBpZiAoIU51bWJlci5pc0Zpbml0ZSh0cykgfHwgIU51bWJlci5pc0Zpbml0ZShzZWNzKSB8fCAhTnVtYmVyLmlzRmluaXRlKG1pbnMpIHx8ICFOdW1iZXIuaXNGaW5pdGUoaG91cnMpKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgdHMgKz0gMTAwMCAqIHNlY3M7XG4gIHRzICs9IDYwICogMTAwMCAqIG1pbnM7XG4gIHRzICs9IDYwICogNjAgKiAxMDAwICogaG91cnM7XG5cbiAgcmV0dXJuIHRzO1xufTtcblxuLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaFxuY29uc3QgaGFzaCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGxldCBoYXNoID0gNTM4MTtcbiAgbGV0IGkgPSB0ZXh0Lmxlbmd0aDtcbiAgd2hpbGUgKGkpIHtcbiAgICBoYXNoID0gKGhhc2ggKiAzMykgXiB0ZXh0LmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuXG4gIHJldHVybiAoaGFzaCA+Pj4gMCkudG9TdHJpbmcoKTtcbn07XG5cbmNvbnN0IGNhbGN1bGF0ZU9mZnNldCA9IGZ1bmN0aW9uICh2dHRDQ3MsIGNjLCBwcmVzZW50YXRpb25UaW1lKSB7XG4gIGxldCBjdXJyQ0MgPSB2dHRDQ3NbY2NdO1xuICBsZXQgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuXG4gIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGRpc2NvbnRpbnVpdHkgb3IgY3VlcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHNpbmNlIHRoZSBsYXN0IGRpc2NvbnRpbnVpdHlcbiAgLy8gT2Zmc2V0ID0gY3VycmVudCBkaXNjb250aW51aXR5IHRpbWVcbiAgaWYgKCFwcmV2Q0MgfHwgKCFwcmV2Q0MubmV3ICYmIGN1cnJDQy5uZXcpKSB7XG4gICAgdnR0Q0NzLmNjT2Zmc2V0ID0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVGhlcmUgaGF2ZSBiZWVuIGRpc2NvbnRpbnVpdGllcyBzaW5jZSBjdWVzIHdlcmUgbGFzdCBwYXJzZWQuXG4gIC8vIE9mZnNldCA9IHRpbWUgZWxhcHNlZFxuICB3aGlsZSAocHJldkNDICYmIHByZXZDQy5uZXcpIHtcbiAgICB2dHRDQ3MuY2NPZmZzZXQgKz0gY3VyckNDLnN0YXJ0IC0gcHJldkNDLnN0YXJ0O1xuICAgIGN1cnJDQy5uZXcgPSBmYWxzZTtcbiAgICBjdXJyQ0MgPSBwcmV2Q0M7XG4gICAgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuICB9XG5cbiAgdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IHByZXNlbnRhdGlvblRpbWU7XG59O1xuXG5jb25zdCBXZWJWVFRQYXJzZXIgPSB7XG4gIHBhcnNlOiBmdW5jdGlvbiAodnR0Qnl0ZUFycmF5LCBzeW5jUFRTLCB2dHRDQ3MsIGNjLCBjYWxsQmFjaywgZXJyb3JDYWxsQmFjaykge1xuICAgIC8vIENvbnZlcnQgYnl0ZUFycmF5IGludG8gc3RyaW5nLCByZXBsYWNpbmcgYW55IHNvbWV3aGF0IGV4b3RpYyBsaW5lZmVlZHMgd2l0aCBcIlxcblwiLCB0aGVuIHNwbGl0IG9uIHRoYXQgY2hhcmFjdGVyLlxuICAgIGxldCByZSA9IC9cXHJcXG58XFxuXFxyfFxcbnxcXHIvZztcbiAgICAvLyBVaW50OEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgaXMgbm90IGltcGxlbWVudGVkIGluIElFMTFcbiAgICBsZXQgdnR0TGluZXMgPSB1dGY4QXJyYXlUb1N0cihuZXcgVWludDhBcnJheSh2dHRCeXRlQXJyYXkpKS50cmltKCkucmVwbGFjZShyZSwgJ1xcbicpLnNwbGl0KCdcXG4nKTtcblxuICAgIGxldCBjdWVUaW1lID0gJzAwOjAwLjAwMCc7XG4gICAgbGV0IG1wZWdUcyA9IDA7XG4gICAgbGV0IGxvY2FsVGltZSA9IDA7XG4gICAgbGV0IHByZXNlbnRhdGlvblRpbWUgPSAwO1xuICAgIGxldCBjdWVzID0gW107XG4gICAgbGV0IHBhcnNpbmdFcnJvcjtcbiAgICBsZXQgaW5IZWFkZXIgPSB0cnVlO1xuICAgIC8vIGxldCBWVFRDdWUgPSBWVFRDdWUgfHwgd2luZG93LlRleHRUcmFja0N1ZTtcblxuICAgIC8vIENyZWF0ZSBwYXJzZXIgb2JqZWN0IHVzaW5nIFZUVEN1ZSB3aXRoIFRleHRUcmFja0N1ZSBmYWxsYmFjayBvbiBjZXJ0YWluIGJyb3dzZXJzLlxuICAgIGxldCBwYXJzZXIgPSBuZXcgVlRUUGFyc2VyKCk7XG5cbiAgICBwYXJzZXIub25jdWUgPSBmdW5jdGlvbiAoY3VlKSB7XG4gICAgICAvLyBBZGp1c3QgY3VlIHRpbWluZzsgY2xhbXAgY3VlcyB0byBzdGFydCBubyBlYXJsaWVyIHRoYW4gLSBhbmQgZHJvcCBjdWVzIHRoYXQgZG9uJ3QgZW5kIGFmdGVyIC0gMCBvbiB0aW1lbGluZS5cbiAgICAgIGxldCBjdXJyQ0MgPSB2dHRDQ3NbY2NdO1xuICAgICAgbGV0IGN1ZU9mZnNldCA9IHZ0dENDcy5jY09mZnNldDtcblxuICAgICAgLy8gVXBkYXRlIG9mZnNldHMgZm9yIG5ldyBkaXNjb250aW51aXRpZXNcbiAgICAgIGlmIChjdXJyQ0MgJiYgY3VyckNDLm5ldykge1xuICAgICAgICBpZiAobG9jYWxUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGxvY2FsIHRpbWUgaXMgcHJvdmlkZWQsIG9mZnNldCA9IGRpc2NvbnRpbnVpdHkgc3RhcnQgdGltZSAtIGxvY2FsIHRpbWVcbiAgICAgICAgICBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsY3VsYXRlT2Zmc2V0KHZ0dENDcywgY2MsIHByZXNlbnRhdGlvblRpbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmVzZW50YXRpb25UaW1lKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgTVBFR1RTLCBvZmZzZXQgPSBwcmVzZW50YXRpb24gdGltZSArIGRpc2NvbnRpbnVpdHkgb2Zmc2V0XG4gICAgICAgIGN1ZU9mZnNldCA9IHByZXNlbnRhdGlvblRpbWUgLSB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBjdWUuc3RhcnRUaW1lICs9IGN1ZU9mZnNldCAtIGxvY2FsVGltZTtcbiAgICAgIGN1ZS5lbmRUaW1lICs9IGN1ZU9mZnNldCAtIGxvY2FsVGltZTtcblxuICAgICAgLy8gQ3JlYXRlIGEgdW5pcXVlIGhhc2ggaWQgZm9yIGEgY3VlIGJhc2VkIG9uIHN0YXJ0L2VuZCB0aW1lcyBhbmQgdGV4dC5cbiAgICAgIC8vIFRoaXMgaGVscHMgdGltZWxpbmUtY29udHJvbGxlciB0byBhdm9pZCBzaG93aW5nIHJlcGVhdGVkIGNhcHRpb25zLlxuICAgICAgY3VlLmlkID0gaGFzaChjdWUuc3RhcnRUaW1lLnRvU3RyaW5nKCkpICsgaGFzaChjdWUuZW5kVGltZS50b1N0cmluZygpKSArIGhhc2goY3VlLnRleHQpO1xuXG4gICAgICAvLyBGaXggZW5jb2Rpbmcgb2Ygc3BlY2lhbCBjaGFyYWN0ZXJzLiBUT0RPOiBUZXN0IHdpdGggYWxsIHNvcnRzIG9mIHdlaXJkIGNoYXJhY3RlcnMuXG4gICAgICBjdWUudGV4dCA9IGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoY3VlLnRleHQpKTtcbiAgICAgIGlmIChjdWUuZW5kVGltZSA+IDApIHtcbiAgICAgICAgY3Vlcy5wdXNoKGN1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHBhcnNlci5vbnBhcnNpbmdlcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBwYXJzaW5nRXJyb3IgPSBlO1xuICAgIH07XG5cbiAgICBwYXJzZXIub25mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwYXJzaW5nRXJyb3IgJiYgZXJyb3JDYWxsQmFjaykge1xuICAgICAgICBlcnJvckNhbGxCYWNrKHBhcnNpbmdFcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhbGxCYWNrKGN1ZXMpO1xuICAgIH07XG5cbiAgICAvLyBHbyB0aHJvdWdoIGNvbnRlbnRzIGxpbmUgYnkgbGluZS5cbiAgICB2dHRMaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgaWYgKGluSGVhZGVyKSB7XG4gICAgICAgIC8vIExvb2sgZm9yIFgtVElNRVNUQU1QLU1BUCBpbiBoZWFkZXIuXG4gICAgICAgIGlmIChzdGFydHNXaXRoKGxpbmUsICdYLVRJTUVTVEFNUC1NQVA9JykpIHtcbiAgICAgICAgICAvLyBPbmNlIGZvdW5kLCBubyBtb3JlIGFyZSBhbGxvd2VkIGFueXdheSwgc28gc3RvcCBzZWFyY2hpbmcuXG4gICAgICAgICAgaW5IZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgICAvLyBFeHRyYWN0IExPQ0FMIGFuZCBNUEVHVFMuXG4gICAgICAgICAgbGluZS5zdWJzdHIoMTYpLnNwbGl0KCcsJykuZm9yRWFjaCh0aW1lc3RhbXAgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGgodGltZXN0YW1wLCAnTE9DQUw6JykpIHtcbiAgICAgICAgICAgICAgY3VlVGltZSA9IHRpbWVzdGFtcC5zdWJzdHIoNik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0c1dpdGgodGltZXN0YW1wLCAnTVBFR1RTOicpKSB7XG4gICAgICAgICAgICAgIG1wZWdUcyA9IHBhcnNlSW50KHRpbWVzdGFtcC5zdWJzdHIoNykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgc3VidGl0bGUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICAgIGlmIChzeW5jUFRTICsgKCh2dHRDQ3NbY2NdLnN0YXJ0ICogOTAwMDApIHx8IDApIDwgMCkge1xuICAgICAgICAgICAgICBzeW5jUFRTICs9IDg1ODk5MzQ1OTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGp1c3QgTVBFR1RTIGJ5IHN5bmMgUFRTLlxuICAgICAgICAgICAgbXBlZ1RzIC09IHN5bmNQVFM7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGN1ZSB0aW1lIHRvIHNlY29uZHNcbiAgICAgICAgICAgIGxvY2FsVGltZSA9IGN1ZVN0cmluZzJtaWxsaXMoY3VlVGltZSkgLyAxMDAwO1xuICAgICAgICAgICAgLy8gQ29udmVydCBNUEVHVFMgdG8gc2Vjb25kcyBmcm9tIDkwa0h6LlxuICAgICAgICAgICAgcHJlc2VudGF0aW9uVGltZSA9IG1wZWdUcyAvIDkwMDAwO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxUaW1lID09PSAtMSkge1xuICAgICAgICAgICAgICBwYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoYE1hbGZvcm1lZCBYLVRJTUVTVEFNUC1NQVA6ICR7bGluZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBwYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoYE1hbGZvcm1lZCBYLVRJTUVTVEFNUC1NQVA6ICR7bGluZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmV0dXJuIHdpdGhvdXQgcGFyc2luZyBYLVRJTUVTVEFNUC1NQVAgbGluZS5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAobGluZSA9PT0gJycpIHtcbiAgICAgICAgICBpbkhlYWRlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBQYXJzZSBsaW5lIGJ5IGRlZmF1bHQuXG4gICAgICBwYXJzZXIucGFyc2UobGluZSArICdcXG4nKTtcbiAgICB9KTtcblxuICAgIHBhcnNlci5mbHVzaCgpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBXZWJWVFRQYXJzZXI7XG4iLCIvKipcbiAqIFhIUiBiYXNlZCBsb2dnZXJcbiovXG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNvbnN0IHsgcGVyZm9ybWFuY2UsIFhNTEh0dHBSZXF1ZXN0IH0gPSB3aW5kb3c7XG5cbmNsYXNzIFhockxvYWRlciB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcpIHtcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy54aHJTZXR1cCkge1xuICAgICAgdGhpcy54aHJTZXR1cCA9IGNvbmZpZy54aHJTZXR1cDtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmFib3J0KCk7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICB9XG5cbiAgYWJvcnQgKCkge1xuICAgIGxldCBsb2FkZXIgPSB0aGlzLmxvYWRlcjtcbiAgICBpZiAobG9hZGVyICYmIGxvYWRlci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gbnVsbDtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lb3V0KTtcbiAgICB0aGlzLnJldHJ5VGltZW91dCA9IG51bGw7XG4gIH1cblxuICBsb2FkIChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgdGhpcy5zdGF0cyA9IHsgdHJlcXVlc3Q6IHBlcmZvcm1hbmNlLm5vdygpLCByZXRyeTogMCB9O1xuICAgIHRoaXMucmV0cnlEZWxheSA9IGNvbmZpZy5yZXRyeURlbGF5O1xuICAgIHRoaXMubG9hZEludGVybmFsKCk7XG4gIH1cblxuICBsb2FkSW50ZXJuYWwgKCkge1xuICAgIGxldCB4aHIsIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgeGhyID0gdGhpcy5sb2FkZXIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIGxldCBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgc3RhdHMudGZpcnN0ID0gMDtcbiAgICBzdGF0cy5sb2FkZWQgPSAwO1xuICAgIGNvbnN0IHhoclNldHVwID0gdGhpcy54aHJTZXR1cDtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoeGhyU2V0dXApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB4aHJTZXR1cCh4aHIsIGNvbnRleHQudXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGZpeCB4aHJTZXR1cDogKHhociwgdXJsKSA9PiB7eGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LUxhbmd1YWdlXCIsIFwidGVzdFwiKTt9XG4gICAgICAgICAgLy8gbm90IHdvcmtpbmcsIGFzIHhoci5zZXRSZXF1ZXN0SGVhZGVyIGV4cGVjdHMgeGhyLnJlYWR5U3RhdGUgPT09IE9QRU5cbiAgICAgICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xuICAgICAgICAgIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXhoci5yZWFkeVN0YXRlKSB7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBjb250ZXh0LnVybCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSUUxMSB0aHJvd3MgYW4gZXhjZXB0aW9uIG9uIHhoci5vcGVuIGlmIGF0dGVtcHRpbmcgdG8gYWNjZXNzIGFuIEhUVFAgcmVzb3VyY2Ugb3ZlciBIVFRQU1xuICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcih7IGNvZGU6IHhoci5zdGF0dXMsIHRleHQ6IGUubWVzc2FnZSB9LCBjb250ZXh0LCB4aHIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0LnJhbmdlRW5kKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCAnYnl0ZXM9JyArIGNvbnRleHQucmFuZ2VTdGFydCArICctJyArIChjb250ZXh0LnJhbmdlRW5kIC0gMSkpO1xuICAgIH1cblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLnJlYWR5c3RhdGVjaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB4aHIub25wcm9ncmVzcyA9IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcyk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IGNvbnRleHQucmVzcG9uc2VUeXBlO1xuXG4gICAgLy8gc2V0dXAgdGltZW91dCBiZWZvcmUgd2UgcGVyZm9ybSByZXF1ZXN0XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSwgdGhpcy5jb25maWcudGltZW91dCk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfVxuXG4gIHJlYWR5c3RhdGVjaGFuZ2UgKGV2ZW50KSB7XG4gICAgbGV0IHhociA9IGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGUsXG4gICAgICBzdGF0cyA9IHRoaXMuc3RhdHMsXG4gICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgY29uZmlnID0gdGhpcy5jb25maWc7XG5cbiAgICAvLyBkb24ndCBwcm9jZWVkIGlmIHhociBoYXMgYmVlbiBhYm9ydGVkXG4gICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyA+PSBIRUFERVJTX1JFQ0VJVkVEXG4gICAgaWYgKHJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgLy8gY2xlYXIgeGhyIHRpbWVvdXQgYW5kIHJlYXJtIGl0IGlmIHJlYWR5U3RhdGUgbGVzcyB0aGFuIDRcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICBpZiAoc3RhdHMudGZpcnN0ID09PSAwKSB7XG4gICAgICAgIHN0YXRzLnRmaXJzdCA9IE1hdGgubWF4KHBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy50cmVxdWVzdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIGxldCBzdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgICAvLyBodHRwIHN0YXR1cyBiZXR3ZWVuIDIwMCB0byAyOTkgYXJlIGFsbCBzdWNjZXNzZnVsXG4gICAgICAgIGlmIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgIHN0YXRzLnRsb2FkID0gTWF0aC5tYXgoc3RhdHMudGZpcnN0LCBwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgICAgbGV0IGRhdGEsIGxlbjtcbiAgICAgICAgICBpZiAoY29udGV4dC5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgICAgIGRhdGEgPSB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRzLmxvYWRlZCA9IHN0YXRzLnRvdGFsID0gbGVuO1xuICAgICAgICAgIGxldCByZXNwb25zZSA9IHsgdXJsOiB4aHIucmVzcG9uc2VVUkwsIGRhdGE6IGRhdGEgfTtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCB4aHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIG1heCBuYiBvZiByZXRyaWVzIHJlYWNoZWQgb3IgaWYgaHR0cCBzdGF0dXMgYmV0d2VlbiA0MDAgYW5kIDQ5OSAoc3VjaCBlcnJvciBjYW5ub3QgYmUgcmVjb3ZlcmVkLCByZXRyeWluZyBpcyB1c2VsZXNzKSwgcmV0dXJuIGVycm9yXG4gICAgICAgICAgaWYgKHN0YXRzLnJldHJ5ID49IGNvbmZpZy5tYXhSZXRyeSB8fCAoc3RhdHVzID49IDQwMCAmJiBzdGF0dXMgPCA0OTkpKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYCR7c3RhdHVzfSB3aGlsZSBsb2FkaW5nICR7Y29udGV4dC51cmx9YCk7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vbkVycm9yKHsgY29kZTogc3RhdHVzLCB0ZXh0OiB4aHIuc3RhdHVzVGV4dCB9LCBjb250ZXh0LCB4aHIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByZXRyeVxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYCR7c3RhdHVzfSB3aGlsZSBsb2FkaW5nICR7Y29udGV4dC51cmx9LCByZXRyeWluZyBpbiAke3RoaXMucmV0cnlEZWxheX0uLi5gKTtcbiAgICAgICAgICAgIC8vIGFib3J0cyBhbmQgcmVzZXRzIGludGVybmFsIHN0YXRlXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIHJldHJ5XG4gICAgICAgICAgICB0aGlzLnJldHJ5VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMubG9hZEludGVybmFsLmJpbmQodGhpcyksIHRoaXMucmV0cnlEZWxheSk7XG4gICAgICAgICAgICAvLyBzZXQgZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICAgICAgdGhpcy5yZXRyeURlbGF5ID0gTWF0aC5taW4oMiAqIHRoaXMucmV0cnlEZWxheSwgY29uZmlnLm1heFJldHJ5RGVsYXkpO1xuICAgICAgICAgICAgc3RhdHMucmV0cnkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlYWR5U3RhdGUgPj0gMiBBTkQgcmVhZHlTdGF0ZSAhPT00IChyZWFkeVN0YXRlID0gSEVBREVSU19SRUNFSVZFRCB8fCBMT0FESU5HKSByZWFybSB0aW1lb3V0IGFzIHhociBub3QgZmluaXNoZWQgeWV0XG4gICAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIGNvbmZpZy50aW1lb3V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsb2FkdGltZW91dCAoKSB7XG4gICAgbG9nZ2VyLndhcm4oYHRpbWVvdXQgd2hpbGUgbG9hZGluZyAke3RoaXMuY29udGV4dC51cmx9YCk7XG4gICAgdGhpcy5jYWxsYmFja3Mub25UaW1lb3V0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgbnVsbCk7XG4gIH1cblxuICBsb2FkcHJvZ3Jlc3MgKGV2ZW50KSB7XG4gICAgbGV0IHhociA9IGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICBzdGF0cyA9IHRoaXMuc3RhdHM7XG5cbiAgICBzdGF0cy5sb2FkZWQgPSBldmVudC5sb2FkZWQ7XG4gICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgIHN0YXRzLnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgfVxuXG4gICAgbGV0IG9uUHJvZ3Jlc3MgPSB0aGlzLmNhbGxiYWNrcy5vblByb2dyZXNzO1xuICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAvLyB0aGlyZCBhcmcgaXMgdG8gcHJvdmlkZSBvbiBwcm9ncmVzcyBkYXRhXG4gICAgICBvblByb2dyZXNzKHN0YXRzLCB0aGlzLmNvbnRleHQsIG51bGwsIHhocik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFhockxvYWRlcjtcbiIsImltcG9ydCBQbGF5ZXIgZnJvbSAneGdwbGF5ZXInXG5pbXBvcnQgSGxzIGZyb20gJy4vaGxzLmpzL2hscydcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJ1xuXG5jbGFzcyBIbHNKc1BsYXllciBleHRlbmRzIFBsYXllciB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucylcbiAgICB0aGlzLmhsc09wdHMgPSBvcHRpb25zLmhsc09wdHMgfHwge31cbiAgICBsZXQgdXRpbCA9IFBsYXllci51dGlsXG4gICAgbGV0IHBsYXllciA9IHRoaXNcbiAgICB0aGlzLmJyb3dzZXIgPSB1dGlscy5nZXRCcm93c2VyVmVyc2lvbigpXG4gICAgaWYocGxheWVyLmNvbmZpZy51c2VIbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKChQbGF5ZXIuc25pZmZlci5kZXZpY2UgPT09ICdtb2JpbGUnICYmIG5hdmlnYXRvci5wbGF0Zm9ybSAhPT0gJ01hY0ludGVsJyAmJiBuYXZpZ2F0b3IucGxhdGZvcm0gIT09ICdXaW4zMicpIHx8IHRoaXMuYnJvd3Nlci5pbmRleE9mKCdTYWZhcmknKSA+IC0xKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0gZWxzZSBpZighcGxheWVyLmNvbmZpZy51c2VIbHMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBOdW1iZXIuaXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsdWUpO1xuICAgIH1cblxuICAgIGxldCBobHNcbiAgICBobHMgPSBuZXcgSGxzKHRoaXMuaGxzT3B0cylcbiAgICB0aGlzLmhscyA9IGhsc1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBsYXllciwgJ3NyYycsIHtcbiAgICAgIGdldCAoKSB7XG4gICAgICAgIHJldHVybiBwbGF5ZXIuY3VycmVudFNyY1xuICAgICAgfSxcbiAgICAgIHNldCAodXJsKSB7XG4gICAgICAgIHV0aWwucmVtb3ZlQ2xhc3MocGxheWVyLnJvb3QsICd4Z3BsYXllci1pcy1saXZlJylcbiAgICAgICAgY29uc3QgbGl2ZURvbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy54Z3BsYXllci1saXZlJylcbiAgICAgICAgaWYgKGxpdmVEb20pIHtcbiAgICAgICAgICBsaXZlRG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGl2ZURvbSlcbiAgICAgICAgfVxuICAgICAgICAvLyBwbGF5ZXIuY29uZmlnLnVybCA9IHVybFxuICAgICAgICBjb25zdCBwYXVzZWQgPSBwbGF5ZXIucGF1c2VkXG4gICAgICAgIHBsYXllci5obHMuc3RvcExvYWQoKVxuICAgICAgICBwbGF5ZXIuaGxzLmRldGFjaE1lZGlhKClcbiAgICAgICAgcGxheWVyLmhscy5kZXN0cm95KClcbiAgICAgICAgcGxheWVyLmhscyA9IG5ldyBIbHMocGxheWVyLmhsc09wdHMpXG4gICAgICAgIHBsYXllci5yZWdpc3Rlcih1cmwpXG4gICAgICAgIGlmICghcGF1c2VkKSB7XG4gICAgICAgICAgcGxheWVyLnBhdXNlKClcbiAgICAgICAgICBwbGF5ZXIub25jZSgncGF1c2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBwbGF5ZXIuaGxzLmxvYWRTb3VyY2UodXJsKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgcGxheWVyLm9uY2UoJ2NhbnBsYXknLCAoKSA9PiB7XG4gICAgICAgICAgICBwbGF5ZXIucGxheSgpLmNhdGNoKGVyciA9PiB7fSlcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBsYXllci5obHMubG9hZFNvdXJjZSh1cmwpXG4gICAgICAgIH1cbiAgICAgICAgcGxheWVyLmhscy5hdHRhY2hNZWRpYShwbGF5ZXIudmlkZW8pXG4gICAgICAgIHBsYXllci5vbmNlKCdjYW5wbGF5JywgKCkgPT4ge1xuICAgICAgICAgIHBsYXllci5jdXJyZW50VGltZSA9IDBcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICAgIHRoaXMucmVnaXN0ZXIodGhpcy5jb25maWcudXJsKVxuICAgIHRoaXMub25jZSgnY29tcGxldGUnLCAoKSA9PiB7XG4gICAgICBobHMuYXR0YWNoTWVkaWEocGxheWVyLnZpZGVvKVxuICAgICAgcGxheWVyLm9uY2UoJ2NhbnBsYXknLCAoKSA9PiB7XG4gICAgICAgIGlmKHBsYXllci5jb25maWcuYXV0b3BsYXkpIHtcbiAgICAgICAgICBwbGF5ZXIucGxheSgpLmNhdGNoKGVyciA9PiB7fSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGlmKHBsYXllci5jb25maWcuaXNMaXZlKSB7XG4gICAgICAgIHV0aWwuYWRkQ2xhc3MocGxheWVyLnJvb3QsICd4Z3BsYXllci1pcy1saXZlJylcbiAgICAgICAgaWYoIXV0aWwuZmluZERvbShwbGF5ZXIucm9vdCwgJy54Z3BsYXllci1saXZlJykpIHtcbiAgICAgICAgICBjb25zdCBsaXZlID0gdXRpbC5jcmVhdGVEb20oJ3hnLWxpdmUnLCAn5q2j5Zyo55u05pKtJywge30sICd4Z3BsYXllci1saXZlJylcbiAgICAgICAgICBwbGF5ZXIuY29udHJvbHMuYXBwZW5kQ2hpbGQobGl2ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5vbmNlKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgaGxzLnN0b3BMb2FkKClcbiAgICB9KVxuICB9XG4gIHJlZ2lzdGVyICh1cmwpIHtcbiAgICBsZXQgaGxzID0gdGhpcy5obHNcbiAgICBsZXQgdXRpbCA9IFBsYXllci51dGlsXG4gICAgbGV0IHBsYXllciA9IHRoaXNcbiAgICBobHMub24oSGxzLkV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgKCkgPT4ge1xuICAgICAgaGxzLmxvYWRTb3VyY2UodXJsKVxuICAgIH0pXG5cbiAgICBobHMub24oSGxzLkV2ZW50cy5MRVZFTF9MT0FERUQsIChuYW1lLCBlKSA9PiB7XG4gICAgICBpZiAoIWhscy5pbml0ZWQpIHtcbiAgICAgICAgaGxzLmluaXRlZCA9IHRydWVcbiAgICAgICAgaWYgKGUgJiYgZS5kZXRhaWxzICYmIGUuZGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgdXRpbC5hZGRDbGFzcyhwbGF5ZXIucm9vdCwgJ3hncGxheWVyLWlzLWxpdmUnKVxuICAgICAgICAgIGlmKCF1dGlsLmZpbmREb20ocGxheWVyLnJvb3QsICcueGdwbGF5ZXItbGl2ZScpKSB7XG4gICAgICAgICAgICBjb25zdCBsaXZlID0gdXRpbC5jcmVhdGVEb20oJ3hnLWxpdmUnLCAn5q2j5Zyo55u05pKtJywge30sICd4Z3BsYXllci1saXZlJylcbiAgICAgICAgICAgIHBsYXllci5jb250cm9scy5hcHBlbmRDaGlsZChsaXZlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgaGxzLm9uKEhscy5FdmVudHMuRVJST1IsIChldmVudCwgZGF0YSkgPT4ge1xuICAgICAgcGxheWVyLmVtaXQoJ0hMU19FUlJPUicsIHtcbiAgICAgICAgZXJyb3JUeXBlOiBkYXRhLnR5cGUsXG4gICAgICAgIGVycm9yRGV0YWlsczogZGF0YS5kZXRhaWxzLFxuICAgICAgICBlcnJvckZhdGFsOiBkYXRhLmZhdGFsLFxuICAgICAgfSlcbiAgICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBIbHMuRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SOlxuICAgICAgICAgICAgaGxzLnN0YXJ0TG9hZCgpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgSGxzLkVycm9yVHlwZXMuTUVESUFfRVJST1I6XG4gICAgICAgICAgICBobHMucmVjb3Zlck1lZGlhRXJyb3IoKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcGxheWVyLmVtaXQoJ2Vycm9yJywgZGF0YSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5fc3RhdGlzdGljcygpO1xuICB9XG5cbiAgX3N0YXRpc3RpY3MoKSB7XG4gICAgbGV0IHN0YXRzSW5mbyA9IHtcbiAgICAgIHNwZWVkOjAsXG4gICAgICBwbGF5ZXJUeXBlOiBcIkhsc1BsYXllclwiXG4gICAgfTtcblxuICAgIGxldCBtZWRpYWluZm8gPSB7XG4gICAgICB2aWRlb0RhdGFSYXRlOjAsXG4gICAgICBhdWRpb0RhdGFSYXRlOjBcbiAgICB9O1xuICAgIGxldCBobHMgPSB0aGlzLmhscztcbiAgICBsZXQgcGxheWVyID0gdGhpcztcblxuICAgIGhscy5vbihIbHMuRXZlbnRzLkZSQUdfTE9BRF9QUk9HUkVTUywgKGZsYWcscGF5bG9hZCkgPT57XG4gICAgICBzdGF0c0luZm8uc3BlZWQgPSBwYXlsb2FkLnN0YXRzLmxvYWRlZCAvIDEwMDA7XG4gICAgfSk7XG4gICAgaGxzLm9uKEhscy5FdmVudHMuRlJBR19QQVJTSU5HX0RBVEEsIChmbGFnLHBheWxvYWQpID0+e1xuICAgICAgaWYgKHBheWxvYWQudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICBtZWRpYWluZm8uZnBzID0gcGFyc2VJbnQocGF5bG9hZC5uYi8ocGF5bG9hZC5lbmRQVFMgLXBheWxvYWQuc3RhcnRQVFMpKTtcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaGxzLm9uKEhscy5FdmVudHMuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwgKGZsYWcscGF5bG9hZCkgPT57XG4gICAgICBtZWRpYWluZm8uaGFzQXVkaW8gPSAocGF5bG9hZC50cmFja3MgJiYgcGF5bG9hZC50cmFja3MuYXVkaW8pPyB0cnVlOiBmYWxzZTtcbiAgICAgIG1lZGlhaW5mby5oYXNWaWRlbyA9IChwYXlsb2FkLnRyYWNrcyAmJiBwYXlsb2FkLnRyYWNrcy5hdWRpbyk/IHRydWU6IGZhbHNlO1xuXG4gICAgICBpZihtZWRpYWluZm8uaGFzQXVkaW8pIHtcbiAgICAgICAgbGV0IHRyYWNrID0gcGF5bG9hZC50cmFja3MuYXVkaW87XG4gICAgICAgIG1lZGlhaW5mby5hdWRpb0NoYW5uZWxDb3VudCA9ICh0cmFjay5tZXRhZGF0YSAmJiB0cmFjay5tZXRhZGF0YS5jaGFubmVsQ291bnQpID8gdHJhY2subWV0YWRhdGEuY2hhbm5lbENvdW50OjA7XG4gICAgICAgIG1lZGlhaW5mby5hdWRpb0NvZGVjID0gdHJhY2suY29kZWM7XG4gICAgICB9XG5cbiAgICAgIGlmKG1lZGlhaW5mby5oYXNWaWRlbykge1xuICAgICAgICBsZXQgdHJhY2sgPSBwYXlsb2FkLnRyYWNrcy52aWRlbztcbiAgICAgICAgbWVkaWFpbmZvLnZpZGVvQ29kZWMgPSB0cmFjay5jb2RlYztcbiAgICAgICAgbWVkaWFpbmZvLndpZHRoID0gKHRyYWNrLm1ldGFkYXRhICYmIHRyYWNrLm1ldGFkYXRhLndpZHRoKSA/IHRyYWNrLm1ldGFkYXRhLndpZHRoOjA7XG4gICAgICAgIG1lZGlhaW5mby5oZWlnaHQgPSAodHJhY2subWV0YWRhdGEgJiYgdHJhY2subWV0YWRhdGEuaGVpZ2h0KSA/IHRyYWNrLm1ldGFkYXRhLmhlaWdodDowO1xuICAgICAgfVxuICAgICAgbWVkaWFpbmZvLmR1cmF0aW9uID0gKHBheWxvYWQuZnJhZyAmJiBwYXlsb2FkLmZyYWcuZHVyYXRpb24pID8gcGF5bG9hZC5mcmFnLmR1cmF0aW9uOjBcbiAgICAgIG1lZGlhaW5mby5sZXZlbCA9KHBheWxvYWQuZnJhZyAmJiBwYXlsb2FkLmZyYWcubGV2ZWxzKSA/IHBheWxvYWQuZnJhZy5sZXZlbHM6MDtcbiAgICAgIGlmKG1lZGlhaW5mby52aWRlb0NvZGVjIHx8IG1lZGlhaW5mby5hdWRpb0NvZGVjKSB7XG4gICAgICAgIG1lZGlhaW5mby5taW1lVHlwZSA9IGB2aWRlby9obHM7IGNvZGVjcz1cIiR7bWVkaWFpbmZvLnZpZGVvQ29kZWN9OyR7bWVkaWFpbmZvLmF1ZGlvQ29kZWN9XCJgXG4gICAgICB9XG5cbiAgICAgIHBsYXllci5tZWRpYWluZm8gPSBtZWRpYWluZm87XG4gICAgICBwbGF5ZXIuZW1pdChcIm1lZGlhX2luZm9cIiwgbWVkaWFpbmZvKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3N0YXRpc3RpY3NUaW1tZXIgPSBzZXRJbnRlcnZhbCgoKT0+e1xuICAgICAgcGxheWVyLmVtaXQoXCJzdGF0aXN0aWNzX2luZm9cIiwgc3RhdHNJbmZvKTtcbiAgICAgIHN0YXRzSW5mby5zcGVlZCA9IDA7XG4gICAgfSwgMTAwMClcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fc3RhdGlzdGljc1RpbW1lcik7XG4gIH1cbn1cblxuSGxzSnNQbGF5ZXIuaXNTdXBwb3J0ZWQgPSBIbHMuaXNTdXBwb3J0ZWRcblxuZXhwb3J0IGRlZmF1bHQgSGxzSnNQbGF5ZXJcbiIsImxldCB1dGlsID0ge31cblxudXRpbC5nZXRCcm93c2VyVmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgLy/lj5blvpfmtY/op4jlmajnmoR1c2VyQWdlbnTlrZfnrKbkuLJcbiAgaWYodXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIm1vYmlsZVwiKSA+IC0xKSB7XG4gICAgcmV0dXJuIFwiVW5rbm93blwiXG4gIH1cbiAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSA+IC0xKSB7XG4gICAgbGV0IHZlcnNpb24gPSB1c2VyQWdlbnQubWF0Y2goL2ZpcmVmb3hcXC9bXFxkLl0rL2dpKVswXS5tYXRjaCgvW1xcZF0rLylbMF1cbiAgICByZXR1cm4gXCJGaXJlZm94IFwiK3ZlcnNpb25cbiAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcIkVkZ2VcIikgPiAtMSkge1xuICAgIGxldCB2ZXJzaW9uID0gdXNlckFnZW50Lm1hdGNoKC9lZGdlXFwvW1xcZC5dKy9naSlbMF0ubWF0Y2goL1tcXGRdKy8pWzBdXG4gICAgcmV0dXJuIFwiRWRnZSBcIit2ZXJzaW9uXG4gIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoXCJydjoxMVwiKSA+IC0xKSB7XG4gICAgcmV0dXJuIFwiSUUgMTFcIlxuICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKFwiT3BlcmFcIikgPiAtMSB8fCB1c2VyQWdlbnQuaW5kZXhPZihcIk9QUlwiKSA+IC0xKSB7XG4gICAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKFwiT3BlcmFcIikgPiAtMSkge1xuICAgICAgbGV0IHZlcnNpb24gPSB1c2VyQWdlbnQubWF0Y2goL29wZXJhXFwvW1xcZC5dKy9naSlbMF0ubWF0Y2goL1tcXGRdKy8pWzBdXG4gICAgICByZXR1cm4gXCJPcGVyYSBcIit2ZXJzaW9uXG4gICAgfVxuICAgIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcIk9QUlwiKSA+IC0xKSB7XG4gICAgICBsZXQgdmVyc2lvbiA9IHVzZXJBZ2VudC5tYXRjaCgvb3ByXFwvW1xcZC5dKy9naSlbMF0ubWF0Y2goL1tcXGRdKy8pWzBdXG4gICAgICByZXR1cm4gXCJPcGVyYSBcIit2ZXJzaW9uXG4gICAgfVxuICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKFwiQ2hyb21lXCIpID4gLTEpIHtcbiAgICBsZXQgdmVyc2lvbiA9IHVzZXJBZ2VudC5tYXRjaCgvY2hyb21lXFwvW1xcZC5dKy9naSlbMF0ubWF0Y2goL1tcXGRdKy8pWzBdXG4gICAgcmV0dXJuIFwiQ2hyb21lIFwiK3ZlcnNpb25cbiAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcIlNhZmFyaVwiKSA+IC0xKSB7XG4gICAgbGV0IHZlcnNpb24gPSB1c2VyQWdlbnQubWF0Y2goL3NhZmFyaVxcL1tcXGQuXSsvZ2kpWzBdLm1hdGNoKC9bXFxkXSsvKVswXVxuICAgIHJldHVybiBcIlNhZmFyaSBcIit2ZXJzaW9uXG4gIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoXCJNU0lFXCIpID4gLTEgfHwgdXNlckFnZW50LmluZGV4T2YoXCJUcmlkZW50XCIpID4gLTEpIHtcbiAgICBpZiAodXNlckFnZW50LmluZGV4T2YoXCJNU0lFXCIpID4gLTEpIHtcbiAgICAgIGxldCB2ZXJzaW9uID0gdXNlckFnZW50Lm1hdGNoKC9tc2llIFtcXGQuXSsvZ2kpWzBdLm1hdGNoKC9bXFxkXSsvKVswXVxuICAgICAgcmV0dXJuIFwiSUUgXCIrdmVyc2lvblxuICAgIH1cbiAgICBpZiAodXNlckFnZW50LmluZGV4T2YoXCJUcmlkZW50XCIpID4gLTEpIHtcbiAgICAgIGxldCB2ZXJzaW9uVHJpZGVudCA9IHVzZXJBZ2VudC5tYXRjaCgvdHJpZGVudFxcL1tcXGQuXSsvZ2kpWzBdLm1hdGNoKC9bXFxkXSsvKVswXVxuICAgICAgbGV0IHZlcnNpb24gPSBwYXJzZUludCh2ZXJzaW9uVHJpZGVudCkgKyA0XG4gICAgICByZXR1cm4gXCJJRSBcIit2ZXJzaW9uXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlVua25vd25cIlxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHV0aWxcbiIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV94Z3BsYXllcl9fOyJdLCJzb3VyY2VSb290IjoiIn0=