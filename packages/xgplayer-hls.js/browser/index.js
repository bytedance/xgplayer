window["HlsJsPlayer"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/eventemitter3/index.js":
/*!***********************************************************************************************!*\
  !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/eventemitter3/index.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "../../node_modules/events/events.js":
/*!*****************************************************************************************!*\
  !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/events/events.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),

/***/ "../../node_modules/url-toolkit/src/url-toolkit.js":
/*!*******************************************************************************************************!*\
  !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/url-toolkit/src/url-toolkit.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// see https://tools.ietf.org/html/rfc1808

/* jshint ignore:start */
(function(root) { 
/* jshint ignore:end */

  var URL_REGEX = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/\?#]*\/)*.*?)??(;.*?)?(\?.*?)?(#.*?)?$/;
  var FIRST_SEGMENT_REGEX = /^([^\/?#]*)(.*)$/;
  var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
  var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g;

  var URLToolkit = { // jshint ignore:line
    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
    // E.g
    // With opts.alwaysNormalize = false (default, spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
    // With opts.alwaysNormalize = true (not spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
    buildAbsoluteURL: function(baseURL, relativeURL, opts) {
      opts = opts || {};
      // remove any remaining space and CRLF
      baseURL = baseURL.trim();
      relativeURL = relativeURL.trim();
      if (!relativeURL) {
        // 2a) If the embedded URL is entirely empty, it inherits the
        // entire base URL (i.e., is set equal to the base URL)
        // and we are done.
        if (!opts.alwaysNormalize) {
          return baseURL;
        }
        var basePartsForNormalise = URLToolkit.parseURL(baseURL);
        if (!basePartsForNormalise) {
          throw new Error('Error trying to parse base URL.');
        }
        basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
        return URLToolkit.buildURLFromParts(basePartsForNormalise);
      }
      var relativeParts = URLToolkit.parseURL(relativeURL);
      if (!relativeParts) {
        throw new Error('Error trying to parse relative URL.');
      }
      if (relativeParts.scheme) {
        // 2b) If the embedded URL starts with a scheme name, it is
        // interpreted as an absolute URL and we are done.
        if (!opts.alwaysNormalize) {
          return relativeURL;
        }
        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
        return URLToolkit.buildURLFromParts(relativeParts);
      }
      var baseParts = URLToolkit.parseURL(baseURL);
      if (!baseParts) {
        throw new Error('Error trying to parse base URL.');
      }
      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
        baseParts.netLoc = pathParts[1];
        baseParts.path = pathParts[2];
      }
      if (baseParts.netLoc && !baseParts.path) {
        baseParts.path = '/';
      }
      var builtParts = {
        // 2c) Otherwise, the embedded URL inherits the scheme of
        // the base URL.
        scheme: baseParts.scheme,
        netLoc: relativeParts.netLoc,
        path: null,
        params: relativeParts.params,
        query: relativeParts.query,
        fragment: relativeParts.fragment
      };
      if (!relativeParts.netLoc) {
        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
        // (if any) of the base URL.
        builtParts.netLoc = baseParts.netLoc;
        // 4) If the embedded URL path is preceded by a slash "/", the
        // path is not relative and we skip to Step 7.
        if (relativeParts.path[0] !== '/') {
          if (!relativeParts.path) {
            // 5) If the embedded URL path is empty (and not preceded by a
            // slash), then the embedded URL inherits the base URL path
            builtParts.path = baseParts.path;
            // 5a) if the embedded URL's <params> is non-empty, we skip to
            // step 7; otherwise, it inherits the <params> of the base
            // URL (if any) and
            if (!relativeParts.params) {
              builtParts.params = baseParts.params;
              // 5b) if the embedded URL's <query> is non-empty, we skip to
              // step 7; otherwise, it inherits the <query> of the base
              // URL (if any) and we skip to step 7.
              if (!relativeParts.query) {
                builtParts.query = baseParts.query;
              }
            }
          } else {
            // 6) The last segment of the base URL's path (anything
            // following the rightmost slash "/", or the entire path if no
            // slash is present) is removed and the embedded URL's path is
            // appended in its place.
            var baseURLPath = baseParts.path;
            var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;
            builtParts.path = URLToolkit.normalizePath(newPath);
          }
        }
      }
      if (builtParts.path === null) {
        builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
      }
      return URLToolkit.buildURLFromParts(builtParts);
    },
    parseURL: function(url) {
      var parts = URL_REGEX.exec(url);
      if (!parts) {
        return null;
      }
      return {
        scheme: parts[1] || '',
        netLoc: parts[2] || '',
        path: parts[3] || '',
        params: parts[4] || '',
        query: parts[5] || '',
        fragment: parts[6] || ''
      };
    },
    normalizePath: function(path) {
      // The following operations are
      // then applied, in order, to the new path:
      // 6a) All occurrences of "./", where "." is a complete path
      // segment, are removed.
      // 6b) If the path ends with "." as a complete path segment,
      // that "." is removed.
      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
      // 6c) All occurrences of "<segment>/../", where <segment> is a
      // complete path segment not equal to "..", are removed.
      // Removal of these path segments is performed iteratively,
      // removing the leftmost matching pattern on each iteration,
      // until no matching pattern remains.
      // 6d) If the path ends with "<segment>/..", where <segment> is a
      // complete path segment not equal to "..", that
      // "<segment>/.." is removed.
      while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line
      return path.split('').reverse().join('');
    },
    buildURLFromParts: function(parts) {
      return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
    }
  };

/* jshint ignore:start */
  if(true)
    module.exports = URLToolkit;
  else {}
})(this);
/* jshint ignore:end */


/***/ }),

/***/ "../../node_modules/webworkify-webpack/index.js":
/*!****************************************************************************************************!*\
  !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/webworkify-webpack/index.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function webpackBootstrapFunc (modules) {
/******/  // The module cache
/******/  var installedModules = {};

/******/  // The require function
/******/  function __webpack_require__(moduleId) {

/******/    // Check if module is in cache
/******/    if(installedModules[moduleId])
/******/      return installedModules[moduleId].exports;

/******/    // Create a new module (and put it into the cache)
/******/    var module = installedModules[moduleId] = {
/******/      i: moduleId,
/******/      l: false,
/******/      exports: {}
/******/    };

/******/    // Execute the module function
/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/    // Flag the module as loaded
/******/    module.l = true;

/******/    // Return the exports of the module
/******/    return module.exports;
/******/  }

/******/  // expose the modules object (__webpack_modules__)
/******/  __webpack_require__.m = modules;

/******/  // expose the module cache
/******/  __webpack_require__.c = installedModules;

/******/  // identity function for calling harmony imports with the correct context
/******/  __webpack_require__.i = function(value) { return value; };

/******/  // define getter function for harmony exports
/******/  __webpack_require__.d = function(exports, name, getter) {
/******/    if(!__webpack_require__.o(exports, name)) {
/******/      Object.defineProperty(exports, name, {
/******/        configurable: false,
/******/        enumerable: true,
/******/        get: getter
/******/      });
/******/    }
/******/  };

/******/  // define __esModule on exports
/******/  __webpack_require__.r = function(exports) {
/******/    Object.defineProperty(exports, '__esModule', { value: true });
/******/  };

/******/  // getDefaultExport function for compatibility with non-harmony modules
/******/  __webpack_require__.n = function(module) {
/******/    var getter = module && module.__esModule ?
/******/      function getDefault() { return module['default']; } :
/******/      function getModuleExports() { return module; };
/******/    __webpack_require__.d(getter, 'a', getter);
/******/    return getter;
/******/  };

/******/  // Object.prototype.hasOwnProperty.call
/******/  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/  // __webpack_public_path__
/******/  __webpack_require__.p = "/";

/******/  // on error function for async loading
/******/  __webpack_require__.oe = function(err) { console.error(err); throw err; };

  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE)
  return f.default || f // try to call default if defined to also support babel esmodule exports
}

var moduleNameReqExp = '[\\.|\\-|\\+|\\w|\/|@]+'
var dependencyRegExp = '\\(\\s*(\/\\*.*?\\*\/)?\\s*.*?(' + moduleNameReqExp + ').*?\\)' // additional chars when output.pathinfo is true

// http://stackoverflow.com/a/2593661/130442
function quoteRegExp (str) {
  return (str + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&')
}

function isNumeric(n) {
  return !isNaN(1 * n); // 1 * n converts integers, integers as string ("123"), 1e3 and "1e3" to integers and strings to NaN
}

function getModuleDependencies (sources, module, queueName) {
  var retval = {}
  retval[queueName] = []

  var fnString = module.toString()
  var wrapperSignature = fnString.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/)
  if (!wrapperSignature) return retval
  var webpackRequireName = wrapperSignature[1]

  // main bundle deps
  var re = new RegExp('(\\\\n|\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')
  var match
  while ((match = re.exec(fnString))) {
    if (match[3] === 'dll-reference') continue
    retval[queueName].push(match[3])
  }

  // dll deps
  re = new RegExp('\\(' + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, 'g')
  while ((match = re.exec(fnString))) {
    if (!sources[match[2]]) {
      retval[queueName].push(match[1])
      sources[match[2]] = __webpack_require__(match[1]).m
    }
    retval[match[2]] = retval[match[2]] || []
    retval[match[2]].push(match[4])
  }

  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3
  var keys = Object.keys(retval);
  for (var i = 0; i < keys.length; i++) {
    for (var j = 0; j < retval[keys[i]].length; j++) {
      if (isNumeric(retval[keys[i]][j])) {
        retval[keys[i]][j] = 1 * retval[keys[i]][j];
      }
    }
  }

  return retval
}

function hasValuesInQueues (queues) {
  var keys = Object.keys(queues)
  return keys.reduce(function (hasValues, key) {
    return hasValues || queues[key].length > 0
  }, false)
}

function getRequiredModules (sources, moduleId) {
  var modulesQueue = {
    main: [moduleId]
  }
  var requiredModules = {
    main: []
  }
  var seenModules = {
    main: {}
  }

  while (hasValuesInQueues(modulesQueue)) {
    var queues = Object.keys(modulesQueue)
    for (var i = 0; i < queues.length; i++) {
      var queueName = queues[i]
      var queue = modulesQueue[queueName]
      var moduleToCheck = queue.pop()
      seenModules[queueName] = seenModules[queueName] || {}
      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue
      seenModules[queueName][moduleToCheck] = true
      requiredModules[queueName] = requiredModules[queueName] || []
      requiredModules[queueName].push(moduleToCheck)
      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)
      var newModulesKeys = Object.keys(newModules)
      for (var j = 0; j < newModulesKeys.length; j++) {
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])
      }
    }
  }

  return requiredModules
}

module.exports = function (moduleId, options) {
  options = options || {}
  var sources = {
    main: __webpack_require__.m
  }

  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId)

  var src = ''

  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {
    var entryModule = 0
    while (requiredModules[module][entryModule]) {
      entryModule++
    }
    requiredModules[module].push(entryModule)
    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'
    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\n'
  })

  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '}))(self);'

  var blob = new window.Blob([src], { type: 'text/javascript' })
  if (options.bare) { return blob }

  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL

  var workerUrl = URL.createObjectURL(blob)
  var worker = new window.Worker(workerUrl)
  worker.objectURL = workerUrl

  return worker
}


/***/ }),

/***/ "./src/hls.js/config.js":
/*!******************************!*\
  !*** ./src/hls.js/config.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hlsDefaultConfig = undefined;

var _abrController = __webpack_require__(/*! ./controller/abr-controller */ "./src/hls.js/controller/abr-controller.js");

var _abrController2 = _interopRequireDefault(_abrController);

var _bufferController = __webpack_require__(/*! ./controller/buffer-controller */ "./src/hls.js/controller/buffer-controller.js");

var _bufferController2 = _interopRequireDefault(_bufferController);

var _capLevelController = __webpack_require__(/*! ./controller/cap-level-controller */ "./src/hls.js/controller/cap-level-controller.js");

var _capLevelController2 = _interopRequireDefault(_capLevelController);

var _fpsController = __webpack_require__(/*! ./controller/fps-controller */ "./src/hls.js/controller/fps-controller.js");

var _fpsController2 = _interopRequireDefault(_fpsController);

var _xhrLoader = __webpack_require__(/*! ./utils/xhr-loader */ "./src/hls.js/utils/xhr-loader.js");

var _xhrLoader2 = _interopRequireDefault(_xhrLoader);

var _audioTrackController = __webpack_require__(/*! ./controller/audio-track-controller */ "./src/hls.js/controller/audio-track-controller.js");

var _audioTrackController2 = _interopRequireDefault(_audioTrackController);

var _audioStreamController = __webpack_require__(/*! ./controller/audio-stream-controller */ "./src/hls.js/controller/audio-stream-controller.js");

var _audioStreamController2 = _interopRequireDefault(_audioStreamController);

var _cues = __webpack_require__(/*! ./utils/cues */ "./src/hls.js/utils/cues.js");

var Cues = _interopRequireWildcard(_cues);

var _timelineController = __webpack_require__(/*! ./controller/timeline-controller */ "./src/hls.js/controller/timeline-controller.js");

var _timelineController2 = _interopRequireDefault(_timelineController);

var _subtitleTrackController = __webpack_require__(/*! ./controller/subtitle-track-controller */ "./src/hls.js/controller/subtitle-track-controller.js");

var _subtitleTrackController2 = _interopRequireDefault(_subtitleTrackController);

var _subtitleStreamController = __webpack_require__(/*! ./controller/subtitle-stream-controller */ "./src/hls.js/controller/subtitle-stream-controller.js");

var _emeController = __webpack_require__(/*! ./controller/eme-controller */ "./src/hls.js/controller/eme-controller.js");

var _emeController2 = _interopRequireDefault(_emeController);

var _mediakeysHelper = __webpack_require__(/*! ./utils/mediakeys-helper */ "./src/hls.js/utils/mediakeys-helper.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import FetchLoader from './utils/fetch-loader';

var hlsDefaultConfig = exports.hlsDefaultConfig = {
  autoStartLoad: true, // used by stream-controller
  startPosition: -1, // used by stream-controller
  defaultAudioCodec: undefined, // used by stream-controller
  debug: false, // used by logger
  capLevelOnFPSDrop: false, // used by fps-controller
  capLevelToPlayerSize: false, // used by cap-level-controller
  initialLiveManifestSize: 1, // used by stream-controller
  maxBufferLength: 30, // used by stream-controller
  maxBufferSize: 60 * 1000 * 1000, // used by stream-controller
  maxBufferHole: 0.5, // used by stream-controller

  lowBufferWatchdogPeriod: 0.5, // used by stream-controller
  highBufferWatchdogPeriod: 3, // used by stream-controller
  nudgeOffset: 0.1, // used by stream-controller
  nudgeMaxRetry: 3, // used by stream-controller
  maxFragLookUpTolerance: 0.25, // used by stream-controller
  liveSyncDurationCount: 3, // used by stream-controller
  liveMaxLatencyDurationCount: Infinity, // used by stream-controller
  liveSyncDuration: undefined, // used by stream-controller
  liveMaxLatencyDuration: undefined, // used by stream-controller
  liveDurationInfinity: false, // used by buffer-controller
  liveBackBufferLength: Infinity, // used by buffer-controller
  maxMaxBufferLength: 600, // used by stream-controller
  enableWorker: true, // used by demuxer
  enableSoftwareAES: true, // used by decrypter
  manifestLoadingTimeOut: 10000, // used by playlist-loader
  manifestLoadingMaxRetry: 1, // used by playlist-loader
  manifestLoadingRetryDelay: 1000, // used by playlist-loader
  manifestLoadingMaxRetryTimeout: 64000, // used by playlist-loader
  startLevel: undefined, // used by level-controller
  levelLoadingTimeOut: 10000, // used by playlist-loader
  levelLoadingMaxRetry: 4, // used by playlist-loader
  levelLoadingRetryDelay: 1000, // used by playlist-loader
  levelLoadingMaxRetryTimeout: 64000, // used by playlist-loader
  fragLoadingTimeOut: 20000, // used by fragment-loader
  fragLoadingMaxRetry: 6, // used by fragment-loader
  fragLoadingRetryDelay: 1000, // used by fragment-loader
  fragLoadingMaxRetryTimeout: 64000, // used by fragment-loader
  startFragPrefetch: false, // used by stream-controller
  fpsDroppedMonitoringPeriod: 5000, // used by fps-controller
  fpsDroppedMonitoringThreshold: 0.2, // used by fps-controller
  appendErrorMaxRetry: 3, // used by buffer-controller
  loader: _xhrLoader2.default,
  // loader: FetchLoader,
  fLoader: undefined, // used by fragment-loader
  pLoader: undefined, // used by playlist-loader
  xhrSetup: undefined, // used by xhr-loader
  licenseXhrSetup: undefined, // used by eme-controller
  // fetchSetup: undefined,
  abrController: _abrController2.default,
  bufferController: _bufferController2.default,
  capLevelController: _capLevelController2.default,
  fpsController: _fpsController2.default,
  stretchShortVideoTrack: false, // used by mp4-remuxer
  maxAudioFramesDrift: 1, // used by mp4-remuxer
  forceKeyFrameOnDiscontinuity: true, // used by ts-demuxer
  abrEwmaFastLive: 3, // used by abr-controller
  abrEwmaSlowLive: 9, // used by abr-controller
  abrEwmaFastVoD: 3, // used by abr-controller
  abrEwmaSlowVoD: 9, // used by abr-controller
  abrEwmaDefaultEstimate: 5e5, // 500 kbps  // used by abr-controller
  abrBandWidthFactor: 0.95, // used by abr-controller
  abrBandWidthUpFactor: 0.7, // used by abr-controller
  abrMaxWithRealBitrate: false, // used by abr-controller
  maxStarvationDelay: 4, // used by abr-controller
  maxLoadingDelay: 4, // used by abr-controller
  minAutoBitrate: 0, // used by hls
  emeEnabled: false, // used by eme-controller
  widevineLicenseUrl: undefined, // used by eme-controller
  requestMediaKeySystemAccessFunc: _mediakeysHelper.requestMediaKeySystemAccess // used by eme-controller
}; /**
    * HLS config
    */

hlsDefaultConfig.subtitleStreamController = _subtitleStreamController.SubtitleStreamController;
hlsDefaultConfig.subtitleTrackController = _subtitleTrackController2.default;
hlsDefaultConfig.timelineController = _timelineController2.default;
hlsDefaultConfig.cueHandler = Cues; // used by timeline-controller
hlsDefaultConfig.enableCEA708Captions = true; // used by timeline-controller
hlsDefaultConfig.enableWebVTT = true; // used by timeline-controller
hlsDefaultConfig.captionsTextTrack1Label = 'English'; // used by timeline-controller
hlsDefaultConfig.captionsTextTrack1LanguageCode = 'en'; // used by timeline-controller
hlsDefaultConfig.captionsTextTrack2Label = 'Spanish'; // used by timeline-controller
hlsDefaultConfig.captionsTextTrack2LanguageCode = 'es'; // used by timeline-controller


hlsDefaultConfig.audioStreamController = _audioStreamController2.default;
hlsDefaultConfig.audioTrackController = _audioTrackController2.default;

hlsDefaultConfig.emeController = _emeController2.default;

/***/ }),

/***/ "./src/hls.js/controller/abr-controller.js":
/*!*************************************************!*\
  !*** ./src/hls.js/controller/abr-controller.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _ewmaBandwidthEstimator = __webpack_require__(/*! ../utils/ewma-bandwidth-estimator */ "./src/hls.js/utils/ewma-bandwidth-estimator.js");

var _ewmaBandwidthEstimator2 = _interopRequireDefault(_ewmaBandwidthEstimator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * simple ABR Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - compute next level based on last fragment bw heuristics
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _window = window,
    performance = _window.performance;

var AbrController = function (_EventHandler) {
  _inherits(AbrController, _EventHandler);

  function AbrController(hls) {
    _classCallCheck(this, AbrController);

    var _this = _possibleConstructorReturn(this, (AbrController.__proto__ || Object.getPrototypeOf(AbrController)).call(this, hls, _events2.default.FRAG_LOADING, _events2.default.FRAG_LOADED, _events2.default.FRAG_BUFFERED, _events2.default.ERROR));

    _this.lastLoadedFragLevel = 0;
    _this._nextAutoLevel = -1;
    _this.hls = hls;
    _this.timer = null;
    _this._bwEstimator = null;
    _this.onCheck = _this._abandonRulesCheck.bind(_this);
    return _this;
  }

  _createClass(AbrController, [{
    key: 'destroy',
    value: function destroy() {
      this.clearTimer();
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag;
      if (frag.type === 'main') {
        if (!this.timer) {
          this.fragCurrent = frag;
          this.timer = setInterval(this.onCheck, 100);
        }

        // lazy init of BwEstimator, rationale is that we use different params for Live/VoD
        // so we need to wait for stream manifest / playlist type to instantiate it.
        if (!this._bwEstimator) {
          var hls = this.hls;
          var config = hls.config;
          var level = frag.level;
          var isLive = hls.levels[level].details.live;

          var ewmaFast = void 0,
              ewmaSlow = void 0;
          if (isLive) {
            ewmaFast = config.abrEwmaFastLive;
            ewmaSlow = config.abrEwmaSlowLive;
          } else {
            ewmaFast = config.abrEwmaFastVoD;
            ewmaSlow = config.abrEwmaSlowVoD;
          }
          this._bwEstimator = new _ewmaBandwidthEstimator2.default(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
        }
      }
    }
  }, {
    key: '_abandonRulesCheck',
    value: function _abandonRulesCheck() {
      /*
        monitor fragment retrieval time...
        we compute expected time of arrival of the complete fragment.
        we compare it to expected time of buffer starvation
      */
      var hls = this.hls;
      var video = hls.media;
      var frag = this.fragCurrent;

      if (!frag) {
        return;
      }

      var loader = frag.loader;
      var minAutoLevel = hls.minAutoLevel;

      // if loader has been destroyed or loading has been aborted, stop timer and return
      if (!loader || loader.stats && loader.stats.aborted) {
        _logger.logger.warn('frag loader destroy or aborted, disarm abandonRules');
        this.clearTimer();
        // reset forced auto level value so that next level will be selected
        this._nextAutoLevel = -1;
        return;
      }
      var stats = loader.stats;
      /* only monitor frag retrieval time if
      (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
      if (video && stats && (!video.paused && video.playbackRate !== 0 || !video.readyState) && frag.autoLevel && frag.level) {
        var requestDelay = performance.now() - stats.trequest,
            playbackRate = Math.abs(video.playbackRate);
        // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
        if (requestDelay > 500 * frag.duration / playbackRate) {
          var levels = hls.levels,
              loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay),
              // byte/s; at least 1 byte/s to avoid division by zero
          // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
          level = levels[frag.level],
              levelBitrate = level.realBitrate ? Math.max(level.realBitrate, level.bitrate) : level.bitrate,
              expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levelBitrate / 8)),
              pos = video.currentTime,
              fragLoadedDelay = (expectedLen - stats.loaded) / loadRate,
              bufferStarvationDelay = (_bufferHelper.BufferHelper.bufferInfo(video, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
          // consider emergency switch down only if we have less than 2 frag buffered AND
          // time to finish loading current fragment is bigger than buffer starvation delay
          // ie if we risk buffer starvation if bw does not increase quickly
          if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {
            var fragLevelNextLoadedDelay = void 0,
                nextLoadLevel = void 0;
            // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
            // we start from current level - 1 and we step down , until we find a matching level
            for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
              // compute time to load next fragment at lower level
              // 0.8 : consider only 80% of current bw to be conservative
              // 8 = bits per byte (bps/Bps)
              var levelNextBitrate = levels[nextLoadLevel].realBitrate ? Math.max(levels[nextLoadLevel].realBitrate, levels[nextLoadLevel].bitrate) : levels[nextLoadLevel].bitrate;
              fragLevelNextLoadedDelay = frag.duration * levelNextBitrate / (8 * 0.8 * loadRate);
              if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
                // we found a lower level that be rebuffering free with current estimated bw !
                break;
              }
            }
            // only emergency switch down if it takes less time to load new fragment at lowest level instead
            // of finishing loading current one ...
            if (fragLevelNextLoadedDelay < fragLoadedDelay) {
              _logger.logger.warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel + ':fragLoadedDelay[' + nextLoadLevel + ']<fragLoadedDelay[' + (frag.level - 1) + '];bufferStarvationDelay:' + fragLevelNextLoadedDelay.toFixed(1) + '<' + fragLoadedDelay.toFixed(1) + ':' + bufferStarvationDelay.toFixed(1));
              // force next load level in auto mode
              hls.nextLoadLevel = nextLoadLevel;
              // update bw estimate for this fragment before cancelling load (this will help reducing the bw)
              this._bwEstimator.sample(requestDelay, stats.loaded);
              // abort fragment loading
              loader.abort();
              // stop abandon rules timer
              this.clearTimer();
              hls.trigger(_events2.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, stats: stats });
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var frag = data.frag;
      if (frag.type === 'main' && Number.isFinite(frag.sn)) {
        // stop monitoring bw once frag loaded
        this.clearTimer();
        // store level id after successful fragment load
        this.lastLoadedFragLevel = frag.level;
        // reset forced auto level value so that next level will be selected
        this._nextAutoLevel = -1;

        // compute level average bitrate
        if (this.hls.config.abrMaxWithRealBitrate) {
          var level = this.hls.levels[frag.level];
          var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + data.stats.loaded;
          var loadedDuration = (level.loaded ? level.loaded.duration : 0) + data.frag.duration;
          level.loaded = { bytes: loadedBytes, duration: loadedDuration };
          level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
        }
        // if fragment has been loaded to perform a bitrate test,
        if (data.frag.bitrateTest) {
          var stats = data.stats;
          stats.tparsed = stats.tbuffered = stats.tload;
          this.onFragBuffered(data);
        }
      }
    }
  }, {
    key: 'onFragBuffered',
    value: function onFragBuffered(data) {
      var stats = data.stats;
      var frag = data.frag;
      // only update stats on first frag buffering
      // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
      // and leading to wrong bw estimation
      // on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)
      if (stats.aborted !== true && frag.type === 'main' && Number.isFinite(frag.sn) && (!frag.bitrateTest || stats.tload === stats.tbuffered)) {
        // use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached
        // in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached
        // as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation
        var fragLoadingProcessingMs = stats.tparsed - stats.trequest;
        _logger.logger.log('latency/loading/parsing/append/kbps:' + Math.round(stats.tfirst - stats.trequest) + '/' + Math.round(stats.tload - stats.tfirst) + '/' + Math.round(stats.tparsed - stats.tload) + '/' + Math.round(stats.tbuffered - stats.tparsed) + '/' + Math.round(8 * stats.loaded / (stats.tbuffered - stats.trequest)));
        this._bwEstimator.sample(fragLoadingProcessingMs, stats.loaded);
        stats.bwEstimate = this._bwEstimator.getEstimate();
        // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration
        if (frag.bitrateTest) {
          this.bitrateTestDelay = fragLoadingProcessingMs / 1000;
        } else {
          this.bitrateTestDelay = 0;
        }
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      // stop timer in case of frag loading error
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          this.clearTimer();
          break;
        default:
          break;
      }
    }
  }, {
    key: 'clearTimer',
    value: function clearTimer() {
      clearInterval(this.timer);
      this.timer = null;
    }

    // return next auto level

  }, {
    key: '_findBestLevel',
    value: function _findBestLevel(currentLevel, currentFragDuration, currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {
      for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
        var levelInfo = levels[i];

        if (!levelInfo) {
          continue;
        }

        var levelDetails = levelInfo.details,
            avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration,
            live = levelDetails ? levelDetails.live : false,
            adjustedbw = void 0;
        // follow algorithm captured from stagefright :
        // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
        // Pick the highest bandwidth stream below or equal to estimated bandwidth.
        // consider only 80% of the available bandwidth, but if we are switching up,
        // be even more conservative (70%) to avoid overestimating and immediately
        // switching back.
        if (i <= currentLevel) {
          adjustedbw = bwFactor * currentBw;
        } else {
          adjustedbw = bwUpFactor * currentBw;
        }

        var bitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate,
            fetchDuration = bitrate * avgDuration / adjustedbw;

        _logger.logger.trace('level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: ' + i + '/' + Math.round(adjustedbw) + '/' + bitrate + '/' + avgDuration + '/' + maxFetchDuration + '/' + fetchDuration);
        // if adjusted bw is greater than level bitrate AND
        if (adjustedbw > bitrate && (
        // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
        // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that _findBestLevel will return -1
        !fetchDuration || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {
          // as we are looping from highest to lowest, this will return the best achievable quality level
          return i;
        }
      }
      // not enough time budget even with quality level 0 ... rebuffering might happen
      return -1;
    }
  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var forcedAutoLevel = this._nextAutoLevel;
      var bwEstimator = this._bwEstimator;
      // in case next auto level has been forced, and bw not available or not reliable, return forced value
      if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {
        return forcedAutoLevel;
      }

      // compute next level using ABR logic
      var nextABRAutoLevel = this._nextABRAutoLevel;
      // if forced auto level has been defined, use it to cap ABR computed quality level
      if (forcedAutoLevel !== -1) {
        nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);
      }

      return nextABRAutoLevel;
    },
    set: function set(nextLevel) {
      this._nextAutoLevel = nextLevel;
    }
  }, {
    key: '_nextABRAutoLevel',
    get: function get() {
      var hls = this.hls,
          maxAutoLevel = hls.maxAutoLevel,
          levels = hls.levels,
          config = hls.config,
          minAutoLevel = hls.minAutoLevel;
      var video = hls.media,
          currentLevel = this.lastLoadedFragLevel,
          currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0,
          pos = video ? video.currentTime : 0,

      // playbackRate is the absolute value of the playback rate; if video.playbackRate is 0, we use 1 to load as
      // if we're playing back at the normal rate.
      playbackRate = video && video.playbackRate !== 0 ? Math.abs(video.playbackRate) : 1.0,
          avgbw = this._bwEstimator ? this._bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate,

      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
      bufferStarvationDelay = (_bufferHelper.BufferHelper.bufferInfo(video, pos, config.maxBufferHole).end - pos) / playbackRate;

      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
      var bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);
      if (bestLevel >= 0) {
        return bestLevel;
      } else {
        _logger.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');
        // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
        // if no matching level found, logic will return 0
        var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay,
            bwFactor = config.abrBandWidthFactor,
            bwUpFactor = config.abrBandWidthUpFactor;
        if (bufferStarvationDelay === 0) {
          // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
          var bitrateTestDelay = this.bitrateTestDelay;
          if (bitrateTestDelay) {
            // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
            // max video loading delay used in  automatic start level selection :
            // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
            // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
            // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration
            var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
            maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
            _logger.logger.trace('bitrate test took ' + Math.round(1000 * bitrateTestDelay) + 'ms, set first fragment max fetchDuration to ' + Math.round(1000 * maxStarvationDelay) + ' ms');
            // don't use conservative factor on bitrate test
            bwFactor = bwUpFactor = 1;
          }
        }
        bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels);
        return Math.max(bestLevel, 0);
      }
    }
  }]);

  return AbrController;
}(_eventHandler2.default);

exports.default = AbrController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/audio-stream-controller.js":
/*!**********************************************************!*\
  !*** ./src/hls.js/controller/audio-stream-controller.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = __webpack_require__(/*! ../utils/binary-search */ "./src/hls.js/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _demuxer = __webpack_require__(/*! ../demux/demuxer */ "./src/hls.js/demux/demuxer.js");

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

var LevelHelper = _interopRequireWildcard(_levelHelper);

var _timeRanges = __webpack_require__(/*! ../utils/time-ranges */ "./src/hls.js/utils/time-ranges.js");

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _discontinuities = __webpack_require__(/*! ../utils/discontinuities */ "./src/hls.js/utils/discontinuities.js");

var _fragmentTracker = __webpack_require__(/*! ./fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _fragment = __webpack_require__(/*! ../loader/fragment */ "./src/hls.js/loader/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _baseStreamController = __webpack_require__(/*! ./base-stream-controller */ "./src/hls.js/controller/base-stream-controller.js");

var _baseStreamController2 = _interopRequireDefault(_baseStreamController);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Audio Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var _window = window,
    performance = _window.performance;


var TICK_INTERVAL = 100; // how often to tick in ms

var AudioStreamController = function (_BaseStreamController) {
  _inherits(AudioStreamController, _BaseStreamController);

  function AudioStreamController(hls, fragmentTracker) {
    _classCallCheck(this, AudioStreamController);

    var _this = _possibleConstructorReturn(this, (AudioStreamController.__proto__ || Object.getPrototypeOf(AudioStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.AUDIO_TRACKS_UPDATED, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.BUFFER_RESET, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED, _events2.default.INIT_PTS_FOUND));

    _this.fragmentTracker = fragmentTracker;
    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this._state = _baseStreamController.State.STOPPED;
    _this.initPTS = [];
    _this.waitingFragment = null;
    _this.videoTrackCC = null;
    return _this;
  }

  // Signal that video PTS was found


  _createClass(AudioStreamController, [{
    key: 'onInitPtsFound',
    value: function onInitPtsFound(data) {
      var demuxerId = data.id,
          cc = data.frag.cc,
          initPTS = data.initPTS;
      if (demuxerId === 'main') {
        // Always update the new INIT PTS
        // Can change due level switch
        this.initPTS[cc] = initPTS;
        this.videoTrackCC = cc;
        _logger.logger.log('InitPTS for cc: ' + cc + ' found from video track: ' + initPTS);

        // If we are waiting we need to demux/remux the waiting frag
        // With the new initPTS
        if (this.state === _baseStreamController.State.WAITING_INIT_PTS) {
          this.tick();
        }
      }
    }
  }, {
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.tracks) {
        var lastCurrentTime = this.lastCurrentTime;
        this.stopLoad();
        this.setInterval(TICK_INTERVAL);
        this.fragLoadError = 0;
        if (lastCurrentTime > 0 && startPosition === -1) {
          _logger.logger.log('audio:override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
          this.state = _baseStreamController.State.IDLE;
        } else {
          this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
          this.state = _baseStreamController.State.STARTING;
        }
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
        this.tick();
      } else {
        this.startPosition = startPosition;
        this.state = _baseStreamController.State.STOPPED;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      var pos = void 0,
          track = void 0,
          trackDetails = void 0,
          hls = this.hls,
          config = hls.config;
      // logger.log('audioStream:' + this.state);
      switch (this.state) {
        case _baseStreamController.State.ERROR:
        // don't do anything in error state to avoid breaking further ...
        case _baseStreamController.State.PAUSED:
        // don't do anything in paused state either ...
        case _baseStreamController.State.BUFFER_FLUSHING:
          break;
        case _baseStreamController.State.STARTING:
          this.state = _baseStreamController.State.WAITING_TRACK;
          this.loadedmetadata = false;
          break;
        case _baseStreamController.State.IDLE:
          var tracks = this.tracks;
          // audio tracks not received => exit loop
          if (!tracks) {
            break;
          }

          // if video not attached AND
          // start fragment already requested OR start frag prefetch disable
          // exit loop
          // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
          if (!this.media && (this.startFragRequested || !config.startFragPrefetch)) {
            break;
          }

          // determine next candidate fragment to be loaded, based on current position and
          //  end of buffer position
          // if we have not yet loaded any fragment, start loading from start position
          if (this.loadedmetadata) {
            pos = this.media.currentTime;
          } else {
            pos = this.nextLoadPosition;
            if (pos === undefined) {
              break;
            }
          }
          var media = this.mediaBuffer ? this.mediaBuffer : this.media,
              videoBuffer = this.videoBuffer ? this.videoBuffer : this.media,
              bufferInfo = _bufferHelper.BufferHelper.bufferInfo(media, pos, config.maxBufferHole),
              mainBufferInfo = _bufferHelper.BufferHelper.bufferInfo(videoBuffer, pos, config.maxBufferHole),
              bufferLen = bufferInfo.len,
              bufferEnd = bufferInfo.end,
              fragPrevious = this.fragPrevious,

          // ensure we buffer at least config.maxBufferLength (default 30s) or config.maxMaxBufferLength (default: 600s)
          // whichever is smaller.
          // once we reach that threshold, don't buffer more than video (mainBufferInfo.len)
          maxConfigBuffer = Math.min(config.maxBufferLength, config.maxMaxBufferLength),
              maxBufLen = Math.max(maxConfigBuffer, mainBufferInfo.len),
              audioSwitch = this.audioSwitch,
              trackId = this.trackId;

          // if buffer length is less than maxBufLen try to load a new fragment
          if ((bufferLen < maxBufLen || audioSwitch) && trackId < tracks.length) {
            trackDetails = tracks[trackId].details;
            // if track info not retrieved yet, switch state and wait for track retrieval
            if (typeof trackDetails === 'undefined') {
              this.state = _baseStreamController.State.WAITING_TRACK;
              break;
            }

            if (!audioSwitch && this._streamEnded(bufferInfo, trackDetails)) {
              this.hls.trigger(_events2.default.BUFFER_EOS, { type: 'audio' });
              this.state = _baseStreamController.State.ENDED;
              return;
            }

            // find fragment index, contiguous with end of buffer position
            var fragments = trackDetails.fragments,
                fragLen = fragments.length,
                start = fragments[0].start,
                end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
                frag = void 0;

            // When switching audio track, reload audio as close as possible to currentTime
            if (audioSwitch) {
              if (trackDetails.live && !trackDetails.PTSKnown) {
                _logger.logger.log('switching audiotrack, live stream, unknown PTS,load first fragment');
                bufferEnd = 0;
              } else {
                bufferEnd = pos;
                // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime
                if (trackDetails.PTSKnown && pos < start) {
                  // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start
                  if (bufferInfo.end > start || bufferInfo.nextStart) {
                    _logger.logger.log('alt audio track ahead of main track, seek to start of alt audio track');
                    this.media.currentTime = start + 0.05;
                  } else {
                    return;
                  }
                }
              }
            }
            if (trackDetails.initSegment && !trackDetails.initSegment.data) {
              frag = trackDetails.initSegment;
            } // eslint-disable-line brace-style
            // if bufferEnd before start of playlist, load first fragment
            else if (bufferEnd <= start) {
                frag = fragments[0];
                if (this.videoTrackCC !== null && frag.cc !== this.videoTrackCC) {
                  // Ensure we find a fragment which matches the continuity of the video track
                  frag = (0, _discontinuities.findFragWithCC)(fragments, this.videoTrackCC);
                }
                if (trackDetails.live && frag.loadIdx && frag.loadIdx === this.fragLoadIdx) {
                  // we just loaded this first fragment, and we are still lagging behind the start of the live playlist
                  // let's force seek to start
                  var nextBuffered = bufferInfo.nextStart ? bufferInfo.nextStart : start;
                  _logger.logger.log('no alt audio available @currentTime:' + this.media.currentTime + ', seeking @' + (nextBuffered + 0.05));
                  this.media.currentTime = nextBuffered + 0.05;
                  return;
                }
              } else {
                var foundFrag = void 0;
                var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;
                var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
                  // offset should be within fragment boundary - config.maxFragLookUpTolerance
                  // this is to cope with situations like
                  // bufferEnd = 9.991
                  // frag[] : [0,10]
                  // frag[1] : [10,20]
                  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
                  //              frag start               frag start+duration
                  //                  |-----------------------------|
                  //              <--->                         <--->
                  //  ...--------><-----------------------------><---------....
                  // previous frag         matching fragment         next frag
                  //  return -1             return 0                 return 1
                  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
                  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
                  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);
                  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
                    return 1;
                  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
                    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
                    return -1;
                  }

                  return 0;
                };

                if (bufferEnd < end) {
                  if (bufferEnd > end - maxFragLookUpTolerance) {
                    maxFragLookUpTolerance = 0;
                  }

                  // Prefer the next fragment if it's within tolerance
                  if (fragNext && !fragmentWithinToleranceTest(fragNext)) {
                    foundFrag = fragNext;
                  } else {
                    foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);
                  }
                } else {
                  // reach end of playlist
                  foundFrag = fragments[fragLen - 1];
                }
                if (foundFrag) {
                  frag = foundFrag;
                  start = foundFrag.start;
                  // logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
                  if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
                    if (frag.sn < trackDetails.endSN) {
                      frag = fragments[frag.sn + 1 - trackDetails.startSN];
                      _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
                    } else {
                      frag = null;
                    }
                  }
                }
              }
            if (frag) {
              // logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
              if (frag.encrypted) {
                _logger.logger.log('Loading key for ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId);
                this.state = _baseStreamController.State.KEY_LOADING;
                hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
              } else {
                _logger.logger.log('Loading ' + frag.sn + ', cc: ' + frag.cc + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
                // only load if fragment is not loaded or if in audio switch
                // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch
                this.fragCurrent = frag;
                if (audioSwitch || this.fragmentTracker.getState(frag) === _fragmentTracker.FragmentState.NOT_LOADED) {
                  this.startFragRequested = true;
                  if (Number.isFinite(frag.sn)) {
                    this.nextLoadPosition = frag.start + frag.duration;
                  }

                  hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
                  this.state = _baseStreamController.State.FRAG_LOADING;
                }
              }
            }
          }
          break;
        case _baseStreamController.State.WAITING_TRACK:
          track = this.tracks[this.trackId];
          // check if playlist is already loaded
          if (track && track.details) {
            this.state = _baseStreamController.State.IDLE;
          }

          break;
        case _baseStreamController.State.FRAG_LOADING_WAITING_RETRY:
          var now = performance.now();
          var retryDate = this.retryDate;
          media = this.media;
          var isSeeking = media && media.seeking;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || isSeeking) {
            _logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');
            this.state = _baseStreamController.State.IDLE;
          }
          break;
        case _baseStreamController.State.WAITING_INIT_PTS:
          var videoTrackCC = this.videoTrackCC;
          if (this.initPTS[videoTrackCC] === undefined) {
            break;
          }

          // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS
          var waitingFrag = this.waitingFragment;
          if (waitingFrag) {
            var waitingFragCC = waitingFrag.frag.cc;
            if (videoTrackCC !== waitingFragCC) {
              track = this.tracks[this.trackId];
              if (track.details && track.details.live) {
                _logger.logger.warn('Waiting fragment CC (' + waitingFragCC + ') does not match video track CC (' + videoTrackCC + ')');
                this.waitingFragment = null;
                this.state = _baseStreamController.State.IDLE;
              }
            } else {
              this.state = _baseStreamController.State.FRAG_LOADING;
              this.onFragLoaded(this.waitingFragment);
              this.waitingFragment = null;
            }
          } else {
            this.state = _baseStreamController.State.IDLE;
          }

          break;
        case _baseStreamController.State.STOPPED:
        case _baseStreamController.State.FRAG_LOADING:
        case _baseStreamController.State.PARSING:
        case _baseStreamController.State.PARSED:
        case _baseStreamController.State.ENDED:
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.tracks && config.autoStartLoad) {
        this.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = this.mediaBuffer = this.videoBuffer = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onAudioTracksUpdated',
    value: function onAudioTracksUpdated(data) {
      _logger.logger.log('audio tracks updated');
      this.tracks = data.audioTracks;
    }
  }, {
    key: 'onAudioTrackSwitching',
    value: function onAudioTrackSwitching(data) {
      // if any URL found on new audio track, it is an alternate audio track
      var altAudio = !!data.url;
      this.trackId = data.id;

      this.fragCurrent = null;
      this.state = _baseStreamController.State.PAUSED;
      this.waitingFragment = null;
      // destroy useless demuxer when switching audio to main
      if (!altAudio) {
        if (this.demuxer) {
          this.demuxer.destroy();
          this.demuxer = null;
        }
      } else {
        // switching to audio track, start timer if not already started
        this.setInterval(TICK_INTERVAL);
      }

      // should we switch tracks ?
      if (altAudio) {
        this.audioSwitch = true;
        // main audio track are handled by stream-controller, just do something if switching to alt audio track
        this.state = _baseStreamController.State.IDLE;
      }
      this.tick();
    }
  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      var newDetails = data.details,
          trackId = data.id,
          track = this.tracks[trackId],
          duration = newDetails.totalduration,
          sliding = 0;

      _logger.logger.log('track ' + trackId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);

      if (newDetails.live) {
        var curDetails = track.details;
        if (curDetails && newDetails.fragments.length > 0) {
          // we already have details for that level, merge them
          LevelHelper.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          // TODO
          // this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown) {
            _logger.logger.log('live audio playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live audio playlist - outdated PTS, unknown sliding');
          }
        } else {
          newDetails.PTSKnown = false;
          _logger.logger.log('live audio playlist - first load, unknown sliding');
        }
      } else {
        newDetails.PTSKnown = false;
      }
      track.details = newDetails;

      // compute start position
      if (!this.startFragRequested) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (Number.isFinite(startTimeOffset)) {
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            this.startPosition = 0;
          }
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
      if (this.state === _baseStreamController.State.WAITING_TRACK) {
        this.state = _baseStreamController.State.IDLE;
      }

      // trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === _baseStreamController.State.KEY_LOADING) {
        this.state = _baseStreamController.State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent,
          fragLoaded = data.frag;
      if (this.state === _baseStreamController.State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'audio' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
        var track = this.tracks[this.trackId],
            details = track.details,
            duration = details.totalduration,
            trackId = fragCurrent.level,
            sn = fragCurrent.sn,
            cc = fragCurrent.cc,
            audioCodec = this.config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2',
            stats = this.stats = data.stats;
        if (sn === 'initSegment') {
          this.state = _baseStreamController.State.IDLE;

          stats.tparsed = stats.tbuffered = performance.now();
          details.initSegment.data = data.payload;
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'audio' });
          this.tick();
        } else {
          this.state = _baseStreamController.State.PARSING;
          // transmux the MPEG-TS data to ISO-BMFF segments
          this.appended = false;
          if (!this.demuxer) {
            this.demuxer = new _demuxer2.default(this.hls, 'audio');
          }

          // Check if we have video initPTS
          // If not we need to wait for it
          var initPTS = this.initPTS[cc];
          var initSegmentData = details.initSegment ? details.initSegment.data : [];
          if (details.initSegment || initPTS !== undefined) {
            this.pendingBuffering = true;
            _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
            // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
            var accurateTimeOffset = false; // details.PTSKnown || !details.live;
            this.demuxer.push(data.payload, initSegmentData, audioCodec, null, fragCurrent, duration, accurateTimeOffset, initPTS);
          } else {
            _logger.logger.log('unknown video PTS for continuity counter ' + cc + ', waiting for video PTS before demuxing audio frag ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
            this.waitingFragment = data;
            this.state = _baseStreamController.State.WAITING_INIT_PTS;
          }
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === _baseStreamController.State.PARSING) {
        var tracks = data.tracks,
            track = void 0;

        // delete any video track found on audio demuxer
        if (tracks.video) {
          delete tracks.video;
        }

        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          track.levelCodec = track.codec;
          track.id = data.id;
          this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
          _logger.logger.log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            var appendObj = { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' };
            if (this.audioSwitch) {
              this.pendingData = [appendObj];
            } else {
              this.appended = true;
              // arm pending Buffering flag before appending a segment
              this.pendingBuffering = true;
              this.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
            }
          }
          // trigger handler right now
          this.tick();
        }
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && data.type === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === _baseStreamController.State.PARSING) {
        var trackId = this.trackId,
            track = this.tracks[trackId],
            hls = this.hls;

        if (!Number.isFinite(data.endPTS)) {
          data.endPTS = data.startPTS + fragCurrent.duration;
          data.endDTS = data.startDTS + fragCurrent.duration;
        }

        fragCurrent.addElementaryStream(_fragment2.default.ElementaryStreamTypes.AUDIO);

        _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb);
        LevelHelper.updateFragPTSDTS(track.details, fragCurrent, data.startPTS, data.endPTS);

        var audioSwitch = this.audioSwitch,
            media = this.media,
            appendOnBufferFlush = false;
        // Only flush audio from old audio tracks when PTS is known on new audio track
        if (audioSwitch && media) {
          if (media.readyState) {
            var currentTime = media.currentTime;
            _logger.logger.log('switching audio track : currentTime:' + currentTime);
            if (currentTime >= data.startPTS) {
              _logger.logger.log('switching audio track : flushing all audio');
              this.state = _baseStreamController.State.BUFFER_FLUSHING;
              hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
              appendOnBufferFlush = true;
              // Lets announce that the initial audio track switch flush occur
              this.audioSwitch = false;
              hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
            }
          } else {
            // Lets announce that the initial audio track switch flush occur
            this.audioSwitch = false;
            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
          }
        }

        var pendingData = this.pendingData;

        if (!pendingData) {
          _logger.logger.warn('Apparently attempt to enqueue media payload without codec initialization data upfront');
          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: null, fatal: true });
          return;
        }

        if (!this.audioSwitch) {
          [data.data1, data.data2].forEach(function (buffer) {
            if (buffer && buffer.length) {
              pendingData.push({ type: data.type, data: buffer, parent: 'audio', content: 'data' });
            }
          });
          if (!appendOnBufferFlush && pendingData.length) {
            pendingData.forEach(function (appendObj) {
              // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
              // in that case it is useless to append following segments
              if (_this2.state === _baseStreamController.State.PARSING) {
                // arm pending Buffering flag before appending a segment
                _this2.pendingBuffering = true;
                _this2.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
              }
            });
            this.pendingData = [];
            this.appended = true;
          }
        }
        // trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === _baseStreamController.State.PARSING) {
        this.stats.tparsed = performance.now();
        this.state = _baseStreamController.State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onBufferReset',
    value: function onBufferReset() {
      // reset reference to sourcebuffers
      this.mediaBuffer = this.videoBuffer = null;
      this.loadedmetadata = false;
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var audioTrack = data.tracks.audio;
      if (audioTrack) {
        this.mediaBuffer = audioTrack.buffer;
        this.loadedmetadata = true;
      }
      if (data.tracks.video) {
        this.videoBuffer = data.tracks.video.buffer;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'audio') {
        var state = this.state;
        if (state === _baseStreamController.State.PARSING || state === _baseStreamController.State.PARSED) {
          // check if all buffers have been appended
          this.pendingBuffering = data.pending > 0;
          this._checkAppendedParsed();
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      // trigger handler right now
      if (this.state === _baseStreamController.State.PARSED && (!this.appended || !this.pendingBuffering)) {
        var frag = this.fragCurrent,
            stats = this.stats,
            hls = this.hls;
        if (frag) {
          this.fragPrevious = frag;
          stats.tbuffered = performance.now();
          hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('audio buffered : ' + _timeRanges2.default.toString(media.buffered));
          if (this.audioSwitch && this.appended) {
            this.audioSwitch = false;
            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: this.trackId });
          }
          this.state = _baseStreamController.State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle frag error not related to audio fragment
      if (frag && frag.type !== 'audio') {
        return;
      }

      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          var _frag = data.frag;
          // don't handle frag error not related to audio fragment
          if (_frag && _frag.type !== 'audio') {
            break;
          }

          if (!data.fatal) {
            var loadError = this.fragLoadError;
            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }

            var config = this.config;
            if (loadError <= config.fragLoadingMaxRetry) {
              this.fragLoadError = loadError;
              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
              _logger.logger.warn('AudioStreamController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = performance.now() + delay;
              // retry loading state
              this.state = _baseStreamController.State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('AudioStreamController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // switch error to fatal
              data.fatal = true;
              this.state = _baseStreamController.State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
          if (this.state !== _baseStreamController.State.ERROR) {
            // if fatal error, stop processing, otherwise move to IDLE to retry loading
            this.state = data.fatal ? _baseStreamController.State.ERROR : _baseStreamController.State.IDLE;
            _logger.logger.warn('AudioStreamController: ' + data.details + ' while loading frag, now switching to ' + this.state + ' state ...');
          }
          break;
        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
          // if in appending state
          if (data.parent === 'audio' && (this.state === _baseStreamController.State.PARSING || this.state === _baseStreamController.State.PARSED)) {
            var media = this.mediaBuffer,
                currentTime = this.media.currentTime,
                mediaBuffered = media && _bufferHelper.BufferHelper.isBuffered(media, currentTime) && _bufferHelper.BufferHelper.isBuffered(media, currentTime + 0.5);
            // reduce max buf len if current position is buffered
            if (mediaBuffered) {
              var _config = this.config;
              if (_config.maxMaxBufferLength >= _config.maxBufferLength) {
                // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
                _config.maxMaxBufferLength /= 2;
                _logger.logger.warn('AudioStreamController: reduce max buffer length to ' + _config.maxMaxBufferLength + 's');
              }
              this.state = _baseStreamController.State.IDLE;
            } else {
              // current position is not buffered, but browser is still complaining about buffer full error
              // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
              // in that case flush the whole audio buffer to recover
              _logger.logger.warn('AudioStreamController: buffer full error also media.currentTime is not buffered, flush audio buffer');
              this.fragCurrent = null;
              // flush everything
              this.state = _baseStreamController.State.BUFFER_FLUSHING;
              this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
            }
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      var _this3 = this;

      var pendingData = this.pendingData;
      if (pendingData && pendingData.length) {
        _logger.logger.log('AudioStreamController: appending pending audio data after buffer flushed');
        pendingData.forEach(function (appendObj) {
          _this3.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
        });
        this.appended = true;
        this.pendingData = [];
        this.state = _baseStreamController.State.PARSED;
      } else {
        // move to IDLE once flush complete. this should trigger new fragment loading
        this.state = _baseStreamController.State.IDLE;
        // reset reference to frag
        this.fragPrevious = null;
        this.tick();
      }
    }
  }, {
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('audio stream:' + previousState + '->' + nextState);
      }
    },
    get: function get() {
      return this._state;
    }
  }]);

  return AudioStreamController;
}(_baseStreamController2.default);

exports.default = AudioStreamController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/audio-track-controller.js":
/*!*********************************************************!*\
  !*** ./src/hls.js/controller/audio-track-controller.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _taskLoop = __webpack_require__(/*! ../task-loop */ "./src/hls.js/task-loop.js");

var _taskLoop2 = _interopRequireDefault(_taskLoop);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class AudioTrackController
 * @implements {EventHandler}
 *
 * Handles main manifest and audio-track metadata loaded,
 * owns and exposes the selectable audio-tracks data-models.
 *
 * Exposes internal interface to select available audio-tracks.
 *
 * Handles errors on loading audio-track playlists. Manages fallback mechanism
 * with redundants tracks (group-IDs).
 *
 * Handles level-loading and group-ID switches for video (fallback on video levels),
 * and eventually adapts the audio-track group-ID to match.
 *
 * @fires AUDIO_TRACK_LOADING
 * @fires AUDIO_TRACK_SWITCHING
 * @fires AUDIO_TRACKS_UPDATED
 * @fires ERROR
 *
 */
var AudioTrackController = function (_TaskLoop) {
  _inherits(AudioTrackController, _TaskLoop);

  function AudioTrackController(hls) {
    _classCallCheck(this, AudioTrackController);

    /**
     * @private
     * Currently selected index in `tracks`
     * @member {number} trackId
     */
    var _this = _possibleConstructorReturn(this, (AudioTrackController.__proto__ || Object.getPrototypeOf(AudioTrackController)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.AUDIO_TRACK_LOADED, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.LEVEL_LOADED, _events2.default.ERROR));

    _this._trackId = -1;

    /**
     * @private
     * If should select tracks according to default track attribute
     * @member {boolean} _selectDefaultTrack
     */
    _this._selectDefaultTrack = true;

    /**
     * @public
     * All tracks available
     * @member {AudioTrack[]}
     */
    _this.tracks = [];

    /**
     * @public
     * List of blacklisted audio track IDs (that have caused failure)
     * @member {number[]}
     */
    _this.trackIdBlacklist = Object.create(null);

    /**
     * @public
     * The currently running group ID for audio
     * (we grab this on manifest-parsed and new level-loaded)
     * @member {string}
     */
    _this.audioGroupId = null;
    return _this;
  }

  /**
   * Reset audio tracks on new manifest loading.
   */


  _createClass(AudioTrackController, [{
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.tracks = [];
      this._trackId = -1;
      this._selectDefaultTrack = true;
    }

    /**
     * Store tracks data from manifest parsed data.
     *
     * Trigger AUDIO_TRACKS_UPDATED event.
     *
     * @param {*} data
     */

  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var tracks = this.tracks = data.audioTracks || [];
      this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });
    }

    /**
     * Store track details of loaded track in our data-model.
     *
     * Set-up metadata update interval task for live-mode streams.
     *
     * @param {} data
     */

  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      if (data.id >= this.tracks.length) {
        _logger.logger.warn('Invalid audio track id:', data.id);
        return;
      }

      _logger.logger.log('audioTrack ' + data.id + ' loaded');

      this.tracks[data.id].details = data.details;

      // check if current playlist is a live playlist
      // and if we have already our reload interval setup
      if (data.details.live && !this.hasInterval()) {
        // if live playlist we will have to reload it periodically
        // set reload period to playlist target duration
        var updatePeriodMs = data.details.targetduration * 1000;
        this.setInterval(updatePeriodMs);
      }

      if (!data.details.live && this.hasInterval()) {
        // playlist is not live and timer is scheduled: cancel it
        this.clearInterval();
      }
    }

    /**
     * Update the internal group ID to any audio-track we may have set manually
     * or because of a failure-handling fallback.
     *
     * Quality-levels should update to that group ID in this case.
     *
     * @param {*} data
     */

  }, {
    key: 'onAudioTrackSwitched',
    value: function onAudioTrackSwitched(data) {
      var audioGroupId = this.tracks[data.id].groupId;
      if (audioGroupId && this.audioGroupId !== audioGroupId) {
        this.audioGroupId = audioGroupId;
      }
    }

    /**
     * When a level gets loaded, if it has redundant audioGroupIds (in the same ordinality as it's redundant URLs)
     * we are setting our audio-group ID internally to the one set, if it is different from the group ID currently set.
     *
     * If group-ID got update, we re-select the appropriate audio-track with this group-ID matching the currently
     * selected one (based on NAME property).
     *
     * @param {*} data
     */

  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      // FIXME: crashes because currentLevel is undefined
      // const levelInfo = this.hls.levels[this.hls.currentLevel];

      var levelInfo = this.hls.levels[data.level];

      if (!levelInfo.audioGroupIds) {
        return;
      }

      var audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];
      if (this.audioGroupId !== audioGroupId) {
        this.audioGroupId = audioGroupId;
        this._selectInitialAudioTrack();
      }
    }

    /**
     * Handle network errors loading audio track manifests
     * and also pausing on any netwok errors.
     *
     * @param {ErrorEventData} data
     */

  }, {
    key: 'onError',
    value: function onError(data) {
      // Only handle network errors
      if (data.type !== _errors.ErrorTypes.NETWORK_ERROR) {
        return;
      }

      // If fatal network error, cancel update task
      if (data.fatal) {
        this.clearInterval();
      }

      // If not an audio-track loading error don't handle further
      if (data.details !== _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR) {
        return;
      }

      _logger.logger.warn('Network failure on audio-track id:', data.context.id);
      this._handleLoadError();
    }

    /**
     * @type {AudioTrack[]} Audio-track list we own
     */

  }, {
    key: '_setAudioTrack',


    /**
     * @private
     * @param {number} newId
     */
    value: function _setAudioTrack(newId) {
      // noop on same audio track id as already set
      if (this._trackId === newId && this.tracks[this._trackId].details) {
        _logger.logger.debug('Same id as current audio-track passed, and track details available -> no-op');
        return;
      }

      // check if level idx is valid
      if (newId < 0 || newId >= this.tracks.length) {
        _logger.logger.warn('Invalid id passed to audio-track controller');
        return;
      }

      var audioTrack = this.tracks[newId];

      _logger.logger.log('Now switching to audio-track index ' + newId);

      // stopping live reloading timer if any
      this.clearInterval();
      this._trackId = newId;

      var url = audioTrack.url,
          type = audioTrack.type,
          id = audioTrack.id;

      this.hls.trigger(_events2.default.AUDIO_TRACK_SWITCHING, { id: id, type: type, url: url });
      this._loadTrackDetailsIfNeeded(audioTrack);
    }

    /**
     * @override
     */

  }, {
    key: 'doTick',
    value: function doTick() {
      this._updateTrack(this._trackId);
    }

    /**
     * Select initial track
     * @private
     */

  }, {
    key: '_selectInitialAudioTrack',
    value: function _selectInitialAudioTrack() {
      var _this2 = this;

      var tracks = this.tracks;
      if (!tracks.length) {
        return;
      }

      var currentAudioTrack = this.tracks[this._trackId];

      var name = null;
      if (currentAudioTrack) {
        name = currentAudioTrack.name;
      }

      // Pre-select default tracks if there are any
      if (this._selectDefaultTrack) {
        var defaultTracks = tracks.filter(function (track) {
          return track.default;
        });
        if (defaultTracks.length) {
          tracks = defaultTracks;
        } else {
          _logger.logger.warn('No default audio tracks defined');
        }
      }

      var trackFound = false;

      var traverseTracks = function traverseTracks() {
        // Select track with right group ID
        tracks.forEach(function (track) {
          if (trackFound) {
            return;
          }
          // We need to match the (pre-)selected group ID
          // and the NAME of the current track.
          if ((!_this2.audioGroupId || track.groupId === _this2.audioGroupId) && (!name || name === track.name)) {
            // If there was a previous track try to stay with the same `NAME`.
            // It should be unique across tracks of same group, and consistent through redundant track groups.
            _this2._setAudioTrack(track.id);
            trackFound = true;
          }
        });
      };

      traverseTracks();

      if (!trackFound) {
        name = null;
        traverseTracks();
      }

      if (!trackFound) {
        _logger.logger.error('No track found for running audio group-ID: ' + this.audioGroupId);

        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
          fatal: true
        });
      }
    }

    /**
     * @private
     * @param {AudioTrack} audioTrack
     * @returns {boolean}
     */

  }, {
    key: '_needsTrackLoading',
    value: function _needsTrackLoading(audioTrack) {
      var details = audioTrack.details,
          url = audioTrack.url;


      if (!details || details.live) {
        // check if we face an audio track embedded in main playlist (audio track without URI attribute)
        return !!url;
      }

      return false;
    }

    /**
     * @private
     * @param {AudioTrack} audioTrack
     */

  }, {
    key: '_loadTrackDetailsIfNeeded',
    value: function _loadTrackDetailsIfNeeded(audioTrack) {
      if (this._needsTrackLoading(audioTrack)) {
        var url = audioTrack.url,
            id = audioTrack.id;
        // track not retrieved yet, or live playlist we need to (re)load it

        _logger.logger.log('loading audio-track playlist for id: ' + id);
        this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: id });
      }
    }

    /**
     * @private
     * @param {number} newId
     */

  }, {
    key: '_updateTrack',
    value: function _updateTrack(newId) {
      // check if level idx is valid
      if (newId < 0 || newId >= this.tracks.length) {
        return;
      }

      // stopping live reloading timer if any
      this.clearInterval();
      this._trackId = newId;
      _logger.logger.log('trying to update audio-track ' + newId);
      var audioTrack = this.tracks[newId];
      this._loadTrackDetailsIfNeeded(audioTrack);
    }

    /**
     * @private
     */

  }, {
    key: '_handleLoadError',
    value: function _handleLoadError() {
      // First, let's black list current track id
      this.trackIdBlacklist[this._trackId] = true;

      // Let's try to fall back on a functional audio-track with the same group ID
      var previousId = this._trackId;
      var _tracks$previousId = this.tracks[previousId],
          name = _tracks$previousId.name,
          language = _tracks$previousId.language,
          groupId = _tracks$previousId.groupId;


      _logger.logger.warn('Loading failed on audio track id: ' + previousId + ', group-id: ' + groupId + ', name/language: "' + name + '" / "' + language + '"');

      // Find a non-blacklisted track ID with the same NAME
      // At least a track that is not blacklisted, thus on another group-ID.
      var newId = previousId;
      for (var i = 0; i < this.tracks.length; i++) {
        if (this.trackIdBlacklist[i]) {
          continue;
        }
        var newTrack = this.tracks[i];
        if (newTrack.name === name) {
          newId = i;
          break;
        }
      }

      if (newId === previousId) {
        _logger.logger.warn('No fallback audio-track found for name/language: "' + name + '" / "' + language + '"');
        return;
      }

      _logger.logger.log('Attempting audio-track fallback id:', newId, 'group-id:', this.tracks[newId].groupId);

      this._setAudioTrack(newId);
    }
  }, {
    key: 'audioTracks',
    get: function get() {
      return this.tracks;
    }

    /**
     * @type {number} Index into audio-tracks list of currently selected track.
     */

  }, {
    key: 'audioTrack',
    get: function get() {
      return this._trackId;
    }

    /**
     * Select current track by index
     */
    ,
    set: function set(newId) {
      this._setAudioTrack(newId);
      // If audio track is selected from API then don't choose from the manifest default track
      this._selectDefaultTrack = false;
    }
  }]);

  return AudioTrackController;
}(_taskLoop2.default);

exports.default = AudioTrackController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/base-stream-controller.js":
/*!*********************************************************!*\
  !*** ./src/hls.js/controller/base-stream-controller.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.State = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _taskLoop = __webpack_require__(/*! ../task-loop */ "./src/hls.js/task-loop.js");

var _taskLoop2 = _interopRequireDefault(_taskLoop);

var _fragmentTracker = __webpack_require__(/*! ./fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var State = exports.State = {
  STOPPED: 'STOPPED',
  STARTING: 'STARTING',
  IDLE: 'IDLE',
  PAUSED: 'PAUSED',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_TRACK: 'WAITING_TRACK',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  BUFFER_FLUSHING: 'BUFFER_FLUSHING',
  ENDED: 'ENDED',
  ERROR: 'ERROR',
  WAITING_INIT_PTS: 'WAITING_INIT_PTS',
  WAITING_LEVEL: 'WAITING_LEVEL'
};

var BaseStreamController = function (_TaskLoop) {
  _inherits(BaseStreamController, _TaskLoop);

  function BaseStreamController() {
    _classCallCheck(this, BaseStreamController);

    return _possibleConstructorReturn(this, (BaseStreamController.__proto__ || Object.getPrototypeOf(BaseStreamController)).apply(this, arguments));
  }

  _createClass(BaseStreamController, [{
    key: 'doTick',
    value: function doTick() {}
  }, {
    key: 'startLoad',
    value: function startLoad() {}
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var frag = this.fragCurrent;
      if (frag) {
        if (frag.loader) {
          frag.loader.abort();
        }
        this.fragmentTracker.removeFragment(frag);
      }
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
      this.fragCurrent = null;
      this.fragPrevious = null;
      this.clearInterval();
      this.clearNextTick();
      this.state = State.STOPPED;
    }
  }, {
    key: '_streamEnded',
    value: function _streamEnded(bufferInfo, levelDetails) {
      var fragCurrent = this.fragCurrent,
          fragmentTracker = this.fragmentTracker;
      // we just got done loading the final fragment and there is no other buffered range after ...
      // rationale is that in case there are any buffered ranges after, it means that there are unbuffered portion in between
      // so we should not switch to ENDED in that case, to be able to buffer them
      // dont switch to ENDED if we need to backtrack last fragment

      if (!levelDetails.live && fragCurrent && !fragCurrent.backtracked && fragCurrent.sn === levelDetails.endSN && !bufferInfo.nextStart) {
        var fragState = fragmentTracker.getState(fragCurrent);
        return fragState === _fragmentTracker.FragmentState.PARTIAL || fragState === _fragmentTracker.FragmentState.OK;
      }
      return false;
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      var config = this.config,
          media = this.media,
          mediaBuffer = this.mediaBuffer,
          state = this.state;

      var currentTime = media ? media.currentTime : null;
      var bufferInfo = _bufferHelper.BufferHelper.bufferInfo(mediaBuffer || media, currentTime, this.config.maxBufferHole);

      if (Number.isFinite(currentTime)) {
        _logger.logger.log('media seeking to ' + currentTime.toFixed(3));
      }

      if (state === State.FRAG_LOADING) {
        var fragCurrent = this.fragCurrent;
        // check if we are seeking to a unbuffered area AND if frag loading is in progress
        if (bufferInfo.len === 0 && fragCurrent) {
          var tolerance = config.maxFragLookUpTolerance;
          var fragStartOffset = fragCurrent.start - tolerance;
          var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
          // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything
          if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
            if (fragCurrent.loader) {
              _logger.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            this.fragPrevious = null;
            // switch to IDLE state to load new fragment
            this.state = State.IDLE;
          } else {
            _logger.logger.log('seeking outside of buffer but within currently loaded fragment range');
          }
        }
      } else if (state === State.ENDED) {
        // if seeking to unbuffered area, clean up fragPrevious
        if (bufferInfo.len === 0) {
          this.fragPrevious = null;
          this.fragCurrent = null;
        }

        // switch to IDLE state to check for potential new fragment
        this.state = State.IDLE;
      }
      if (media) {
        this.lastCurrentTime = currentTime;
      }

      // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target
      if (!this.loadedmetadata) {
        this.nextLoadPosition = this.startPosition = currentTime;
      }

      // tick to speed up processing
      this.tick();
    }
  }, {
    key: 'onMediaEnded',
    value: function onMediaEnded() {
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onHandlerDestroying',
    value: function onHandlerDestroying() {
      this.stopLoad();
      _get(BaseStreamController.prototype.__proto__ || Object.getPrototypeOf(BaseStreamController.prototype), 'onHandlerDestroying', this).call(this);
    }
  }, {
    key: 'onHandlerDestroyed',
    value: function onHandlerDestroyed() {
      this.state = State.STOPPED;
      this.fragmentTracker = null;
    }
  }]);

  return BaseStreamController;
}(_taskLoop2.default);

exports.default = BaseStreamController;

/***/ }),

/***/ "./src/hls.js/controller/buffer-controller.js":
/*!****************************************************!*\
  !*** ./src/hls.js/controller/buffer-controller.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _mediasourceHelper = __webpack_require__(/*! ../utils/mediasource-helper */ "./src/hls.js/utils/mediasource-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Buffer Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var MediaSource = (0, _mediasourceHelper.getMediaSource)();

var BufferController = function (_EventHandler) {
  _inherits(BufferController, _EventHandler);

  function BufferController(hls) {
    _classCallCheck(this, BufferController);

    // the value that we have set mediasource.duration to
    // (the actual duration may be tweaked slighly by the browser)
    var _this = _possibleConstructorReturn(this, (BufferController.__proto__ || Object.getPrototypeOf(BufferController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_RESET, _events2.default.BUFFER_APPENDING, _events2.default.BUFFER_CODECS, _events2.default.BUFFER_EOS, _events2.default.BUFFER_FLUSHING, _events2.default.LEVEL_PTS_UPDATED, _events2.default.LEVEL_UPDATED));

    _this._msDuration = null;
    // the value that we want to set mediaSource.duration to
    _this._levelDuration = null;
    // the target duration of the current media playlist
    _this._levelTargetDuration = 10;
    // current stream state: true - for live broadcast, false - for VoD content
    _this._live = null;
    // cache the self generated object url to detect hijack of video tag
    _this._objectUrl = null;
    // The number of BUFFER_CODEC events received before any sourceBuffers are created
    _this.bufferCodecEventsExpected = 0;

    // Source Buffer listeners
    _this.onsbue = _this.onSBUpdateEnd.bind(_this);
    _this.onsbe = _this.onSBUpdateError.bind(_this);
    _this.pendingTracks = {};
    _this.tracks = {};
    return _this;
  }

  _createClass(BufferController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onLevelPtsUpdated',
    value: function onLevelPtsUpdated(data) {
      var type = data.type;
      var audioTrack = this.tracks.audio;

      // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
      // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
      // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue
      // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`
      // event if SB is in updating state.
      // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486

      if (type === 'audio' && audioTrack && audioTrack.container === 'audio/mpeg') {
        // Chrome audio mp3 track
        var audioBuffer = this.sourceBuffer.audio;
        var delta = Math.abs(audioBuffer.timestampOffset - data.start);

        // adjust timestamp offset if time delta is greater than 100ms
        if (delta > 0.1) {
          var updating = audioBuffer.updating;

          try {
            audioBuffer.abort();
          } catch (err) {
            _logger.logger.warn('can not abort audio buffer: ' + err);
          }

          if (!updating) {
            _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + data.start);
            audioBuffer.timestampOffset = data.start;
          } else {
            this.audioTimestampOffset = data.start;
          }
        }
      }
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
      // sourcebuffers will be created all at once when the expected nb of tracks will be reached
      // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
      // it will contain the expected nb of source buffers, no need to compute it
      this.bufferCodecEventsExpected = data.altAudio ? 2 : 1;
      _logger.logger.log(this.bufferCodecEventsExpected + ' bufferCodec event(s) expected');
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var media = this.media = data.media;
      if (media) {
        // setup the media source
        var ms = this.mediaSource = new MediaSource();
        // Media Source listeners
        this.onmso = this.onMediaSourceOpen.bind(this);
        this.onmse = this.onMediaSourceEnded.bind(this);
        this.onmsc = this.onMediaSourceClose.bind(this);
        ms.addEventListener('sourceopen', this.onmso);
        ms.addEventListener('sourceended', this.onmse);
        ms.addEventListener('sourceclose', this.onmsc);
        // link video and media Source
        media.src = window.URL.createObjectURL(ms);
        // cache the locally generated object url
        this._objectUrl = media.src;
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      _logger.logger.log('media source detaching');
      var ms = this.mediaSource;
      if (ms) {
        if (ms.readyState === 'open') {
          try {
            // endOfStream could trigger exception if any sourcebuffer is in updating state
            // we don't really care about checking sourcebuffer state here,
            // as we are anyway detaching the MediaSource
            // let's just avoid this exception to propagate
            ms.endOfStream();
          } catch (err) {
            _logger.logger.warn('onMediaDetaching:' + err.message + ' while calling endOfStream');
          }
        }
        ms.removeEventListener('sourceopen', this.onmso);
        ms.removeEventListener('sourceended', this.onmse);
        ms.removeEventListener('sourceclose', this.onmsc);

        // Detach properly the MediaSource from the HTMLMediaElement as
        // suggested in https://github.com/w3c/media-source/issues/53.
        if (this.media) {
          window.URL.revokeObjectURL(this._objectUrl);

          // clean up video tag src only if it's our own url. some external libraries might
          // hijack the video tag and change its 'src' without destroying the Hls instance first
          if (this.media.src === this._objectUrl) {
            this.media.removeAttribute('src');
            this.media.load();
          } else {
            _logger.logger.warn('media.src was changed by a third party - skip cleanup');
          }
        }

        this.mediaSource = null;
        this.media = null;
        this._objectUrl = null;
        this.pendingTracks = {};
        this.tracks = {};
        this.sourceBuffer = {};
        this.flushRange = [];
        this.segments = [];
        this.appended = 0;
      }
      this.onmso = this.onmse = this.onmsc = null;
      this.hls.trigger(_events2.default.MEDIA_DETACHED);
    }
  }, {
    key: 'onMediaSourceOpen',
    value: function onMediaSourceOpen() {
      _logger.logger.log('media source opened');
      this.hls.trigger(_events2.default.MEDIA_ATTACHED, { media: this.media });
      var mediaSource = this.mediaSource;
      if (mediaSource) {
        // once received, don't listen anymore to sourceopen event
        mediaSource.removeEventListener('sourceopen', this.onmso);
      }
      this.checkPendingTracks();
    }
  }, {
    key: 'checkPendingTracks',
    value: function checkPendingTracks() {
      var bufferCodecEventsExpected = this.bufferCodecEventsExpected,
          pendingTracks = this.pendingTracks;
      // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.
      // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after
      // data has been appended to existing ones.
      // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.

      var pendingTracksCount = Object.keys(pendingTracks).length;
      if (pendingTracksCount && !bufferCodecEventsExpected || pendingTracksCount === 2) {
        // ok, let's create them now !
        this.createSourceBuffers(pendingTracks);
        this.pendingTracks = {};
        // append any pending segments now !
        this.doAppending();
      }
    }
  }, {
    key: 'onMediaSourceClose',
    value: function onMediaSourceClose() {
      _logger.logger.log('media source closed');
    }
  }, {
    key: 'onMediaSourceEnded',
    value: function onMediaSourceEnded() {
      _logger.logger.log('media source ended');
    }
  }, {
    key: 'onSBUpdateEnd',
    value: function onSBUpdateEnd() {
      // update timestampOffset
      if (this.audioTimestampOffset) {
        var audioBuffer = this.sourceBuffer.audio;
        _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + this.audioTimestampOffset);
        audioBuffer.timestampOffset = this.audioTimestampOffset;
        delete this.audioTimestampOffset;
      }

      if (this._needsFlush) {
        this.doFlush();
      }

      if (this._needsEos) {
        this.checkEos();
      }

      this.appending = false;
      var parent = this.parent;
      // count nb of pending segments waiting for appending on this sourcebuffer
      var pending = this.segments.reduce(function (counter, segment) {
        return segment.parent === parent ? counter + 1 : counter;
      }, 0);

      // this.sourceBuffer is better to use than media.buffered as it is closer to the PTS data from the fragments
      var timeRanges = {};
      var sourceBuffer = this.sourceBuffer;
      for (var streamType in sourceBuffer) {
        timeRanges[streamType] = sourceBuffer[streamType].buffered;
      }

      // Seek
      if (this._paused === false && timeRanges["video"] && timeRanges["video"].length > 0 && timeRanges["audio"] && timeRanges["audio"].length > 0) {

        if (timeRanges["video"].end(0) - timeRanges["video"].start(0) > 1 && timeRanges["audio"].end(0) - timeRanges["audio"].start(0) > 1) {
          // Seek to the point that can play;
          var startTime = Math.max(timeRanges["video"].start(0), timeRanges["audio"].start(0));
          this.media.currentTime = startTime;
          this.media.play();
          delete this["_paused"];
        } else {
          // Try to seek more
          var endTime = Math.max(timeRanges["video"].end(0), timeRanges["audio"].end(0));
          this.media.currentTime = endTime;
          this.media.play();
        }
      }

      this.hls.trigger(_events2.default.BUFFER_APPENDED, { parent: parent, pending: pending, timeRanges: timeRanges });
      // don't append in flushing mode
      if (!this._needsFlush) {
        this.doAppending();
      }

      this.updateMediaElementDuration();

      // appending goes first
      if (pending === 0) {
        this.flushLiveBackBuffer();
      }
    }
  }, {
    key: 'onSBUpdateError',
    value: function onSBUpdateError(event) {
      _logger.logger.error('sourceBuffer error:', event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
      // we don't need to do more than that, as accordin to the spec, updateend will be fired just after
    }
  }, {
    key: 'onBufferReset',
    value: function onBufferReset() {
      var sourceBuffer = this.sourceBuffer;
      for (var type in sourceBuffer) {
        var sb = sourceBuffer[type];
        try {
          this.mediaSource.removeSourceBuffer(sb);
          sb.removeEventListener('updateend', this.onsbue);
          sb.removeEventListener('error', this.onsbe);
        } catch (err) {}
      }
      this.sourceBuffer = {};
      this.flushRange = [];
      this.segments = [];
      this.appended = 0;
    }
  }, {
    key: 'onBufferCodecs',
    value: function onBufferCodecs(tracks) {
      var _this2 = this;

      // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
      // if sourcebuffers already created, do nothing ...
      /** tracks, trackbuffer 
      if (Object.keys(this.sourceBuffer).length) {
        return;
      }*/

      Object.keys(tracks).forEach(function (trackName) {
        _this2.pendingTracks[trackName] = tracks[trackName];
      });
      var mediaSource = this.mediaSource;

      this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);
      if (mediaSource && mediaSource.readyState === 'open') {
        this.checkPendingTracks();
      }
    }
  }, {
    key: 'createSourceBuffers',
    value: function createSourceBuffers(tracks) {
      var sourceBuffer = this.sourceBuffer,
          mediaSource = this.mediaSource;
      for (var trackName in tracks) {
        if (!sourceBuffer[trackName]) {
          var track = tracks[trackName];
          // use levelCodec as first priority
          var codec = track.levelCodec || track.codec;
          var mimeType = track.container + ';codecs=' + codec;
          _logger.logger.log('creating sourceBuffer(' + mimeType + ')');
          try {
            var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
            sb.addEventListener('updateend', this.onsbue);
            sb.addEventListener('error', this.onsbe);
            this.tracks[trackName] = { codec: codec, container: track.container };
            track.buffer = sb;
          } catch (err) {
            if (err.code == 22) {
              _logger.logger.log("Found new track, try to rebuild");
              this._paused = false;
              // setup the media source
              var ms = this.mediaSource = new MediaSource();
              // Media Source listeners
              this.onmso = this.onMediaSourceOpen.bind(this);
              this.onmse = this.onMediaSourceEnded.bind(this);
              this.onmsc = this.onMediaSourceClose.bind(this);

              for (var i = 0; i < Object.keys(this.tracks).length; i++) {
                var _track = this.tracks[Object.keys(this.tracks)[i]];
                this.pendingTracks[Object.keys(this.tracks)[i]] = _track;
              }
              this.tracks = {};
              this.sourceBuffer = {};
              ms.addEventListener('sourceopen', this.onmso);
              ms.addEventListener('sourceended', this.onmse);
              ms.addEventListener('sourceclose', this.onmsc);
              // link video and media Source
              this.media.src = window.URL.createObjectURL(ms);
              // cache the locally generated object url
              this._objectUrl = media.src;
            } else {
              _logger.logger.error('error while trying to add sourceBuffer:' + err.message);
              this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });
            }
          }
        }
      }

      this.hls.trigger(_events2.default.BUFFER_CREATED, { tracks: tracks });
    }
  }, {
    key: 'onBufferAppending',
    value: function onBufferAppending(data) {
      if (!this._needsFlush) {
        if (!this.segments) {
          this.segments = [data];
        } else {
          this.segments.push(data);
        }

        this.doAppending();
      }
    }
  }, {
    key: 'onBufferAppendFail',
    value: function onBufferAppendFail(data) {
      _logger.logger.error('sourceBuffer error:', data.event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
    }

    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()

  }, {
    key: 'onBufferEos',
    value: function onBufferEos(data) {
      var sb = this.sourceBuffer;
      var dataType = data.type;
      for (var type in sb) {
        if (!dataType || type === dataType) {
          if (!sb[type].ended) {
            sb[type].ended = true;
            _logger.logger.log(type + ' sourceBuffer now EOS');
          }
        }
      }
      this.checkEos();
    }

    // if all source buffers are marked as ended, signal endOfStream() to MediaSource.

  }, {
    key: 'checkEos',
    value: function checkEos() {
      var sb = this.sourceBuffer,
          mediaSource = this.mediaSource;
      if (!mediaSource || mediaSource.readyState !== 'open') {
        this._needsEos = false;
        return;
      }
      for (var type in sb) {
        var sbobj = sb[type];
        if (!sbobj.ended) {
          return;
        }

        if (sbobj.updating) {
          this._needsEos = true;
          return;
        }
      }
      _logger.logger.log('all media data are available, signal endOfStream() to MediaSource and stop loading fragment');
      // Notify the media element that it now has all of the media data
      try {
        mediaSource.endOfStream();
      } catch (e) {
        _logger.logger.warn('exception while calling mediaSource.endOfStream()');
      }
      this._needsEos = false;
    }
  }, {
    key: 'onBufferFlushing',
    value: function onBufferFlushing(data) {
      this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });
      // attempt flush immediately
      this.flushBufferCounter = 0;
      this.doFlush();
    }
  }, {
    key: 'flushLiveBackBuffer',
    value: function flushLiveBackBuffer() {
      // clear back buffer for live only
      if (!this._live) {
        return;
      }

      var liveBackBufferLength = this.hls.config.liveBackBufferLength;
      if (!isFinite(liveBackBufferLength) || liveBackBufferLength < 0) {
        return;
      }

      var currentTime = this.media.currentTime;
      var sourceBuffer = this.sourceBuffer;
      var bufferTypes = Object.keys(sourceBuffer);
      var targetBackBufferPosition = currentTime - Math.max(liveBackBufferLength, this._levelTargetDuration);

      for (var index = bufferTypes.length - 1; index >= 0; index--) {
        var bufferType = bufferTypes[index],
            buffered = sourceBuffer[bufferType].buffered;

        // when target buffer start exceeds actual buffer start
        if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
          // remove buffer up until current time minus minimum back buffer length (removing buffer too close to current
          // time will lead to playback freezing)
          // credits for level target duration - https://github.com/videojs/http-streaming/blob/3132933b6aa99ddefab29c10447624efd6fd6e52/src/segment-loader.js#L91
          this.removeBufferRange(bufferType, sourceBuffer[bufferType], 0, targetBackBufferPosition);
        }
      }
    }
  }, {
    key: 'onLevelUpdated',
    value: function onLevelUpdated(_ref) {
      var details = _ref.details;

      if (details.fragments.length > 0) {
        this._levelDuration = details.totalduration + details.fragments[0].start;
        this._levelTargetDuration = details.averagetargetduration || details.targetduration || 10;
        this._live = details.live;
        this.updateMediaElementDuration();
      }
    }

    /**
     * Update Media Source duration to current level duration or override to Infinity if configuration parameter
     * 'liveDurationInfinity` is set to `true`
     * More details: https://github.com/video-dev/hls.js/issues/355
     */

  }, {
    key: 'updateMediaElementDuration',
    value: function updateMediaElementDuration() {
      var config = this.hls.config;

      var duration = void 0;

      if (this._levelDuration === null || !this.media || !this.mediaSource || !this.sourceBuffer || this.media.readyState === 0 || this.mediaSource.readyState !== 'open') {
        return;
      }

      for (var type in this.sourceBuffer) {
        if (this.sourceBuffer[type].updating === true) {
          // can't set duration whilst a buffer is updating
          return;
        }
      }

      duration = this.media.duration;
      // initialise to the value that the media source is reporting
      if (this._msDuration === null) {
        this._msDuration = this.mediaSource.duration;
      }

      if (this._live === true && config.liveDurationInfinity === true) {
        // Override duration to Infinity
        _logger.logger.log('Media Source duration is set to Infinity');
        this._msDuration = this.mediaSource.duration = Infinity;
      } else if (this._levelDuration > this._msDuration && this._levelDuration > duration || !Number.isFinite(duration)) {
        // levelDuration was the last value we set.
        // not using mediaSource.duration as the browser may tweak this value
        // only update Media Source duration if its value increase, this is to avoid
        // flushing already buffered portion when switching between quality level
        _logger.logger.log('Updating Media Source duration to ' + this._levelDuration.toFixed(3));
        this._msDuration = this.mediaSource.duration = this._levelDuration;
      }
    }
  }, {
    key: 'doFlush',
    value: function doFlush() {
      // loop through all buffer ranges to flush
      while (this.flushRange.length) {
        var range = this.flushRange[0];
        // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
        if (this.flushBuffer(range.start, range.end, range.type)) {
          // range flushed, remove from flush array
          this.flushRange.shift();
          this.flushBufferCounter = 0;
        } else {
          this._needsFlush = true;
          // avoid looping, wait for SB update end to retrigger a flush
          return;
        }
      }
      if (this.flushRange.length === 0) {
        // everything flushed
        this._needsFlush = false;

        // let's recompute this.appended, which is used to avoid flush looping
        var appended = 0;
        var sourceBuffer = this.sourceBuffer;
        try {
          for (var type in sourceBuffer) {
            appended += sourceBuffer[type].buffered.length;
          }
        } catch (error) {
          // error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource
          // this is harmess at this stage, catch this to avoid reporting an internal exception
          _logger.logger.error('error while accessing sourceBuffer.buffered');
        }
        this.appended = appended;
        this.hls.trigger(_events2.default.BUFFER_FLUSHED);
      }
    }
  }, {
    key: 'doAppending',
    value: function doAppending() {
      var hls = this.hls,
          segments = this.segments,
          sourceBuffer = this.sourceBuffer;

      if (Object.keys(sourceBuffer).length) {
        if (this.media.error) {
          this.segments = [];
          _logger.logger.error('trying to append although a media error occured, flush segment and abort');
          return;
        }
        if (this.appending) {
          // logger.log(`sb appending in progress`);
          return;
        }
        if (segments && segments.length) {
          var segment = segments.shift();
          try {
            var type = segment.type,
                sb = sourceBuffer[type];
            if (sb) {
              if (!sb.updating) {
                // reset sourceBuffer ended flag before appending segment
                sb.ended = false;
                // logger.log(`appending ${segment.content} ${type} SB, size:${segment.data.length}, ${segment.parent}`);
                this.parent = segment.parent;
                console.log('append buffer ', segment);
                sb.appendBuffer(segment.data);
                this.appendError = 0;
                this.appended++;
                this.appending = true;
              } else {
                segments.unshift(segment);
              }
            } else {
              // in case we don't have any source buffer matching with this segment type,
              // it means that Mediasource fails to create sourcebuffer
              // discard this segment, and trigger update end
              this.onSBUpdateEnd();
            }
          } catch (err) {
            // in case any error occured while appending, put back segment in segments table
            _logger.logger.error('error while trying to append buffer:' + err.message);
            segments.unshift(segment);
            var event = { type: _errors.ErrorTypes.MEDIA_ERROR, parent: segment.parent };
            if (err.code !== 22) {
              if (this.appendError) {
                this.appendError++;
              } else {
                this.appendError = 1;
              }

              event.details = _errors.ErrorDetails.BUFFER_APPEND_ERROR;
              /* with UHD content, we could get loop of quota exceeded error until
                browser is able to evict some data from sourcebuffer. retrying help recovering this
              */
              if (this.appendError > hls.config.appendErrorMaxRetry) {
                _logger.logger.log('fail ' + hls.config.appendErrorMaxRetry + ' times to append segment in sourceBuffer');
                this.segments = [];
                event.fatal = true;
                hls.trigger(_events2.default.ERROR, event);
              } else {
                event.fatal = false;
                hls.trigger(_events2.default.ERROR, event);
              }
            } else {
              // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
              // let's stop appending any segments, and report BUFFER_FULL_ERROR error
              this.segments = [];
              event.details = _errors.ErrorDetails.BUFFER_FULL_ERROR;
              event.fatal = false;
              hls.trigger(_events2.default.ERROR, event);
            }
          }
        }
      }
    }

    /*
      flush specified buffered range,
      return true once range has been flushed.
      as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
    */

  }, {
    key: 'flushBuffer',
    value: function flushBuffer(startOffset, endOffset, typeIn) {
      var sb = void 0;
      var sourceBuffer = this.sourceBuffer;
      if (Object.keys(sourceBuffer).length) {
        _logger.logger.log('flushBuffer,pos/start/end: ' + this.media.currentTime.toFixed(3) + '/' + startOffset + '/' + endOffset);
        // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
        if (this.flushBufferCounter < this.appended) {
          for (var type in sourceBuffer) {
            // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
            // if no, let's flush all sourcebuffers
            if (typeIn && type !== typeIn) {
              continue;
            }

            sb = sourceBuffer[type];
            // we are going to flush buffer, mark source buffer as 'not ended'
            sb.ended = false;
            if (!sb.updating) {
              if (this.removeBufferRange(type, sb, startOffset, endOffset)) {
                this.flushBufferCounter++;
                return false;
              }
            } else {
              _logger.logger.warn('cannot flush, sb updating in progress');
              return false;
            }
          }
        } else {
          _logger.logger.warn('abort flushing too many retries');
        }
        _logger.logger.log('buffer flushed');
      }
      // everything flushed !
      return true;
    }

    /**
     * Removes first buffered range from provided source buffer that lies within given start and end offsets.
     *
     * @param type Type of the source buffer, logging purposes only.
     * @param sb Target SourceBuffer instance.
     * @param startOffset
     * @param endOffset
     *
     * @returns {boolean} True when source buffer remove requested.
     */

  }, {
    key: 'removeBufferRange',
    value: function removeBufferRange(type, sb, startOffset, endOffset) {
      try {
        for (var i = 0; i < sb.buffered.length; i++) {
          var bufStart = sb.buffered.start(i);
          var bufEnd = sb.buffered.end(i);
          var removeStart = Math.max(bufStart, startOffset);
          var removeEnd = Math.min(bufEnd, endOffset);

          /* sometimes sourcebuffer.remove() does not flush
            the exact expected time range.
            to avoid rounding issues/infinite loop,
            only flush buffer range of length greater than 500ms.
          */
          if (Math.min(removeEnd, bufEnd) - removeStart > 0.5) {
            _logger.logger.log('sb remove ' + type + ' [' + removeStart + ',' + removeEnd + '], of [' + bufStart + ',' + bufEnd + '], pos:' + this.media.currentTime);
            sb.remove(removeStart, removeEnd);
            return true;
          }
        }
      } catch (error) {
        _logger.logger.warn('removeBufferRange failed', error);
      }

      return false;
    }
  }]);

  return BufferController;
}(_eventHandler2.default);

exports.default = BufferController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/cap-level-controller.js":
/*!*******************************************************!*\
  !*** ./src/hls.js/controller/cap-level-controller.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * cap stream level to media size dimension controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var CapLevelController = function (_EventHandler) {
  _inherits(CapLevelController, _EventHandler);

  function CapLevelController(hls) {
    _classCallCheck(this, CapLevelController);

    var _this = _possibleConstructorReturn(this, (CapLevelController.__proto__ || Object.getPrototypeOf(CapLevelController)).call(this, hls, _events2.default.FPS_DROP_LEVEL_CAPPING, _events2.default.MEDIA_ATTACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_CODECS, _events2.default.MEDIA_DETACHING));

    _this.autoLevelCapping = Number.POSITIVE_INFINITY;
    _this.firstLevel = null;
    _this.levels = [];
    _this.media = null;
    _this.restrictedLevels = [];
    _this.timer = null;
    return _this;
  }

  _createClass(CapLevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.hls.config.capLevelToPlayerSize) {
        this.media = null;
        this._stopCapping();
      }
    }
  }, {
    key: 'onFpsDropLevelCapping',
    value: function onFpsDropLevelCapping(data) {
      // Don't add a restricted level more than once
      if (CapLevelController.isLevelAllowed(data.droppedLevel, this.restrictedLevels)) {
        this.restrictedLevels.push(data.droppedLevel);
      }
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media instanceof window.HTMLVideoElement ? data.media : null;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var hls = this.hls;
      this.restrictedLevels = [];
      this.levels = data.levels;
      this.firstLevel = data.firstLevel;
      if (hls.config.capLevelToPlayerSize && data.video) {
        // Start capping immediately if the manifest has signaled video codecs
        this._startCapping();
      }
    }

    // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted
    // to the first level

  }, {
    key: 'onBufferCodecs',
    value: function onBufferCodecs(data) {
      var hls = this.hls;
      if (hls.config.capLevelToPlayerSize && data.video) {
        // If the manifest did not signal a video codec capping has been deferred until we're certain video is present
        this._startCapping();
      }
    }
  }, {
    key: 'onLevelsUpdated',
    value: function onLevelsUpdated(data) {
      this.levels = data.levels;
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      this._stopCapping();
    }
  }, {
    key: 'detectPlayerSize',
    value: function detectPlayerSize() {
      if (this.media) {
        var levelsLength = this.levels ? this.levels.length : 0;
        if (levelsLength) {
          var hls = this.hls;
          hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
          if (hls.autoLevelCapping > this.autoLevelCapping) {
            // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
            // usually happen when the user go to the fullscreen mode.
            hls.streamController.nextLevelSwitch();
          }
          this.autoLevelCapping = hls.autoLevelCapping;
        }
      }
    }

    /*
    * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
    */

  }, {
    key: 'getMaxLevel',
    value: function getMaxLevel(capLevelIndex) {
      var _this2 = this;

      if (!this.levels) {
        return -1;
      }

      var validLevels = this.levels.filter(function (level, index) {
        return CapLevelController.isLevelAllowed(index, _this2.restrictedLevels) && index <= capLevelIndex;
      });

      return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
    }
  }, {
    key: '_startCapping',
    value: function _startCapping() {
      if (this.timer) {
        // Don't reset capping if started twice; this can happen if the manifest signals a video codec
        return;
      }
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      this.hls.firstLevel = this.getMaxLevel(this.firstLevel);
      clearInterval(this.timer);
      this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);
      this.detectPlayerSize();
    }
  }, {
    key: '_stopCapping',
    value: function _stopCapping() {
      this.restrictedLevels = [];
      this.firstLevel = null;
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      if (this.timer) {
        this.timer = clearInterval(this.timer);
        this.timer = null;
      }
    }
  }, {
    key: 'mediaWidth',
    get: function get() {
      var width = void 0;
      var media = this.media;
      if (media) {
        width = media.width || media.clientWidth || media.offsetWidth;
        width *= CapLevelController.contentScaleFactor;
      }
      return width;
    }
  }, {
    key: 'mediaHeight',
    get: function get() {
      var height = void 0;
      var media = this.media;
      if (media) {
        height = media.height || media.clientHeight || media.offsetHeight;
        height *= CapLevelController.contentScaleFactor;
      }
      return height;
    }
  }], [{
    key: 'isLevelAllowed',
    value: function isLevelAllowed(level) {
      var restrictedLevels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      return restrictedLevels.indexOf(level) === -1;
    }
  }, {
    key: 'getMaxLevelByMediaSize',
    value: function getMaxLevelByMediaSize(levels, width, height) {
      if (!levels || levels && !levels.length) {
        return -1;
      }

      // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next
      // to determine whether we've chosen the greatest bandwidth for the media's dimensions
      var atGreatestBandiwdth = function atGreatestBandiwdth(curLevel, nextLevel) {
        if (!nextLevel) {
          return true;
        }

        return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
      };

      // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to
      // the max level
      var maxLevelIndex = levels.length - 1;

      for (var i = 0; i < levels.length; i += 1) {
        var level = levels[i];
        if ((level.width >= width || level.height >= height) && atGreatestBandiwdth(level, levels[i + 1])) {
          maxLevelIndex = i;
          break;
        }
      }

      return maxLevelIndex;
    }
  }, {
    key: 'contentScaleFactor',
    get: function get() {
      var pixelRatio = 1;
      try {
        pixelRatio = window.devicePixelRatio;
      } catch (e) {}
      return pixelRatio;
    }
  }]);

  return CapLevelController;
}(_eventHandler2.default);

exports.default = CapLevelController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/eme-controller.js":
/*!*************************************************!*\
  !*** ./src/hls.js/controller/eme-controller.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author Stephan Hesse <disparat@gmail.com> | <tchakabam@gmail.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * DRM support for Hls.js
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _window = window,
    XMLHttpRequest = _window.XMLHttpRequest;


var MAX_LICENSE_REQUEST_FAILURES = 3;

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess
 */
var KeySystems = {
  WIDEVINE: 'com.widevine.alpha',
  PLAYREADY: 'com.microsoft.playready'
};

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration
 * @param {Array<string>} audioCodecs List of required audio codecs to support
 * @param {Array<string>} videoCodecs List of required video codecs to support
 * @param {object} drmSystemOptions Optional parameters/requirements for the key-system
 * @returns {Array<MediaSystemConfiguration>} An array of supported configurations
 */

var createWidevineMediaKeySystemConfigurations = function createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs, drmSystemOptions) {
  /* jshint ignore:line */
  var baseConfig = {
    // initDataTypes: ['keyids', 'mp4'],
    // label: "",
    // persistentState: "not-allowed", // or "required" ?
    // distinctiveIdentifier: "not-allowed", // or "required" ?
    // sessionTypes: ['temporary'],
    videoCapabilities: [
      // { contentType: 'video/mp4; codecs="avc1.42E01E"' }
    ]
  };

  videoCodecs.forEach(function (codec) {
    baseConfig.videoCapabilities.push({
      contentType: 'video/mp4; codecs="' + codec + '"'
    });
  });

  return [baseConfig];
};

/**
 * The idea here is to handle key-system (and their respective platforms) specific configuration differences
 * in order to work with the local requestMediaKeySystemAccess method.
 *
 * We can also rule-out platform-related key-system support at this point by throwing an error or returning null.
 *
 * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
 * @param {Array<string>} audioCodecs List of required audio codecs to support
 * @param {Array<string>} videoCodecs List of required video codecs to support
 * @returns {Array<MediaSystemConfiguration> | null} A non-empty Array of MediaKeySystemConfiguration objects or `null`
 */
var getSupportedMediaKeySystemConfigurations = function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs) {
  switch (keySystem) {
    case KeySystems.WIDEVINE:
      return createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs);
    default:
      throw Error('Unknown key-system: ' + keySystem);
  }
};

/**
 * Controller to deal with encrypted media extensions (EME)
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API
 *
 * @class
 * @constructor
 */

var EMEController = function (_EventHandler) {
  _inherits(EMEController, _EventHandler);

  /**
     * @constructs
     * @param {Hls} hls Our Hls.js instance
     */
  function EMEController(hls) {
    _classCallCheck(this, EMEController);

    var _this = _possibleConstructorReturn(this, (EMEController.__proto__ || Object.getPrototypeOf(EMEController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MANIFEST_PARSED));

    _this._widevineLicenseUrl = hls.config.widevineLicenseUrl;
    _this._licenseXhrSetup = hls.config.licenseXhrSetup;
    _this._emeEnabled = hls.config.emeEnabled;

    _this._requestMediaKeySystemAccess = hls.config.requestMediaKeySystemAccessFunc;

    _this._mediaKeysList = [];
    _this._media = null;

    _this._hasSetMediaKeys = false;
    _this._isMediaEncrypted = false;

    _this._requestLicenseFailureCount = 0;
    return _this;
  }

  /**
     *
     * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
     * @returns {string} License server URL for key-system (if any configured, otherwise causes error)
     */


  _createClass(EMEController, [{
    key: 'getLicenseServerUrl',
    value: function getLicenseServerUrl(keySystem) {
      var url = void 0;
      switch (keySystem) {
        case KeySystems.WIDEVINE:
          url = this._widevineLicenseUrl;
          break;
        default:
          url = null;
          break;
      }

      if (!url) {
        _logger.logger.error('No license server URL configured for key-system "' + keySystem + '"');
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
          fatal: true
        });
      }

      return url;
    }

    /**
       * Requests access object and adds it to our list upon success
       * @private
       * @param {string} keySystem System ID (see `KeySystems`)
       * @param {Array<string>} audioCodecs List of required audio codecs to support
       * @param {Array<string>} videoCodecs List of required video codecs to support
       */

  }, {
    key: '_attemptKeySystemAccess',
    value: function _attemptKeySystemAccess(keySystem, audioCodecs, videoCodecs) {
      var _this2 = this;

      // TODO: add other DRM "options"

      var mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs);

      if (!mediaKeySystemConfigs) {
        _logger.logger.warn('Can not create config for key-system (maybe because platform is not supported):', keySystem);
        return;
      }

      _logger.logger.log('Requesting encrypted media key-system access');

      // expecting interface like window.navigator.requestMediaKeySystemAccess
      this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs).then(function (mediaKeySystemAccess) {
        _this2._onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess);
      }).catch(function (err) {
        _logger.logger.error('Failed to obtain key-system "' + keySystem + '" access:', err);
      });
    }
  }, {
    key: '_onMediaKeySystemAccessObtained',


    /**
       * Handles obtaining access to a key-system
       *
       * @param {string} keySystem
       * @param {MediaKeySystemAccess} mediaKeySystemAccess https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemAccess
       */
    value: function _onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess) {
      var _this3 = this;

      _logger.logger.log('Access for key-system "' + keySystem + '" obtained');

      var mediaKeysListItem = {
        mediaKeys: null,
        mediaKeysSession: null,
        mediaKeysSessionInitialized: false,
        mediaKeySystemAccess: mediaKeySystemAccess,
        mediaKeySystemDomain: keySystem
      };

      this._mediaKeysList.push(mediaKeysListItem);

      mediaKeySystemAccess.createMediaKeys().then(function (mediaKeys) {
        mediaKeysListItem.mediaKeys = mediaKeys;

        _logger.logger.log('Media-keys created for key-system "' + keySystem + '"');

        _this3._onMediaKeysCreated();
      }).catch(function (err) {
        _logger.logger.error('Failed to create media-keys:', err);
      });
    }

    /**
       * Handles key-creation (represents access to CDM). We are going to create key-sessions upon this
       * for all existing keys where no session exists yet.
       */

  }, {
    key: '_onMediaKeysCreated',
    value: function _onMediaKeysCreated() {
      var _this4 = this;

      // check for all key-list items if a session exists, otherwise, create one
      this._mediaKeysList.forEach(function (mediaKeysListItem) {
        if (!mediaKeysListItem.mediaKeysSession) {
          mediaKeysListItem.mediaKeysSession = mediaKeysListItem.mediaKeys.createSession();
          _this4._onNewMediaKeySession(mediaKeysListItem.mediaKeysSession);
        }
      });
    }

    /**
       *
       * @param {*} keySession
       */

  }, {
    key: '_onNewMediaKeySession',
    value: function _onNewMediaKeySession(keySession) {
      var _this5 = this;

      _logger.logger.log('New key-system session ' + keySession.sessionId);

      keySession.addEventListener('message', function (event) {
        _this5._onKeySessionMessage(keySession, event.message);
      }, false);
    }
  }, {
    key: '_onKeySessionMessage',
    value: function _onKeySessionMessage(keySession, message) {
      _logger.logger.log('Got EME message event, creating license request');

      this._requestLicense(message, function (data) {
        _logger.logger.log('Received license data, updating key-session');
        keySession.update(data);
      });
    }
  }, {
    key: '_onMediaEncrypted',
    value: function _onMediaEncrypted(initDataType, initData) {
      _logger.logger.log('Media is encrypted using "' + initDataType + '" init data type');

      this._isMediaEncrypted = true;
      this._mediaEncryptionInitDataType = initDataType;
      this._mediaEncryptionInitData = initData;

      this._attemptSetMediaKeys();
      this._generateRequestWithPreferredKeySession();
    }
  }, {
    key: '_attemptSetMediaKeys',
    value: function _attemptSetMediaKeys() {
      if (!this._hasSetMediaKeys) {
        // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
        var keysListItem = this._mediaKeysList[0];
        if (!keysListItem || !keysListItem.mediaKeys) {
          _logger.logger.error('Fatal: Media is encrypted but no CDM access or no keys have been obtained yet');
          this.hls.trigger(_events2.default.ERROR, {
            type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
            details: _errors.ErrorDetails.KEY_SYSTEM_NO_KEYS,
            fatal: true
          });
          return;
        }

        _logger.logger.log('Setting keys for encrypted media');

        this._media.setMediaKeys(keysListItem.mediaKeys);
        this._hasSetMediaKeys = true;
      }
    }
  }, {
    key: '_generateRequestWithPreferredKeySession',
    value: function _generateRequestWithPreferredKeySession() {
      var _this6 = this;

      // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
      var keysListItem = this._mediaKeysList[0];
      if (!keysListItem) {
        _logger.logger.error('Fatal: Media is encrypted but not any key-system access has been obtained yet');
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
          fatal: true
        });
        return;
      }

      if (keysListItem.mediaKeysSessionInitialized) {
        _logger.logger.warn('Key-Session already initialized but requested again');
        return;
      }

      var keySession = keysListItem.mediaKeysSession;
      if (!keySession) {
        _logger.logger.error('Fatal: Media is encrypted but no key-session existing');
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_NO_SESSION,
          fatal: true
        });
      }

      var initDataType = this._mediaEncryptionInitDataType;
      var initData = this._mediaEncryptionInitData;

      _logger.logger.log('Generating key-session request for "' + initDataType + '" init data type');

      keysListItem.mediaKeysSessionInitialized = true;

      keySession.generateRequest(initDataType, initData).then(function () {
        _logger.logger.debug('Key-session generation succeeded');
      }).catch(function (err) {
        _logger.logger.error('Error generating key-session request:', err);
        _this6.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_NO_SESSION,
          fatal: false
        });
      });
    }

    /**
       * @param {string} url License server URL
       * @param {ArrayBuffer} keyMessage Message data issued by key-system
       * @param {function} callback Called when XHR has succeeded
       * @returns {XMLHttpRequest} Unsent (but opened state) XHR object
       */

  }, {
    key: '_createLicenseXhr',
    value: function _createLicenseXhr(url, keyMessage, callback) {
      var xhr = new XMLHttpRequest();
      var licenseXhrSetup = this._licenseXhrSetup;

      try {
        if (licenseXhrSetup) {
          try {
            licenseXhrSetup(xhr, url);
          } catch (e) {
            // let's try to open before running setup
            xhr.open('POST', url, true);
            licenseXhrSetup(xhr, url);
          }
        }
        // if licenseXhrSetup did not yet call open, let's do it now
        if (!xhr.readyState) {
          xhr.open('POST', url, true);
        }
      } catch (e) {
        // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
        _logger.logger.error('Error setting up key-system license XHR', e);
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
          fatal: true
        });
        return;
      }

      xhr.responseType = 'arraybuffer';
      xhr.onreadystatechange = this._onLicenseRequestReadyStageChange.bind(this, xhr, url, keyMessage, callback);
      return xhr;
    }

    /**
       * @param {XMLHttpRequest} xhr
       * @param {string} url License server URL
       * @param {ArrayBuffer} keyMessage Message data issued by key-system
       * @param {function} callback Called when XHR has succeeded
       *
       */

  }, {
    key: '_onLicenseRequestReadyStageChange',
    value: function _onLicenseRequestReadyStageChange(xhr, url, keyMessage, callback) {
      switch (xhr.readyState) {
        case 4:
          if (xhr.status === 200) {
            this._requestLicenseFailureCount = 0;
            _logger.logger.log('License request succeeded');
            callback(xhr.response);
          } else {
            _logger.logger.error('License Request XHR failed (' + url + '). Status: ' + xhr.status + ' (' + xhr.statusText + ')');

            this._requestLicenseFailureCount++;
            if (this._requestLicenseFailureCount <= MAX_LICENSE_REQUEST_FAILURES) {
              var attemptsLeft = MAX_LICENSE_REQUEST_FAILURES - this._requestLicenseFailureCount + 1;
              _logger.logger.warn('Retrying license request, ' + attemptsLeft + ' attempts left');
              this._requestLicense(keyMessage, callback);
              return;
            }

            this.hls.trigger(_events2.default.ERROR, {
              type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
              details: _errors.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
              fatal: true
            });
          }
          break;
      }
    }

    /**
       * @param {object} keysListItem
       * @param {ArrayBuffer} keyMessage
       * @returns {ArrayBuffer} Challenge data posted to license server
       */

  }, {
    key: '_generateLicenseRequestChallenge',
    value: function _generateLicenseRequestChallenge(keysListItem, keyMessage) {
      var challenge = void 0;

      if (keysListItem.mediaKeySystemDomain === KeySystems.PLAYREADY) {
        _logger.logger.error('PlayReady is not supported (yet)');

        // from https://github.com/MicrosoftEdge/Demos/blob/master/eme/scripts/demo.js
        /*
          if (this.licenseType !== this.LICENSE_TYPE_WIDEVINE) {
              // For PlayReady CDMs, we need to dig the Challenge out of the XML.
              var keyMessageXml = new DOMParser().parseFromString(String.fromCharCode.apply(null, new Uint16Array(keyMessage)), 'application/xml');
              if (keyMessageXml.getElementsByTagName('Challenge')[0]) {
                  challenge = atob(keyMessageXml.getElementsByTagName('Challenge')[0].childNodes[0].nodeValue);
              } else {
                  throw 'Cannot find <Challenge> in key message';
              }
              var headerNames = keyMessageXml.getElementsByTagName('name');
              var headerValues = keyMessageXml.getElementsByTagName('value');
              if (headerNames.length !== headerValues.length) {
                  throw 'Mismatched header <name>/<value> pair in key message';
              }
              for (var i = 0; i < headerNames.length; i++) {
                  xhr.setRequestHeader(headerNames[i].childNodes[0].nodeValue, headerValues[i].childNodes[0].nodeValue);
              }
          }
          */
      } else if (keysListItem.mediaKeySystemDomain === KeySystems.WIDEVINE) {
        // For Widevine CDMs, the challenge is the keyMessage.
        challenge = keyMessage;
      } else {
        _logger.logger.error('Unsupported key-system:', keysListItem.mediaKeySystemDomain);
      }

      return challenge;
    }
  }, {
    key: '_requestLicense',
    value: function _requestLicense(keyMessage, callback) {
      _logger.logger.log('Requesting content license for key-system');

      var keysListItem = this._mediaKeysList[0];
      if (!keysListItem) {
        _logger.logger.error('Fatal error: Media is encrypted but no key-system access has been obtained yet');
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
          fatal: true
        });
        return;
      }

      var url = this.getLicenseServerUrl(keysListItem.mediaKeySystemDomain);
      var xhr = this._createLicenseXhr(url, keyMessage, callback);

      _logger.logger.log('Sending license request to URL: ' + url);

      xhr.send(this._generateLicenseRequestChallenge(keysListItem, keyMessage));
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var _this7 = this;

      if (!this._emeEnabled) {
        return;
      }

      var media = data.media;

      // keep reference of media
      this._media = media;

      // FIXME: also handle detaching media !

      media.addEventListener('encrypted', function (e) {
        _this7._onMediaEncrypted(e.initDataType, e.initData);
      });
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      if (!this._emeEnabled) {
        return;
      }

      var audioCodecs = data.levels.map(function (level) {
        return level.audioCodec;
      });
      var videoCodecs = data.levels.map(function (level) {
        return level.videoCodec;
      });

      this._attemptKeySystemAccess(KeySystems.WIDEVINE, audioCodecs, videoCodecs);
    }
  }, {
    key: 'requestMediaKeySystemAccess',
    get: function get() {
      if (!this._requestMediaKeySystemAccess) {
        throw new Error('No requestMediaKeySystemAccess function configured');
      }

      return this._requestMediaKeySystemAccess;
    }
  }]);

  return EMEController;
}(_eventHandler2.default);

exports.default = EMEController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/fps-controller.js":
/*!*************************************************!*\
  !*** ./src/hls.js/controller/fps-controller.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FPS Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var _window = window,
    performance = _window.performance;

var FPSController = function (_EventHandler) {
  _inherits(FPSController, _EventHandler);

  function FPSController(hls) {
    _classCallCheck(this, FPSController);

    return _possibleConstructorReturn(this, (FPSController.__proto__ || Object.getPrototypeOf(FPSController)).call(this, hls, _events2.default.MEDIA_ATTACHING));
  }

  _createClass(FPSController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearInterval(this.timer);
      }

      this.isVideoPlaybackQualityAvailable = false;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var config = this.hls.config;
      if (config.capLevelOnFPSDrop) {
        var video = this.video = data.media instanceof window.HTMLVideoElement ? data.media : null;
        if (typeof video.getVideoPlaybackQuality === 'function') {
          this.isVideoPlaybackQualityAvailable = true;
        }

        clearInterval(this.timer);
        this.timer = setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
      }
    }
  }, {
    key: 'checkFPS',
    value: function checkFPS(video, decodedFrames, droppedFrames) {
      var currentTime = performance.now();
      if (decodedFrames) {
        if (this.lastTime) {
          var currentPeriod = currentTime - this.lastTime,
              currentDropped = droppedFrames - this.lastDroppedFrames,
              currentDecoded = decodedFrames - this.lastDecodedFrames,
              droppedFPS = 1000 * currentDropped / currentPeriod,
              hls = this.hls;
          hls.trigger(_events2.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
          if (droppedFPS > 0) {
            // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
            if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
              var currentLevel = hls.currentLevel;
              _logger.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
              if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
                currentLevel = currentLevel - 1;
                hls.trigger(_events2.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: hls.currentLevel });
                hls.autoLevelCapping = currentLevel;
                hls.streamController.nextLevelSwitch();
              }
            }
          }
        }
        this.lastTime = currentTime;
        this.lastDroppedFrames = droppedFrames;
        this.lastDecodedFrames = decodedFrames;
      }
    }
  }, {
    key: 'checkFPSInterval',
    value: function checkFPSInterval() {
      var video = this.video;
      if (video) {
        if (this.isVideoPlaybackQualityAvailable) {
          var videoPlaybackQuality = video.getVideoPlaybackQuality();
          this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
        } else {
          this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
        }
      }
    }
  }]);

  return FPSController;
}(_eventHandler2.default);

exports.default = FPSController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/fragment-finders.js":
/*!***************************************************!*\
  !*** ./src/hls.js/controller/fragment-finders.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findFragmentByPDT = findFragmentByPDT;
exports.findFragmentByPTS = findFragmentByPTS;
exports.fragmentWithinToleranceTest = fragmentWithinToleranceTest;
exports.pdtWithinToleranceTest = pdtWithinToleranceTest;

var _binarySearch = __webpack_require__(/*! ../utils/binary-search */ "./src/hls.js/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns first fragment whose endPdt value exceeds the given PDT.
 * @param {Array<Fragment>} fragments - The array of candidate fragments
 * @param {number|null} [PDTValue = null] - The PDT value which must be exceeded
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start/end can be within in order to be considered contiguous
 * @returns {*|null} fragment - The best matching fragment
 */
function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
  if (!Array.isArray(fragments) || !fragments.length || !Number.isFinite(PDTValue)) {
    return null;
  }

  // if less than start
  if (PDTValue < fragments[0].programDateTime) {
    return null;
  }

  if (PDTValue >= fragments[fragments.length - 1].endProgramDateTime) {
    return null;
  }

  maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
  for (var seg = 0; seg < fragments.length; ++seg) {
    var frag = fragments[seg];
    if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
      return frag;
    }
  }

  return null;
}

/**
 * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.
 * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus
 * breaking any traps which would cause the same fragment to be continuously selected within a small range.
 * @param {*} fragPrevious - The last frag successfully appended
 * @param {Array<Fragment>} fragments - The array of candidate fragments
 * @param {number} [bufferEnd = 0] - The end of the contiguous buffered range the playhead is currently within
 * @param {number} maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous
 * @returns {*} foundFrag - The best matching fragment
 */
function findFragmentByPTS(fragPrevious, fragments) {
  var bufferEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var maxFragLookUpTolerance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : null;
  // Prefer the next fragment if it's within tolerance
  if (fragNext && !fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext)) {
    return fragNext;
  }
  return _binarySearch2.default.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
}

/**
 * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.
 * @param {*} candidate - The fragment to test
 * @param {number} [bufferEnd = 0] - The end of the current buffered range the playhead is currently within
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous
 * @returns {number} - 0 if it matches, 1 if too low, -1 if too high
 */
function fragmentWithinToleranceTest() {
  var bufferEnd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var maxFragLookUpTolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var candidate = arguments[2];

  // offset should be within fragment boundary - config.maxFragLookUpTolerance
  // this is to cope with situations like
  // bufferEnd = 9.991
  // frag[] : [0,10]
  // frag[1] : [10,20]
  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
  //              frag start               frag start+duration
  //                  |-----------------------------|
  //              <--->                         <--->
  //  ...--------><-----------------------------><---------....
  // previous frag         matching fragment         next frag
  //  return -1             return 0                 return 1
  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
    return 1;
  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
    return -1;
  }

  return 0;
}

/**
 * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.
 * This function tests the candidate's program date time values, as represented in Unix time
 * @param {*} candidate - The fragment to test
 * @param {number} [pdtBufferEnd = 0] - The Unix time representing the end of the current buffered range
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous
 * @returns {boolean} True if contiguous, false otherwise
 */
function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;
  return candidate.endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
}

/***/ }),

/***/ "./src/hls.js/controller/fragment-tracker.js":
/*!***************************************************!*\
  !*** ./src/hls.js/controller/fragment-tracker.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FragmentTracker = exports.FragmentState = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FragmentState = exports.FragmentState = {
  NOT_LOADED: 'NOT_LOADED',
  APPENDING: 'APPENDING',
  PARTIAL: 'PARTIAL',
  OK: 'OK'
};

var FragmentTracker = exports.FragmentTracker = function (_EventHandler) {
  _inherits(FragmentTracker, _EventHandler);

  function FragmentTracker(hls) {
    _classCallCheck(this, FragmentTracker);

    var _this = _possibleConstructorReturn(this, (FragmentTracker.__proto__ || Object.getPrototypeOf(FragmentTracker)).call(this, hls, _events2.default.BUFFER_APPENDED, _events2.default.FRAG_BUFFERED, _events2.default.FRAG_LOADED));

    _this.bufferPadding = 0.2;

    _this.fragments = Object.create(null);
    _this.timeRanges = Object.create(null);

    _this.config = hls.config;
    return _this;
  }

  _createClass(FragmentTracker, [{
    key: 'destroy',
    value: function destroy() {
      this.fragments = Object.create(null);
      this.timeRanges = Object.create(null);
      this.config = null;
      _eventHandler2.default.prototype.destroy.call(this);
      _get(FragmentTracker.prototype.__proto__ || Object.getPrototypeOf(FragmentTracker.prototype), 'destroy', this).call(this);
    }

    /**
     * Return a Fragment that match the position and levelType.
     * If not found any Fragment, return null
     * @param {number} position
     * @param {LevelType} levelType
     * @returns {Fragment|null}
     */

  }, {
    key: 'getBufferedFrag',
    value: function getBufferedFrag(position, levelType) {
      var fragments = this.fragments;
      var bufferedFrags = Object.keys(fragments).filter(function (key) {
        var fragmentEntity = fragments[key];
        if (fragmentEntity.body.type !== levelType) {
          return false;
        }

        if (!fragmentEntity.buffered) {
          return false;
        }

        var frag = fragmentEntity.body;
        return frag.startPTS <= position && position <= frag.endPTS;
      });
      if (bufferedFrags.length === 0) {
        return null;
      } else {
        // https://github.com/video-dev/hls.js/pull/1545#discussion_r166229566
        var bufferedFragKey = bufferedFrags.pop();
        return fragments[bufferedFragKey].body;
      }
    }

    /**
     * Partial fragments effected by coded frame eviction will be removed
     * The browser will unload parts of the buffer to free up memory for new buffer data
     * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
     * @param {String} elementaryStream The elementaryStream of media this is (eg. video/audio)
     * @param {TimeRanges} timeRange TimeRange object from a sourceBuffer
     */

  }, {
    key: 'detectEvictedFragments',
    value: function detectEvictedFragments(elementaryStream, timeRange) {
      var _this2 = this;

      var fragmentTimes = void 0,
          time = void 0;
      // Check if any flagged fragments have been unloaded
      Object.keys(this.fragments).forEach(function (key) {
        var fragmentEntity = _this2.fragments[key];
        if (fragmentEntity.buffered === true) {
          var esData = fragmentEntity.range[elementaryStream];
          if (esData) {
            fragmentTimes = esData.time;
            for (var i = 0; i < fragmentTimes.length; i++) {
              time = fragmentTimes[i];

              if (_this2.isTimeBuffered(time.startPTS, time.endPTS, timeRange) === false) {
                // Unregister partial fragment as it needs to load again to be reused
                _this2.removeFragment(fragmentEntity.body);
                break;
              }
            }
          }
        }
      });
    }

    /**
     * Checks if the fragment passed in is loaded in the buffer properly
     * Partially loaded fragments will be registered as a partial fragment
     * @param {Object} fragment Check the fragment against all sourceBuffers loaded
     */

  }, {
    key: 'detectPartialFragments',
    value: function detectPartialFragments(fragment) {
      var _this3 = this;

      var fragKey = this.getFragmentKey(fragment);
      var fragmentEntity = this.fragments[fragKey];
      if (fragmentEntity) {
        fragmentEntity.buffered = true;

        Object.keys(this.timeRanges).forEach(function (elementaryStream) {
          if (fragment.hasElementaryStream(elementaryStream)) {
            var timeRange = _this3.timeRanges[elementaryStream];
            // Check for malformed fragments
            // Gaps need to be calculated for each elementaryStream
            fragmentEntity.range[elementaryStream] = _this3.getBufferedTimes(fragment.startPTS, fragment.endPTS, timeRange);
          }
        });
      }
    }
  }, {
    key: 'getBufferedTimes',
    value: function getBufferedTimes(startPTS, endPTS, timeRange) {
      var fragmentTimes = [];
      var startTime = void 0,
          endTime = void 0;
      var fragmentPartial = false;
      for (var i = 0; i < timeRange.length; i++) {
        startTime = timeRange.start(i) - this.bufferPadding;
        endTime = timeRange.end(i) + this.bufferPadding;
        if (startPTS >= startTime && endPTS <= endTime) {
          // Fragment is entirely contained in buffer
          // No need to check the other timeRange times since it's completely playable
          fragmentTimes.push({
            startPTS: Math.max(startPTS, timeRange.start(i)),
            endPTS: Math.min(endPTS, timeRange.end(i))
          });
          break;
        } else if (startPTS < endTime && endPTS > startTime) {
          // Check for intersection with buffer
          // Get playable sections of the fragment
          fragmentTimes.push({
            startPTS: Math.max(startPTS, timeRange.start(i)),
            endPTS: Math.min(endPTS, timeRange.end(i))
          });
          fragmentPartial = true;
        } else if (endPTS <= startTime) {
          // No need to check the rest of the timeRange as it is in order
          break;
        }
      }

      return {
        time: fragmentTimes,
        partial: fragmentPartial
      };
    }
  }, {
    key: 'getFragmentKey',
    value: function getFragmentKey(fragment) {
      return fragment.type + '_' + fragment.level + '_' + fragment.urlId + '_' + fragment.sn;
    }

    /**
     * Gets the partial fragment for a certain time
     * @param {Number} time
     * @returns {Object} fragment Returns a partial fragment at a time or null if there is no partial fragment
     */

  }, {
    key: 'getPartialFragment',
    value: function getPartialFragment(time) {
      var _this4 = this;

      var timePadding = void 0,
          startTime = void 0,
          endTime = void 0;
      var bestFragment = null;
      var bestOverlap = 0;
      Object.keys(this.fragments).forEach(function (key) {
        var fragmentEntity = _this4.fragments[key];
        if (_this4.isPartial(fragmentEntity)) {
          startTime = fragmentEntity.body.startPTS - _this4.bufferPadding;
          endTime = fragmentEntity.body.endPTS + _this4.bufferPadding;
          if (time >= startTime && time <= endTime) {
            // Use the fragment that has the most padding from start and end time
            timePadding = Math.min(time - startTime, endTime - time);
            if (bestOverlap <= timePadding) {
              bestFragment = fragmentEntity.body;
              bestOverlap = timePadding;
            }
          }
        }
      });
      return bestFragment;
    }

    /**
     * @param {Object} fragment The fragment to check
     * @returns {String} Returns the fragment state when a fragment never loaded or if it partially loaded
     */

  }, {
    key: 'getState',
    value: function getState(fragment) {
      var fragKey = this.getFragmentKey(fragment);
      var fragmentEntity = this.fragments[fragKey];
      var state = FragmentState.NOT_LOADED;

      if (fragmentEntity !== undefined) {
        if (!fragmentEntity.buffered) {
          state = FragmentState.APPENDING;
        } else if (this.isPartial(fragmentEntity) === true) {
          state = FragmentState.PARTIAL;
        } else {
          state = FragmentState.OK;
        }
      }

      return state;
    }
  }, {
    key: 'isPartial',
    value: function isPartial(fragmentEntity) {
      return fragmentEntity.buffered === true && (fragmentEntity.range.video !== undefined && fragmentEntity.range.video.partial === true || fragmentEntity.range.audio !== undefined && fragmentEntity.range.audio.partial === true);
    }
  }, {
    key: 'isTimeBuffered',
    value: function isTimeBuffered(startPTS, endPTS, timeRange) {
      var startTime = void 0,
          endTime = void 0;
      for (var i = 0; i < timeRange.length; i++) {
        startTime = timeRange.start(i) - this.bufferPadding;
        endTime = timeRange.end(i) + this.bufferPadding;
        if (startPTS >= startTime && endPTS <= endTime) {
          return true;
        }

        if (endPTS <= startTime) {
          // No need to check the rest of the timeRange as it is in order
          return false;
        }
      }

      return false;
    }

    /**
     * Fires when a fragment loading is completed
     */

  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(e) {
      var fragment = e.frag;
      // don't track initsegment (for which sn is not a number)
      // don't track frags used for bitrateTest, they're irrelevant.
      if (!Number.isFinite(fragment.sn) || fragment.bitrateTest) {
        return;
      }

      this.fragments[this.getFragmentKey(fragment)] = {
        body: fragment,
        range: Object.create(null),
        buffered: false
      };
    }

    /**
     * Fires when the buffer is updated
     */

  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(e) {
      var _this5 = this;

      // Store the latest timeRanges loaded in the buffer
      this.timeRanges = e.timeRanges;
      Object.keys(this.timeRanges).forEach(function (elementaryStream) {
        var timeRange = _this5.timeRanges[elementaryStream];
        _this5.detectEvictedFragments(elementaryStream, timeRange);
      });
    }

    /**
     * Fires after a fragment has been loaded into the source buffer
     */

  }, {
    key: 'onFragBuffered',
    value: function onFragBuffered(e) {
      this.detectPartialFragments(e.frag);
    }

    /**
     * Return true if fragment tracker has the fragment.
     * @param {Object} fragment
     * @returns {boolean}
     */

  }, {
    key: 'hasFragment',
    value: function hasFragment(fragment) {
      var fragKey = this.getFragmentKey(fragment);
      return this.fragments[fragKey] !== undefined;
    }

    /**
     * Remove a fragment from fragment tracker until it is loaded again
     * @param {Object} fragment The fragment to remove
     */

  }, {
    key: 'removeFragment',
    value: function removeFragment(fragment) {
      var fragKey = this.getFragmentKey(fragment);
      delete this.fragments[fragKey];
    }

    /**
     * Remove all fragments from fragment tracker.
     */

  }, {
    key: 'removeAllFragments',
    value: function removeAllFragments() {
      this.fragments = Object.create(null);
    }
  }]);

  return FragmentTracker;
}(_eventHandler2.default);

/***/ }),

/***/ "./src/hls.js/controller/gap-controller.js":
/*!*************************************************!*\
  !*** ./src/hls.js/controller/gap-controller.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var stallDebounceInterval = 1000;
var jumpThreshold = 0.5; // tolerance needed as some browsers stalls playback before reaching buffered range end

var GapController = function () {
  function GapController(config, media, fragmentTracker, hls) {
    _classCallCheck(this, GapController);

    this.config = config;
    this.media = media;
    this.fragmentTracker = fragmentTracker;
    this.hls = hls;
    this.stallReported = false;
  }

  /**
   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.
   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).
   * @param lastCurrentTime
   * @param buffered
   */


  _createClass(GapController, [{
    key: 'poll',
    value: function poll(lastCurrentTime, buffered) {
      var config = this.config,
          media = this.media;

      var currentTime = media.currentTime;
      var tnow = window.performance.now();

      if (currentTime !== lastCurrentTime) {
        // The playhead is now moving, but was previously stalled
        if (this.stallReported) {
          _logger.logger.warn('playback not stuck anymore @' + currentTime + ', after ' + Math.round(tnow - this.stalled) + 'ms');
          this.stallReported = false;
        }
        this.stalled = null;
        this.nudgeRetry = 0;
        return;
      }

      if (media.ended || !media.buffered.length || media.readyState > 2) {
        return;
      }

      if (media.seeking && _bufferHelper.BufferHelper.isBuffered(media, currentTime)) {
        return;
      }

      // The playhead isn't moving but it should be
      // Allow some slack time to for small stalls to resolve themselves
      var stalledDuration = tnow - this.stalled;
      var bufferInfo = _bufferHelper.BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);
      if (!this.stalled) {
        this.stalled = tnow;
        return;
      } else if (stalledDuration >= stallDebounceInterval) {
        // Report stalling after trying to fix
        this._reportStall(bufferInfo.len);
      }

      this._tryFixBufferStall(bufferInfo, stalledDuration);
    }

    /**
     * Detects and attempts to fix known buffer stalling issues.
     * @param bufferInfo - The properties of the current buffer.
     * @param stalledDuration - The amount of time Hls.js has been stalling for.
     * @private
     */

  }, {
    key: '_tryFixBufferStall',
    value: function _tryFixBufferStall(bufferInfo, stalledDuration) {
      var config = this.config,
          fragmentTracker = this.fragmentTracker,
          media = this.media;

      var currentTime = media.currentTime;

      var partial = fragmentTracker.getPartialFragment(currentTime);
      if (partial) {
        // Try to skip over the buffer hole caused by a partial fragment
        // This method isn't limited by the size of the gap between buffered ranges
        this._trySkipBufferHole(partial);
      }

      if (bufferInfo.len > jumpThreshold && stalledDuration > config.highBufferWatchdogPeriod * 1000) {
        // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds
        // We only try to jump the hole if it's under the configured size
        // Reset stalled so to rearm watchdog timer
        this.stalled = null;
        this._tryNudgeBuffer();
      }
    }

    /**
     * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.
     * @param bufferLen - The playhead distance from the end of the current buffer segment.
     * @private
     */

  }, {
    key: '_reportStall',
    value: function _reportStall(bufferLen) {
      var hls = this.hls,
          media = this.media,
          stallReported = this.stallReported;

      if (!stallReported) {
        // Report stalled error once
        this.stallReported = true;
        _logger.logger.warn('Playback stalling at @' + media.currentTime + ' due to low buffer');
        hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.BUFFER_STALLED_ERROR,
          fatal: false,
          buffer: bufferLen
        });
      }
    }

    /**
     * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments
     * @param partial - The partial fragment found at the current time (where playback is stalling).
     * @private
     */

  }, {
    key: '_trySkipBufferHole',
    value: function _trySkipBufferHole(partial) {
      var hls = this.hls,
          media = this.media;

      var currentTime = media.currentTime;
      var lastEndTime = 0;
      // Check if currentTime is between unbuffered regions of partial fragments
      for (var i = 0; i < media.buffered.length; i++) {
        var startTime = media.buffered.start(i);
        if (currentTime >= lastEndTime && currentTime < startTime) {
          media.currentTime = Math.max(startTime, media.currentTime + 0.1);
          _logger.logger.warn('skipping hole, adjusting currentTime from ' + currentTime + ' to ' + media.currentTime);
          this.stalled = null;
          hls.trigger(_events2.default.ERROR, {
            type: _errors.ErrorTypes.MEDIA_ERROR,
            details: _errors.ErrorDetails.BUFFER_SEEK_OVER_HOLE,
            fatal: false,
            reason: 'fragment loaded with buffer holes, seeking from ' + currentTime + ' to ' + media.currentTime,
            frag: partial
          });
          return;
        }
        lastEndTime = media.buffered.end(i);
      }
    }

    /**
     * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.
     * @private
     */

  }, {
    key: '_tryNudgeBuffer',
    value: function _tryNudgeBuffer() {
      var config = this.config,
          hls = this.hls,
          media = this.media;

      var currentTime = media.currentTime;
      var nudgeRetry = (this.nudgeRetry || 0) + 1;
      this.nudgeRetry = nudgeRetry;

      if (nudgeRetry < config.nudgeMaxRetry) {
        var targetTime = currentTime + nudgeRetry * config.nudgeOffset;
        _logger.logger.log('adjust currentTime from ' + currentTime + ' to ' + targetTime);
        // playback stalled in buffered area ... let's nudge currentTime to try to overcome this
        media.currentTime = targetTime;
        hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.BUFFER_NUDGE_ON_STALL,
          fatal: false
        });
      } else {
        _logger.logger.error('still stuck in high buffer @' + currentTime + ' after ' + config.nudgeMaxRetry + ', raise fatal error');
        hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.BUFFER_STALLED_ERROR,
          fatal: true
        });
      }
    }
  }]);

  return GapController;
}();

exports.default = GapController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/id3-track-controller.js":
/*!*******************************************************!*\
  !*** ./src/hls.js/controller/id3-track-controller.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _id = __webpack_require__(/*! ../demux/id3 */ "./src/hls.js/demux/id3.js");

var _id2 = _interopRequireDefault(_id);

var _texttrackUtils = __webpack_require__(/*! ../utils/texttrack-utils */ "./src/hls.js/utils/texttrack-utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * id3 metadata track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var ID3TrackController = function (_EventHandler) {
  _inherits(ID3TrackController, _EventHandler);

  function ID3TrackController(hls) {
    _classCallCheck(this, ID3TrackController);

    var _this = _possibleConstructorReturn(this, (ID3TrackController.__proto__ || Object.getPrototypeOf(ID3TrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_METADATA));

    _this.id3Track = undefined;
    _this.media = undefined;
    return _this;
  }

  _createClass(ID3TrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Add ID3 metatadata text track.

  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      this.media = data.media;
      if (!this.media) {}
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      (0, _texttrackUtils.clearCurrentCues)(this.id3Track);
      this.id3Track = undefined;
      this.media = undefined;
    }
  }, {
    key: 'getID3Track',
    value: function getID3Track(textTracks) {
      for (var i = 0; i < textTracks.length; i++) {
        var textTrack = textTracks[i];
        if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {
          // send 'addtrack' when reusing the textTrack for metadata,
          // same as what we do for captions
          (0, _texttrackUtils.sendAddTrackEvent)(textTrack, this.media);

          return textTrack;
        }
      }
      return this.media.addTextTrack('metadata', 'id3');
    }
  }, {
    key: 'onFragParsingMetadata',
    value: function onFragParsingMetadata(data) {
      var fragment = data.frag;
      var samples = data.samples;

      // create track dynamically
      if (!this.id3Track) {
        this.id3Track = this.getID3Track(this.media.textTracks);
        this.id3Track.mode = 'hidden';
      }

      // Attempt to recreate Safari functionality by creating
      // WebKitDataCue objects when available and store the decoded
      // ID3 data in the value property of the cue
      var Cue = window.WebKitDataCue || window.VTTCue || window.TextTrackCue;

      for (var i = 0; i < samples.length; i++) {
        var frames = _id2.default.getID3Frames(samples[i].data);
        if (frames) {
          var startTime = samples[i].pts;
          var endTime = i < samples.length - 1 ? samples[i + 1].pts : fragment.endPTS;

          // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
          if (startTime === endTime) {
            endTime += 0.0001;
          }

          for (var j = 0; j < frames.length; j++) {
            var frame = frames[j];
            // Safari doesn't put the timestamp frame in the TextTrack
            if (!_id2.default.isTimeStampFrame(frame)) {
              var cue = new Cue(startTime, endTime, '');
              cue.value = frame;
              this.id3Track.addCue(cue);
            }
          }
        }
      }
    }
  }]);

  return ID3TrackController;
}(_eventHandler2.default);

exports.default = ID3TrackController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/level-controller.js":
/*!***************************************************!*\
  !*** ./src/hls.js/controller/level-controller.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _codecs = __webpack_require__(/*! ../utils/codecs */ "./src/hls.js/utils/codecs.js");

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Level Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var _window = window,
    performance = _window.performance;

var chromeOrFirefox = void 0;

var LevelController = function (_EventHandler) {
  _inherits(LevelController, _EventHandler);

  function LevelController(hls) {
    _classCallCheck(this, LevelController);

    var _this = _possibleConstructorReturn(this, (LevelController.__proto__ || Object.getPrototypeOf(LevelController)).call(this, hls, _events2.default.MANIFEST_LOADED, _events2.default.LEVEL_LOADED, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.FRAG_LOADED, _events2.default.ERROR));

    _this.canload = false;
    _this.currentLevelIndex = null;
    _this.manualLevelIndex = -1;
    _this.timer = null;

    chromeOrFirefox = /chrome|firefox/.test(navigator.userAgent.toLowerCase());
    return _this;
  }

  _createClass(LevelController, [{
    key: 'onHandlerDestroying',
    value: function onHandlerDestroying() {
      this.clearTimer();
      this.manualLevelIndex = -1;
    }
  }, {
    key: 'clearTimer',
    value: function clearTimer() {
      if (this.timer !== null) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      var levels = this._levels;

      this.canload = true;
      this.levelRetryCount = 0;

      // clean up live level details to force reload them, and reset load errors
      if (levels) {
        levels.forEach(function (level) {
          level.loadError = 0;
          var levelDetails = level.details;
          if (levelDetails && levelDetails.live) {
            level.details = undefined;
          }
        });
      }
      // speed up live playlist refresh if timer exists
      if (this.timer !== null) {
        this.loadLevel();
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.canload = false;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var levels = [];
      var audioTracks = [];
      var bitrateStart = void 0;
      var levelSet = {};
      var levelFromSet = null;
      var videoCodecFound = false;
      var audioCodecFound = false;

      // regroup redundant levels together
      data.levels.forEach(function (level) {
        var attributes = level.attrs;
        level.loadError = 0;
        level.fragmentError = false;

        videoCodecFound = videoCodecFound || !!level.videoCodec;
        audioCodecFound = audioCodecFound || !!level.audioCodec;

        // erase audio codec info if browser does not support mp4a.40.34.
        // demuxer will autodetect codec and fallback to mpeg/audio
        if (chromeOrFirefox && level.audioCodec && level.audioCodec.indexOf('mp4a.40.34') !== -1) {
          level.audioCodec = undefined;
        }

        levelFromSet = levelSet[level.bitrate]; // FIXME: we would also have to match the resolution here

        if (!levelFromSet) {
          level.url = [level.url];
          level.urlId = 0;
          levelSet[level.bitrate] = level;
          levels.push(level);
        } else {
          levelFromSet.url.push(level.url);
        }

        if (attributes) {
          if (attributes.AUDIO) {
            audioCodecFound = true;
            (0, _levelHelper.addGroupId)(levelFromSet || level, 'audio', attributes.AUDIO);
          }
          if (attributes.SUBTITLES) {
            (0, _levelHelper.addGroupId)(levelFromSet || level, 'text', attributes.SUBTITLES);
          }
        }
      });

      // remove audio-only level if we also have levels with audio+video codecs signalled
      if (videoCodecFound && audioCodecFound) {
        levels = levels.filter(function (_ref) {
          var videoCodec = _ref.videoCodec;
          return !!videoCodec;
        });
      }

      // only keep levels with supported audio/video codecs
      levels = levels.filter(function (_ref2) {
        var audioCodec = _ref2.audioCodec,
            videoCodec = _ref2.videoCodec;

        return (!audioCodec || (0, _codecs.isCodecSupportedInMp4)(audioCodec, 'audio')) && (!videoCodec || (0, _codecs.isCodecSupportedInMp4)(videoCodec, 'video'));
      });

      if (data.audioTracks) {
        audioTracks = data.audioTracks.filter(function (track) {
          return !track.audioCodec || (0, _codecs.isCodecSupportedInMp4)(track.audioCodec, 'audio');
        });
        // Reassign id's after filtering since they're used as array indices
        audioTracks.forEach(function (track, index) {
          track.id = index;
        });
      }

      if (levels.length > 0) {
        // start bitrate is the first bitrate of the manifest
        bitrateStart = levels[0].bitrate;
        // sort level on bitrate
        levels.sort(function (a, b) {
          return a.bitrate - b.bitrate;
        });
        this._levels = levels;
        // find index of first level in sorted levels
        for (var i = 0; i < levels.length; i++) {
          if (levels[i].bitrate === bitrateStart) {
            this._firstLevel = i;
            _logger.logger.log('manifest loaded,' + levels.length + ' level(s) found, first bitrate:' + bitrateStart);
            break;
          }
        }

        // Audio is only alternate if manifest include a URI along with the audio group tag
        this.hls.trigger(_events2.default.MANIFEST_PARSED, {
          levels: levels,
          audioTracks: audioTracks,
          firstLevel: this._firstLevel,
          stats: data.stats,
          audio: audioCodecFound,
          video: videoCodecFound,
          altAudio: audioTracks.some(function (t) {
            return !!t.url;
          })
        });
      } else {
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
          fatal: true,
          url: this.hls.url,
          reason: 'no level with compatible codecs found in manifest'
        });
      }
    }
  }, {
    key: 'setLevelInternal',
    value: function setLevelInternal(newLevel) {
      var levels = this._levels;
      var hls = this.hls;
      // check if level idx is valid
      if (newLevel >= 0 && newLevel < levels.length) {
        // stopping live reloading timer if any
        this.clearTimer();
        if (this.currentLevelIndex !== newLevel) {
          _logger.logger.log('switching to level ' + newLevel);
          this.currentLevelIndex = newLevel;
          var levelProperties = levels[newLevel];
          levelProperties.level = newLevel;
          hls.trigger(_events2.default.LEVEL_SWITCHING, levelProperties);
        }
        var level = levels[newLevel];
        var levelDetails = level.details;

        // check if we need to load playlist for this level
        if (!levelDetails || levelDetails.live) {
          // level not retrieved yet, or live playlist we need to (re)load it
          var urlId = level.urlId;
          hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });
        }
      } else {
        // invalid level id given, trigger error
        hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.OTHER_ERROR,
          details: _errors.ErrorDetails.LEVEL_SWITCH_ERROR,
          level: newLevel,
          fatal: false,
          reason: 'invalid level idx'
        });
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      if (data.fatal) {
        if (data.type === _errors.ErrorTypes.NETWORK_ERROR) {
          this.clearTimer();
        }

        return;
      }

      var levelError = false,
          fragmentError = false;
      var levelIndex = void 0;

      // try to recover not fatal errors
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          levelIndex = data.frag.level;
          fragmentError = true;
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          levelIndex = data.context.level;
          levelError = true;
          break;
        case _errors.ErrorDetails.REMUX_ALLOC_ERROR:
          levelIndex = data.level;
          levelError = true;
          break;
      }

      if (levelIndex !== undefined) {
        this.recoverLevel(data, levelIndex, levelError, fragmentError);
      }
    }

    /**
     * Switch to a redundant stream if any available.
     * If redundant stream is not available, emergency switch down if ABR mode is enabled.
     *
     * @param {Object} errorEvent
     * @param {Number} levelIndex current level index
     * @param {Boolean} levelError
     * @param {Boolean} fragmentError
     */
    // FIXME Find a better abstraction where fragment/level retry management is well decoupled

  }, {
    key: 'recoverLevel',
    value: function recoverLevel(errorEvent, levelIndex, levelError, fragmentError) {
      var _this2 = this;

      var config = this.hls.config;
      var errorDetails = errorEvent.details;

      var level = this._levels[levelIndex];
      var redundantLevels = void 0,
          delay = void 0,
          nextLevel = void 0;

      level.loadError++;
      level.fragmentError = fragmentError;

      if (levelError) {
        if (this.levelRetryCount + 1 <= config.levelLoadingMaxRetry) {
          // exponential backoff capped to max retry timeout
          delay = Math.min(Math.pow(2, this.levelRetryCount) * config.levelLoadingRetryDelay, config.levelLoadingMaxRetryTimeout);
          // Schedule level reload
          this.timer = setTimeout(function () {
            return _this2.loadLevel();
          }, delay);
          // boolean used to inform stream controller not to switch back to IDLE on non fatal error
          errorEvent.levelRetry = true;
          this.levelRetryCount++;
          _logger.logger.warn('level controller, ' + errorDetails + ', retry in ' + delay + ' ms, current retry count is ' + this.levelRetryCount);
        } else {
          _logger.logger.error('level controller, cannot recover from ' + errorDetails + ' error');
          this.currentLevelIndex = null;
          // stopping live reloading timer if any
          this.clearTimer();
          // switch error to fatal
          errorEvent.fatal = true;
          return;
        }
      }

      // Try any redundant streams if available for both errors: level and fragment
      // If level.loadError reaches redundantLevels it means that we tried them all, no hope  => let's switch down
      if (levelError || fragmentError) {
        redundantLevels = level.url.length;

        if (redundantLevels > 1 && level.loadError < redundantLevels) {
          level.urlId = (level.urlId + 1) % redundantLevels;
          level.details = undefined;

          _logger.logger.warn('level controller, ' + errorDetails + ' for level ' + levelIndex + ': switching to redundant URL-id ' + level.urlId);

          // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);
          // console.log('New video quality level audio group id:', level.attrs.AUDIO);
        } else {
          // Search for available level
          if (this.manualLevelIndex === -1) {
            // When lowest level has been reached, let's start hunt from the top
            nextLevel = levelIndex === 0 ? this._levels.length - 1 : levelIndex - 1;
            _logger.logger.warn('level controller, ' + errorDetails + ': switch to ' + nextLevel);
            this.hls.nextAutoLevel = this.currentLevelIndex = nextLevel;
          } else if (fragmentError) {
            // Allow fragment retry as long as configuration allows.
            // reset this._level so that another call to set level() will trigger again a frag load
            _logger.logger.warn('level controller, ' + errorDetails + ': reload a fragment');
            this.currentLevelIndex = null;
          }
        }
      }
    }

    // reset errors on the successful load of a fragment

  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(_ref3) {
      var frag = _ref3.frag;

      if (frag !== undefined && frag.type === 'main') {
        var level = this._levels[frag.level];
        if (level !== undefined) {
          level.fragmentError = false;
          level.loadError = 0;
          this.levelRetryCount = 0;
        }
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var _this3 = this;

      var level = data.level,
          details = data.details;
      // only process level loaded events matching with expected level

      if (level !== this.currentLevelIndex) {
        return;
      }

      var curLevel = this._levels[level];
      // reset level load error counter on successful level loaded only if there is no issues with fragments
      if (!curLevel.fragmentError) {
        curLevel.loadError = 0;
        this.levelRetryCount = 0;
      }
      // if current playlist is a live playlist, arm a timer to reload it
      if (details.live) {
        var reloadInterval = (0, _levelHelper.computeReloadInterval)(curLevel.details, details, data.stats.trequest);
        _logger.logger.log('live playlist, reload in ' + Math.round(reloadInterval) + ' ms');
        this.timer = setTimeout(function () {
          return _this3.loadLevel();
        }, reloadInterval);
      } else {
        this.clearTimer();
      }
    }
  }, {
    key: 'onAudioTrackSwitched',
    value: function onAudioTrackSwitched(data) {
      var audioGroupId = this.hls.audioTracks[data.id].groupId;

      var currentLevel = this.hls.levels[this.currentLevelIndex];
      if (!currentLevel) {
        return;
      }

      if (currentLevel.audioGroupIds) {
        var urlId = -1;

        for (var i = 0; i < currentLevel.audioGroupIds.length; i++) {
          if (currentLevel.audioGroupIds[i] === audioGroupId) {
            urlId = i;
            break;
          }
        }

        if (urlId !== currentLevel.urlId) {
          currentLevel.urlId = urlId;
          this.startLoad();
        }
      }
    }
  }, {
    key: 'loadLevel',
    value: function loadLevel() {
      _logger.logger.debug('call to loadLevel');

      if (this.currentLevelIndex !== null && this.canload) {
        var levelObject = this._levels[this.currentLevelIndex];

        if ((typeof levelObject === 'undefined' ? 'undefined' : _typeof(levelObject)) === 'object' && levelObject.url.length > 0) {
          var level = this.currentLevelIndex;
          var id = levelObject.urlId;
          var url = levelObject.url[id];

          _logger.logger.log('Attempt loading level index ' + level + ' with URL-id ' + id);

          // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);
          // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);

          this.hls.trigger(_events2.default.LEVEL_LOADING, { url: url, level: level, id: id });
        }
      }
    }
  }, {
    key: 'levels',
    get: function get() {
      return this._levels;
    }
  }, {
    key: 'level',
    get: function get() {
      return this.currentLevelIndex;
    },
    set: function set(newLevel) {
      var levels = this._levels;
      if (levels) {
        newLevel = Math.min(newLevel, levels.length - 1);
        if (this.currentLevelIndex !== newLevel || !levels[newLevel].details) {
          this.setLevelInternal(newLevel);
        }
      }
    }
  }, {
    key: 'manualLevel',
    get: function get() {
      return this.manualLevelIndex;
    },
    set: function set(newLevel) {
      this.manualLevelIndex = newLevel;
      if (this._startLevel === undefined) {
        this._startLevel = newLevel;
      }

      if (newLevel !== -1) {
        this.level = newLevel;
      }
    }
  }, {
    key: 'firstLevel',
    get: function get() {
      return this._firstLevel;
    },
    set: function set(newLevel) {
      this._firstLevel = newLevel;
    }
  }, {
    key: 'startLevel',
    get: function get() {
      // hls.startLevel takes precedence over config.startLevel
      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)
      if (this._startLevel === undefined) {
        var configStartLevel = this.hls.config.startLevel;
        if (configStartLevel !== undefined) {
          return configStartLevel;
        } else {
          return this._firstLevel;
        }
      } else {
        return this._startLevel;
      }
    },
    set: function set(newLevel) {
      this._startLevel = newLevel;
    }
  }, {
    key: 'nextLoadLevel',
    get: function get() {
      if (this.manualLevelIndex !== -1) {
        return this.manualLevelIndex;
      } else {
        return this.hls.nextAutoLevel;
      }
    },
    set: function set(nextLevel) {
      this.level = nextLevel;
      if (this.manualLevelIndex === -1) {
        this.hls.nextAutoLevel = nextLevel;
      }
    }
  }]);

  return LevelController;
}(_eventHandler2.default);

exports.default = LevelController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/level-helper.js":
/*!***********************************************!*\
  !*** ./src/hls.js/controller/level-helper.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addGroupId = addGroupId;
exports.updatePTS = updatePTS;
exports.updateFragPTSDTS = updateFragPTSDTS;
exports.mergeDetails = mergeDetails;
exports.mergeSubtitlePlaylists = mergeSubtitlePlaylists;
exports.mapFragmentIntersection = mapFragmentIntersection;
exports.adjustSliding = adjustSliding;
exports.computeReloadInterval = computeReloadInterval;

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function addGroupId(level, type, id) {
  switch (type) {
    case 'audio':
      if (!level.audioGroupIds) {
        level.audioGroupIds = [];
      }
      level.audioGroupIds.push(id);
      break;
    case 'text':
      if (!level.textGroupIds) {
        level.textGroupIds = [];
      }
      level.textGroupIds.push(id);
      break;
  }
} /**
   * @module LevelHelper
   *
   * Providing methods dealing with playlist sliding and drift
   *
   * TODO: Create an actual `Level` class/model that deals with all this logic in an object-oriented-manner.
   *
   * */

function updatePTS(fragments, fromIdx, toIdx) {
  var fragFrom = fragments[fromIdx],
      fragTo = fragments[toIdx],
      fragToPTS = fragTo.startPTS;
  // if we know startPTS[toIdx]
  if (Number.isFinite(fragToPTS)) {
    // update fragment duration.
    // it helps to fix drifts between playlist reported duration and fragment real duration
    if (toIdx > fromIdx) {
      fragFrom.duration = fragToPTS - fragFrom.start;
      if (fragFrom.duration < 0) {
        _logger.logger.warn('negative duration computed for frag ' + fragFrom.sn + ',level ' + fragFrom.level + ', there should be some duration drift between playlist and fragment!');
      }
    } else {
      fragTo.duration = fragFrom.start - fragToPTS;
      if (fragTo.duration < 0) {
        _logger.logger.warn('negative duration computed for frag ' + fragTo.sn + ',level ' + fragTo.level + ', there should be some duration drift between playlist and fragment!');
      }
    }
  } else {
    // we dont know startPTS[toIdx]
    if (toIdx > fromIdx) {
      fragTo.start = fragFrom.start + fragFrom.duration;
    } else {
      fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
    }
  }
}

function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
  // update frag PTS/DTS
  var maxStartPTS = startPTS;
  if (Number.isFinite(frag.startPTS)) {
    // delta PTS between audio and video
    var deltaPTS = Math.abs(frag.startPTS - startPTS);
    if (!Number.isFinite(frag.deltaPTS)) {
      frag.deltaPTS = deltaPTS;
    } else {
      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
    }

    maxStartPTS = Math.max(startPTS, frag.startPTS);
    startPTS = Math.min(startPTS, frag.startPTS);
    endPTS = Math.max(endPTS, frag.endPTS);
    startDTS = Math.min(startDTS, frag.startDTS);
    endDTS = Math.max(endDTS, frag.endDTS);
  }

  var drift = startPTS - frag.start;
  frag.start = frag.startPTS = startPTS;
  frag.maxStartPTS = maxStartPTS;
  frag.endPTS = endPTS;
  frag.startDTS = startDTS;
  frag.endDTS = endDTS;
  frag.duration = endPTS - startPTS;

  var sn = frag.sn;
  // exit if sn out of range
  if (!details || sn < details.startSN || sn > details.endSN) {
    return 0;
  }

  var fragIdx = void 0,
      fragments = void 0,
      i = void 0;
  fragIdx = sn - details.startSN;
  fragments = details.fragments;
  // update frag reference in fragments array
  // rationale is that fragments array might not contain this frag object.
  // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()
  // if we don't update frag, we won't be able to propagate PTS info on the playlist
  // resulting in invalid sliding computation
  fragments[fragIdx] = frag;
  // adjust fragment PTS/duration from seqnum-1 to frag 0
  for (i = fragIdx; i > 0; i--) {
    updatePTS(fragments, i, i - 1);
  }

  // adjust fragment PTS/duration from seqnum to last frag
  for (i = fragIdx; i < fragments.length - 1; i++) {
    updatePTS(fragments, i, i + 1);
  }

  details.PTSKnown = true;
  return drift;
}

function mergeDetails(oldDetails, newDetails) {
  // potentially retrieve cached initsegment
  if (newDetails.initSegment && oldDetails.initSegment) {
    newDetails.initSegment = oldDetails.initSegment;
  }

  // check if old/new playlists have fragments in common
  // loop through overlapping SN and update startPTS , cc, and duration if any found
  var ccOffset = 0;
  var PTSFrag = void 0;
  mapFragmentIntersection(oldDetails, newDetails, function (oldFrag, newFrag) {
    ccOffset = oldFrag.cc - newFrag.cc;
    if (Number.isFinite(oldFrag.startPTS)) {
      newFrag.start = newFrag.startPTS = oldFrag.startPTS;
      newFrag.endPTS = oldFrag.endPTS;
      newFrag.duration = oldFrag.duration;
      newFrag.backtracked = oldFrag.backtracked;
      newFrag.dropped = oldFrag.dropped;
      PTSFrag = newFrag;
    }
    // PTS is known when there are overlapping segments
    newDetails.PTSKnown = true;
  });

  if (!newDetails.PTSKnown) {
    return;
  }

  if (ccOffset) {
    _logger.logger.log('discontinuity sliding from playlist, take drift into account');
    var newFragments = newDetails.fragments;
    for (var i = 0; i < newFragments.length; i++) {
      newFragments[i].cc += ccOffset;
    }
  }

  // if at least one fragment contains PTS info, recompute PTS information for all fragments
  if (PTSFrag) {
    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
  } else {
    // ensure that delta is within oldFragments range
    // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
    // in that case we also need to adjust start offset of all fragments
    adjustSliding(oldDetails, newDetails);
  }
  // if we are here, it means we have fragments overlapping between
  // old and new level. reliable PTS info is thus relying on old level
  newDetails.PTSKnown = oldDetails.PTSKnown;
}

function mergeSubtitlePlaylists(oldPlaylist, newPlaylist) {
  var referenceStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var lastIndex = -1;
  mapFragmentIntersection(oldPlaylist, newPlaylist, function (oldFrag, newFrag, index) {
    newFrag.start = oldFrag.start;
    lastIndex = index;
  });

  var frags = newPlaylist.fragments;
  if (lastIndex < 0) {
    frags.forEach(function (frag) {
      frag.start += referenceStart;
    });
    return;
  }

  for (var i = lastIndex + 1; i < frags.length; i++) {
    frags[i].start = frags[i - 1].start + frags[i - 1].duration;
  }
}

function mapFragmentIntersection(oldPlaylist, newPlaylist, intersectionFn) {
  if (!oldPlaylist || !newPlaylist) {
    return;
  }

  var start = Math.max(oldPlaylist.startSN, newPlaylist.startSN) - newPlaylist.startSN;
  var end = Math.min(oldPlaylist.endSN, newPlaylist.endSN) - newPlaylist.startSN;
  var delta = newPlaylist.startSN - oldPlaylist.startSN;

  for (var i = start; i <= end; i++) {
    var oldFrag = oldPlaylist.fragments[delta + i];
    var newFrag = newPlaylist.fragments[i];
    if (!oldFrag || !newFrag) {
      break;
    }
    intersectionFn(oldFrag, newFrag, i);
  }
}

function adjustSliding(oldPlaylist, newPlaylist) {
  var delta = newPlaylist.startSN - oldPlaylist.startSN;
  var oldFragments = oldPlaylist.fragments;
  var newFragments = newPlaylist.fragments;

  if (delta < 0 || delta > oldFragments.length) {
    return;
  }
  for (var i = 0; i < newFragments.length; i++) {
    newFragments[i].start += oldFragments[delta].start;
  }
}

function computeReloadInterval(currentPlaylist, newPlaylist, lastRequestTime) {
  var reloadInterval = 1000 * (newPlaylist.averagetargetduration ? newPlaylist.averagetargetduration : newPlaylist.targetduration);
  var minReloadInterval = reloadInterval / 2;
  if (currentPlaylist && newPlaylist.endSN === currentPlaylist.endSN) {
    // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
    // changed then it MUST wait for a period of one-half the target
    // duration before retrying.
    reloadInterval = minReloadInterval;
  }

  if (lastRequestTime) {
    reloadInterval = Math.max(minReloadInterval, reloadInterval - (window.performance.now() - lastRequestTime));
  }
  // in any case, don't reload more than half of target duration
  return Math.round(reloadInterval);
}

/***/ }),

/***/ "./src/hls.js/controller/stream-controller.js":
/*!****************************************************!*\
  !*** ./src/hls.js/controller/stream-controller.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _binarySearch = __webpack_require__(/*! ../utils/binary-search */ "./src/hls.js/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _demuxer = __webpack_require__(/*! ../demux/demuxer */ "./src/hls.js/demux/demuxer.js");

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _fragmentTracker = __webpack_require__(/*! ./fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _fragment = __webpack_require__(/*! ../loader/fragment */ "./src/hls.js/loader/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _playlistLoader = __webpack_require__(/*! ../loader/playlist-loader */ "./src/hls.js/loader/playlist-loader.js");

var _playlistLoader2 = _interopRequireDefault(_playlistLoader);

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

var LevelHelper = _interopRequireWildcard(_levelHelper);

var _timeRanges = __webpack_require__(/*! ../utils/time-ranges */ "./src/hls.js/utils/time-ranges.js");

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _discontinuities = __webpack_require__(/*! ../utils/discontinuities */ "./src/hls.js/utils/discontinuities.js");

var _fragmentFinders = __webpack_require__(/*! ./fragment-finders */ "./src/hls.js/controller/fragment-finders.js");

var _gapController = __webpack_require__(/*! ./gap-controller */ "./src/hls.js/controller/gap-controller.js");

var _gapController2 = _interopRequireDefault(_gapController);

var _baseStreamController = __webpack_require__(/*! ./base-stream-controller */ "./src/hls.js/controller/base-stream-controller.js");

var _baseStreamController2 = _interopRequireDefault(_baseStreamController);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var TICK_INTERVAL = 100; // how often to tick in ms

var StreamController = function (_BaseStreamController) {
  _inherits(StreamController, _BaseStreamController);

  function StreamController(hls, fragmentTracker) {
    _classCallCheck(this, StreamController);

    var _this = _possibleConstructorReturn(this, (StreamController.__proto__ || Object.getPrototypeOf(StreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.LEVEL_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_LOAD_EMERGENCY_ABORTED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED));

    _this.fragmentTracker = fragmentTracker;
    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this._state = _baseStreamController.State.STOPPED;
    _this.stallReported = false;
    _this.gapController = null;
    return _this;
  }

  _createClass(StreamController, [{
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.levels) {
        var lastCurrentTime = this.lastCurrentTime,
            hls = this.hls;
        this.stopLoad();
        this.setInterval(TICK_INTERVAL);
        this.level = -1;
        this.fragLoadError = 0;
        if (!this.startFragRequested) {
          // determine load level
          var startLevel = hls.startLevel;
          if (startLevel === -1) {
            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
            startLevel = 0;
            this.bitrateTest = true;
          }
          // set new level to playlist loader : this will trigger start level load
          // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
          this.level = hls.nextLoadLevel = startLevel;
          this.loadedmetadata = false;
        }
        // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime
        if (lastCurrentTime > 0 && startPosition === -1) {
          _logger.logger.log('override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
          startPosition = lastCurrentTime;
        }
        this.state = _baseStreamController.State.IDLE;
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
        this.tick();
      } else {
        this.forceStartLoad = true;
        this.state = _baseStreamController.State.STOPPED;
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.forceStartLoad = false;
      _get(StreamController.prototype.__proto__ || Object.getPrototypeOf(StreamController.prototype), 'stopLoad', this).call(this);
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      switch (this.state) {
        case _baseStreamController.State.BUFFER_FLUSHING:
          // in buffer flushing state, reset fragLoadError counter
          this.fragLoadError = 0;
          break;
        case _baseStreamController.State.IDLE:
          this._doTickIdle();
          break;
        case _baseStreamController.State.WAITING_LEVEL:
          var level = this.levels[this.level];
          // check if playlist is already loaded
          if (level && level.details) {
            this.state = _baseStreamController.State.IDLE;
          }

          break;
        case _baseStreamController.State.FRAG_LOADING_WAITING_RETRY:
          var now = window.performance.now();
          var retryDate = this.retryDate;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || this.media && this.media.seeking) {
            _logger.logger.log('mediaController: retryDate reached, switch back to IDLE state');
            this.state = _baseStreamController.State.IDLE;
          }
          break;
        case _baseStreamController.State.ERROR:
        case _baseStreamController.State.STOPPED:
        case _baseStreamController.State.FRAG_LOADING:
        case _baseStreamController.State.PARSING:
        case _baseStreamController.State.PARSED:
        case _baseStreamController.State.ENDED:
          break;
        default:
          break;
      }
      // check buffer
      this._checkBuffer();
      // check/update current fragment
      this._checkFragmentChanged();
    }

    // Ironically the "idle" state is the on we do the most logic in it seems ....
    // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
    //       played segment, or on pause/play/seek instead of naively checking every 100ms?

  }, {
    key: '_doTickIdle',
    value: function _doTickIdle() {
      var hls = this.hls,
          config = hls.config,
          media = this.media;

      // if start level not parsed yet OR
      // if video not attached AND start fragment already requested OR start frag prefetch disable
      // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment
      if (this.levelLastLoaded === undefined || !media && (this.startFragRequested || !config.startFragPrefetch)) {
        return;
      }

      // if we have not yet loaded any fragment, start loading from start position
      var pos = void 0;
      if (this.loadedmetadata) {
        pos = media.currentTime;
      } else {
        pos = this.nextLoadPosition;
      }

      // determine next load level
      var level = hls.nextLoadLevel,
          levelInfo = this.levels[level];

      if (!levelInfo) {
        return;
      }

      var levelBitrate = levelInfo.bitrate,
          maxBufLen = void 0;

      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
      if (levelBitrate) {
        maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
      } else {
        maxBufLen = config.maxBufferLength;
      }

      maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);

      // determine next candidate fragment to be loaded, based on current position and end of buffer position
      // ensure up to `config.maxMaxBufferLength` of buffer upfront

      var bufferInfo = _bufferHelper.BufferHelper.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole),
          bufferLen = bufferInfo.len;
      // Stay idle if we are still with buffer margins
      if (bufferLen >= maxBufLen) {
        return;
      }

      // if buffer length is less than maxBufLen try to load a new fragment ...
      _logger.logger.trace('buffer length of ' + bufferLen.toFixed(3) + ' is below max of ' + maxBufLen.toFixed(3) + '. checking for more payload ...');

      // set next load level : this will trigger a playlist load if needed
      this.level = hls.nextLoadLevel = level;

      var levelDetails = levelInfo.details;
      // if level info not retrieved yet, switch state and wait for level retrieval
      // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
      // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
      if (!levelDetails || levelDetails.live && this.levelLastLoaded !== level) {
        this.state = _baseStreamController.State.WAITING_LEVEL;
        return;
      }

      if (this._streamEnded(bufferInfo, levelDetails)) {
        var data = {};
        if (this.altAudio) {
          data.type = 'video';
        }

        this.hls.trigger(_events2.default.BUFFER_EOS, data);
        this.state = _baseStreamController.State.ENDED;
        return;
      }
      // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)
      this._fetchPayloadOrEos(pos, bufferInfo, levelDetails);
    }
  }, {
    key: '_fetchPayloadOrEos',
    value: function _fetchPayloadOrEos(pos, bufferInfo, levelDetails) {
      var fragPrevious = this.fragPrevious,
          level = this.level,
          fragments = levelDetails.fragments,
          fragLen = fragments.length;

      // empty playlist
      if (fragLen === 0) {
        return;
      }

      // find fragment index, contiguous with end of buffer position
      var start = fragments[0].start,
          end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
          bufferEnd = bufferInfo.end,
          frag = void 0;

      if (levelDetails.initSegment && !levelDetails.initSegment.data) {
        frag = levelDetails.initSegment;
      } else {
        // in case of live playlist we need to ensure that requested position is not located before playlist start
        if (levelDetails.live) {
          var initialLiveManifestSize = this.config.initialLiveManifestSize;
          if (fragLen < initialLiveManifestSize) {
            _logger.logger.warn('Can not start playback of a level, reason: not enough fragments ' + fragLen + ' < ' + initialLiveManifestSize);
            return;
          }

          frag = this._ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen);
          // if it explicitely returns null don't load any fragment and exit function now
          if (frag === null) {
            return;
          }
        } else {
          // VoD playlist: if bufferEnd before start of playlist, load first fragment
          if (bufferEnd < start) {
            frag = fragments[0];
          }
        }
      }
      if (!frag) {
        frag = this._findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails);
      }

      if (frag) {
        if (frag.encrypted) {
          _logger.logger.log('Loading key for ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level);
          this._loadKey(frag);
        } else {
          _logger.logger.log('Loading ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level + ', currentTime:' + pos.toFixed(3) + ',bufferEnd:' + bufferEnd.toFixed(3));
          this._loadFragment(frag);
        }
      }
    }
  }, {
    key: '_ensureFragmentAtLivePoint',
    value: function _ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen) {
      var config = this.hls.config,
          media = this.media;

      var frag = void 0;

      // check if requested position is within seekable boundaries :
      // logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);
      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;

      if (bufferEnd < Math.max(start - config.maxFragLookUpTolerance, end - maxLatency)) {
        var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);
        _logger.logger.log('buffer end: ' + bufferEnd.toFixed(3) + ' is located too far from the end of live sliding playlist, reset currentTime to : ' + liveSyncPosition.toFixed(3));
        bufferEnd = liveSyncPosition;
        if (media && media.readyState && media.duration > liveSyncPosition) {
          media.currentTime = liveSyncPosition;
        }

        this.nextLoadPosition = liveSyncPosition;
      }

      // if end of buffer greater than live edge, don't load any fragment
      // this could happen if live playlist intermittently slides in the past.
      // level 1 loaded [182580161,182580167]
      // level 1 loaded [182580162,182580169]
      // Loading 182580168 of [182580162 ,182580169],level 1 ..
      // Loading 182580169 of [182580162 ,182580169],level 1 ..
      // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
      // level 1 loaded [182580164,182580171]
      //
      // don't return null in case media not loaded yet (readystate === 0)
      if (levelDetails.PTSKnown && bufferEnd > end && media && media.readyState) {
        return null;
      }

      if (this.startFragRequested && !levelDetails.PTSKnown) {
        /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
           try to load frag matching with next SN.
           even if SN are not synchronized between playlists, loading this frag will help us
           compute playlist sliding and find the right one after in case it was not the right consecutive one */
        if (fragPrevious) {
          if (levelDetails.hasProgramDateTime) {
            // Relies on PDT in order to switch bitrates (Support EXT-X-DISCONTINUITY without EXT-X-DISCONTINUITY-SEQUENCE)
            _logger.logger.log('live playlist, switching playlist, load frag with same PDT: ' + fragPrevious.programDateTime);
            frag = (0, _fragmentFinders.findFragmentByPDT)(fragments, fragPrevious.endProgramDateTime, config.maxFragLookUpTolerance);
          } else {
            // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)
            var targetSN = fragPrevious.sn + 1;
            if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
              var fragNext = fragments[targetSN - levelDetails.startSN];
              if (fragPrevious.cc === fragNext.cc) {
                frag = fragNext;
                _logger.logger.log('live playlist, switching playlist, load frag with next SN: ' + frag.sn);
              }
            }
            // next frag SN not available (or not with same continuity counter)
            // look for a frag sharing the same CC
            if (!frag) {
              frag = _binarySearch2.default.search(fragments, function (frag) {
                return fragPrevious.cc - frag.cc;
              });
              if (frag) {
                _logger.logger.log('live playlist, switching playlist, load frag with same CC: ' + frag.sn);
              }
            }
          }
        }
        if (!frag) {
          /* we have no idea about which fragment should be loaded.
             so let's load mid fragment. it will help computing playlist sliding and find the right one
          */
          frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];
          _logger.logger.log('live playlist, switching playlist, unknown, load middle frag : ' + frag.sn);
        }
      }

      return frag;
    }
  }, {
    key: '_findFragment',
    value: function _findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails) {
      var config = this.hls.config;
      var frag = void 0;

      if (bufferEnd < end) {
        var lookupTolerance = bufferEnd > end - config.maxFragLookUpTolerance ? 0 : config.maxFragLookUpTolerance;
        // Remove the tolerance if it would put the bufferEnd past the actual end of stream
        // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)
        frag = (0, _fragmentFinders.findFragmentByPTS)(fragPrevious, fragments, bufferEnd, lookupTolerance);
      } else {
        // reach end of playlist
        frag = fragments[fragLen - 1];
      }
      if (frag) {
        var curSNIdx = frag.sn - levelDetails.startSN;
        var sameLevel = fragPrevious && frag.level === fragPrevious.level;
        var prevFrag = fragments[curSNIdx - 1];
        var nextFrag = fragments[curSNIdx + 1];
        // logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
        if (fragPrevious && frag.sn === fragPrevious.sn) {
          if (sameLevel && !frag.backtracked) {
            if (frag.sn < levelDetails.endSN) {
              var deltaPTS = fragPrevious.deltaPTS;
              // if there is a significant delta between audio and video, larger than max allowed hole,
              // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
              // let's try to load previous fragment again to get last keyframe
              // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)
              if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx) {
                frag = prevFrag;
                _logger.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');
              } else {
                frag = nextFrag;
                _logger.logger.log('SN just loaded, load next one: ' + frag.sn, frag);
              }
            } else {
              frag = null;
            }
          } else if (frag.backtracked) {
            // Only backtrack a max of 1 consecutive fragment to prevent sliding back too far when little or no frags start with keyframes
            if (nextFrag && nextFrag.backtracked) {
              _logger.logger.warn('Already backtracked from fragment ' + nextFrag.sn + ', will not backtrack to fragment ' + frag.sn + '. Loading fragment ' + nextFrag.sn);
              frag = nextFrag;
            } else {
              // If a fragment has dropped frames and it's in a same level/sequence, load the previous fragment to try and find the keyframe
              // Reset the dropped count now since it won't be reset until we parse the fragment again, which prevents infinite backtracking on the same segment
              _logger.logger.warn('Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe');
              frag.dropped = 0;
              if (prevFrag) {
                frag = prevFrag;
                frag.backtracked = true;
              } else if (curSNIdx) {
                // can't backtrack on very first fragment
                frag = null;
              }
            }
          }
        }
      }
      return frag;
    }
  }, {
    key: '_loadKey',
    value: function _loadKey(frag) {
      this.state = _baseStreamController.State.KEY_LOADING;
      this.hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
    }
  }, {
    key: '_loadFragment',
    value: function _loadFragment(frag) {
      // Check if fragment is not loaded
      var fragState = this.fragmentTracker.getState(frag);

      this.fragCurrent = frag;
      this.startFragRequested = true;
      // Don't update nextLoadPosition for fragments which are not buffered
      if (Number.isFinite(frag.sn) && !frag.bitrateTest) {
        this.nextLoadPosition = frag.start + frag.duration;
      }

      // Allow backtracked fragments to load
      if (frag.backtracked || fragState === _fragmentTracker.FragmentState.NOT_LOADED || fragState === _fragmentTracker.FragmentState.PARTIAL) {
        frag.autoLevel = this.hls.autoLevelEnabled;
        frag.bitrateTest = this.bitrateTest;

        this.hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
        // lazy demuxer init, as this could take some time ... do it during frag loading
        if (!this.demuxer) {
          this.demuxer = new _demuxer2.default(this.hls, 'main');
        }

        this.state = _baseStreamController.State.FRAG_LOADING;
      } else if (fragState === _fragmentTracker.FragmentState.APPENDING) {
        // Lower the buffer size and try again
        if (this._reduceMaxBufferLength(frag.duration)) {
          this.fragmentTracker.removeFragment(frag);
        }
      }
    }
  }, {
    key: 'getBufferedFrag',
    value: function getBufferedFrag(position) {
      return this.fragmentTracker.getBufferedFrag(position, _playlistLoader2.default.LevelType.MAIN);
    }
  }, {
    key: 'followingBufferedFrag',
    value: function followingBufferedFrag(frag) {
      if (frag) {
        // try to get range of next fragment (500ms after this range)
        return this.getBufferedFrag(frag.endPTS + 0.5);
      }
      return null;
    }
  }, {
    key: '_checkFragmentChanged',
    value: function _checkFragmentChanged() {
      var fragPlayingCurrent = void 0,
          currentTime = void 0,
          video = this.media;
      if (video && video.readyState && video.seeking === false) {
        currentTime = video.currentTime;
        /* if video element is in seeked state, currentTime can only increase.
          (assuming that playback rate is positive ...)
          As sometimes currentTime jumps back to zero after a
          media decode error, check this, to avoid seeking back to
          wrong position after a media decode error
        */
        if (currentTime > this.lastCurrentTime) {
          this.lastCurrentTime = currentTime;
        }

        if (_bufferHelper.BufferHelper.isBuffered(video, currentTime)) {
          fragPlayingCurrent = this.getBufferedFrag(currentTime);
        } else if (_bufferHelper.BufferHelper.isBuffered(video, currentTime + 0.1)) {
          /* ensure that FRAG_CHANGED event is triggered at startup,
            when first video frame is displayed and playback is paused.
            add a tolerance of 100ms, in case current position is not buffered,
            check if current pos+100ms is buffered and use that buffer range
            for FRAG_CHANGED event reporting */
          fragPlayingCurrent = this.getBufferedFrag(currentTime + 0.1);
        }
        if (fragPlayingCurrent) {
          var fragPlaying = fragPlayingCurrent;
          if (fragPlaying !== this.fragPlaying) {
            this.hls.trigger(_events2.default.FRAG_CHANGED, { frag: fragPlaying });
            var fragPlayingLevel = fragPlaying.level;
            if (!this.fragPlaying || this.fragPlaying.level !== fragPlayingLevel) {
              this.hls.trigger(_events2.default.LEVEL_SWITCHED, { level: fragPlayingLevel });
            }

            this.fragPlaying = fragPlaying;
          }
        }
      }
    }

    /*
      on immediate level switch :
       - pause playback if playing
       - cancel any pending load request
       - and trigger a buffer flush
    */

  }, {
    key: 'immediateLevelSwitch',
    value: function immediateLevelSwitch() {
      _logger.logger.log('immediateLevelSwitch');
      if (!this.immediateSwitch) {
        this.immediateSwitch = true;
        var media = this.media,
            previouslyPaused = void 0;
        if (media) {
          previouslyPaused = media.paused;
          media.pause();
        } else {
          // don't restart playback after instant level switch in case media not attached
          previouslyPaused = true;
        }
        this.previouslyPaused = previouslyPaused;
      }
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && fragCurrent.loader) {
        fragCurrent.loader.abort();
      }

      this.fragCurrent = null;
      // flush everything
      this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
    }

    /**
     * on immediate level switch end, after new fragment has been buffered:
     * - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
     * - resume the playback if needed
     */

  }, {
    key: 'immediateLevelSwitchEnd',
    value: function immediateLevelSwitchEnd() {
      var media = this.media;
      if (media && media.buffered.length) {
        this.immediateSwitch = false;
        if (_bufferHelper.BufferHelper.isBuffered(media, media.currentTime)) {
          // only nudge if currentTime is buffered
          media.currentTime -= 0.0001;
        }
        if (!this.previouslyPaused) {
          media.play();
        }
      }
    }

    /**
     * try to switch ASAP without breaking video playback:
     * in order to ensure smooth but quick level switching,
     * we need to find the next flushable buffer range
     * we should take into account new segment fetch time
     */

  }, {
    key: 'nextLevelSwitch',
    value: function nextLevelSwitch() {
      var media = this.media;
      // ensure that media is defined and that metadata are available (to retrieve currentTime)
      if (media && media.readyState) {
        var fetchdelay = void 0,
            fragPlayingCurrent = void 0,
            nextBufferedFrag = void 0;
        fragPlayingCurrent = this.getBufferedFrag(media.currentTime);
        if (fragPlayingCurrent && fragPlayingCurrent.startPTS > 1) {
          // flush buffer preceding current fragment (flush until current fragment start offset)
          // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
          this.flushMainBuffer(0, fragPlayingCurrent.startPTS - 1);
        }
        if (!media.paused) {
          // add a safety delay of 1s
          var nextLevelId = this.hls.nextLoadLevel,
              nextLevel = this.levels[nextLevelId],
              fragLastKbps = this.fragLastKbps;
          if (fragLastKbps && this.fragCurrent) {
            fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;
          } else {
            fetchdelay = 0;
          }
        } else {
          fetchdelay = 0;
        }
        // logger.log('fetchdelay:'+fetchdelay);
        // find buffer range that will be reached once new fragment will be fetched
        nextBufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
        if (nextBufferedFrag) {
          // we can flush buffer range following this one without stalling playback
          nextBufferedFrag = this.followingBufferedFrag(nextBufferedFrag);
          if (nextBufferedFrag) {
            // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
            var fragCurrent = this.fragCurrent;
            if (fragCurrent && fragCurrent.loader) {
              fragCurrent.loader.abort();
            }

            this.fragCurrent = null;
            // start flush position is the start PTS of next buffered frag.
            // we use frag.naxStartPTS which is max(audio startPTS, video startPTS).
            // in case there is a small PTS Delta between audio and video, using maxStartPTS avoids flushing last samples from current fragment
            this.flushMainBuffer(nextBufferedFrag.maxStartPTS, Number.POSITIVE_INFINITY);
          }
        }
      }
    }
  }, {
    key: 'flushMainBuffer',
    value: function flushMainBuffer(startOffset, endOffset) {
      this.state = _baseStreamController.State.BUFFER_FLUSHING;
      var flushScope = { startOffset: startOffset, endOffset: endOffset };
      // if alternate audio tracks are used, only flush video, otherwise flush everything
      if (this.altAudio) {
        flushScope.type = 'video';
      }

      this.hls.trigger(_events2.default.BUFFER_FLUSHING, flushScope);
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvseeked = this.onMediaSeeked.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('seeked', this.onvseeked);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.levels && config.autoStartLoad) {
        this.hls.startLoad(config.startPosition);
      }

      this.gapController = new _gapController2.default(config, media, this.fragmentTracker, this.hls);
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // reset fragment backtracked flag
      var levels = this.levels;
      if (levels) {
        levels.forEach(function (level) {
          if (level.details) {
            level.details.fragments.forEach(function (fragment) {
              fragment.backtracked = undefined;
            });
          }
        });
      }
      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('seeked', this.onvseeked);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = this.mediaBuffer = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onMediaSeeked',
    value: function onMediaSeeked() {
      var media = this.media,
          currentTime = media ? media.currentTime : undefined;
      if (Number.isFinite(currentTime)) {
        _logger.logger.log('media seeked to ' + currentTime.toFixed(3));
      }

      // tick to speed up FRAGMENT_PLAYING triggering
      this.tick();
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset buffer on manifest loading
      _logger.logger.log('trigger BUFFER_RESET');
      this.hls.trigger(_events2.default.BUFFER_RESET);
      this.fragmentTracker.removeAllFragments();
      this.stalled = false;
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var aac = false,
          heaac = false,
          codec = void 0;
      data.levels.forEach(function (level) {
        // detect if we have different kind of audio codecs used amongst playlists
        codec = level.audioCodec;
        if (codec) {
          if (codec.indexOf('mp4a.40.2') !== -1) {
            aac = true;
          }

          if (codec.indexOf('mp4a.40.5') !== -1) {
            heaac = true;
          }
        }
      });
      this.audioCodecSwitch = aac && heaac;
      if (this.audioCodecSwitch) {
        _logger.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
      }

      this.levels = data.levels;
      this.startFragRequested = false;
      var config = this.config;
      if (config.autoStartLoad || this.forceStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var newDetails = data.details;
      var newLevelId = data.level;
      var lastLevel = this.levels[this.levelLastLoaded];
      var curLevel = this.levels[newLevelId];
      var duration = newDetails.totalduration;
      var sliding = 0;

      _logger.logger.log('level ' + newLevelId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);

      if (newDetails.live) {
        var curDetails = curLevel.details;
        if (curDetails && newDetails.fragments.length > 0) {
          // we already have details for that level, merge them
          LevelHelper.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown && Number.isFinite(sliding)) {
            _logger.logger.log('live playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live playlist - outdated PTS, unknown sliding');
            (0, _discontinuities.alignStream)(this.fragPrevious, lastLevel, newDetails);
          }
        } else {
          _logger.logger.log('live playlist - first load, unknown sliding');
          newDetails.PTSKnown = false;
          (0, _discontinuities.alignStream)(this.fragPrevious, lastLevel, newDetails);
        }
      } else {
        newDetails.PTSKnown = false;
      }
      // override level info
      curLevel.details = newDetails;
      this.levelLastLoaded = newLevelId;
      this.hls.trigger(_events2.default.LEVEL_UPDATED, { details: newDetails, level: newLevelId });

      if (this.startFragRequested === false) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1 || this.lastCurrentTime === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (Number.isFinite(startTimeOffset)) {
            if (startTimeOffset < 0) {
              _logger.logger.log('negative start time offset ' + startTimeOffset + ', count from end of last fragment');
              startTimeOffset = sliding + duration + startTimeOffset;
            }
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
            if (newDetails.live) {
              this.startPosition = this.computeLivePosition(sliding, newDetails);
              _logger.logger.log('configure startPosition to ' + this.startPosition);
            } else {
              this.startPosition = 0;
            }
          }
          this.lastCurrentTime = this.startPosition;
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment
      if (this.state === _baseStreamController.State.WAITING_LEVEL) {
        this.state = _baseStreamController.State.IDLE;
      }

      // trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === _baseStreamController.State.KEY_LOADING) {
        this.state = _baseStreamController.State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent,
          hls = this.hls,
          levels = this.levels,
          media = this.media;

      var fragLoaded = data.frag;
      if (this.state === _baseStreamController.State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'main' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
        var stats = data.stats;
        var currentLevel = levels[fragCurrent.level];
        var details = currentLevel.details;
        // reset frag bitrate test in any case after frag loaded event
        // if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0
        // then this means that we should be able to load a fragment at a higher quality level
        this.bitrateTest = false;
        this.stats = stats;

        _logger.logger.log('Loaded ' + fragCurrent.sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + fragCurrent.level);
        if (fragLoaded.bitrateTest && hls.nextLoadLevel) {
          // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
          this.state = _baseStreamController.State.IDLE;
          this.startFragRequested = false;
          stats.tparsed = stats.tbuffered = window.performance.now();
          hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
          this.tick();
        } else if (fragLoaded.sn === 'initSegment') {
          this.state = _baseStreamController.State.IDLE;
          stats.tparsed = stats.tbuffered = window.performance.now();
          details.initSegment.data = data.payload;
          hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
          this.tick();
        } else {
          _logger.logger.log('Parsing ' + fragCurrent.sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + fragCurrent.level + ', cc ' + fragCurrent.cc);
          this.state = _baseStreamController.State.PARSING;
          this.pendingBuffering = true;
          this.appended = false;

          // Bitrate test frags are not usually buffered so the fragment tracker ignores them. If Hls.js decides to buffer
          // it (and therefore ends up at this line), then the fragment tracker needs to be manually informed.
          if (fragLoaded.bitrateTest) {
            fragLoaded.bitrateTest = false;
            this.fragmentTracker.onFragLoaded({
              frag: fragLoaded
            });
          }

          // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live) and if media is not seeking (this is to overcome potential timestamp drifts between playlists and fragments)
          var accurateTimeOffset = !(media && media.seeking) && (details.PTSKnown || !details.live);
          var initSegmentData = details.initSegment ? details.initSegment.data : [];
          var audioCodec = this._getAudioCodec(currentLevel);

          // transmux the MPEG-TS data to ISO-BMFF segments
          var demuxer = this.demuxer = this.demuxer || new _demuxer2.default(this.hls, 'main');
          demuxer.push(data.payload, initSegmentData, audioCodec, currentLevel.videoCodec, fragCurrent, details.totalduration, accurateTimeOffset);
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;

      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === _baseStreamController.State.PARSING) {
        var tracks = data.tracks,
            trackName = void 0,
            track = void 0;

        // if audio track is expected to come from audio stream controller, discard any coming from main
        if (tracks.audio && this.altAudio) {
          delete tracks.audio;
        }

        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          var audioCodec = this.levels[this.level].audioCodec,
              ua = navigator.userAgent.toLowerCase();
          if (audioCodec && this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec.indexOf('mp4a.40.5') !== -1) {
              audioCodec = 'mp4a.40.2';
            } else {
              audioCodec = 'mp4a.40.5';
            }
          }
          // in case AAC and HE-AAC audio codecs are signalled in manifest
          // force HE-AAC , as it seems that most browsers prefers that way,
          // except for mono streams OR on FF
          // these conditions might need to be reviewed ...
          if (this.audioCodecSwitch) {
            // don't force HE-AAC if mono stream
            if (track.metadata.channelCount !== 1 &&
            // don't force HE-AAC if firefox
            ua.indexOf('firefox') === -1) {
              audioCodec = 'mp4a.40.5';
            }
          }
          // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
          if (ua.indexOf('android') !== -1 && track.container !== 'audio/mpeg') {
            // Exclude mpeg audio
            audioCodec = 'mp4a.40.2';
            _logger.logger.log('Android: force audio codec to ' + audioCodec);
          }
          track.levelCodec = audioCodec;
          track.id = data.id;
        }
        track = tracks.video;
        if (track) {
          track.levelCodec = this.levels[this.level].videoCodec;
          track.id = data.id;
        }
        this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
        // loop through tracks that are going to be provided to bufferController
        for (trackName in tracks) {
          track = tracks[trackName];
          _logger.logger.log('main track:' + trackName + ',container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            this.appended = true;
            // arm pending Buffering flag before appending a segment
            this.pendingBuffering = true;
            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });
          }
        }
        // trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && !(data.type === 'audio' && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
      this.state === _baseStreamController.State.PARSING) {
        var level = this.levels[this.level],
            frag = fragCurrent;
        if (!Number.isFinite(data.endPTS)) {
          data.endPTS = data.startPTS + fragCurrent.duration;
          data.endDTS = data.startDTS + fragCurrent.duration;
        }

        if (data.hasAudio === true) {
          frag.addElementaryStream(_fragment2.default.ElementaryStreamTypes.AUDIO);
        }

        if (data.hasVideo === true) {
          frag.addElementaryStream(_fragment2.default.ElementaryStreamTypes.VIDEO);
        }

        _logger.logger.log('Parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb + ',dropped:' + (data.dropped || 0));

        // Detect gaps in a fragment  and try to fix it by finding a keyframe in the previous fragment (see _findFragments)
        if (data.type === 'video') {
          frag.dropped = data.dropped;
          if (frag.dropped) {
            if (!frag.backtracked) {
              var levelDetails = level.details;
              if (levelDetails && frag.sn === levelDetails.startSN) {
                _logger.logger.warn('missing video frame(s) on first frag, appending with gap', frag.sn);
              } else {
                _logger.logger.warn('missing video frame(s), backtracking fragment', frag.sn);
                // Return back to the IDLE state without appending to buffer
                // Causes findFragments to backtrack a segment and find the keyframe
                // Audio fragments arriving before video sets the nextLoadPosition, causing _findFragments to skip the backtracked fragment
                this.fragmentTracker.removeFragment(frag);
                frag.backtracked = true;
                this.nextLoadPosition = data.startPTS;
                this.state = _baseStreamController.State.IDLE;
                this.fragPrevious = frag;
                this.tick();
                return;
              }
            } else {
              _logger.logger.warn('Already backtracked on this fragment, appending with the gap', frag.sn);
            }
          } else {
            // Only reset the backtracked flag if we've loaded the frag without any dropped frames
            frag.backtracked = false;
          }
        }

        var drift = LevelHelper.updateFragPTSDTS(level.details, frag, data.startPTS, data.endPTS, data.startDTS, data.endDTS),
            hls = this.hls;
        hls.trigger(_events2.default.LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift, type: data.type, start: data.startPTS, end: data.endPTS });
        // has remuxer dropped video frames located before first keyframe ?
        [data.data1, data.data2].forEach(function (buffer) {
          // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
          // in that case it is useless to append following segments
          if (buffer && buffer.length && _this2.state === _baseStreamController.State.PARSING) {
            _this2.appended = true;
            // arm pending Buffering flag before appending a segment
            _this2.pendingBuffering = true;
            hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });
          }
        });
        // trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === _baseStreamController.State.PARSING) {
        this.stats.tparsed = window.performance.now();
        this.state = _baseStreamController.State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onAudioTrackSwitching',
    value: function onAudioTrackSwitching(data) {
      // if any URL found on new audio track, it is an alternate audio track
      var altAudio = !!data.url,
          trackId = data.id;
      // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
      // don't do anything if we switch to alt audio: audio stream controller is handling it.
      // we will just have to change buffer scheduling on audioTrackSwitched
      if (!altAudio) {
        if (this.mediaBuffer !== this.media) {
          _logger.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');
          this.mediaBuffer = this.media;
          var fragCurrent = this.fragCurrent;
          // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
          if (fragCurrent.loader) {
            _logger.logger.log('switching to main audio track, cancel main fragment load');
            fragCurrent.loader.abort();
          }
          this.fragCurrent = null;
          this.fragPrevious = null;
          // destroy demuxer to force init segment generation (following audio switch)
          if (this.demuxer) {
            this.demuxer.destroy();
            this.demuxer = null;
          }
          // switch to IDLE state to load new fragment
          this.state = _baseStreamController.State.IDLE;
        }
        var hls = this.hls;
        // switching to main audio, flush all audio and trigger track switched
        hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
        this.altAudio = false;
      }
    }
  }, {
    key: 'onAudioTrackSwitched',
    value: function onAudioTrackSwitched(data) {
      var trackId = data.id,
          altAudio = !!this.hls.audioTracks[trackId].url;
      if (altAudio) {
        var videoBuffer = this.videoBuffer;
        // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
        if (videoBuffer && this.mediaBuffer !== videoBuffer) {
          _logger.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');
          this.mediaBuffer = videoBuffer;
        }
      }
      this.altAudio = altAudio;
      this.tick();
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var tracks = data.tracks,
          mediaTrack = void 0,
          name = void 0,
          alternate = false;
      for (var type in tracks) {
        var track = tracks[type];
        if (track.id === 'main') {
          name = type;
          mediaTrack = track;
          // keep video source buffer reference
          if (type === 'video') {
            this.videoBuffer = tracks[type].buffer;
          }
        } else {
          alternate = true;
        }
      }
      if (alternate && mediaTrack) {
        _logger.logger.log('alternate track found, use ' + name + '.buffered to schedule main fragment loading');
        this.mediaBuffer = mediaTrack.buffer;
      } else {
        this.mediaBuffer = this.media;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'main') {
        var state = this.state;
        if (state === _baseStreamController.State.PARSING || state === _baseStreamController.State.PARSED) {
          // check if all buffers have been appended
          this.pendingBuffering = data.pending > 0;
          this._checkAppendedParsed();
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      // trigger handler right now
      if (this.state === _baseStreamController.State.PARSED && (!this.appended || !this.pendingBuffering)) {
        var frag = this.fragCurrent;
        if (frag) {
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('main buffered : ' + _timeRanges2.default.toString(media.buffered));
          this.fragPrevious = frag;
          var stats = this.stats;
          stats.tbuffered = window.performance.now();
          // we should get rid of this.fragLastKbps
          this.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });
          this.state = _baseStreamController.State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag || this.fragCurrent;
      // don't handle frag error not related to main fragment
      if (frag && frag.type !== 'main') {
        return;
      }

      // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
      var mediaBuffered = !!this.media && _bufferHelper.BufferHelper.isBuffered(this.media, this.media.currentTime) && _bufferHelper.BufferHelper.isBuffered(this.media, this.media.currentTime + 0.5);

      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          if (!data.fatal) {
            // keep retrying until the limit will be reached
            if (this.fragLoadError + 1 <= this.config.fragLoadingMaxRetry) {
              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
              var delay = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout);
              _logger.logger.warn('mediaController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = window.performance.now() + delay;
              // retry loading state
              // if loadedmetadata is not set, it means that we are emergency switch down on first frag
              // in that case, reset startFragRequested flag
              if (!this.loadedmetadata) {
                this.startFragRequested = false;
                this.nextLoadPosition = this.startPosition;
              }
              this.fragLoadError++;
              this.state = _baseStreamController.State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('mediaController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // switch error to fatal
              data.fatal = true;
              this.state = _baseStreamController.State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          if (this.state !== _baseStreamController.State.ERROR) {
            if (data.fatal) {
              // if fatal error, stop processing
              this.state = _baseStreamController.State.ERROR;
              _logger.logger.warn('streamController: ' + data.details + ',switch to ' + this.state + ' state ...');
            } else {
              // in case of non fatal error while loading level, if level controller is not retrying to load level , switch back to IDLE
              if (!data.levelRetry && this.state === _baseStreamController.State.WAITING_LEVEL) {
                this.state = _baseStreamController.State.IDLE;
              }
            }
          }
          break;
        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
          // if in appending state
          if (data.parent === 'main' && (this.state === _baseStreamController.State.PARSING || this.state === _baseStreamController.State.PARSED)) {
            // reduce max buf len if current position is buffered
            if (mediaBuffered) {
              this._reduceMaxBufferLength(this.config.maxBufferLength);
              this.state = _baseStreamController.State.IDLE;
            } else {
              // current position is not buffered, but browser is still complaining about buffer full error
              // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
              // in that case flush the whole buffer to recover
              _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush everything');
              this.fragCurrent = null;
              // flush everything
              this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
            }
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: '_reduceMaxBufferLength',
    value: function _reduceMaxBufferLength(minLength) {
      var config = this.config;
      if (config.maxMaxBufferLength >= minLength) {
        // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
        config.maxMaxBufferLength /= 2;
        _logger.logger.warn('main:reduce max buffer length to ' + config.maxMaxBufferLength + 's');
        return true;
      }
      return false;
    }

    /**
     * Checks the health of the buffer and attempts to resolve playback stalls.
     * @private
     */

  }, {
    key: '_checkBuffer',
    value: function _checkBuffer() {
      var media = this.media;

      if (!media || media.readyState === 0) {
        // Exit early if we don't have media or if the media hasn't bufferd anything yet (readyState 0)
        return;
      }

      var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;
      var buffered = mediaBuffer.buffered;

      if (!this.loadedmetadata && buffered.length) {
        this.loadedmetadata = true;
        this._seekToStartPos();
      } else if (this.immediateSwitch) {
        this.immediateLevelSwitchEnd();
      } else {
        this.gapController.poll(this.lastCurrentTime, buffered);
      }
    }
  }, {
    key: 'onFragLoadEmergencyAborted',
    value: function onFragLoadEmergencyAborted() {
      this.state = _baseStreamController.State.IDLE;
      // if loadedmetadata is not set, it means that we are emergency switch down on first frag
      // in that case, reset startFragRequested flag
      if (!this.loadedmetadata) {
        this.startFragRequested = false;
        this.nextLoadPosition = this.startPosition;
      }
      this.tick();
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      /* after successful buffer flushing, filter flushed fragments from bufferedFrags
        use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)
      */
      var media = this.mediaBuffer ? this.mediaBuffer : this.media;
      if (media) {
        // filter fragments potentially evicted from buffer. this is to avoid memleak on live streams
        this.fragmentTracker.detectEvictedFragments(_fragment2.default.ElementaryStreamTypes.VIDEO, media.buffered);
      }
      // move to IDLE once flush complete. this should trigger new fragment loading
      this.state = _baseStreamController.State.IDLE;
      // reset reference to frag
      this.fragPrevious = null;
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      this.audioCodecSwap = !this.audioCodecSwap;
    }
  }, {
    key: 'computeLivePosition',
    value: function computeLivePosition(sliding, levelDetails) {
      var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;
      return sliding + Math.max(0, levelDetails.totalduration - targetLatency);
    }

    /**
     * Seeks to the set startPosition if not equal to the mediaElement's current time.
     * @private
     */

  }, {
    key: '_seekToStartPos',
    value: function _seekToStartPos() {
      var media = this.media;

      var currentTime = media.currentTime;
      // only adjust currentTime if different from startPosition or if startPosition not buffered
      // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
      var startPosition = media.seeking ? currentTime : this.startPosition;
      // if currentTime not matching with expected startPosition or startPosition not buffered but close to first buffered
      if (currentTime !== startPosition) {
        // if startPosition not buffered, let's seek to buffered.start(0)
        _logger.logger.log('target start position not buffered, seek to buffered.start(0) ' + startPosition + ' from current time ' + currentTime + ' ');
        media.currentTime = startPosition;
      }
    }
  }, {
    key: '_getAudioCodec',
    value: function _getAudioCodec(currentLevel) {
      var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
      if (this.audioCodecSwap) {
        _logger.logger.log('swapping playlist audio codec');
        if (audioCodec) {
          if (audioCodec.indexOf('mp4a.40.5') !== -1) {
            audioCodec = 'mp4a.40.2';
          } else {
            audioCodec = 'mp4a.40.5';
          }
        }
      }

      return audioCodec;
    }
  }, {
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('main stream:' + previousState + '->' + nextState);
        this.hls.trigger(_events2.default.STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });
      }
    },
    get: function get() {
      return this._state;
    }
  }, {
    key: 'currentLevel',
    get: function get() {
      var media = this.media;
      if (media) {
        var frag = this.getBufferedFrag(media.currentTime);
        if (frag) {
          return frag.level;
        }
      }
      return -1;
    }
  }, {
    key: 'nextBufferedFrag',
    get: function get() {
      var media = this.media;
      if (media) {
        // first get end range of current fragment
        return this.followingBufferedFrag(this.getBufferedFrag(media.currentTime));
      } else {
        return null;
      }
    }
  }, {
    key: 'nextLevel',
    get: function get() {
      var frag = this.nextBufferedFrag;
      if (frag) {
        return frag.level;
      } else {
        return -1;
      }
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this._liveSyncPosition;
    },
    set: function set(value) {
      this._liveSyncPosition = value;
    }
  }]);

  return StreamController;
}(_baseStreamController2.default);

exports.default = StreamController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/subtitle-stream-controller.js":
/*!*************************************************************!*\
  !*** ./src/hls.js/controller/subtitle-stream-controller.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SubtitleStreamController = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _decrypter = __webpack_require__(/*! ../crypt/decrypter */ "./src/hls.js/crypt/decrypter.js");

var _decrypter2 = _interopRequireDefault(_decrypter);

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _fragmentFinders = __webpack_require__(/*! ./fragment-finders */ "./src/hls.js/controller/fragment-finders.js");

var _fragmentTracker = __webpack_require__(/*! ./fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _baseStreamController = __webpack_require__(/*! ./base-stream-controller */ "./src/hls.js/controller/base-stream-controller.js");

var _baseStreamController2 = _interopRequireDefault(_baseStreamController);

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @class SubtitleStreamController
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _window = window,
    performance = _window.performance;

var TICK_INTERVAL = 500; // how often to tick in ms

var SubtitleStreamController = exports.SubtitleStreamController = function (_BaseStreamController) {
  _inherits(SubtitleStreamController, _BaseStreamController);

  function SubtitleStreamController(hls, fragmentTracker) {
    _classCallCheck(this, SubtitleStreamController);

    var _this = _possibleConstructorReturn(this, (SubtitleStreamController.__proto__ || Object.getPrototypeOf(SubtitleStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.ERROR, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.SUBTITLE_TRACKS_UPDATED, _events2.default.SUBTITLE_TRACK_SWITCH, _events2.default.SUBTITLE_TRACK_LOADED, _events2.default.SUBTITLE_FRAG_PROCESSED, _events2.default.LEVEL_UPDATED));

    _this.fragmentTracker = fragmentTracker;
    _this.config = hls.config;
    _this.state = _baseStreamController.State.STOPPED;
    _this.tracks = [];
    _this.tracksBuffered = [];
    _this.currentTrackId = -1;
    _this.decrypter = new _decrypter2.default(hls, hls.config);
    // lastAVStart stores the time in seconds for the start time of a level load
    _this.lastAVStart = 0;
    _this._onMediaSeeking = _this.onMediaSeeking.bind(_this);
    return _this;
  }

  _createClass(SubtitleStreamController, [{
    key: 'onSubtitleFragProcessed',
    value: function onSubtitleFragProcessed(data) {
      var frag = data.frag,
          success = data.success;

      this.fragPrevious = frag;
      this.state = _baseStreamController.State.IDLE;
      if (!success) {
        return;
      }

      var buffered = this.tracksBuffered[this.currentTrackId];
      if (!buffered) {
        return;
      }

      // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo
      // so we can re-use the logic used to detect how much have been buffered
      var timeRange = void 0;
      var fragStart = frag.start;
      for (var i = 0; i < buffered.length; i++) {
        if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {
          timeRange = buffered[i];
          break;
        }
      }

      var fragEnd = frag.start + frag.duration;
      if (timeRange) {
        timeRange.end = fragEnd;
      } else {
        timeRange = {
          start: fragStart,
          end: fragEnd
        };
        buffered.push(timeRange);
      }
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(_ref) {
      var media = _ref.media;

      this.media = media;
      media.addEventListener('seeking', this._onMediaSeeking);
      this.state = _baseStreamController.State.IDLE;
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      this.media.removeEventListener('seeking', this._onMediaSeeking);
      this.media = null;
      this.state = _baseStreamController.State.STOPPED;
    }

    // If something goes wrong, proceed to next frag, if we were processing one.

  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle error not related to subtitle fragment
      if (!frag || frag.type !== 'subtitle') {
        return;
      }
      this.state = _baseStreamController.State.IDLE;
    }

    // Got all new subtitle tracks.

  }, {
    key: 'onSubtitleTracksUpdated',
    value: function onSubtitleTracksUpdated(data) {
      var _this2 = this;

      _logger.logger.log('subtitle tracks updated');
      this.tracksBuffered = [];
      this.tracks = data.subtitleTracks;
      this.tracks.forEach(function (track) {
        _this2.tracksBuffered[track.id] = [];
      });
    }
  }, {
    key: 'onSubtitleTrackSwitch',
    value: function onSubtitleTrackSwitch(data) {
      this.currentTrackId = data.id;

      if (!this.tracks || this.currentTrackId === -1) {
        this.clearInterval();
        return;
      }

      // Check if track has the necessary details to load fragments
      var currentTrack = this.tracks[this.currentTrackId];
      if (currentTrack && currentTrack.details) {
        this.setInterval(TICK_INTERVAL);
      }
    }

    // Got a new set of subtitle fragments.

  }, {
    key: 'onSubtitleTrackLoaded',
    value: function onSubtitleTrackLoaded(data) {
      var id = data.id,
          details = data.details;
      var currentTrackId = this.currentTrackId,
          tracks = this.tracks;

      var currentTrack = tracks[currentTrackId];
      if (id >= tracks.length || id !== currentTrackId || !currentTrack) {
        return;
      }

      if (details.live) {
        (0, _levelHelper.mergeSubtitlePlaylists)(currentTrack.details, details, this.lastAVStart);
      }
      currentTrack.details = details;
      this.setInterval(TICK_INTERVAL);
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === _baseStreamController.State.KEY_LOADING) {
        this.state = _baseStreamController.State.IDLE;
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent;
      var decryptData = data.frag.decryptdata;
      var fragLoaded = data.frag;
      var hls = this.hls;

      if (this.state === _baseStreamController.State.FRAG_LOADING && fragCurrent && data.frag.type === 'subtitle' && fragCurrent.sn === data.frag.sn) {
        // check to see if the payload needs to be decrypted
        if (data.payload.byteLength > 0 && decryptData && decryptData.key && decryptData.method === 'AES-128') {
          var startTime = performance.now();

          // decrypt the subtitles
          this.decrypter.decrypt(data.payload, decryptData.key.buffer, decryptData.iv.buffer, function (decryptedData) {
            var endTime = performance.now();
            hls.trigger(_events2.default.FRAG_DECRYPTED, { frag: fragLoaded, payload: decryptedData, stats: { tstart: startTime, tdecrypt: endTime } });
          });
        }
      }
    }
  }, {
    key: 'onLevelUpdated',
    value: function onLevelUpdated(_ref2) {
      var details = _ref2.details;

      var frags = details.fragments;
      this.lastAVStart = frags.length ? frags[0].start : 0;
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      if (!this.media) {
        this.state = _baseStreamController.State.IDLE;
        return;
      }

      switch (this.state) {
        case _baseStreamController.State.IDLE:
          {
            var config = this.config,
                currentTrackId = this.currentTrackId,
                fragmentTracker = this.fragmentTracker,
                media = this.media,
                tracks = this.tracks;

            if (!tracks || !tracks[currentTrackId] || !tracks[currentTrackId].details) {
              break;
            }

            var maxBufferHole = config.maxBufferHole,
                maxFragLookUpTolerance = config.maxFragLookUpTolerance;

            var maxConfigBuffer = Math.min(config.maxBufferLength, config.maxMaxBufferLength);
            var bufferedInfo = _bufferHelper.BufferHelper.bufferedInfo(this._getBuffered(), media.currentTime, maxBufferHole);
            var bufferEnd = bufferedInfo.end,
                bufferLen = bufferedInfo.len;


            var trackDetails = tracks[currentTrackId].details;
            var fragments = trackDetails.fragments;
            var fragLen = fragments.length;
            var end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration;

            if (bufferLen > maxConfigBuffer) {
              return;
            }

            var foundFrag = void 0;
            var fragPrevious = this.fragPrevious;
            if (bufferEnd < end) {
              if (fragPrevious && trackDetails.hasProgramDateTime) {
                foundFrag = (0, _fragmentFinders.findFragmentByPDT)(fragments, fragPrevious.endProgramDateTime, maxFragLookUpTolerance);
              }
              if (!foundFrag) {
                foundFrag = (0, _fragmentFinders.findFragmentByPTS)(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance);
              }
            } else {
              foundFrag = fragments[fragLen - 1];
            }

            if (foundFrag && foundFrag.encrypted) {
              _logger.logger.log('Loading key for ' + foundFrag.sn);
              this.state = _baseStreamController.State.KEY_LOADING;
              this.hls.trigger(_events2.default.KEY_LOADING, { frag: foundFrag });
            } else if (foundFrag && fragmentTracker.getState(foundFrag) === _fragmentTracker.FragmentState.NOT_LOADED) {
              // only load if fragment is not loaded
              this.fragCurrent = foundFrag;
              this.state = _baseStreamController.State.FRAG_LOADING;
              this.hls.trigger(_events2.default.FRAG_LOADING, { frag: foundFrag });
            }
          }
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.lastAVStart = 0;
      _get(SubtitleStreamController.prototype.__proto__ || Object.getPrototypeOf(SubtitleStreamController.prototype), 'stopLoad', this).call(this);
    }
  }, {
    key: '_getBuffered',
    value: function _getBuffered() {
      return this.tracksBuffered[this.currentTrackId] || [];
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      this.fragPrevious = null;
    }
  }]);

  return SubtitleStreamController;
}(_baseStreamController2.default);

/***/ }),

/***/ "./src/hls.js/controller/subtitle-track-controller.js":
/*!************************************************************!*\
  !*** ./src/hls.js/controller/subtitle-track-controller.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SubtitleTrackController = function (_EventHandler) {
  _inherits(SubtitleTrackController, _EventHandler);

  function SubtitleTrackController(hls) {
    _classCallCheck(this, SubtitleTrackController);

    var _this = _possibleConstructorReturn(this, (SubtitleTrackController.__proto__ || Object.getPrototypeOf(SubtitleTrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADED, _events2.default.SUBTITLE_TRACK_LOADED));

    _this.tracks = [];
    _this.trackId = -1;
    _this.media = null;
    _this.stopped = true;

    /**
     * @member {boolean} subtitleDisplay Enable/disable subtitle display rendering
     */
    _this.subtitleDisplay = true;
    return _this;
  }

  _createClass(SubtitleTrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Listen for subtitle track change, then extract the current track ID.

  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var _this2 = this;

      this.media = data.media;
      if (!this.media) {
        return;
      }

      if (this.queuedDefaultTrack) {
        this.subtitleTrack = this.queuedDefaultTrack;
        delete this.queuedDefaultTrack;
      }

      this.trackChangeListener = this._onTextTracksChanged.bind(this);

      this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);
      if (this.useTextTrackPolling) {
        this.subtitlePollingInterval = setInterval(function () {
          _this2.trackChangeListener();
        }, 500);
      } else {
        this.media.textTracks.addEventListener('change', this.trackChangeListener);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      if (!this.media) {
        return;
      }

      if (this.useTextTrackPolling) {
        clearInterval(this.subtitlePollingInterval);
      } else {
        this.media.textTracks.removeEventListener('change', this.trackChangeListener);
      }

      this.media = null;
    }

    // Fired whenever a new manifest is loaded.

  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this3 = this;

      var tracks = data.subtitles || [];
      this.tracks = tracks;
      this.hls.trigger(_events2.default.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: tracks });

      // loop through available subtitle tracks and autoselect default if needed
      // TODO: improve selection logic to handle forced, etc
      tracks.forEach(function (track) {
        if (track.default) {
          // setting this.subtitleTrack will trigger internal logic
          // if media has not been attached yet, it will fail
          // we keep a reference to the default track id
          // and we'll set subtitleTrack when onMediaAttached is triggered
          if (_this3.media) {
            _this3.subtitleTrack = track.id;
          } else {
            _this3.queuedDefaultTrack = track.id;
          }
        }
      });
    }
  }, {
    key: 'onSubtitleTrackLoaded',
    value: function onSubtitleTrackLoaded(data) {
      var _this4 = this;

      var id = data.id,
          details = data.details;
      var trackId = this.trackId,
          tracks = this.tracks;

      var currentTrack = tracks[trackId];
      if (id >= tracks.length || id !== trackId || !currentTrack || this.stopped) {
        this._clearReloadTimer();
        return;
      }

      _logger.logger.log('subtitle track ' + id + ' loaded');
      if (details.live) {
        var reloadInterval = (0, _levelHelper.computeReloadInterval)(currentTrack.details, details, data.stats.trequest);
        _logger.logger.log('Reloading live subtitle playlist in ' + reloadInterval + 'ms');
        this.timer = setTimeout(function () {
          _this4._loadCurrentTrack();
        }, reloadInterval);
      } else {
        this._clearReloadTimer();
      }
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      this.stopped = false;
      this._loadCurrentTrack();
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.stopped = true;
      this._clearReloadTimer();
    }

    /** get alternate subtitle tracks list from playlist **/

  }, {
    key: '_clearReloadTimer',
    value: function _clearReloadTimer() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    }
  }, {
    key: '_loadCurrentTrack',
    value: function _loadCurrentTrack() {
      var trackId = this.trackId,
          tracks = this.tracks,
          hls = this.hls;

      var currentTrack = tracks[trackId];
      if (trackId < 0 || !currentTrack || currentTrack.details && !currentTrack.details.live) {
        return;
      }
      _logger.logger.log('Loading subtitle track ' + trackId);
      hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: currentTrack.url, id: trackId });
    }

    /**
     * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.
     * This operates on the DOM textTracks.
     * A value of -1 will disable all subtitle tracks.
     * @param newId - The id of the next track to enable
     * @private
     */

  }, {
    key: '_toggleTrackModes',
    value: function _toggleTrackModes(newId) {
      var media = this.media,
          subtitleDisplay = this.subtitleDisplay,
          trackId = this.trackId;

      if (!media) {
        return;
      }

      var textTracks = filterSubtitleTracks(media.textTracks);
      if (newId === -1) {
        [].slice.call(textTracks).forEach(function (track) {
          track.mode = 'disabled';
        });
      } else {
        var oldTrack = textTracks[trackId];
        if (oldTrack) {
          oldTrack.mode = 'disabled';
        }
      }

      var nextTrack = textTracks[newId];
      if (nextTrack) {
        nextTrack.mode = subtitleDisplay ? 'showing' : 'hidden';
      }
    }

    /**
       * This method is responsible for validating the subtitle index and periodically reloading if live.
       * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.
       * @param newId - The id of the subtitle track to activate.
       */

  }, {
    key: '_setSubtitleTrackInternal',
    value: function _setSubtitleTrackInternal(newId) {
      var hls = this.hls,
          tracks = this.tracks;

      if (!Number.isFinite(newId) || newId < -1 || newId >= tracks.length) {
        return;
      }

      this.trackId = newId;
      _logger.logger.log('Switching to subtitle track ' + newId);
      hls.trigger(_events2.default.SUBTITLE_TRACK_SWITCH, { id: newId });
      this._loadCurrentTrack();
    }
  }, {
    key: '_onTextTracksChanged',
    value: function _onTextTracksChanged() {
      // Media is undefined when switching streams via loadSource()
      if (!this.media) {
        return;
      }

      var trackId = -1;
      var tracks = filterSubtitleTracks(this.media.textTracks);
      for (var id = 0; id < tracks.length; id++) {
        if (tracks[id].mode === 'hidden') {
          // Do not break in case there is a following track with showing.
          trackId = id;
        } else if (tracks[id].mode === 'showing') {
          trackId = id;
          break;
        }
      }

      // Setting current subtitleTrack will invoke code.
      this.subtitleTrack = trackId;
    }
  }, {
    key: 'subtitleTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected subtitle track (index in subtitle track lists) **/

  }, {
    key: 'subtitleTrack',
    get: function get() {
      return this.trackId;
    }

    /** select a subtitle track, based on its index in subtitle track lists**/
    ,
    set: function set(subtitleTrackId) {
      if (this.trackId !== subtitleTrackId) {
        this._toggleTrackModes(subtitleTrackId);
        this._setSubtitleTrackInternal(subtitleTrackId);
      }
    }
  }]);

  return SubtitleTrackController;
}(_eventHandler2.default);

function filterSubtitleTracks(textTrackList) {
  var tracks = [];
  for (var i = 0; i < textTrackList.length; i++) {
    var track = textTrackList[i];
    // Edge adds a track without a label; we don't want to use it
    if (track.kind === 'subtitles' && track.label) {
      tracks.push(textTrackList[i]);
    }
  }
  return tracks;
}

exports.default = SubtitleTrackController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/timeline-controller.js":
/*!******************************************************!*\
  !*** ./src/hls.js/controller/timeline-controller.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _cea608Parser = __webpack_require__(/*! ../utils/cea-608-parser */ "./src/hls.js/utils/cea-608-parser.js");

var _cea608Parser2 = _interopRequireDefault(_cea608Parser);

var _outputFilter = __webpack_require__(/*! ../utils/output-filter */ "./src/hls.js/utils/output-filter.js");

var _outputFilter2 = _interopRequireDefault(_outputFilter);

var _webvttParser = __webpack_require__(/*! ../utils/webvtt-parser */ "./src/hls.js/utils/webvtt-parser.js");

var _webvttParser2 = _interopRequireDefault(_webvttParser);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _texttrackUtils = __webpack_require__(/*! ../utils/texttrack-utils */ "./src/hls.js/utils/texttrack-utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Timeline Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

function canReuseVttTextTrack(inUseTrack, manifestTrack) {
  return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
}

function intersection(x1, x2, y1, y2) {
  return Math.min(x2, y2) - Math.max(x1, y1);
}

var TimelineController = function (_EventHandler) {
  _inherits(TimelineController, _EventHandler);

  function TimelineController(hls) {
    _classCallCheck(this, TimelineController);

    var _this = _possibleConstructorReturn(this, (TimelineController.__proto__ || Object.getPrototypeOf(TimelineController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_USERDATA, _events2.default.FRAG_DECRYPTED, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.FRAG_LOADED, _events2.default.LEVEL_SWITCHING, _events2.default.INIT_PTS_FOUND));

    _this.hls = hls;
    _this.config = hls.config;
    _this.enabled = true;
    _this.Cues = hls.config.cueHandler;
    _this.textTracks = [];
    _this.tracks = [];
    _this.unparsedVttFrags = [];
    _this.initPTS = [];
    _this.cueRanges = [];
    _this.captionsTracks = {};

    _this.captionsProperties = {
      textTrack1: {
        label: _this.config.captionsTextTrack1Label,
        languageCode: _this.config.captionsTextTrack1LanguageCode
      },
      textTrack2: {
        label: _this.config.captionsTextTrack2Label,
        languageCode: _this.config.captionsTextTrack2LanguageCode
      }
    };

    if (_this.config.enableCEA708Captions) {
      var channel1 = new _outputFilter2.default(_this, 'textTrack1');
      var channel2 = new _outputFilter2.default(_this, 'textTrack2');

      _this.cea608Parser = new _cea608Parser2.default(0, channel1, channel2);
    }
    return _this;
  }

  _createClass(TimelineController, [{
    key: 'addCues',
    value: function addCues(trackName, startTime, endTime, screen) {
      // skip cues which overlap more than 50% with previously parsed time ranges
      var ranges = this.cueRanges;
      var merged = false;
      for (var i = ranges.length; i--;) {
        var cueRange = ranges[i];
        var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
        if (overlap >= 0) {
          cueRange[0] = Math.min(cueRange[0], startTime);
          cueRange[1] = Math.max(cueRange[1], endTime);
          merged = true;
          if (overlap / (endTime - startTime) > 0.5) {
            return;
          }
        }
      }
      if (!merged) {
        ranges.push([startTime, endTime]);
      }

      this.Cues.newCue(this.captionsTracks[trackName], startTime, endTime, screen);
    }

    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.

  }, {
    key: 'onInitPtsFound',
    value: function onInitPtsFound(data) {
      var _this2 = this;

      if (data.id === 'main') {
        this.initPTS[data.frag.cc] = data.initPTS;
      }

      // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.
      // Parse any unparsed fragments upon receiving the initial PTS.
      if (this.unparsedVttFrags.length) {
        var unparsedVttFrags = this.unparsedVttFrags;
        this.unparsedVttFrags = [];
        unparsedVttFrags.forEach(function (frag) {
          _this2.onFragLoaded(frag);
        });
      }
    }
  }, {
    key: 'getExistingTrack',
    value: function getExistingTrack(trackName) {
      var media = this.media;

      if (media) {
        for (var i = 0; i < media.textTracks.length; i++) {
          var textTrack = media.textTracks[i];
          if (textTrack[trackName]) {
            return textTrack;
          }
        }
      }
      return null;
    }
  }, {
    key: 'createCaptionsTrack',
    value: function createCaptionsTrack(trackName) {
      var _captionsProperties$t = this.captionsProperties[trackName],
          label = _captionsProperties$t.label,
          languageCode = _captionsProperties$t.languageCode;

      var captionsTracks = this.captionsTracks;
      if (!captionsTracks[trackName]) {
        // Enable reuse of existing text track.
        var existingTrack = this.getExistingTrack(trackName);
        if (!existingTrack) {
          var textTrack = this.createTextTrack('captions', label, languageCode);
          if (textTrack) {
            // Set a special property on the track so we know it's managed by Hls.js
            textTrack[trackName] = true;
            captionsTracks[trackName] = textTrack;
          }
        } else {
          captionsTracks[trackName] = existingTrack;
          (0, _texttrackUtils.clearCurrentCues)(captionsTracks[trackName]);
          (0, _texttrackUtils.sendAddTrackEvent)(captionsTracks[trackName], this.media);
        }
      }
    }
  }, {
    key: 'createTextTrack',
    value: function createTextTrack(kind, label, lang) {
      var media = this.media;
      if (media) {
        return media.addTextTrack(kind, label, lang);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media;
      this._cleanTracks();
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var captionsTracks = this.captionsTracks;

      Object.keys(captionsTracks).forEach(function (trackName) {
        (0, _texttrackUtils.clearCurrentCues)(captionsTracks[trackName]);
        delete captionsTracks[trackName];
      });
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.lastSn = -1; // Detect discontiguity in fragment parsing
      this.prevCC = -1;
      this.vttCCs = { // Detect discontinuity in subtitle manifests
        ccOffset: 0,
        presentationOffset: 0,
        0: {
          start: 0, prevCC: -1, new: false
        }
      };
      this._cleanTracks();
    }
  }, {
    key: '_cleanTracks',
    value: function _cleanTracks() {
      // clear outdated subtitles
      var media = this.media;
      if (media) {
        var textTracks = media.textTracks;
        if (textTracks) {
          for (var i = 0; i < textTracks.length; i++) {
            (0, _texttrackUtils.clearCurrentCues)(textTracks[i]);
          }
        }
      }
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this3 = this;

      this.textTracks = [];
      this.unparsedVttFrags = this.unparsedVttFrags || [];
      this.initPTS = [];
      this.cueRanges = [];

      if (this.config.enableWebVTT) {
        this.tracks = data.subtitles || [];
        var inUseTracks = this.media ? this.media.textTracks : [];

        this.tracks.forEach(function (track, index) {
          var textTrack = void 0;
          if (index < inUseTracks.length) {
            var inUseTrack = null;

            for (var i = 0; i < inUseTracks.length; i++) {
              if (canReuseVttTextTrack(inUseTracks[i], track)) {
                inUseTrack = inUseTracks[i];
                break;
              }
            }

            // Reuse tracks with the same label, but do not reuse 608/708 tracks
            if (inUseTrack) {
              textTrack = inUseTrack;
            }
          }
          if (!textTrack) {
            textTrack = _this3.createTextTrack('subtitles', track.name, track.lang);
          }

          if (track.default) {
            textTrack.mode = _this3.hls.subtitleDisplay ? 'showing' : 'hidden';
          } else {
            textTrack.mode = 'disabled';
          }

          _this3.textTracks.push(textTrack);
        });
      }
    }
  }, {
    key: 'onLevelSwitching',
    value: function onLevelSwitching() {
      this.enabled = this.hls.currentLevel.closedCaptions !== 'NONE';
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var frag = data.frag,
          payload = data.payload;
      if (frag.type === 'main') {
        var sn = frag.sn;
        // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack
        if (sn !== this.lastSn + 1) {
          var cea608Parser = this.cea608Parser;
          if (cea608Parser) {
            cea608Parser.reset();
          }
        }
        this.lastSn = sn;
      } // eslint-disable-line brace-style
      // If fragment is subtitle type, parse as WebVTT.
      else if (frag.type === 'subtitle') {
          if (payload.byteLength) {
            // We need an initial synchronisation PTS. Store fragments as long as none has arrived.
            if (!Number.isFinite(this.initPTS[frag.cc])) {
              this.unparsedVttFrags.push(data);
              if (this.initPTS.length) {
                // finish unsuccessfully, otherwise the subtitle-stream-controller could be blocked from loading new frags.
                this.hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
              }
              return;
            }

            var decryptData = frag.decryptdata;
            // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.
            if (decryptData == null || decryptData.key == null || decryptData.method !== 'AES-128') {
              this._parseVTTs(frag, payload);
            }
          } else {
            // In case there is no payload, finish unsuccessfully.
            this.hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
          }
        }
    }
  }, {
    key: '_parseVTTs',
    value: function _parseVTTs(frag, payload) {
      var vttCCs = this.vttCCs;
      if (!vttCCs[frag.cc]) {
        vttCCs[frag.cc] = { start: frag.start, prevCC: this.prevCC, new: true };
        this.prevCC = frag.cc;
      }
      var textTracks = this.textTracks,
          hls = this.hls;

      // Parse the WebVTT file contents.
      _webvttParser2.default.parse(payload, this.initPTS[frag.cc], vttCCs, frag.cc, function (cues) {
        var currentTrack = textTracks[frag.level];
        // WebVTTParser.parse is an async method and if the currently selected text track mode is set to "disabled"
        // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null
        // and trying to access getCueById method of cues will throw an exception
        if (currentTrack.mode === 'disabled') {
          hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
          return;
        }
        // Add cues and trigger event with success true.
        cues.forEach(function (cue) {
          // Sometimes there are cue overlaps on segmented vtts so the same
          // cue can appear more than once in different vtt files.
          // This avoid showing duplicated cues with same timecode and text.
          if (!currentTrack.cues.getCueById(cue.id)) {
            try {
              currentTrack.addCue(cue);
            } catch (err) {
              var textTrackCue = new window.TextTrackCue(cue.startTime, cue.endTime, cue.text);
              textTrackCue.id = cue.id;
              currentTrack.addCue(textTrackCue);
            }
          }
        });
        hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: true, frag: frag });
      }, function (e) {
        // Something went wrong while parsing. Trigger event with success false.
        _logger.logger.log('Failed to parse VTT cue: ' + e);
        hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
      });
    }
  }, {
    key: 'onFragDecrypted',
    value: function onFragDecrypted(data) {
      var decryptedData = data.payload,
          frag = data.frag;

      if (frag.type === 'subtitle') {
        if (!Number.isFinite(this.initPTS[frag.cc])) {
          this.unparsedVttFrags.push(data);
          return;
        }

        this._parseVTTs(frag, decryptedData);
      }
    }
  }, {
    key: 'onFragParsingUserdata',
    value: function onFragParsingUserdata(data) {
      // push all of the CEA-708 messages into the interpreter
      // immediately. It will create the proper timestamps based on our PTS value
      if (this.enabled && this.config.enableCEA708Captions) {
        for (var i = 0; i < data.samples.length; i++) {
          var ccdatas = this.extractCea608Data(data.samples[i].bytes);
          this.cea608Parser.addData(data.samples[i].pts, ccdatas);
        }
      }
    }
  }, {
    key: 'extractCea608Data',
    value: function extractCea608Data(byteArray) {
      var count = byteArray[0] & 31;
      var position = 2;
      var tmpByte = void 0,
          ccbyte1 = void 0,
          ccbyte2 = void 0,
          ccValid = void 0,
          ccType = void 0;
      var actualCCBytes = [];

      for (var j = 0; j < count; j++) {
        tmpByte = byteArray[position++];
        ccbyte1 = 0x7F & byteArray[position++];
        ccbyte2 = 0x7F & byteArray[position++];
        ccValid = (4 & tmpByte) !== 0;
        ccType = 3 & tmpByte;

        if (ccbyte1 === 0 && ccbyte2 === 0) {
          continue;
        }

        if (ccValid) {
          if (ccType === 0) {
            // || ccType === 1
            actualCCBytes.push(ccbyte1);
            actualCCBytes.push(ccbyte2);
          }
        }
      }
      return actualCCBytes;
    }
  }]);

  return TimelineController;
}(_eventHandler2.default);

exports.default = TimelineController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/crypt/aes-crypto.js":
/*!****************************************!*\
  !*** ./src/hls.js/crypt/aes-crypto.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AESCrypto = function () {
  function AESCrypto(subtle, iv) {
    _classCallCheck(this, AESCrypto);

    this.subtle = subtle;
    this.aesIV = iv;
  }

  _createClass(AESCrypto, [{
    key: 'decrypt',
    value: function decrypt(data, key) {
      return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);
    }
  }]);

  return AESCrypto;
}();

exports.default = AESCrypto;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/crypt/aes-decryptor.js":
/*!*******************************************!*\
  !*** ./src/hls.js/crypt/aes-decryptor.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.removePadding = removePadding;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// PKCS7
function removePadding(buffer) {
  var outputBytes = buffer.byteLength;
  var paddingBytes = outputBytes && new DataView(buffer).getUint8(outputBytes - 1);
  if (paddingBytes) {
    return buffer.slice(0, outputBytes - paddingBytes);
  } else {
    return buffer;
  }
}

var AESDecryptor = function () {
  function AESDecryptor() {
    _classCallCheck(this, AESDecryptor);

    // Static after running initTable
    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.sBox = new Uint32Array(256);
    this.invSBox = new Uint32Array(256);

    // Changes during runtime
    this.key = new Uint32Array(0);

    this.initTable();
  }

  // Using view.getUint32() also swaps the byte order.


  _createClass(AESDecryptor, [{
    key: 'uint8ArrayToUint32Array_',
    value: function uint8ArrayToUint32Array_(arrayBuffer) {
      var view = new DataView(arrayBuffer);
      var newArray = new Uint32Array(4);
      for (var i = 0; i < 4; i++) {
        newArray[i] = view.getUint32(i * 4);
      }

      return newArray;
    }
  }, {
    key: 'initTable',
    value: function initTable() {
      var sBox = this.sBox;
      var invSBox = this.invSBox;
      var subMix = this.subMix;
      var subMix0 = subMix[0];
      var subMix1 = subMix[1];
      var subMix2 = subMix[2];
      var subMix3 = subMix[3];
      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var d = new Uint32Array(256);
      var x = 0;
      var xi = 0;
      var i = 0;
      for (i = 0; i < 256; i++) {
        if (i < 128) {
          d[i] = i << 1;
        } else {
          d[i] = i << 1 ^ 0x11b;
        }
      }

      for (i = 0; i < 256; i++) {
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        sBox[x] = sx;
        invSBox[sx] = x;

        // Compute multiplication
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];

        // Compute sub/invSub bytes, mix columns tables
        var t = d[sx] * 0x101 ^ sx * 0x1010100;
        subMix0[x] = t << 24 | t >>> 8;
        subMix1[x] = t << 16 | t >>> 16;
        subMix2[x] = t << 8 | t >>> 24;
        subMix3[x] = t;

        // Compute inv sub bytes, inv mix columns tables
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        invSubMix0[sx] = t << 24 | t >>> 8;
        invSubMix1[sx] = t << 16 | t >>> 16;
        invSubMix2[sx] = t << 8 | t >>> 24;
        invSubMix3[sx] = t;

        // Compute next counter
        if (!x) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
    }
  }, {
    key: 'expandKey',
    value: function expandKey(keyBuffer) {
      // convert keyBuffer to Uint32Array
      var key = this.uint8ArrayToUint32Array_(keyBuffer);
      var sameKey = true;
      var offset = 0;

      while (offset < key.length && sameKey) {
        sameKey = key[offset] === this.key[offset];
        offset++;
      }

      if (sameKey) {
        return;
      }

      this.key = key;
      var keySize = this.keySize = key.length;

      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
        throw new Error('Invalid aes key size=' + keySize);
      }

      var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
      var ksRow = void 0;
      var invKsRow = void 0;

      var keySchedule = this.keySchedule = new Uint32Array(ksRows);
      var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
      var sbox = this.sBox;
      var rcon = this.rcon;

      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var prev = void 0;
      var t = void 0;

      for (ksRow = 0; ksRow < ksRows; ksRow++) {
        if (ksRow < keySize) {
          prev = keySchedule[ksRow] = key[ksRow];
          continue;
        }
        t = prev;

        if (ksRow % keySize === 0) {
          // Rot word
          t = t << 8 | t >>> 24;

          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];

          // Mix Rcon
          t ^= rcon[ksRow / keySize | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
        }

        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
      }

      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;
        if (invKsRow & 3) {
          t = keySchedule[ksRow];
        } else {
          t = keySchedule[ksRow - 4];
        }

        if (invKsRow < 4 || ksRow <= 4) {
          invKeySchedule[invKsRow] = t;
        } else {
          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
        }

        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
      }
    }

    // Adding this as a method greatly improves performance.

  }, {
    key: 'networkToHostOrderSwap',
    value: function networkToHostOrderSwap(word) {
      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
    }
  }, {
    key: 'decrypt',
    value: function decrypt(inputArrayBuffer, offset, aesIV, removePKCS7Padding) {
      var nRounds = this.keySize + 6;
      var invKeySchedule = this.invKeySchedule;
      var invSBOX = this.invSBox;

      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var initVector = this.uint8ArrayToUint32Array_(aesIV);
      var initVector0 = initVector[0];
      var initVector1 = initVector[1];
      var initVector2 = initVector[2];
      var initVector3 = initVector[3];

      var inputInt32 = new Int32Array(inputArrayBuffer);
      var outputInt32 = new Int32Array(inputInt32.length);

      var t0 = void 0,
          t1 = void 0,
          t2 = void 0,
          t3 = void 0;
      var s0 = void 0,
          s1 = void 0,
          s2 = void 0,
          s3 = void 0;
      var inputWords0 = void 0,
          inputWords1 = void 0,
          inputWords2 = void 0,
          inputWords3 = void 0;

      var ksRow = void 0,
          i = void 0;
      var swapWord = this.networkToHostOrderSwap;

      while (offset < inputInt32.length) {
        inputWords0 = swapWord(inputInt32[offset]);
        inputWords1 = swapWord(inputInt32[offset + 1]);
        inputWords2 = swapWord(inputInt32[offset + 2]);
        inputWords3 = swapWord(inputInt32[offset + 3]);

        s0 = inputWords0 ^ invKeySchedule[0];
        s1 = inputWords3 ^ invKeySchedule[1];
        s2 = inputWords2 ^ invKeySchedule[2];
        s3 = inputWords1 ^ invKeySchedule[3];

        ksRow = 4;

        // Iterate through the rounds of decryption
        for (i = 1; i < nRounds; i++) {
          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
          // Update state
          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;

          ksRow = ksRow + 4;
        }

        // Shift rows, sub bytes, add round key
        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];
        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
        ksRow = ksRow + 3;

        // Write
        outputInt32[offset] = swapWord(t0 ^ initVector0);
        outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
        outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
        outputInt32[offset + 3] = swapWord(t1 ^ initVector3);

        // reset initVector to last 4 unsigned int
        initVector0 = inputWords0;
        initVector1 = inputWords1;
        initVector2 = inputWords2;
        initVector3 = inputWords3;

        offset = offset + 4;
      }

      return removePKCS7Padding ? removePadding(outputInt32.buffer) : outputInt32.buffer;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.key = undefined;
      this.keySize = undefined;
      this.ksRows = undefined;

      this.sBox = undefined;
      this.invSBox = undefined;
      this.subMix = undefined;
      this.invSubMix = undefined;
      this.keySchedule = undefined;
      this.invKeySchedule = undefined;

      this.rcon = undefined;
    }
  }]);

  return AESDecryptor;
}();

exports.default = AESDecryptor;

/***/ }),

/***/ "./src/hls.js/crypt/decrypter.js":
/*!***************************************!*\
  !*** ./src/hls.js/crypt/decrypter.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _aesCrypto = __webpack_require__(/*! ./aes-crypto */ "./src/hls.js/crypt/aes-crypto.js");

var _aesCrypto2 = _interopRequireDefault(_aesCrypto);

var _fastAesKey = __webpack_require__(/*! ./fast-aes-key */ "./src/hls.js/crypt/fast-aes-key.js");

var _fastAesKey2 = _interopRequireDefault(_fastAesKey);

var _aesDecryptor = __webpack_require__(/*! ./aes-decryptor */ "./src/hls.js/crypt/aes-decryptor.js");

var _aesDecryptor2 = _interopRequireDefault(_aesDecryptor);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _getSelfScope = __webpack_require__(/*! ../utils/get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// see https://stackoverflow.com/a/11237259/589493
var global = (0, _getSelfScope.getSelfScope)(); // safeguard for code that might run both on worker and main thread

var Decrypter = function () {
  function Decrypter(observer, config) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$removePKCS7Paddi = _ref.removePKCS7Padding,
        removePKCS7Padding = _ref$removePKCS7Paddi === undefined ? true : _ref$removePKCS7Paddi;

    _classCallCheck(this, Decrypter);

    this.logEnabled = true;
    this.observer = observer;
    this.config = config;
    this.removePKCS7Padding = removePKCS7Padding;
    // built in decryptor expects PKCS7 padding
    if (removePKCS7Padding) {
      try {
        var browserCrypto = global.crypto;
        if (browserCrypto) {
          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
        }
      } catch (e) {}
    }
    this.disableWebCrypto = !this.subtle;
  }

  _createClass(Decrypter, [{
    key: 'isSync',
    value: function isSync() {
      return this.disableWebCrypto && this.config.enableSoftwareAES;
    }
  }, {
    key: 'decrypt',
    value: function decrypt(data, key, iv, callback) {
      var _this = this;

      if (this.disableWebCrypto && this.config.enableSoftwareAES) {
        if (this.logEnabled) {
          _logger.logger.log('JS AES decrypt');
          this.logEnabled = false;
        }
        var decryptor = this.decryptor;
        if (!decryptor) {
          this.decryptor = decryptor = new _aesDecryptor2.default();
        }

        decryptor.expandKey(key);
        callback(decryptor.decrypt(data, 0, iv, this.removePKCS7Padding));
      } else {
        if (this.logEnabled) {
          _logger.logger.log('WebCrypto AES decrypt');
          this.logEnabled = false;
        }
        var subtle = this.subtle;
        if (this.key !== key) {
          this.key = key;
          this.fastAesKey = new _fastAesKey2.default(subtle, key);
        }

        this.fastAesKey.expandKey().then(function (aesKey) {
          // decrypt using web crypto
          var crypto = new _aesCrypto2.default(subtle, iv);
          crypto.decrypt(data, aesKey).catch(function (err) {
            _this.onWebCryptoError(err, data, key, iv, callback);
          }).then(function (result) {
            callback(result);
          });
        }).catch(function (err) {
          _this.onWebCryptoError(err, data, key, iv, callback);
        });
      }
    }
  }, {
    key: 'onWebCryptoError',
    value: function onWebCryptoError(err, data, key, iv, callback) {
      if (this.config.enableSoftwareAES) {
        _logger.logger.log('WebCrypto Error, disable WebCrypto API');
        this.disableWebCrypto = true;
        this.logEnabled = true;
        this.decrypt(data, key, iv, callback);
      } else {
        _logger.logger.error('decrypting error : ' + err.message);
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var decryptor = this.decryptor;
      if (decryptor) {
        decryptor.destroy();
        this.decryptor = undefined;
      }
    }
  }]);

  return Decrypter;
}();

exports.default = Decrypter;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/crypt/fast-aes-key.js":
/*!******************************************!*\
  !*** ./src/hls.js/crypt/fast-aes-key.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FastAESKey = function () {
  function FastAESKey(subtle, key) {
    _classCallCheck(this, FastAESKey);

    this.subtle = subtle;
    this.key = key;
  }

  _createClass(FastAESKey, [{
    key: 'expandKey',
    value: function expandKey() {
      return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);
    }
  }]);

  return FastAESKey;
}();

exports.default = FastAESKey;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/aacdemuxer.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/aacdemuxer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AAC demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _adts = __webpack_require__(/*! ./adts */ "./src/hls.js/demux/adts.js");

var ADTS = _interopRequireWildcard(_adts);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _id = __webpack_require__(/*! ../demux/id3 */ "./src/hls.js/demux/id3.js");

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AACDemuxer = function () {
  function AACDemuxer(observer, remuxer, config) {
    _classCallCheck(this, AACDemuxer);

    this.observer = observer;
    this.config = config;
    this.remuxer = remuxer;
  }

  _createClass(AACDemuxer, [{
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this._audioTrack = { container: 'audio/adts', type: 'audio', id: 0, sequenceNumber: 0, isAAC: true, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
    }
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var track = this._audioTrack;
      var id3Data = _id2.default.getID3Data(data, 0) || [];
      var timestamp = _id2.default.getTimeStamp(id3Data);
      var pts = Number.isFinite(timestamp) ? timestamp * 90 : timeOffset * 90000;
      var frameIndex = 0;
      var stamp = pts;
      var length = data.length;
      var offset = id3Data.length;

      var id3Samples = [{ pts: stamp, dts: stamp, data: id3Data }];

      while (offset < length - 1) {
        if (ADTS.isHeader(data, offset) && offset + 5 < length) {
          ADTS.initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
          var frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);
          if (frame) {
            offset += frame.length;
            stamp = frame.sample.pts;
            frameIndex++;
          } else {
            _logger.logger.log('Unable to parse AAC frame');
            break;
          }
        } else if (_id2.default.isHeader(data, offset)) {
          id3Data = _id2.default.getID3Data(data, offset);
          id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
          offset += id3Data.length;
        } else {
          // nothing found, keep looking
          offset++;
        }
      }

      this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      if (!data) {
        return false;
      }

      // Check for the ADTS sync word
      // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
      // Layer bits (position 14 and 15) in header should be always 0 for ADTS
      // More info https://wiki.multimedia.cx/index.php?title=ADTS
      var id3Data = _id2.default.getID3Data(data, 0) || [];
      var offset = id3Data.length;

      for (var length = data.length; offset < length; offset++) {
        if (ADTS.probe(data, offset)) {
          _logger.logger.log('ADTS sync word found !');
          return true;
        }
      }
      return false;
    }
  }]);

  return AACDemuxer;
}();

exports.default = AACDemuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/adts.js":
/*!**********************************!*\
  !*** ./src/hls.js/demux/adts.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAudioConfig = getAudioConfig;
exports.isHeaderPattern = isHeaderPattern;
exports.getHeaderLength = getHeaderLength;
exports.getFullFrameLength = getFullFrameLength;
exports.isHeader = isHeader;
exports.probe = probe;
exports.initTrackConfig = initTrackConfig;
exports.getFrameDuration = getFrameDuration;
exports.parseFrameHeader = parseFrameHeader;
exports.appendFrame = appendFrame;

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _getSelfScope = __webpack_require__(/*! ../utils/get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *  ADTS parser helper
 */
function getAudioConfig(observer, data, offset, audioCodec) {
  var adtsObjectType = void 0,
      // :int
  adtsSampleingIndex = void 0,
      // :int
  adtsExtensionSampleingIndex = void 0,
      // :int
  adtsChanelConfig = void 0,
      // :int
  config = void 0,
      userAgent = navigator.userAgent.toLowerCase(),
      manifestCodec = audioCodec,
      adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
  // byte 2
  adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
  adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;
  if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
    observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });
    return;
  }
  adtsChanelConfig = (data[offset + 2] & 0x01) << 2;
  // byte 3
  adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;
  _logger.logger.log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);
  // firefox: freq less than 24kHz = AAC SBR (HE-AAC)
  if (/firefox/i.test(userAgent)) {
    if (adtsSampleingIndex >= 6) {
      adtsObjectType = 5;
      config = new Array(4);
      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
      // there is a factor 2 between frame sample rate and output sample rate
      // multiply frequency by 2 (see table below, equivalent to substract 3)
      adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
    } else {
      adtsObjectType = 2;
      config = new Array(2);
      adtsExtensionSampleingIndex = adtsSampleingIndex;
    }
    // Android : always use AAC
  } else if (userAgent.indexOf('android') !== -1) {
    adtsObjectType = 2;
    config = new Array(2);
    adtsExtensionSampleingIndex = adtsSampleingIndex;
  } else {
    /*  for other browsers (Chrome/Vivaldi/Opera ...)
        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
    */
    adtsObjectType = 5;
    config = new Array(4);
    // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
    if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
      // there is a factor 2 between frame sample rate and output sample rate
      // multiply frequency by 2 (see table below, equivalent to substract 3)
      adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
    } else {
      // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
      // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
      if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChanelConfig === 1) {
        adtsObjectType = 2;
        config = new Array(2);
      }
      adtsExtensionSampleingIndex = adtsSampleingIndex;
    }
  }
  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
      ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()
    Audio Profile / Audio Object Type
    0: Null
    1: AAC Main
    2: AAC LC (Low Complexity)
    3: AAC SSR (Scalable Sample Rate)
    4: AAC LTP (Long Term Prediction)
    5: SBR (Spectral Band Replication)
    6: AAC Scalable
   sampling freq
    0: 96000 Hz
    1: 88200 Hz
    2: 64000 Hz
    3: 48000 Hz
    4: 44100 Hz
    5: 32000 Hz
    6: 24000 Hz
    7: 22050 Hz
    8: 16000 Hz
    9: 12000 Hz
    10: 11025 Hz
    11: 8000 Hz
    12: 7350 Hz
    13: Reserved
    14: Reserved
    15: frequency is written explictly
    Channel Configurations
    These are the channel configurations:
    0: Defined in AOT Specifc Config
    1: 1 channel: front-center
    2: 2 channels: front-left, front-right
  */
  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
  config[0] = adtsObjectType << 3;
  // samplingFrequencyIndex
  config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
  config[1] |= (adtsSampleingIndex & 0x01) << 7;
  // channelConfiguration
  config[1] |= adtsChanelConfig << 3;
  if (adtsObjectType === 5) {
    // adtsExtensionSampleingIndex
    config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
    config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
    // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
    //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
    config[2] |= 2 << 2;
    config[3] = 0;
  }
  return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: 'mp4a.40.' + adtsObjectType, manifestCodec: manifestCodec };
}

function isHeaderPattern(data, offset) {
  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;
}

function getHeaderLength(data, offset) {
  return data[offset + 1] & 0x01 ? 7 : 9;
}

function getFullFrameLength(data, offset) {
  return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
}

function isHeader(data, offset) {
  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
  // Layer bits (position 14 and 15) in header should be always 0 for ADTS
  // More info https://wiki.multimedia.cx/index.php?title=ADTS
  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
    return true;
  }

  return false;
}

function probe(data, offset) {
  // same as isHeader but we also check that ADTS frame follows last ADTS frame
  // or end of data is reached
  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
    // ADTS header Length
    var headerLength = getHeaderLength(data, offset);
    // ADTS frame Length
    var frameLength = headerLength;
    if (offset + 5 < data.length) {
      frameLength = getFullFrameLength(data, offset);
    }

    var newOffset = offset + frameLength;
    if (newOffset === data.length || newOffset + 1 < data.length && isHeaderPattern(data, newOffset)) {
      return true;
    }
  }
  return false;
}

function initTrackConfig(track, observer, data, offset, audioCodec) {
  if (!track.samplerate) {
    var config = getAudioConfig(observer, data, offset, audioCodec);
    track.config = config.config;
    track.samplerate = config.samplerate;
    track.channelCount = config.channelCount;
    track.codec = config.codec;
    track.manifestCodec = config.manifestCodec;
    _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
  }
}

function getFrameDuration(samplerate) {
  return 1024 * 90000 / samplerate;
}

function parseFrameHeader(data, offset, pts, frameIndex, frameDuration) {
  var headerLength = void 0,
      frameLength = void 0,
      stamp = void 0;
  var length = data.length;

  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
  headerLength = getHeaderLength(data, offset);
  // retrieve frame size
  frameLength = getFullFrameLength(data, offset);
  frameLength -= headerLength;

  if (frameLength > 0 && offset + headerLength + frameLength <= length) {
    stamp = pts + frameIndex * frameDuration;
    // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
    return { headerLength: headerLength, frameLength: frameLength, stamp: stamp };
  }

  return undefined;
}

function appendFrame(track, data, offset, pts, frameIndex) {
  var frameDuration = getFrameDuration(track.samplerate);
  var header = parseFrameHeader(data, offset, pts, frameIndex, frameDuration);
  if (header) {
    var stamp = header.stamp;
    var headerLength = header.headerLength;
    var frameLength = header.frameLength;

    // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
    var aacSample = {
      unit: data.subarray(offset + headerLength, offset + headerLength + frameLength),
      pts: stamp,
      dts: stamp
    };

    track.samples.push(aacSample);
    track.len += frameLength;

    return { sample: aacSample, length: frameLength + headerLength };
  }

  return undefined;
}

/***/ }),

/***/ "./src/hls.js/demux/demuxer-inline.js":
/*!********************************************!*\
  !*** ./src/hls.js/demux/demuxer-inline.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * inline demuxer: probe fragments and instantiate
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _decrypter = __webpack_require__(/*! ../crypt/decrypter */ "./src/hls.js/crypt/decrypter.js");

var _decrypter2 = _interopRequireDefault(_decrypter);

var _aacdemuxer = __webpack_require__(/*! ../demux/aacdemuxer */ "./src/hls.js/demux/aacdemuxer.js");

var _aacdemuxer2 = _interopRequireDefault(_aacdemuxer);

var _mp4demuxer = __webpack_require__(/*! ../demux/mp4demuxer */ "./src/hls.js/demux/mp4demuxer.js");

var _mp4demuxer2 = _interopRequireDefault(_mp4demuxer);

var _tsdemuxer = __webpack_require__(/*! ../demux/tsdemuxer */ "./src/hls.js/demux/tsdemuxer.js");

var _tsdemuxer2 = _interopRequireDefault(_tsdemuxer);

var _mp3demuxer = __webpack_require__(/*! ../demux/mp3demuxer */ "./src/hls.js/demux/mp3demuxer.js");

var _mp3demuxer2 = _interopRequireDefault(_mp3demuxer);

var _mp4Remuxer = __webpack_require__(/*! ../remux/mp4-remuxer */ "./src/hls.js/remux/mp4-remuxer.js");

var _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);

var _passthroughRemuxer = __webpack_require__(/*! ../remux/passthrough-remuxer */ "./src/hls.js/remux/passthrough-remuxer.js");

var _passthroughRemuxer2 = _interopRequireDefault(_passthroughRemuxer);

var _getSelfScope = __webpack_require__(/*! ../utils/get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// see https://stackoverflow.com/a/11237259/589493
var global = (0, _getSelfScope.getSelfScope)(); // safeguard for code that might run both on worker and main thread

var now = void 0;
// performance.now() not available on WebWorker, at least on Safari Desktop
try {
  now = global.performance.now.bind(global.performance);
} catch (err) {
  _logger.logger.debug('Unable to use Performance API on this environment');
  now = global.Date.now;
}

var DemuxerInline = function () {
  function DemuxerInline(observer, typeSupported, config, vendor) {
    _classCallCheck(this, DemuxerInline);

    this.observer = observer;
    this.typeSupported = typeSupported;
    this.config = config;
    this.vendor = vendor;
  }

  _createClass(DemuxerInline, [{
    key: 'destroy',
    value: function destroy() {
      var demuxer = this.demuxer;
      if (demuxer) {
        demuxer.destroy();
      }
    }
  }, {
    key: 'push',
    value: function push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
      var _this = this;

      if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === 'AES-128') {
        var decrypter = this.decrypter;
        if (decrypter == null) {
          decrypter = this.decrypter = new _decrypter2.default(this.observer, this.config);
        }

        var startTime = now();
        decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {
          var endTime = now();
          _this.observer.trigger(_events2.default.FRAG_DECRYPTED, { stats: { tstart: startTime, tdecrypt: endTime } });
          _this.pushDecrypted(new Uint8Array(decryptedData), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
        });
      } else {
        this.pushDecrypted(new Uint8Array(data), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
      }
    }
  }, {
    key: 'pushDecrypted',
    value: function pushDecrypted(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
      var demuxer = this.demuxer;
      if (!demuxer ||
      // in case of continuity change, or track switch
      // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)
      // so let's check that current demuxer is still valid
      (discontinuity || trackSwitch) && !this.probe(data)) {
        var observer = this.observer;
        var typeSupported = this.typeSupported;
        var config = this.config;
        // probing order is TS/AAC/MP3/MP4
        var muxConfig = [{ demux: _tsdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp4demuxer2.default, remux: _passthroughRemuxer2.default }, { demux: _aacdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp3demuxer2.default, remux: _mp4Remuxer2.default }];

        // probe for content type
        for (var i = 0, len = muxConfig.length; i < len; i++) {
          var mux = muxConfig[i];
          var probe = mux.demux.probe;
          if (probe(data)) {
            var _remuxer = this.remuxer = new mux.remux(observer, config, typeSupported, this.vendor);
            demuxer = new mux.demux(observer, _remuxer, config, typeSupported);
            this.probe = probe;
            break;
          }
        }
        if (!demuxer) {
          observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });
          return;
        }
        this.demuxer = demuxer;
      }
      var remuxer = this.remuxer;

      if (discontinuity || trackSwitch) {
        demuxer.resetInitSegment(initSegment, audioCodec, videoCodec, duration);
        remuxer.resetInitSegment();
      }
      if (discontinuity) {
        demuxer.resetTimeStamp(defaultInitPTS);
        remuxer.resetTimeStamp(defaultInitPTS);
      }
      if (typeof demuxer.setDecryptData === 'function') {
        demuxer.setDecryptData(decryptdata);
      }

      demuxer.append(data, timeOffset, contiguous, accurateTimeOffset);
    }
  }]);

  return DemuxerInline;
}();

exports.default = DemuxerInline;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/demuxer-worker.js":
/*!********************************************!*\
  !*** ./src/hls.js/demux/demuxer-worker.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _demuxerInline = __webpack_require__(/*! ../demux/demuxer-inline */ "./src/hls.js/demux/demuxer-inline.js");

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _events3 = __webpack_require__(/*! events */ "../../node_modules/events/events.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* demuxer web worker.
 *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
 *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
 */

var DemuxerWorker = function DemuxerWorker(self) {
  // observer setup
  var observer = new _events3.EventEmitter();
  observer.trigger = function trigger(event) {
    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    observer.emit.apply(observer, [event, event].concat(data));
  };

  observer.off = function off(event) {
    for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      data[_key2 - 1] = arguments[_key2];
    }

    observer.removeListener.apply(observer, [event].concat(data));
  };

  var forwardMessage = function forwardMessage(ev, data) {
    self.postMessage({ event: ev, data: data });
  };

  self.addEventListener('message', function (ev) {
    var data = ev.data;
    // console.log('demuxer cmd:' + data.cmd);
    switch (data.cmd) {
      case 'init':
        var config = JSON.parse(data.config);
        self.demuxer = new _demuxerInline2.default(observer, data.typeSupported, config, data.vendor);

        (0, _logger.enableLogs)(config.debug);

        // signal end of worker init
        forwardMessage('init', null);
        break;
      case 'demux':
        self.demuxer.push(data.data, data.decryptdata, data.initSegment, data.audioCodec, data.videoCodec, data.timeOffset, data.discontinuity, data.trackSwitch, data.contiguous, data.duration, data.accurateTimeOffset, data.defaultInitPTS);
        break;
      default:
        break;
    }
  });

  // forward events to main thread
  observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
  observer.on(_events2.default.FRAG_PARSED, forwardMessage);
  observer.on(_events2.default.ERROR, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);
  observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);

  // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
  observer.on(_events2.default.FRAG_PARSING_DATA, function (ev, data) {
    var transferable = [];
    var message = { event: ev, data: data };
    if (data.data1) {
      message.data1 = data.data1.buffer;
      transferable.push(data.data1.buffer);
      delete data.data1;
    }
    if (data.data2) {
      message.data2 = data.data2.buffer;
      transferable.push(data.data2.buffer);
      delete data.data2;
    }
    self.postMessage(message, transferable);
  });
};

exports.default = DemuxerWorker;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/demuxer.js":
/*!*************************************!*\
  !*** ./src/hls.js/demux/demuxer.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! events */ "../../node_modules/events/events.js");

var _webworkifyWebpack = __webpack_require__(/*! webworkify-webpack */ "../../node_modules/webworkify-webpack/index.js");

var work = _interopRequireWildcard(_webworkifyWebpack);

var _events2 = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events3 = _interopRequireDefault(_events2);

var _demuxerInline = __webpack_require__(/*! ../demux/demuxer-inline */ "./src/hls.js/demux/demuxer-inline.js");

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _mediasourceHelper = __webpack_require__(/*! ../utils/mediasource-helper */ "./src/hls.js/utils/mediasource-helper.js");

var _getSelfScope = __webpack_require__(/*! ../utils/get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

var _observer = __webpack_require__(/*! ../observer */ "./src/hls.js/observer.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// see https://stackoverflow.com/a/11237259/589493
var global = (0, _getSelfScope.getSelfScope)(); // safeguard for code that might run both on worker and main thread
var MediaSource = (0, _mediasourceHelper.getMediaSource)();

var Demuxer = function () {
  function Demuxer(hls, id) {
    var _this = this;

    _classCallCheck(this, Demuxer);

    this.hls = hls;
    this.id = id;

    var observer = this.observer = new _observer.Observer();
    var config = hls.config;

    var forwardMessage = function forwardMessage(ev, data) {
      data = data || {};
      data.frag = _this.frag;
      data.id = _this.id;
      hls.trigger(ev, data);
    };

    // forward events to main thread
    observer.on(_events3.default.FRAG_DECRYPTED, forwardMessage);
    observer.on(_events3.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
    observer.on(_events3.default.FRAG_PARSING_DATA, forwardMessage);
    observer.on(_events3.default.FRAG_PARSED, forwardMessage);
    observer.on(_events3.default.ERROR, forwardMessage);
    observer.on(_events3.default.FRAG_PARSING_METADATA, forwardMessage);
    observer.on(_events3.default.FRAG_PARSING_USERDATA, forwardMessage);
    observer.on(_events3.default.INIT_PTS_FOUND, forwardMessage);

    var typeSupported = {
      mp4: MediaSource.isTypeSupported('video/mp4'),
      mpeg: MediaSource.isTypeSupported('audio/mpeg'),
      mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"')
    };
    // navigator.vendor is not always available in Web Worker
    // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator
    var vendor = navigator.vendor;
    if (config.enableWorker && typeof Worker !== 'undefined') {
      _logger.logger.log('demuxing in webworker');
      var w = void 0;
      try {
        w = this.w = work(/*require.resolve*/(/*! ../demux/demuxer-worker.js */ "./src/hls.js/demux/demuxer-worker.js"));
        this.onwmsg = this.onWorkerMessage.bind(this);
        w.addEventListener('message', this.onwmsg);
        w.onerror = function (event) {
          hls.trigger(_events3.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });
        };
        w.postMessage({ cmd: 'init', typeSupported: typeSupported, vendor: vendor, id: id, config: JSON.stringify(config) });
      } catch (err) {
        _logger.logger.warn('Error in worker:', err);
        _logger.logger.error('Error while initializing DemuxerWorker, fallback on DemuxerInline');
        if (w) {
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          global.URL.revokeObjectURL(w.objectURL);
        }
        this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
        this.w = undefined;
      }
    } else {
      this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
    }
  }

  _createClass(Demuxer, [{
    key: 'destroy',
    value: function destroy() {
      var w = this.w;
      if (w) {
        w.removeEventListener('message', this.onwmsg);
        w.terminate();
        this.w = null;
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.destroy();
          this.demuxer = null;
        }
      }
      var observer = this.observer;
      if (observer) {
        observer.removeAllListeners();
        this.observer = null;
      }
    }
  }, {
    key: 'push',
    value: function push(data, initSegment, audioCodec, videoCodec, frag, duration, accurateTimeOffset, defaultInitPTS) {
      var w = this.w;
      var timeOffset = Number.isFinite(frag.startPTS) ? frag.startPTS : frag.start;
      var decryptdata = frag.decryptdata;
      var lastFrag = this.frag;
      var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
      var trackSwitch = !(lastFrag && frag.level === lastFrag.level);
      var nextSN = lastFrag && frag.sn === lastFrag.sn + 1;
      var contiguous = !trackSwitch && nextSN;
      if (discontinuity) {
        _logger.logger.log(this.id + ':discontinuity detected');
      }

      if (trackSwitch) {
        _logger.logger.log(this.id + ':switch detected');
      }

      this.frag = frag;
      if (w) {
        // post fragment payload as transferable objects for ArrayBuffer (no copy)
        w.postMessage({ cmd: 'demux', data: data, decryptdata: decryptdata, initSegment: initSegment, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, discontinuity: discontinuity, trackSwitch: trackSwitch, contiguous: contiguous, duration: duration, accurateTimeOffset: accurateTimeOffset, defaultInitPTS: defaultInitPTS }, data instanceof ArrayBuffer ? [data] : []);
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
        }
      }
    }
  }, {
    key: 'onWorkerMessage',
    value: function onWorkerMessage(ev) {
      var data = ev.data,
          hls = this.hls;
      switch (data.event) {
        case 'init':
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          global.URL.revokeObjectURL(this.w.objectURL);
          break;
        // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
        case _events3.default.FRAG_PARSING_DATA:
          data.data.data1 = new Uint8Array(data.data1);
          if (data.data2) {
            data.data.data2 = new Uint8Array(data.data2);
          }

        /* falls through */
        default:
          data.data = data.data || {};
          data.data.frag = this.frag;
          data.data.id = this.id;
          hls.trigger(data.event, data.data);
          break;
      }
    }
  }]);

  return Demuxer;
}();

exports.default = Demuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/exp-golomb.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/exp-golomb.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ExpGolomb = function () {
  function ExpGolomb(data) {
    _classCallCheck(this, ExpGolomb);

    this.data = data;
    // the number of bytes left to examine in this.data
    this.bytesAvailable = data.byteLength;
    // the current word being examined
    this.word = 0; // :uint
    // the number of bits left to examine in the current word
    this.bitsAvailable = 0; // :uint
  }

  // ():void


  _createClass(ExpGolomb, [{
    key: 'loadWord',
    value: function loadWord() {
      var data = this.data,
          bytesAvailable = this.bytesAvailable,
          position = data.byteLength - bytesAvailable,
          workingBytes = new Uint8Array(4),
          availableBytes = Math.min(4, bytesAvailable);
      if (availableBytes === 0) {
        throw new Error('no bytes available');
      }

      workingBytes.set(data.subarray(position, position + availableBytes));
      this.word = new DataView(workingBytes.buffer).getUint32(0);
      // track the amount of this.data that has been processed
      this.bitsAvailable = availableBytes * 8;
      this.bytesAvailable -= availableBytes;
    }

    // (count:int):void

  }, {
    key: 'skipBits',
    value: function skipBits(count) {
      var skipBytes = void 0; // :int
      if (this.bitsAvailable > count) {
        this.word <<= count;
        this.bitsAvailable -= count;
      } else {
        count -= this.bitsAvailable;
        skipBytes = count >> 3;
        count -= skipBytes >> 3;
        this.bytesAvailable -= skipBytes;
        this.loadWord();
        this.word <<= count;
        this.bitsAvailable -= count;
      }
    }

    // (size:int):uint

  }, {
    key: 'readBits',
    value: function readBits(size) {
      var bits = Math.min(this.bitsAvailable, size),
          // :uint
      valu = this.word >>> 32 - bits; // :uint
      if (size > 32) {
        _logger.logger.error('Cannot read more than 32 bits at a time');
      }

      this.bitsAvailable -= bits;
      if (this.bitsAvailable > 0) {
        this.word <<= bits;
      } else if (this.bytesAvailable > 0) {
        this.loadWord();
      }

      bits = size - bits;
      if (bits > 0 && this.bitsAvailable) {
        return valu << bits | this.readBits(bits);
      } else {
        return valu;
      }
    }

    // ():uint

  }, {
    key: 'skipLZ',
    value: function skipLZ() {
      var leadingZeroCount = void 0; // :uint
      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
        if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {
          // the first bit of working word is 1
          this.word <<= leadingZeroCount;
          this.bitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      // we exhausted word and still have not found a 1
      this.loadWord();
      return leadingZeroCount + this.skipLZ();
    }

    // ():void

  }, {
    key: 'skipUEG',
    value: function skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():void

  }, {
    key: 'skipEG',
    value: function skipEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():uint

  }, {
    key: 'readUEG',
    value: function readUEG() {
      var clz = this.skipLZ(); // :uint
      return this.readBits(clz + 1) - 1;
    }

    // ():int

  }, {
    key: 'readEG',
    value: function readEG() {
      var valu = this.readUEG(); // :int
      if (0x01 & valu) {
        // the number is odd if the low order bit is set
        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
      } else {
        return -1 * (valu >>> 1); // divide by two then make it negative
      }
    }

    // Some convenience functions
    // :Boolean

  }, {
    key: 'readBoolean',
    value: function readBoolean() {
      return this.readBits(1) === 1;
    }

    // ():int

  }, {
    key: 'readUByte',
    value: function readUByte() {
      return this.readBits(8);
    }

    // ():int

  }, {
    key: 'readUShort',
    value: function readUShort() {
      return this.readBits(16);
    }
    // ():int

  }, {
    key: 'readUInt',
    value: function readUInt() {
      return this.readBits(32);
    }

    /**
     * Advance the ExpGolomb decoder past a scaling list. The scaling
     * list is optionally transmitted as part of a sequence parameter
     * set and is not relevant to transmuxing.
     * @param count {number} the number of entries in this scaling list
     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
     */

  }, {
    key: 'skipScalingList',
    value: function skipScalingList(count) {
      var lastScale = 8,
          nextScale = 8,
          j = void 0,
          deltaScale = void 0;
      for (j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = this.readEG();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    }

    /**
     * Read a sequence parameter set and return some interesting video
     * properties. A sequence parameter set is the H264 metadata that
     * describes the properties of upcoming video frames.
     * @param data {Uint8Array} the bytes of a sequence parameter set
     * @return {object} an object with configuration parsed from the
     * sequence parameter set, including the dimensions of the
     * associated video frames.
     */

  }, {
    key: 'readSPS',
    value: function readSPS() {
      var frameCropLeftOffset = 0,
          frameCropRightOffset = 0,
          frameCropTopOffset = 0,
          frameCropBottomOffset = 0,
          profileIdc = void 0,
          profileCompat = void 0,
          levelIdc = void 0,
          numRefFramesInPicOrderCntCycle = void 0,
          picWidthInMbsMinus1 = void 0,
          picHeightInMapUnitsMinus1 = void 0,
          frameMbsOnlyFlag = void 0,
          scalingListCount = void 0,
          i = void 0,
          readUByte = this.readUByte.bind(this),
          readBits = this.readBits.bind(this),
          readUEG = this.readUEG.bind(this),
          readBoolean = this.readBoolean.bind(this),
          skipBits = this.skipBits.bind(this),
          skipEG = this.skipEG.bind(this),
          skipUEG = this.skipUEG.bind(this),
          skipScalingList = this.skipScalingList.bind(this);

      readUByte();
      profileIdc = readUByte(); // profile_idc
      profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)
      skipBits(3); // reserved_zero_3bits u(3),
      levelIdc = readUByte(); // level_idc u(8)
      skipUEG(); // seq_parameter_set_id
      // some profiles have more optional data we don't need
      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
        var chromaFormatIdc = readUEG();
        if (chromaFormatIdc === 3) {
          skipBits(1);
        } // separate_colour_plane_flag

        skipUEG(); // bit_depth_luma_minus8
        skipUEG(); // bit_depth_chroma_minus8
        skipBits(1); // qpprime_y_zero_transform_bypass_flag
        if (readBoolean()) {
          // seq_scaling_matrix_present_flag
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i = 0; i < scalingListCount; i++) {
            if (readBoolean()) {
              // seq_scaling_list_present_flag[ i ]
              if (i < 6) {
                skipScalingList(16);
              } else {
                skipScalingList(64);
              }
            }
          }
        }
      }
      skipUEG(); // log2_max_frame_num_minus4
      var picOrderCntType = readUEG();
      if (picOrderCntType === 0) {
        readUEG(); // log2_max_pic_order_cnt_lsb_minus4
      } else if (picOrderCntType === 1) {
        skipBits(1); // delta_pic_order_always_zero_flag
        skipEG(); // offset_for_non_ref_pic
        skipEG(); // offset_for_top_to_bottom_field
        numRefFramesInPicOrderCntCycle = readUEG();
        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
          skipEG();
        } // offset_for_ref_frame[ i ]
      }
      skipUEG(); // max_num_ref_frames
      skipBits(1); // gaps_in_frame_num_value_allowed_flag
      picWidthInMbsMinus1 = readUEG();
      picHeightInMapUnitsMinus1 = readUEG();
      frameMbsOnlyFlag = readBits(1);
      if (frameMbsOnlyFlag === 0) {
        skipBits(1);
      } // mb_adaptive_frame_field_flag

      skipBits(1); // direct_8x8_inference_flag
      if (readBoolean()) {
        // frame_cropping_flag
        frameCropLeftOffset = readUEG();
        frameCropRightOffset = readUEG();
        frameCropTopOffset = readUEG();
        frameCropBottomOffset = readUEG();
      }
      var pixelRatio = [1, 1];
      if (readBoolean()) {
        // vui_parameters_present_flag
        if (readBoolean()) {
          // aspect_ratio_info_present_flag
          var aspectRatioIdc = readUByte();
          switch (aspectRatioIdc) {
            case 1:
              pixelRatio = [1, 1];break;
            case 2:
              pixelRatio = [12, 11];break;
            case 3:
              pixelRatio = [10, 11];break;
            case 4:
              pixelRatio = [16, 11];break;
            case 5:
              pixelRatio = [40, 33];break;
            case 6:
              pixelRatio = [24, 11];break;
            case 7:
              pixelRatio = [20, 11];break;
            case 8:
              pixelRatio = [32, 11];break;
            case 9:
              pixelRatio = [80, 33];break;
            case 10:
              pixelRatio = [18, 11];break;
            case 11:
              pixelRatio = [15, 11];break;
            case 12:
              pixelRatio = [64, 33];break;
            case 13:
              pixelRatio = [160, 99];break;
            case 14:
              pixelRatio = [4, 3];break;
            case 15:
              pixelRatio = [3, 2];break;
            case 16:
              pixelRatio = [2, 1];break;
            case 255:
              {
                pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
                break;
              }
          }
        }
      }
      return {
        width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
        pixelRatio: pixelRatio
      };
    }
  }, {
    key: 'readSliceType',
    value: function readSliceType() {
      // skip NALu type
      this.readUByte();
      // discard first_mb_in_slice
      this.readUEG();
      // return slice_type
      return this.readUEG();
    }
  }]);

  return ExpGolomb;
}();

exports.default = ExpGolomb;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/id3.js":
/*!*********************************!*\
  !*** ./src/hls.js/demux/id3.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * ID3 parser
 */
var ID3 = function () {
  function ID3() {
    _classCallCheck(this, ID3);
  }

  _createClass(ID3, null, [{
    key: 'isHeader',

    /**
     * Returns true if an ID3 header can be found at offset in data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {boolean} - True if an ID3 header is found
     */
    value: function isHeader(data, offset) {
      /*
      * http://id3.org/id3v2.3.0
      * [0]     = 'I'
      * [1]     = 'D'
      * [2]     = '3'
      * [3,4]   = {Version}
      * [5]     = {Flags}
      * [6-9]   = {ID3 Size}
      *
      * An ID3v2 tag can be detected with the following pattern:
      *  $49 44 33 yy yy xx zz zz zz zz
      * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80
      */
      if (offset + 10 <= data.length) {
        // look for 'ID3' identifier
        if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {
          // check version is within range
          if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
            // check size is within range
            if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
              return true;
            }
          }
        }
      }

      return false;
    }

    /**
     * Returns true if an ID3 footer can be found at offset in data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {boolean} - True if an ID3 footer is found
     */

  }, {
    key: 'isFooter',
    value: function isFooter(data, offset) {
      /*
      * The footer is a copy of the header, but with a different identifier
      */
      if (offset + 10 <= data.length) {
        // look for '3DI' identifier
        if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {
          // check version is within range
          if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
            // check size is within range
            if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
              return true;
            }
          }
        }
      }

      return false;
    }

    /**
     * Returns any adjacent ID3 tags found in data starting at offset, as one block of data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {Uint8Array} - The block of data containing any ID3 tags found
     */

  }, {
    key: 'getID3Data',
    value: function getID3Data(data, offset) {
      var front = offset;
      var length = 0;

      while (ID3.isHeader(data, offset)) {
        // ID3 header is 10 bytes
        length += 10;

        var size = ID3._readSize(data, offset + 6);
        length += size;

        if (ID3.isFooter(data, offset + 10)) {
          // ID3 footer is 10 bytes
          length += 10;
        }

        offset += length;
      }

      if (length > 0) {
        return data.subarray(front, front + length);
      }

      return undefined;
    }
  }, {
    key: '_readSize',
    value: function _readSize(data, offset) {
      var size = 0;
      size = (data[offset] & 0x7f) << 21;
      size |= (data[offset + 1] & 0x7f) << 14;
      size |= (data[offset + 2] & 0x7f) << 7;
      size |= data[offset + 3] & 0x7f;
      return size;
    }

    /**
     * Searches for the Elementary Stream timestamp found in the ID3 data chunk
     * @param {Uint8Array} data - Block of data containing one or more ID3 tags
     * @return {number} - The timestamp
     */

  }, {
    key: 'getTimeStamp',
    value: function getTimeStamp(data) {
      var frames = ID3.getID3Frames(data);
      for (var i = 0; i < frames.length; i++) {
        var frame = frames[i];
        if (ID3.isTimeStampFrame(frame)) {
          return ID3._readTimeStamp(frame);
        }
      }

      return undefined;
    }

    /**
     * Returns true if the ID3 frame is an Elementary Stream timestamp frame
     * @param {ID3 frame} frame
     */

  }, {
    key: 'isTimeStampFrame',
    value: function isTimeStampFrame(frame) {
      return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';
    }
  }, {
    key: '_getFrameData',
    value: function _getFrameData(data) {
      /*
      Frame ID       $xx xx xx xx (four characters)
      Size           $xx xx xx xx
      Flags          $xx xx
      */
      var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
      var size = ID3._readSize(data, 4);

      // skip frame id, size, and flags
      var offset = 10;

      return { type: type, size: size, data: data.subarray(offset, offset + size) };
    }

    /**
     * Returns an array of ID3 frames found in all the ID3 tags in the id3Data
     * @param {Uint8Array} id3Data - The ID3 data containing one or more ID3 tags
     * @return {ID3 frame[]} - Array of ID3 frame objects
     */

  }, {
    key: 'getID3Frames',
    value: function getID3Frames(id3Data) {
      var offset = 0;
      var frames = [];

      while (ID3.isHeader(id3Data, offset)) {
        var size = ID3._readSize(id3Data, offset + 6);
        // skip past ID3 header
        offset += 10;
        var end = offset + size;
        // loop through frames in the ID3 tag
        while (offset + 8 < end) {
          var frameData = ID3._getFrameData(id3Data.subarray(offset));
          var frame = ID3._decodeFrame(frameData);
          if (frame) {
            frames.push(frame);
          }

          // skip frame header and frame data
          offset += frameData.size + 10;
        }

        if (ID3.isFooter(id3Data, offset)) {
          offset += 10;
        }
      }

      return frames;
    }
  }, {
    key: '_decodeFrame',
    value: function _decodeFrame(frame) {
      if (frame.type === 'PRIV') {
        return ID3._decodePrivFrame(frame);
      } else if (frame.type[0] === 'T') {
        return ID3._decodeTextFrame(frame);
      } else if (frame.type[0] === 'W') {
        return ID3._decodeURLFrame(frame);
      }

      return undefined;
    }
  }, {
    key: '_readTimeStamp',
    value: function _readTimeStamp(timeStampFrame) {
      if (timeStampFrame.data.byteLength === 8) {
        var data = new Uint8Array(timeStampFrame.data);
        // timestamp is 33 bit expressed as a big-endian eight-octet number,
        // with the upper 31 bits set to zero.
        var pts33Bit = data[3] & 0x1;
        var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
        timestamp /= 45;

        if (pts33Bit) {
          timestamp += 47721858.84;
        } // 2^32 / 90

        return Math.round(timestamp);
      }

      return undefined;
    }
  }, {
    key: '_decodePrivFrame',
    value: function _decodePrivFrame(frame) {
      /*
      Format: <text string>\0<binary data>
      */
      if (frame.size < 2) {
        return undefined;
      }

      var owner = ID3._utf8ArrayToStr(frame.data, true);
      var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));

      return { key: frame.type, info: owner, data: privateData.buffer };
    }
  }, {
    key: '_decodeTextFrame',
    value: function _decodeTextFrame(frame) {
      if (frame.size < 2) {
        return undefined;
      }

      if (frame.type === 'TXXX') {
        /*
        Format:
        [0]   = {Text Encoding}
        [1-?] = {Description}\0{Value}
        */
        var index = 1;
        var description = ID3._utf8ArrayToStr(frame.data.subarray(index));

        index += description.length + 1;
        var value = ID3._utf8ArrayToStr(frame.data.subarray(index));

        return { key: frame.type, info: description, data: value };
      } else {
        /*
        Format:
        [0]   = {Text Encoding}
        [1-?] = {Value}
        */
        var text = ID3._utf8ArrayToStr(frame.data.subarray(1));
        return { key: frame.type, data: text };
      }
    }
  }, {
    key: '_decodeURLFrame',
    value: function _decodeURLFrame(frame) {
      if (frame.type === 'WXXX') {
        /*
        Format:
        [0]   = {Text Encoding}
        [1-?] = {Description}\0{URL}
        */
        if (frame.size < 2) {
          return undefined;
        }

        var index = 1;
        var description = ID3._utf8ArrayToStr(frame.data.subarray(index));

        index += description.length + 1;
        var value = ID3._utf8ArrayToStr(frame.data.subarray(index));

        return { key: frame.type, info: description, data: value };
      } else {
        /*
        Format:
        [0-?] = {URL}
        */
        var url = ID3._utf8ArrayToStr(frame.data);
        return { key: frame.type, data: url };
      }
    }

    // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
    // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
    /* utf.js - UTF-8 <=> UTF-16 convertion
     *
     * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
     * Version: 1.0
     * LastModified: Dec 25 1999
     * This library is free.  You can redistribute it and/or modify it.
     */

  }, {
    key: '_utf8ArrayToStr',
    value: function _utf8ArrayToStr(array) {
      var exitOnNull = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var len = array.length;
      var c = void 0;
      var char2 = void 0;
      var char3 = void 0;
      var out = '';
      var i = 0;
      while (i < len) {
        c = array[i++];
        if (c === 0x00 && exitOnNull) {
          return out;
        } else if (c === 0x00 || c === 0x03) {
          // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it
          continue;
        }
        switch (c >> 4) {
          case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:
            // 0xxxxxxx
            out += String.fromCharCode(c);
            break;
          case 12:case 13:
            // 110x xxxx   10xx xxxx
            char2 = array[i++];
            out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);
            break;
          case 14:
            // 1110 xxxx  10xx xxxx  10xx xxxx
            char2 = array[i++];
            char3 = array[i++];
            out += String.fromCharCode((c & 0x0F) << 12 | (char2 & 0x3F) << 6 | (char3 & 0x3F) << 0);
            break;
          default:
        }
      }
      return out;
    }
  }]);

  return ID3;
}();

var utf8ArrayToStr = ID3._utf8ArrayToStr;

exports.default = ID3;
exports.utf8ArrayToStr = utf8ArrayToStr;

/***/ }),

/***/ "./src/hls.js/demux/mp3demuxer.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/mp3demuxer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * MP3 demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _id = __webpack_require__(/*! ../demux/id3 */ "./src/hls.js/demux/id3.js");

var _id2 = _interopRequireDefault(_id);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _mpegaudio = __webpack_require__(/*! ./mpegaudio */ "./src/hls.js/demux/mpegaudio.js");

var _mpegaudio2 = _interopRequireDefault(_mpegaudio);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MP3Demuxer = function () {
  function MP3Demuxer(observer, remuxer, config) {
    _classCallCheck(this, MP3Demuxer);

    this.observer = observer;
    this.config = config;
    this.remuxer = remuxer;
  }

  _createClass(MP3Demuxer, [{
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this._audioTrack = { container: 'audio/mpeg', type: 'audio', id: -1, sequenceNumber: 0, isAAC: false, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
    }
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var id3Data = _id2.default.getID3Data(data, 0);
      var timestamp = _id2.default.getTimeStamp(id3Data);
      var pts = timestamp ? 90 * timestamp : timeOffset * 90000;
      var offset = id3Data.length;
      var length = data.length;
      var frameIndex = 0,
          stamp = 0;
      var track = this._audioTrack;

      var id3Samples = [{ pts: pts, dts: pts, data: id3Data }];

      while (offset < length) {
        if (_mpegaudio2.default.isHeader(data, offset)) {
          var frame = _mpegaudio2.default.appendFrame(track, data, offset, pts, frameIndex);
          if (frame) {
            offset += frame.length;
            stamp = frame.sample.pts;
            frameIndex++;
          } else {
            // logger.log('Unable to parse Mpeg audio frame');
            break;
          }
        } else if (_id2.default.isHeader(data, offset)) {
          id3Data = _id2.default.getID3Data(data, offset);
          id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
          offset += id3Data.length;
        } else {
          // nothing found, keep looking
          offset++;
        }
      }

      this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      // check if data contains ID3 timestamp and MPEG sync word
      var offset = void 0,
          length = void 0;
      var id3Data = _id2.default.getID3Data(data, 0);
      if (id3Data && _id2.default.getTimeStamp(id3Data) !== undefined) {
        // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
        // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
        // More info http://www.mp3-tech.org/programmer/frame_header.html
        for (offset = id3Data.length, length = Math.min(data.length - 1, offset + 100); offset < length; offset++) {
          if (_mpegaudio2.default.probe(data, offset)) {
            _logger.logger.log('MPEG Audio sync word found !');
            return true;
          }
        }
      }
      return false;
    }
  }]);

  return MP3Demuxer;
}();

exports.default = MP3Demuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/mp4demuxer.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/mp4demuxer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * MP4 demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UINT32_MAX = Math.pow(2, 32) - 1;

var MP4Demuxer = function () {
  function MP4Demuxer(observer, remuxer) {
    _classCallCheck(this, MP4Demuxer);

    this.observer = observer;
    this.remuxer = remuxer;
  }

  _createClass(MP4Demuxer, [{
    key: 'resetTimeStamp',
    value: function resetTimeStamp(initPTS) {
      this.initPTS = initPTS;
    }
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      // jshint unused:false
      if (initSegment && initSegment.byteLength) {
        var initData = this.initData = MP4Demuxer.parseInitSegment(initSegment);

        // default audio codec if nothing specified
        // TODO : extract that from initsegment
        if (audioCodec == null) {
          audioCodec = 'mp4a.40.5';
        }

        if (videoCodec == null) {
          videoCodec = 'avc1.42e01e';
        }

        var tracks = {};
        if (initData.audio && initData.video) {
          tracks.audiovideo = { container: 'video/mp4', codec: audioCodec + ',' + videoCodec, initSegment: duration ? initSegment : null };
        } else {
          if (initData.audio) {
            tracks.audio = { container: 'audio/mp4', codec: audioCodec, initSegment: duration ? initSegment : null };
          }

          if (initData.video) {
            tracks.video = { container: 'video/mp4', codec: videoCodec, initSegment: duration ? initSegment : null };
          }
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, { tracks: tracks });
      } else {
        if (audioCodec) {
          this.audioCodec = audioCodec;
        }

        if (videoCodec) {
          this.videoCodec = videoCodec;
        }
      }
    }
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var initData = this.initData;
      if (!initData) {
        this.resetInitSegment(data, this.audioCodec, this.videoCodec, false);
        initData = this.initData;
      }
      var startDTS = void 0,
          initPTS = this.initPTS;
      if (initPTS === undefined) {
        var _startDTS = MP4Demuxer.getStartDTS(initData, data);
        this.initPTS = initPTS = _startDTS - timeOffset;
        this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });
      }
      MP4Demuxer.offsetStartDTS(initData, data, initPTS);
      startDTS = MP4Demuxer.getStartDTS(initData, data);
      this.remuxer.remux(initData.audio, initData.video, null, null, startDTS, contiguous, accurateTimeOffset, data);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      // ensure we find a moof box in the first 16 kB
      return MP4Demuxer.findBox({ data: data, start: 0, end: Math.min(data.length, 16384) }, ['moof']).length > 0;
    }
  }, {
    key: 'bin2str',
    value: function bin2str(buffer) {
      return String.fromCharCode.apply(null, buffer);
    }
  }, {
    key: 'readUint16',
    value: function readUint16(buffer, offset) {
      if (buffer.data) {
        offset += buffer.start;
        buffer = buffer.data;
      }

      var val = buffer[offset] << 8 | buffer[offset + 1];

      return val < 0 ? 65536 + val : val;
    }
  }, {
    key: 'readUint32',
    value: function readUint32(buffer, offset) {
      if (buffer.data) {
        offset += buffer.start;
        buffer = buffer.data;
      }

      var val = buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
      return val < 0 ? 4294967296 + val : val;
    }
  }, {
    key: 'writeUint32',
    value: function writeUint32(buffer, offset, value) {
      if (buffer.data) {
        offset += buffer.start;
        buffer = buffer.data;
      }
      buffer[offset] = value >> 24;
      buffer[offset + 1] = value >> 16 & 0xff;
      buffer[offset + 2] = value >> 8 & 0xff;
      buffer[offset + 3] = value & 0xff;
    }

    // Find the data for a box specified by its path

  }, {
    key: 'findBox',
    value: function findBox(data, path) {
      var results = [],
          i = void 0,
          size = void 0,
          type = void 0,
          end = void 0,
          subresults = void 0,
          start = void 0,
          endbox = void 0;

      if (data.data) {
        start = data.start;
        end = data.end;
        data = data.data;
      } else {
        start = 0;
        end = data.byteLength;
      }

      if (!path.length) {
        // short-circuit the search for empty paths
        return null;
      }

      for (i = start; i < end;) {
        size = MP4Demuxer.readUint32(data, i);
        type = MP4Demuxer.bin2str(data.subarray(i + 4, i + 8));
        endbox = size > 1 ? i + size : end;

        if (type === path[0]) {
          if (path.length === 1) {
            // this is the end of the path and we've found the box we were
            // looking for
            results.push({ data: data, start: i + 8, end: endbox });
          } else {
            // recursively search for the next box along the path
            subresults = MP4Demuxer.findBox({ data: data, start: i + 8, end: endbox }, path.slice(1));
            if (subresults.length) {
              results = results.concat(subresults);
            }
          }
        }
        i = endbox;
      }

      // we've finished searching all of data
      return results;
    }
  }, {
    key: 'parseSegmentIndex',
    value: function parseSegmentIndex(initSegment) {
      var moov = MP4Demuxer.findBox(initSegment, ['moov'])[0];
      var moovEndOffset = moov ? moov.end : null; // we need this in case we need to chop of garbage of the end of current data

      var index = 0;
      var sidx = MP4Demuxer.findBox(initSegment, ['sidx']);
      var references = void 0;

      if (!sidx || !sidx[0]) {
        return null;
      }

      references = [];
      sidx = sidx[0];

      var version = sidx.data[0];

      // set initial offset, we skip the reference ID (not needed)
      index = version === 0 ? 8 : 16;

      var timescale = MP4Demuxer.readUint32(sidx, index);
      index += 4;

      // TODO: parse earliestPresentationTime and firstOffset
      // usually zero in our case
      var earliestPresentationTime = 0;
      var firstOffset = 0;

      if (version === 0) {
        index += 8;
      } else {
        index += 16;
      }

      // skip reserved
      index += 2;

      var startByte = sidx.end + firstOffset;

      var referencesCount = MP4Demuxer.readUint16(sidx, index);
      index += 2;

      for (var i = 0; i < referencesCount; i++) {
        var referenceIndex = index;

        var referenceInfo = MP4Demuxer.readUint32(sidx, referenceIndex);
        referenceIndex += 4;

        var referenceSize = referenceInfo & 0x7FFFFFFF;
        var referenceType = (referenceInfo & 0x80000000) >>> 31;

        if (referenceType === 1) {
          console.warn('SIDX has hierarchical references (not supported)');
          return;
        }

        var subsegmentDuration = MP4Demuxer.readUint32(sidx, referenceIndex);
        referenceIndex += 4;

        references.push({
          referenceSize: referenceSize,
          subsegmentDuration: subsegmentDuration, // unscaled
          info: {
            duration: subsegmentDuration / timescale,
            start: startByte,
            end: startByte + referenceSize - 1
          }
        });

        startByte += referenceSize;

        // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits
        // for |sapDelta|.
        referenceIndex += 4;

        // skip to next ref
        index = referenceIndex;
      }

      return {
        earliestPresentationTime: earliestPresentationTime,
        timescale: timescale,
        version: version,
        referencesCount: referencesCount,
        references: references,
        moovEndOffset: moovEndOffset
      };
    }

    /**
     * Parses an MP4 initialization segment and extracts stream type and
     * timescale values for any declared tracks. Timescale values indicate the
     * number of clock ticks per second to assume for time-based values
     * elsewhere in the MP4.
     *
     * To determine the start time of an MP4, you need two pieces of
     * information: the timescale unit and the earliest base media decode
     * time. Multiple timescales can be specified within an MP4 but the
     * base media decode time is always expressed in the timescale from
     * the media header box for the track:
     * ```
     * moov > trak > mdia > mdhd.timescale
     * moov > trak > mdia > hdlr
     * ```
     * @param init {Uint8Array} the bytes of the init segment
     * @return {object} a hash of track type to timescale values or null if
     * the init segment is malformed.
     */

  }, {
    key: 'parseInitSegment',
    value: function parseInitSegment(initSegment) {
      var result = [];
      var traks = MP4Demuxer.findBox(initSegment, ['moov', 'trak']);

      traks.forEach(function (trak) {
        var tkhd = MP4Demuxer.findBox(trak, ['tkhd'])[0];
        if (tkhd) {
          var version = tkhd.data[tkhd.start];
          var index = version === 0 ? 12 : 20;
          var trackId = MP4Demuxer.readUint32(tkhd, index);

          var mdhd = MP4Demuxer.findBox(trak, ['mdia', 'mdhd'])[0];
          if (mdhd) {
            version = mdhd.data[mdhd.start];
            index = version === 0 ? 12 : 20;
            var timescale = MP4Demuxer.readUint32(mdhd, index);

            var hdlr = MP4Demuxer.findBox(trak, ['mdia', 'hdlr'])[0];
            if (hdlr) {
              var hdlrType = MP4Demuxer.bin2str(hdlr.data.subarray(hdlr.start + 8, hdlr.start + 12));
              var type = { 'soun': 'audio', 'vide': 'video' }[hdlrType];
              if (type) {
                // extract codec info. TODO : parse codec details to be able to build MIME type
                var codecBox = MP4Demuxer.findBox(trak, ['mdia', 'minf', 'stbl', 'stsd']);
                if (codecBox.length) {
                  codecBox = codecBox[0];
                  var codecType = MP4Demuxer.bin2str(codecBox.data.subarray(codecBox.start + 12, codecBox.start + 16));
                  _logger.logger.log('MP4Demuxer:' + type + ':' + codecType + ' found');
                }
                result[trackId] = { timescale: timescale, type: type };
                result[type] = { timescale: timescale, id: trackId };
              }
            }
          }
        }
      });
      return result;
    }

    /**
    * Determine the base media decode start time, in seconds, for an MP4
    * fragment. If multiple fragments are specified, the earliest time is
    * returned.
    *
    * The base media decode time can be parsed from track fragment
    * metadata:
    * ```
    * moof > traf > tfdt.baseMediaDecodeTime
    * ```
    * It requires the timescale value from the mdhd to interpret.
    *
    * @param timescale {object} a hash of track ids to timescale values.
    * @return {number} the earliest base media decode start time for the
    * fragment, in seconds
    */

  }, {
    key: 'getStartDTS',
    value: function getStartDTS(initData, fragment) {
      var trafs = void 0,
          baseTimes = void 0,
          result = void 0;

      // we need info from two childrend of each track fragment box
      trafs = MP4Demuxer.findBox(fragment, ['moof', 'traf']);

      // determine the start times for each track
      baseTimes = [].concat.apply([], trafs.map(function (traf) {
        return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
          var id = void 0,
              scale = void 0,
              baseTime = void 0;

          // get the track id from the tfhd
          id = MP4Demuxer.readUint32(tfhd, 4);
          // assume a 90kHz clock if no timescale was specified
          scale = initData[id].timescale || 90e3;

          // get the base media decode time from the tfdt
          baseTime = MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
            var version = void 0,
                result = void 0;

            version = tfdt.data[tfdt.start];
            result = MP4Demuxer.readUint32(tfdt, 4);
            if (version === 1) {
              result *= Math.pow(2, 32);

              result += MP4Demuxer.readUint32(tfdt, 8);
            }
            return result;
          })[0];
          // convert base time to seconds
          return baseTime / scale;
        });
      }));

      // return the minimum
      result = Math.min.apply(null, baseTimes);
      return isFinite(result) ? result : 0;
    }
  }, {
    key: 'offsetStartDTS',
    value: function offsetStartDTS(initData, fragment, timeOffset) {
      MP4Demuxer.findBox(fragment, ['moof', 'traf']).map(function (traf) {
        return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
          // get the track id from the tfhd
          var id = MP4Demuxer.readUint32(tfhd, 4);
          // assume a 90kHz clock if no timescale was specified
          var timescale = initData[id].timescale || 90e3;

          // get the base media decode time from the tfdt
          MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
            var version = tfdt.data[tfdt.start];
            var baseMediaDecodeTime = MP4Demuxer.readUint32(tfdt, 4);
            if (version === 0) {
              MP4Demuxer.writeUint32(tfdt, 4, baseMediaDecodeTime - timeOffset * timescale);
            } else {
              baseMediaDecodeTime *= Math.pow(2, 32);
              baseMediaDecodeTime += MP4Demuxer.readUint32(tfdt, 8);
              baseMediaDecodeTime -= timeOffset * timescale;
              baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
              var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
              var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
              MP4Demuxer.writeUint32(tfdt, 4, upper);
              MP4Demuxer.writeUint32(tfdt, 8, lower);
            }
          });
        });
      });
    }
  }]);

  return MP4Demuxer;
}();

exports.default = MP4Demuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/mpegaudio.js":
/*!***************************************!*\
  !*** ./src/hls.js/demux/mpegaudio.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 *  MPEG parser helper
 */

var MpegAudio = {

  BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],

  SamplingRateMap: [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000],

  SamplesCoefficients: [
  // MPEG 2.5
  [0, // Reserved
  72, // Layer3
  144, // Layer2
  12 // Layer1
  ],
  // Reserved
  [0, // Reserved
  0, // Layer3
  0, // Layer2
  0 // Layer1
  ],
  // MPEG 2
  [0, // Reserved
  72, // Layer3
  144, // Layer2
  12 // Layer1
  ],
  // MPEG 1
  [0, // Reserved
  144, // Layer3
  144, // Layer2
  12 // Layer1
  ]],

  BytesInSlot: [0, // Reserved
  1, // Layer3
  1, // Layer2
  4 // Layer1
  ],

  appendFrame: function appendFrame(track, data, offset, pts, frameIndex) {
    // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
    if (offset + 24 > data.length) {
      return undefined;
    }

    var header = this.parseHeader(data, offset);
    if (header && offset + header.frameLength <= data.length) {
      var frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;
      var stamp = pts + frameIndex * frameDuration;
      var sample = { unit: data.subarray(offset, offset + header.frameLength), pts: stamp, dts: stamp };

      track.config = [];
      track.channelCount = header.channelCount;
      track.samplerate = header.sampleRate;
      track.samples.push(sample);
      track.len += header.frameLength;

      return { sample: sample, length: header.frameLength };
    }

    return undefined;
  },

  parseHeader: function parseHeader(data, offset) {
    var headerB = data[offset + 1] >> 3 & 3;
    var headerC = data[offset + 1] >> 1 & 3;
    var headerE = data[offset + 2] >> 4 & 15;
    var headerF = data[offset + 2] >> 2 & 3;
    var headerG = data[offset + 2] >> 1 & 1;
    if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {
      var columnInBitrates = headerB === 3 ? 3 - headerC : headerC === 3 ? 3 : 4;
      var bitRate = MpegAudio.BitratesMap[columnInBitrates * 14 + headerE - 1] * 1000;
      var columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;
      var sampleRate = MpegAudio.SamplingRateMap[columnInSampleRates * 3 + headerF];
      var channelCount = data[offset + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)
      var sampleCoefficient = MpegAudio.SamplesCoefficients[headerB][headerC];
      var bytesInSlot = MpegAudio.BytesInSlot[headerC];
      var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
      var frameLength = parseInt(sampleCoefficient * bitRate / sampleRate + headerG, 10) * bytesInSlot;

      return { sampleRate: sampleRate, channelCount: channelCount, frameLength: frameLength, samplesPerFrame: samplesPerFrame };
    }

    return undefined;
  },

  isHeaderPattern: function isHeaderPattern(data, offset) {
    return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;
  },

  isHeader: function isHeader(data, offset) {
    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
    // More info http://www.mp3-tech.org/programmer/frame_header.html
    if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
      return true;
    }

    return false;
  },

  probe: function probe(data, offset) {
    // same as isHeader but we also check that MPEG frame follows last MPEG frame
    // or end of data is reached
    if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
      // MPEG header Length
      var headerLength = 4;
      // MPEG frame Length
      var header = this.parseHeader(data, offset);
      var frameLength = headerLength;
      if (header && header.frameLength) {
        frameLength = header.frameLength;
      }

      var newOffset = offset + frameLength;
      if (newOffset === data.length || newOffset + 1 < data.length && this.isHeaderPattern(data, newOffset)) {
        return true;
      }
    }
    return false;
  }
};

exports.default = MpegAudio;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/demux/sample-aes.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/sample-aes.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SAMPLE-AES decrypter
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _decrypter = __webpack_require__(/*! ../crypt/decrypter */ "./src/hls.js/crypt/decrypter.js");

var _decrypter2 = _interopRequireDefault(_decrypter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SampleAesDecrypter = function () {
  function SampleAesDecrypter(observer, config, decryptdata, discardEPB) {
    _classCallCheck(this, SampleAesDecrypter);

    this.decryptdata = decryptdata;
    this.discardEPB = discardEPB;
    this.decrypter = new _decrypter2.default(observer, config, { removePKCS7Padding: false });
  }

  _createClass(SampleAesDecrypter, [{
    key: 'decryptBuffer',
    value: function decryptBuffer(encryptedData, callback) {
      this.decrypter.decrypt(encryptedData, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, callback);
    }

    // AAC - encrypt all full 16 bytes blocks starting from offset 16

  }, {
    key: 'decryptAacSample',
    value: function decryptAacSample(samples, sampleIndex, callback, sync) {
      var curUnit = samples[sampleIndex].unit;
      var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
      var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);

      var localthis = this;
      this.decryptBuffer(encryptedBuffer, function (decryptedData) {
        decryptedData = new Uint8Array(decryptedData);
        curUnit.set(decryptedData, 16);

        if (!sync) {
          localthis.decryptAacSamples(samples, sampleIndex + 1, callback);
        }
      });
    }
  }, {
    key: 'decryptAacSamples',
    value: function decryptAacSamples(samples, sampleIndex, callback) {
      for (;; sampleIndex++) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }

        if (samples[sampleIndex].unit.length < 32) {
          continue;
        }

        var sync = this.decrypter.isSync();

        this.decryptAacSample(samples, sampleIndex, callback, sync);

        if (!sync) {
          return;
        }
      }
    }

    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32

  }, {
    key: 'getAvcEncryptedData',
    value: function getAvcEncryptedData(decodedData) {
      var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
      var encryptedData = new Int8Array(encryptedDataLen);
      var outputPos = 0;
      for (var inputPos = 32; inputPos <= decodedData.length - 16; inputPos += 160, outputPos += 16) {
        encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
      }

      return encryptedData;
    }
  }, {
    key: 'getAvcDecryptedUnit',
    value: function getAvcDecryptedUnit(decodedData, decryptedData) {
      decryptedData = new Uint8Array(decryptedData);
      var inputPos = 0;
      for (var outputPos = 32; outputPos <= decodedData.length - 16; outputPos += 160, inputPos += 16) {
        decodedData.set(decryptedData.subarray(inputPos, inputPos + 16), outputPos);
      }

      return decodedData;
    }
  }, {
    key: 'decryptAvcSample',
    value: function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync) {
      var decodedData = this.discardEPB(curUnit.data);
      var encryptedData = this.getAvcEncryptedData(decodedData);
      var localthis = this;

      this.decryptBuffer(encryptedData.buffer, function (decryptedData) {
        curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedData);

        if (!sync) {
          localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
        }
      });
    }
  }, {
    key: 'decryptAvcSamples',
    value: function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
      for (;; sampleIndex++, unitIndex = 0) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }

        var curUnits = samples[sampleIndex].units;
        for (;; unitIndex++) {
          if (unitIndex >= curUnits.length) {
            break;
          }

          var curUnit = curUnits[unitIndex];
          if (curUnit.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
            continue;
          }

          var sync = this.decrypter.isSync();

          this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);

          if (!sync) {
            return;
          }
        }
      }
    }
  }]);

  return SampleAesDecrypter;
}();

exports.default = SampleAesDecrypter;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/tsdemuxer.js":
/*!***************************************!*\
  !*** ./src/hls.js/demux/tsdemuxer.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * highly optimized TS demuxer:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * parse PAT, PMT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract PES packet from audio and video PIDs
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * trigger the remuxer upon parsing completion
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also controls the remuxing process :
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

// import Hex from '../utils/hex';


var _adts = __webpack_require__(/*! ./adts */ "./src/hls.js/demux/adts.js");

var ADTS = _interopRequireWildcard(_adts);

var _mpegaudio = __webpack_require__(/*! ./mpegaudio */ "./src/hls.js/demux/mpegaudio.js");

var _mpegaudio2 = _interopRequireDefault(_mpegaudio);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _expGolomb = __webpack_require__(/*! ./exp-golomb */ "./src/hls.js/demux/exp-golomb.js");

var _expGolomb2 = _interopRequireDefault(_expGolomb);

var _sampleAes = __webpack_require__(/*! ./sample-aes */ "./src/hls.js/demux/sample-aes.js");

var _sampleAes2 = _interopRequireDefault(_sampleAes);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// We are using fixed track IDs for driving the MP4 remuxer
// instead of following the TS PIDs.
// There is no reason not to do this and some browsers/SourceBuffer-demuxers
// may not like if there are TrackID "switches"
// See https://github.com/video-dev/hls.js/issues/1331
// Here we are mapping our internal track types to constant MP4 track IDs
// With MSE currently one can only have one track of each, and we are muxing
// whatever video/audio rendition in them.
var RemuxerTrackIdConfig = {
  video: 1,
  audio: 2,
  id3: 3,
  text: 4
};

var TSDemuxer = function () {
  function TSDemuxer(observer, remuxer, config, typeSupported) {
    _classCallCheck(this, TSDemuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    this.remuxer = remuxer;
    this.sampleAes = null;
  }

  _createClass(TSDemuxer, [{
    key: 'setDecryptData',
    value: function setDecryptData(decryptdata) {
      if (decryptdata != null && decryptdata.key != null && decryptdata.method === 'SAMPLE-AES') {
        this.sampleAes = new _sampleAes2.default(this.observer, this.config, decryptdata, this.discardEPB);
      } else {
        this.sampleAes = null;
      }
    }
  }, {
    key: 'resetInitSegment',


    /**
     * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
     * Resets all internal track instances of the demuxer.
     *
     * @override Implements generic demuxing/remuxing interface (see DemuxerInline)
     * @param {object} initSegment
     * @param {string} audioCodec
     * @param {string} videoCodec
     * @param {number} duration (in TS timescale = 90kHz)
     */
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this.pmtParsed = false;
      this._pmtId = -1;

      this._avcTrack = TSDemuxer.createTrack('video', duration);
      this._audioTrack = TSDemuxer.createTrack('audio', duration);
      this._id3Track = TSDemuxer.createTrack('id3', duration);
      this._txtTrack = TSDemuxer.createTrack('text', duration);

      // flush any partial content
      this.aacOverFlow = null;
      this.aacLastPTS = null;
      this.avcSample = null;
      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this._duration = duration;
    }

    /**
     *
     * @override
     */

  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}

    // feed incoming data to the front of the parsing pipeline

  }, {
    key: 'append',
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var start = void 0,
          len = data.length,
          stt = void 0,
          pid = void 0,
          atf = void 0,
          offset = void 0,
          pes = void 0,
          unknownPIDs = false;
      this.contiguous = contiguous;
      var pmtParsed = this.pmtParsed,
          avcTrack = this._avcTrack,
          audioTrack = this._audioTrack,
          id3Track = this._id3Track,
          avcId = avcTrack.pid,
          audioId = audioTrack.pid,
          id3Id = id3Track.pid,
          pmtId = this._pmtId,
          avcData = avcTrack.pesData,
          audioData = audioTrack.pesData,
          id3Data = id3Track.pesData,
          parsePAT = this._parsePAT,
          parsePMT = this._parsePMT,
          parsePES = this._parsePES,
          parseAVCPES = this._parseAVCPES.bind(this),
          parseAACPES = this._parseAACPES.bind(this),
          parseMPEGPES = this._parseMPEGPES.bind(this),
          parseID3PES = this._parseID3PES.bind(this);

      var syncOffset = TSDemuxer._syncOffset(data);

      // don't parse last TS packet if incomplete
      len -= (len + syncOffset) % 188;

      // loop through TS packets
      for (start = syncOffset; start < len; start += 188) {
        if (data[start] === 0x47) {
          stt = !!(data[start + 1] & 0x40);
          // pid is a 13-bit field starting at the last bit of TS[1]
          pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
          atf = (data[start + 3] & 0x30) >> 4;
          // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
          if (atf > 1) {
            offset = start + 5 + data[start + 4];
            // continue if there is only adaptation field
            if (offset === start + 188) {
              continue;
            }
          } else {
            offset = start + 4;
          }
          switch (pid) {
            case avcId:
              if (stt) {
                if (avcData && (pes = parsePES(avcData)) && pes.pts !== undefined) {
                  parseAVCPES(pes, false);
                }

                avcData = { data: [], size: 0 };
              }
              if (avcData) {
                avcData.data.push(data.subarray(offset, start + 188));
                avcData.size += start + 188 - offset;
              }
              break;
            case audioId:
              if (stt) {
                if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {
                  if (audioTrack.isAAC) {
                    parseAACPES(pes);
                  } else {
                    parseMPEGPES(pes);
                  }
                }
                audioData = { data: [], size: 0 };
              }
              if (audioData) {
                audioData.data.push(data.subarray(offset, start + 188));
                audioData.size += start + 188 - offset;
              }
              break;
            case id3Id:
              if (stt) {
                if (id3Data && (pes = parsePES(id3Data)) && pes.pts !== undefined) {
                  parseID3PES(pes);
                }

                id3Data = { data: [], size: 0 };
              }
              if (id3Data) {
                id3Data.data.push(data.subarray(offset, start + 188));
                id3Data.size += start + 188 - offset;
              }
              break;
            case 0:
              if (stt) {
                offset += data[offset] + 1;
              }

              pmtId = this._pmtId = parsePAT(data, offset);
              break;
            case pmtId:
              if (stt) {
                offset += data[offset] + 1;
              }

              var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, this.sampleAes != null);

              // only update track id if track PID found while parsing PMT
              // this is to avoid resetting the PID to -1 in case
              // track PID transiently disappears from the stream
              // this could happen in case of transient missing audio samples for example
              // NOTE this is only the PID of the track as found in TS,
              // but we are not using this for MP4 track IDs.
              avcId = parsedPIDs.avc;
              if (avcId > 0) {
                avcTrack.pid = avcId;
              }

              audioId = parsedPIDs.audio;
              if (audioId > 0) {
                audioTrack.pid = audioId;
                audioTrack.isAAC = parsedPIDs.isAAC;
              }
              id3Id = parsedPIDs.id3;
              if (id3Id > 0) {
                id3Track.pid = id3Id;
              }

              if (unknownPIDs && !pmtParsed) {
                _logger.logger.log('reparse from beginning');
                unknownPIDs = false;
                // we set it to -188, the += 188 in the for loop will reset start to 0
                start = syncOffset - 188;
              }
              pmtParsed = this.pmtParsed = true;
              break;
            case 17:
            case 0x1fff:
              break;
            default:
              unknownPIDs = true;
              break;
          }
        } else {
          this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });
        }
      }
      // try to parse last PES packets
      if (avcData && (pes = parsePES(avcData)) && pes.pts !== undefined) {
        parseAVCPES(pes, true);
        avcTrack.pesData = null;
      } else {
        // either avcData null or PES truncated, keep it for next frag parsing
        avcTrack.pesData = avcData;
      }

      if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {
        if (audioTrack.isAAC) {
          parseAACPES(pes);
        } else {
          parseMPEGPES(pes);
        }

        audioTrack.pesData = null;
      } else {
        if (audioData && audioData.size) {
          _logger.logger.log('last AAC PES packet truncated,might overlap between fragments');
        }

        // either audioData null or PES truncated, keep it for next frag parsing
        audioTrack.pesData = audioData;
      }

      if (id3Data && (pes = parsePES(id3Data)) && pes.pts !== undefined) {
        parseID3PES(pes);
        id3Track.pesData = null;
      } else {
        // either id3Data null or PES truncated, keep it for next frag parsing
        id3Track.pesData = id3Data;
      }

      if (this.sampleAes == null) {
        this.remuxer.remux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
      } else {
        this.decryptAndRemux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'decryptAndRemux',
    value: function decryptAndRemux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      if (audioTrack.samples && audioTrack.isAAC) {
        var localthis = this;
        this.sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {
          localthis.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
        });
      } else {
        this.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'decryptAndRemuxAvc',
    value: function decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      if (videoTrack.samples) {
        var localthis = this;
        this.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {
          localthis.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
        });
      } else {
        this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this._initPTS = this._initDTS = undefined;
      this._duration = 0;
    }
  }, {
    key: '_parsePAT',
    value: function _parsePAT(data, offset) {
      // skip the PSI header and parse the first PMT entry
      return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];
      // logger.log('PMT PID:'  + this._pmtId);
    }
  }, {
    key: '_parsePMT',
    value: function _parsePMT(data, offset, mpegSupported, isSampleAes) {
      var sectionLength = void 0,
          tableEnd = void 0,
          programInfoLength = void 0,
          pid = void 0,
          result = { audio: -1, avc: -1, id3: -1, isAAC: true };
      sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
      tableEnd = offset + 3 + sectionLength - 4;
      // to determine where the table is, we have to figure out how
      // long the program info descriptors are
      programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
      // advance the offset to the first entry in the mapping table
      offset += 12 + programInfoLength;
      while (offset < tableEnd) {
        pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];
        switch (data[offset]) {
          case 0xcf:
            // SAMPLE-AES AAC
            if (!isSampleAes) {
              _logger.logger.log('unkown stream type:' + data[offset]);
              break;
            }
          /* falls through */

          // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
          case 0x0f:
            // logger.log('AAC PID:'  + pid);
            if (result.audio === -1) {
              result.audio = pid;
            }

            break;

          // Packetized metadata (ID3)
          case 0x15:
            // logger.log('ID3 PID:'  + pid);
            if (result.id3 === -1) {
              result.id3 = pid;
            }

            break;

          case 0xdb:
            // SAMPLE-AES AVC
            if (!isSampleAes) {
              _logger.logger.log('unkown stream type:' + data[offset]);
              break;
            }
          /* falls through */

          // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
          case 0x1b:
            // logger.log('AVC PID:'  + pid);
            if (result.avc === -1) {
              result.avc = pid;
            }

            break;

          // ISO/IEC 11172-3 (MPEG-1 audio)
          // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
          case 0x03:
          case 0x04:
            // logger.log('MPEG PID:'  + pid);
            if (!mpegSupported) {
              _logger.logger.log('MPEG audio found, not supported in this browser for now');
            } else if (result.audio === -1) {
              result.audio = pid;
              result.isAAC = false;
            }
            break;

          case 0x24:
            _logger.logger.warn('HEVC stream type found, not supported for now');
            break;

          default:
            _logger.logger.log('unkown stream type:' + data[offset]);
            break;
        }
        // move to the next table entry
        // skip past the elementary stream descriptors, if present
        offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;
      }
      return result;
    }
  }, {
    key: '_parsePES',
    value: function _parsePES(stream) {
      var i = 0,
          frag = void 0,
          pesFlags = void 0,
          pesPrefix = void 0,
          pesLen = void 0,
          pesHdrLen = void 0,
          pesData = void 0,
          pesPts = void 0,
          pesDts = void 0,
          payloadStartOffset = void 0,
          data = stream.data;
      // safety check
      if (!stream || stream.size === 0) {
        return null;
      }

      // we might need up to 19 bytes to read PES header
      // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
      // usually only one merge is needed (and this is rare ...)
      while (data[0].length < 19 && data.length > 1) {
        var newData = new Uint8Array(data[0].length + data[1].length);
        newData.set(data[0]);
        newData.set(data[1], data[0].length);
        data[0] = newData;
        data.splice(1, 1);
      }
      // retrieve PTS/DTS from first fragment
      frag = data[0];
      pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
      if (pesPrefix === 1) {
        pesLen = (frag[4] << 8) + frag[5];
        // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
        // minus 6 : PES header size
        if (pesLen && pesLen > stream.size - 6) {
          return null;
        }

        pesFlags = frag[7];
        if (pesFlags & 0xC0) {
          /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
              as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
              as Bitwise operators treat their operands as a sequence of 32 bits */
          pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
          (frag[10] & 0xFF) * 4194304 + // 1 << 22
          (frag[11] & 0xFE) * 16384 + // 1 << 14
          (frag[12] & 0xFF) * 128 + // 1 << 7
          (frag[13] & 0xFE) / 2;
          // check if greater than 2^32 -1
          if (pesPts > 4294967295) {
            // decrement 2^33
            pesPts -= 8589934592;
          }
          if (pesFlags & 0x40) {
            pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
            (frag[15] & 0xFF) * 4194304 + // 1 << 22
            (frag[16] & 0xFE) * 16384 + // 1 << 14
            (frag[17] & 0xFF) * 128 + // 1 << 7
            (frag[18] & 0xFE) / 2;
            // check if greater than 2^32 -1
            if (pesDts > 4294967295) {
              // decrement 2^33
              pesDts -= 8589934592;
            }
            if (pesPts - pesDts > 60 * 90000) {
              _logger.logger.warn(Math.round((pesPts - pesDts) / 90000) + 's delta between PTS and DTS, align them');
              pesPts = pesDts;
            }
          } else {
            pesDts = pesPts;
          }
        }
        pesHdrLen = frag[8];
        // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension
        payloadStartOffset = pesHdrLen + 9;

        stream.size -= payloadStartOffset;
        // reassemble PES packet
        pesData = new Uint8Array(stream.size);
        for (var j = 0, dataLen = data.length; j < dataLen; j++) {
          frag = data[j];
          var len = frag.byteLength;
          if (payloadStartOffset) {
            if (payloadStartOffset > len) {
              // trim full frag if PES header bigger than frag
              payloadStartOffset -= len;
              continue;
            } else {
              // trim partial frag if PES header smaller than frag
              frag = frag.subarray(payloadStartOffset);
              len -= payloadStartOffset;
              payloadStartOffset = 0;
            }
          }
          pesData.set(frag, i);
          i += len;
        }
        if (pesLen) {
          // payload size : remove PES header + PES extension
          pesLen -= pesHdrLen + 3;
        }
        return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
      } else {
        return null;
      }
    }
  }, {
    key: 'pushAccesUnit',
    value: function pushAccesUnit(avcSample, avcTrack) {
      if (avcSample.units.length && avcSample.frame) {
        var samples = avcTrack.samples;
        var nbSamples = samples.length;
        // only push AVC sample if starting with a keyframe is not mandatory OR
        //    if keyframe already found in this fragment OR
        //       keyframe found in last fragment (track.sps) AND
        //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
        if (!this.config.forceKeyFrameOnDiscontinuity || avcSample.key === true || avcTrack.sps && (nbSamples || this.contiguous)) {
          avcSample.id = nbSamples;
          samples.push(avcSample);
        } else {
          // dropped samples, track it
          avcTrack.dropped++;
        }
      }
      if (avcSample.debug.length) {
        _logger.logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);
      }
    }
  }, {
    key: '_parseAVCPES',
    value: function _parseAVCPES(pes, last) {
      var _this = this;

      // logger.log('parse new PES');
      var track = this._avcTrack,
          units = this._parseAVCNALu(pes.data),
          debug = false,
          expGolombDecoder = void 0,
          avcSample = this.avcSample,
          push = void 0,
          spsfound = false,
          i = void 0,
          pushAccesUnit = this.pushAccesUnit.bind(this),
          createAVCSample = function createAVCSample(key, pts, dts, debug) {
        return { key: key, pts: pts, dts: dts, units: [], debug: debug };
      };
      // free pes.data to save up some memory
      pes.data = null;

      // if new NAL units found and last sample still there, let's push ...
      // this helps parsing streams with missing AUD (only do this if AUD never found)
      if (avcSample && units.length && !track.audFound) {
        pushAccesUnit(avcSample, track);
        avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');
      }

      units.forEach(function (unit) {
        switch (unit.type) {
          // NDR
          case 1:
            push = true;
            if (!avcSample) {
              avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');
            }

            if (debug) {
              avcSample.debug += 'NDR ';
            }

            avcSample.frame = true;
            var data = unit.data;
            // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)
            if (spsfound && data.length > 4) {
              // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
              var sliceType = new _expGolomb2.default(data).readSliceType();
              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.
              // if (sliceType === 2 || sliceType === 7) {
              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                avcSample.key = true;
              }
            }
            break;
          // IDR
          case 5:
            push = true;
            // handle PES not starting with AUD
            if (!avcSample) {
              avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');
            }

            if (debug) {
              avcSample.debug += 'IDR ';
            }

            avcSample.key = true;
            avcSample.frame = true;
            break;
          // SEI
          case 6:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'SEI ';
            }

            expGolombDecoder = new _expGolomb2.default(_this.discardEPB(unit.data));

            // skip frameType
            expGolombDecoder.readUByte();

            var payloadType = 0;
            var payloadSize = 0;
            var endOfCaptions = false;
            var b = 0;

            while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
              payloadType = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadType += b;
              } while (b === 0xFF);

              // Parse payload size.
              payloadSize = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadSize += b;
              } while (b === 0xFF);

              // TODO: there can be more than one payload in an SEI packet...
              // TODO: need to read type and size in a while loop to get them all
              if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {
                endOfCaptions = true;

                var countryCode = expGolombDecoder.readUByte();

                if (countryCode === 181) {
                  var providerCode = expGolombDecoder.readUShort();

                  if (providerCode === 49) {
                    var userStructure = expGolombDecoder.readUInt();

                    if (userStructure === 0x47413934) {
                      var userDataType = expGolombDecoder.readUByte();

                      // Raw CEA-608 bytes wrapped in CEA-708 packet
                      if (userDataType === 3) {
                        var firstByte = expGolombDecoder.readUByte();
                        var secondByte = expGolombDecoder.readUByte();

                        var totalCCs = 31 & firstByte;
                        var byteArray = [firstByte, secondByte];

                        for (i = 0; i < totalCCs; i++) {
                          // 3 bytes per CC
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                        }

                        _this._insertSampleInOrder(_this._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });
                      }
                    }
                  }
                }
              } else if (payloadSize < expGolombDecoder.bytesAvailable) {
                for (i = 0; i < payloadSize; i++) {
                  expGolombDecoder.readUByte();
                }
              }
            }
            break;
          // SPS
          case 7:
            push = true;
            spsfound = true;
            if (debug && avcSample) {
              avcSample.debug += 'SPS ';
            }

            if (!track.sps) {
              expGolombDecoder = new _expGolomb2.default(unit.data);
              var config = expGolombDecoder.readSPS();
              track.width = config.width;
              track.height = config.height;
              track.pixelRatio = config.pixelRatio;
              track.sps = [unit.data];
              track.duration = _this._duration;
              var codecarray = unit.data.subarray(1, 4);
              var codecstring = 'avc1.';
              for (i = 0; i < 3; i++) {
                var h = codecarray[i].toString(16);
                if (h.length < 2) {
                  h = '0' + h;
                }

                codecstring += h;
              }
              track.codec = codecstring;
            }
            break;
          // PPS
          case 8:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'PPS ';
            }

            if (!track.pps) {
              track.pps = [unit.data];
            }

            break;
          // AUD
          case 9:
            push = false;
            track.audFound = true;
            if (avcSample) {
              pushAccesUnit(avcSample, track);
            }

            avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');
            break;
          // Filler Data
          case 12:
            push = false;
            break;
          default:
            push = false;
            if (avcSample) {
              avcSample.debug += 'unknown NAL ' + unit.type + ' ';
            }

            break;
        }
        if (avcSample && push) {
          var _units = avcSample.units;
          _units.push(unit);
        }
      });
      // if last PES packet, push samples
      if (last && avcSample) {
        pushAccesUnit(avcSample, track);
        this.avcSample = null;
      }
    }
  }, {
    key: '_insertSampleInOrder',
    value: function _insertSampleInOrder(arr, data) {
      var len = arr.length;
      if (len > 0) {
        if (data.pts >= arr[len - 1].pts) {
          arr.push(data);
        } else {
          for (var pos = len - 1; pos >= 0; pos--) {
            if (data.pts < arr[pos].pts) {
              arr.splice(pos, 0, data);
              break;
            }
          }
        }
      } else {
        arr.push(data);
      }
    }
  }, {
    key: '_getLastNalUnit',
    value: function _getLastNalUnit() {
      var avcSample = this.avcSample,
          lastUnit = void 0;
      // try to fallback to previous sample if current one is empty
      if (!avcSample || avcSample.units.length === 0) {
        var track = this._avcTrack,
            samples = track.samples;
        avcSample = samples[samples.length - 1];
      }
      if (avcSample) {
        var units = avcSample.units;
        lastUnit = units[units.length - 1];
      }
      return lastUnit;
    }
  }, {
    key: '_parseAVCNALu',
    value: function _parseAVCNALu(array) {
      var i = 0,
          len = array.byteLength,
          value = void 0,
          overflow = void 0,
          track = this._avcTrack,
          state = track.naluState || 0,
          lastState = state;
      var units = [],
          unit = void 0,
          unitType = void 0,
          lastUnitStart = -1,
          lastUnitType = void 0;
      // logger.log('PES:' + Hex.hexDump(array));

      if (state === -1) {
        // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
        lastUnitStart = 0;
        // NALu type is value read from offset 0
        lastUnitType = array[0] & 0x1f;
        state = 0;
        i = 1;
      }

      while (i < len) {
        value = array[i++];
        // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case
        if (!state) {
          state = value ? 0 : 1;
          continue;
        }
        if (state === 1) {
          state = value ? 0 : 2;
          continue;
        }
        // here we have state either equal to 2 or 3
        if (!value) {
          state = 3;
        } else if (value === 1) {
          if (lastUnitStart >= 0) {
            unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
            // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
            units.push(unit);
          } else {
            // lastUnitStart is undefined => this is the first start code found in this PES packet
            // first check if start code delimiter is overlapping between 2 PES packets,
            // ie it started in last packet (lastState not zero)
            // and ended at the beginning of this PES packet (i <= 4 - lastState)
            var lastUnit = this._getLastNalUnit();
            if (lastUnit) {
              if (lastState && i <= 4 - lastState) {
                // start delimiter overlapping between PES packets
                // strip start delimiter bytes from the end of last NAL unit
                // check if lastUnit had a state different from zero
                if (lastUnit.state) {
                  // strip last bytes
                  lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                }
              }
              // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
              overflow = i - state - 1;
              if (overflow > 0) {
                // logger.log('first NALU found with overflow:' + overflow);
                var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
                tmp.set(lastUnit.data, 0);
                tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
                lastUnit.data = tmp;
              }
            }
          }
          // check if we can read unit type
          if (i < len) {
            unitType = array[i] & 0x1f;
            // logger.log('find NALU @ offset:' + i + ',type:' + unitType);
            lastUnitStart = i;
            lastUnitType = unitType;
            state = 0;
          } else {
            // not enough byte to read unit type. let's read it on next PES parsing
            state = -1;
          }
        } else {
          state = 0;
        }
      }
      if (lastUnitStart >= 0 && state >= 0) {
        unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
        units.push(unit);
        // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
      }
      // no NALu found
      if (units.length === 0) {
        // append pes.data to previous NAL unit
        var _lastUnit = this._getLastNalUnit();
        if (_lastUnit) {
          var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);
          _tmp.set(_lastUnit.data, 0);
          _tmp.set(array, _lastUnit.data.byteLength);
          _lastUnit.data = _tmp;
        }
      }
      track.naluState = state;
      return units;
    }

    /**
     * remove Emulation Prevention bytes from a RBSP
     */

  }, {
    key: 'discardEPB',
    value: function discardEPB(data) {
      var length = data.byteLength,
          EPBPositions = [],
          i = 1,
          newLength = void 0,
          newData = void 0;

      // Find all `Emulation Prevention Bytes`
      while (i < length - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
          EPBPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }

      // If no Emulation Prevention Bytes were found just return the original
      // array
      if (EPBPositions.length === 0) {
        return data;
      }

      // Create a new array to hold the NAL unit data
      newLength = length - EPBPositions.length;
      newData = new Uint8Array(newLength);
      var sourceIndex = 0;

      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === EPBPositions[0]) {
          // Skip this byte
          sourceIndex++;
          // Remove this position index
          EPBPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    }
  }, {
    key: '_parseAACPES',
    value: function _parseAACPES(pes) {
      var track = this._audioTrack,
          data = pes.data,
          pts = pes.pts,
          startOffset = 0,
          aacOverFlow = this.aacOverFlow,
          aacLastPTS = this.aacLastPTS,
          frameDuration = void 0,
          frameIndex = void 0,
          offset = void 0,
          stamp = void 0,
          len = void 0;
      if (aacOverFlow) {
        var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
        tmp.set(aacOverFlow, 0);
        tmp.set(data, aacOverFlow.byteLength);
        // logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
        data = tmp;
      }
      // look for ADTS header (0xFFFx)
      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
        if (ADTS.isHeader(data, offset)) {
          break;
        }
      }
      // if ADTS header does not start straight from the beginning of the PES payload, raise an error
      if (offset) {
        var reason = void 0,
            fatal = void 0;
        if (offset < len - 1) {
          reason = 'AAC PES did not start with ADTS header,offset:' + offset;
          fatal = false;
        } else {
          reason = 'no ADTS header found in AAC PES';
          fatal = true;
        }
        _logger.logger.warn('parsing error:' + reason);
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });
        if (fatal) {
          return;
        }
      }

      ADTS.initTrackConfig(track, this.observer, data, offset, this.audioCodec);
      frameIndex = 0;
      frameDuration = ADTS.getFrameDuration(track.samplerate);

      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
      // first sample PTS should be equal to last sample PTS + frameDuration
      if (aacOverFlow && aacLastPTS) {
        var newPTS = aacLastPTS + frameDuration;
        if (Math.abs(newPTS - pts) > 1) {
          _logger.logger.log('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));
          pts = newPTS;
        }
      }

      // scan for aac samples
      while (offset < len) {
        if (ADTS.isHeader(data, offset) && offset + 5 < len) {
          var frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);
          if (frame) {
            // logger.log(`${Math.round(frame.sample.pts)} : AAC`);
            offset += frame.length;
            stamp = frame.sample.pts;
            frameIndex++;
          } else {
            // logger.log('Unable to parse AAC frame');
            break;
          }
        } else {
          // nothing found, keep looking
          offset++;
        }
      }

      if (offset < len) {
        aacOverFlow = data.subarray(offset, len);
        // logger.log(`AAC: overflow detected:${len-offset}`);
      } else {
        aacOverFlow = null;
      }

      this.aacOverFlow = aacOverFlow;
      this.aacLastPTS = stamp;
    }
  }, {
    key: '_parseMPEGPES',
    value: function _parseMPEGPES(pes) {
      var data = pes.data;
      var length = data.length;
      var frameIndex = 0;
      var offset = 0;
      var pts = pes.pts;

      while (offset < length) {
        if (_mpegaudio2.default.isHeader(data, offset)) {
          var frame = _mpegaudio2.default.appendFrame(this._audioTrack, data, offset, pts, frameIndex);
          if (frame) {
            offset += frame.length;
            frameIndex++;
          } else {
            // logger.log('Unable to parse Mpeg audio frame');
            break;
          }
        } else {
          // nothing found, keep looking
          offset++;
        }
      }
    }
  }, {
    key: '_parseID3PES',
    value: function _parseID3PES(pes) {
      this._id3Track.samples.push(pes);
    }
  }], [{
    key: 'probe',
    value: function probe(data) {
      var syncOffset = TSDemuxer._syncOffset(data);
      if (syncOffset < 0) {
        return false;
      } else {
        if (syncOffset) {
          _logger.logger.warn('MPEG2-TS detected but first sync word found @ offset ' + syncOffset + ', junk ahead ?');
        }

        return true;
      }
    }
  }, {
    key: '_syncOffset',
    value: function _syncOffset(data) {
      // scan 1000 first bytes
      var scanwindow = Math.min(1000, data.length - 3 * 188);
      var i = 0;
      while (i < scanwindow) {
        // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
        if (data[i] === 0x47 && data[i + 188] === 0x47 && data[i + 2 * 188] === 0x47) {
          return i;
        } else {
          i++;
        }
      }
      return -1;
    }

    /**
     * Creates a track model internal to demuxer used to drive remuxing input
     *
     * @param {string} type 'audio' | 'video' | 'id3' | 'text'
     * @param {number} duration
     * @return {object} TSDemuxer's internal track model
     */

  }, {
    key: 'createTrack',
    value: function createTrack(type, duration) {
      return {
        container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,
        type: type,
        id: RemuxerTrackIdConfig[type],
        pid: -1,
        inputTimeScale: 90000,
        sequenceNumber: 0,
        samples: [],
        len: 0,
        dropped: type === 'video' ? 0 : undefined,
        isAAC: type === 'audio' ? true : undefined,
        duration: type === 'audio' ? duration : undefined
      };
    }
  }]);

  return TSDemuxer;
}();

exports.default = TSDemuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/errors.js":
/*!******************************!*\
  !*** ./src/hls.js/errors.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var ErrorTypes = exports.ErrorTypes = {
  // Identifier for a network error (loading error / timeout ...)
  NETWORK_ERROR: 'networkError',
  // Identifier for a media Error (video/parsing/mediasource error)
  MEDIA_ERROR: 'mediaError',
  // EME (encrypted media extensions) errors
  KEY_SYSTEM_ERROR: 'keySystemError',
  // Identifier for a mux Error (demuxing/remuxing)
  MUX_ERROR: 'muxError',
  // Identifier for all other errors
  OTHER_ERROR: 'otherError'
};

/**
 * @enum {ErrorDetails}
 * @typedef {string} ErrorDetail
 */
var ErrorDetails = exports.ErrorDetails = {
  KEY_SYSTEM_NO_KEYS: 'keySystemNoKeys',
  KEY_SYSTEM_NO_ACCESS: 'keySystemNoAccess',
  KEY_SYSTEM_NO_SESSION: 'keySystemNoSession',
  KEY_SYSTEM_LICENSE_REQUEST_FAILED: 'keySystemLicenseRequestFailed',
  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_ERROR: 'manifestLoadError',
  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',
  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
  MANIFEST_PARSING_ERROR: 'manifestParsingError',
  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
  MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',
  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_ERROR: 'levelLoadError',
  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',
  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
  LEVEL_SWITCH_ERROR: 'levelSwitchError',
  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',
  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',
  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  FRAG_LOAD_ERROR: 'fragLoadError',
  // Identifier for fragment load timeout error - data: { frag : fragment object}
  FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',
  // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
  FRAG_DECRYPT_ERROR: 'fragDecryptError',
  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
  FRAG_PARSING_ERROR: 'fragParsingError',
  // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
  REMUX_ALLOC_ERROR: 'remuxAllocError',
  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  KEY_LOAD_ERROR: 'keyLoadError',
  // Identifier for decrypt key load timeout error - data: { frag : fragment object}
  KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',
  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
  BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',
  // Identifier for a buffer append error - data: append error description
  BUFFER_APPEND_ERROR: 'bufferAppendError',
  // Identifier for a buffer appending error event - data: appending error description
  BUFFER_APPENDING_ERROR: 'bufferAppendingError',
  // Identifier for a buffer stalled error event
  BUFFER_STALLED_ERROR: 'bufferStalledError',
  // Identifier for a buffer full event
  BUFFER_FULL_ERROR: 'bufferFullError',
  // Identifier for a buffer seek over hole event
  BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',
  // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
  BUFFER_NUDGE_ON_STALL: 'bufferNudgeOnStall',
  // Identifier for an internal exception happening inside hls.js while handling an event
  INTERNAL_EXCEPTION: 'internalException'
};

/***/ }),

/***/ "./src/hls.js/event-handler.js":
/*!*************************************!*\
  !*** ./src/hls.js/event-handler.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * All objects in the event handling chain should inherit from this class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = __webpack_require__(/*! ./utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ./errors */ "./src/hls.js/errors.js");

var _events = __webpack_require__(/*! ./events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FORBIDDEN_EVENT_NAMES = {
  'hlsEventGeneric': true,
  'hlsHandlerDestroying': true,
  'hlsHandlerDestroyed': true
};

var EventHandler = function () {
  function EventHandler(hls) {
    _classCallCheck(this, EventHandler);

    this.hls = hls;
    this.onEvent = this.onEvent.bind(this);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    this.handledEvents = events;
    this.useGenericHandler = true;

    this.registerListeners();
  }

  _createClass(EventHandler, [{
    key: 'destroy',
    value: function destroy() {
      this.onHandlerDestroying();
      this.unregisterListeners();
      this.onHandlerDestroyed();
    }
  }, {
    key: 'onHandlerDestroying',
    value: function onHandlerDestroying() {}
  }, {
    key: 'onHandlerDestroyed',
    value: function onHandlerDestroyed() {}
  }, {
    key: 'isEventHandler',
    value: function isEventHandler() {
      return _typeof(this.handledEvents) === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';
    }
  }, {
    key: 'registerListeners',
    value: function registerListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          if (FORBIDDEN_EVENT_NAMES[event]) {
            throw new Error('Forbidden event-name: ' + event);
          }

          this.hls.on(event, this.onEvent);
        }, this);
      }
    }
  }, {
    key: 'unregisterListeners',
    value: function unregisterListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          this.hls.off(event, this.onEvent);
        }, this);
      }
    }

    /**
     * arguments: event (string), data (any)
     */

  }, {
    key: 'onEvent',
    value: function onEvent(event, data) {
      this.onEventGeneric(event, data);
    }
  }, {
    key: 'onEventGeneric',
    value: function onEventGeneric(event, data) {
      var eventToFunction = function eventToFunction(event, data) {
        var funcName = 'on' + event.replace('hls', '');
        if (typeof this[funcName] !== 'function') {
          throw new Error('Event ' + event + ' has no generic handler in this ' + this.constructor.name + ' class (tried ' + funcName + ')');
        }

        return this[funcName].bind(this, data);
      };
      try {
        eventToFunction.call(this, event, data).call();
      } catch (err) {
        _logger.logger.error('An internal error happened while handling event ' + event + '. Error message: "' + err.message + '". Here is a stacktrace:', err);
        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });
      }
    }
  }]);

  return EventHandler;
}();

exports.default = EventHandler;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/events.js":
/*!******************************!*\
  !*** ./src/hls.js/events.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @readonly
 * @enum {string}
 */
var HlsEvents = {
  // fired before MediaSource is attaching to media element - data: { media }
  MEDIA_ATTACHING: 'hlsMediaAttaching',
  // fired when MediaSource has been succesfully attached to media element - data: { }
  MEDIA_ATTACHED: 'hlsMediaAttached',
  // fired before detaching MediaSource from media element - data: { }
  MEDIA_DETACHING: 'hlsMediaDetaching',
  // fired when MediaSource has been detached from media element - data: { }
  MEDIA_DETACHED: 'hlsMediaDetached',
  // fired when we buffer is going to be reset - data: { }
  BUFFER_RESET: 'hlsBufferReset',
  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
  BUFFER_CODECS: 'hlsBufferCodecs',
  // fired when sourcebuffers have been created - data: { tracks : tracks }
  BUFFER_CREATED: 'hlsBufferCreated',
  // fired when we append a segment to the buffer - data: { segment: segment object }
  BUFFER_APPENDING: 'hlsBufferAppending',
  // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
  BUFFER_APPENDED: 'hlsBufferAppended',
  // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
  BUFFER_EOS: 'hlsBufferEos',
  // fired when the media buffer should be flushed - data { startOffset, endOffset }
  BUFFER_FLUSHING: 'hlsBufferFlushing',
  // fired when the media buffer has been flushed - data: { }
  BUFFER_FLUSHED: 'hlsBufferFlushed',
  // fired to signal that a manifest loading starts - data: { url : manifestURL}
  MANIFEST_LOADING: 'hlsManifestLoading',
  // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
  MANIFEST_LOADED: 'hlsManifestLoaded',
  // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
  MANIFEST_PARSED: 'hlsManifestParsed',
  // fired when a level switch is requested - data: { level : id of new level }
  LEVEL_SWITCHING: 'hlsLevelSwitching',
  // fired when a level switch is effective - data: { level : id of new level }
  LEVEL_SWITCHED: 'hlsLevelSwitched',
  // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
  LEVEL_LOADING: 'hlsLevelLoading',
  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
  LEVEL_LOADED: 'hlsLevelLoaded',
  // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
  LEVEL_UPDATED: 'hlsLevelUpdated',
  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
  // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
  // fired when an audio track switching is requested - data: { id : audio track id }
  AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',
  // fired when an audio track switch actually occurs - data: { id : audio track id }
  AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',
  // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
  // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
  // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
  SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',
  // fired when an subtitle track switch occurs - data: { id : subtitle track id }
  SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',
  // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
  SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',
  // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
  SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',
  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
  SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',
  // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
  INIT_PTS_FOUND: 'hlsInitPtsFound',
  // fired when a fragment loading starts - data: { frag : fragment object }
  FRAG_LOADING: 'hlsFragLoading',
  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
  // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
  FRAG_LOADED: 'hlsFragLoaded',
  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }
  FRAG_DECRYPTED: 'hlsFragDecrypted',
  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
  // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
  FRAG_PARSING_DATA: 'hlsFragParsingData',
  // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
  FRAG_PARSED: 'hlsFragParsed',
  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
  FRAG_BUFFERED: 'hlsFragBuffered',
  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
  FRAG_CHANGED: 'hlsFragChanged',
  // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
  FPS_DROP: 'hlsFpsDrop',
  // triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
  ERROR: 'hlsError',
  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
  DESTROYING: 'hlsDestroying',
  // fired when a decrypt key loading starts - data: { frag : fragment object }
  KEY_LOADING: 'hlsKeyLoading',
  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
  KEY_LOADED: 'hlsKeyLoaded',
  // fired upon stream controller state transitions - data: { previousState, nextState }
  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
};

exports.default = HlsEvents;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/hls.js":
/*!***************************!*\
  !*** ./src/hls.js/hls.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "../../node_modules/url-toolkit/src/url-toolkit.js");

var URLToolkit = _interopRequireWildcard(_urlToolkit);

var _errors = __webpack_require__(/*! ./errors */ "./src/hls.js/errors.js");

var _playlistLoader = __webpack_require__(/*! ./loader/playlist-loader */ "./src/hls.js/loader/playlist-loader.js");

var _playlistLoader2 = _interopRequireDefault(_playlistLoader);

var _fragmentLoader = __webpack_require__(/*! ./loader/fragment-loader */ "./src/hls.js/loader/fragment-loader.js");

var _fragmentLoader2 = _interopRequireDefault(_fragmentLoader);

var _keyLoader = __webpack_require__(/*! ./loader/key-loader */ "./src/hls.js/loader/key-loader.js");

var _keyLoader2 = _interopRequireDefault(_keyLoader);

var _fragmentTracker = __webpack_require__(/*! ./controller/fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _streamController = __webpack_require__(/*! ./controller/stream-controller */ "./src/hls.js/controller/stream-controller.js");

var _streamController2 = _interopRequireDefault(_streamController);

var _levelController = __webpack_require__(/*! ./controller/level-controller */ "./src/hls.js/controller/level-controller.js");

var _levelController2 = _interopRequireDefault(_levelController);

var _id3TrackController = __webpack_require__(/*! ./controller/id3-track-controller */ "./src/hls.js/controller/id3-track-controller.js");

var _id3TrackController2 = _interopRequireDefault(_id3TrackController);

var _isSupported2 = __webpack_require__(/*! ./is-supported */ "./src/hls.js/is-supported.js");

var _logger = __webpack_require__(/*! ./utils/logger */ "./src/hls.js/utils/logger.js");

var _config = __webpack_require__(/*! ./config */ "./src/hls.js/config.js");

var _events = __webpack_require__(/*! ./events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _observer = __webpack_require__(/*! ./observer */ "./src/hls.js/observer.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module Hls
 * @class
 * @constructor
 */
var Hls = function (_Observer) {
  _inherits(Hls, _Observer);

  _createClass(Hls, null, [{
    key: 'isSupported',


    /**
     * @type {boolean}
     */
    value: function isSupported() {
      return (0, _isSupported2.isSupported)();
    }

    /**
     * @type {HlsEvents}
     */

  }, {
    key: 'version',

    /**
     * @type {string}
     */
    get: function get() {
      return __VERSION__;
    }
  }, {
    key: 'Events',
    get: function get() {
      return _events2.default;
    }

    /**
     * @type {HlsErrorTypes}
     */

  }, {
    key: 'ErrorTypes',
    get: function get() {
      return _errors.ErrorTypes;
    }

    /**
     * @type {HlsErrorDetails}
     */

  }, {
    key: 'ErrorDetails',
    get: function get() {
      return _errors.ErrorDetails;
    }

    /**
     * @type {HlsConfig}
     */

  }, {
    key: 'DefaultConfig',
    get: function get() {
      if (!Hls.defaultConfig) {
        return _config.hlsDefaultConfig;
      }

      return Hls.defaultConfig;
    }

    /**
     * @type {HlsConfig}
     */
    ,
    set: function set(defaultConfig) {
      Hls.defaultConfig = defaultConfig;
    }

    /**
     * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
     *
     * @constructs Hls
     * @param {HlsConfig} config
     */

  }]);

  function Hls() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Hls);

    var _this = _possibleConstructorReturn(this, (Hls.__proto__ || Object.getPrototypeOf(Hls)).call(this));

    var defaultConfig = Hls.DefaultConfig;

    if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {
      throw new Error('Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');
    }

    for (var prop in defaultConfig) {
      if (prop in config) continue;
      config[prop] = defaultConfig[prop];
    }

    if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
    }

    if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
    }

    (0, _logger.enableLogs)(config.debug);
    _this.config = config;
    _this._autoLevelCapping = -1;

    // core controllers and network loaders

    /**
     * @member {AbrController} abrController
     */
    var abrController = _this.abrController = new config.abrController(_this);

    var bufferController = new config.bufferController(_this);
    var capLevelController = new config.capLevelController(_this);
    var fpsController = new config.fpsController(_this);
    var playListLoader = new _playlistLoader2.default(_this);
    var fragmentLoader = new _fragmentLoader2.default(_this);
    var keyLoader = new _keyLoader2.default(_this);
    var id3TrackController = new _id3TrackController2.default(_this);

    // network controllers

    /**
     * @member {LevelController} levelController
     */
    var levelController = _this.levelController = new _levelController2.default(_this);

    // FIXME: FragmentTracker must be defined before StreamController because the order of event handling is important
    var fragmentTracker = new _fragmentTracker.FragmentTracker(_this);

    /**
     * @member {StreamController} streamController
     */
    var streamController = _this.streamController = new _streamController2.default(_this, fragmentTracker);

    var networkControllers = [levelController, streamController];

    // optional audio stream controller
    /**
     * @var {ICoreComponent | Controller}
     */
    var Controller = config.audioStreamController;
    if (Controller) {
      networkControllers.push(new Controller(_this, fragmentTracker));
    }

    /**
     * @member {INetworkController[]} networkControllers
     */
    _this.networkControllers = networkControllers;

    /**
     * @var {ICoreComponent[]}
     */
    var coreComponents = [playListLoader, fragmentLoader, keyLoader, abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];

    // optional audio track and subtitle controller
    Controller = config.audioTrackController;
    if (Controller) {
      var audioTrackController = new Controller(_this);

      /**
       * @member {AudioTrackController} audioTrackController
       */
      _this.audioTrackController = audioTrackController;
      coreComponents.push(audioTrackController);
    }

    Controller = config.subtitleTrackController;
    if (Controller) {
      var subtitleTrackController = new Controller(_this);

      /**
       * @member {SubtitleTrackController} subtitleTrackController
       */
      _this.subtitleTrackController = subtitleTrackController;
      networkControllers.push(subtitleTrackController);
    }

    Controller = config.emeController;
    if (Controller) {
      var emeController = new Controller(_this);

      /**
       * @member {EMEController} emeController
       */
      _this.emeController = emeController;
      coreComponents.push(emeController);
    }

    // optional subtitle controllers
    Controller = config.subtitleStreamController;
    if (Controller) {
      networkControllers.push(new Controller(_this, fragmentTracker));
    }
    Controller = config.timelineController;
    if (Controller) {
      coreComponents.push(new Controller(_this));
    }

    /**
     * @member {ICoreComponent[]}
     */
    _this.coreComponents = coreComponents;
    return _this;
  }

  /**
   * Dispose of the instance
   */


  _createClass(Hls, [{
    key: 'destroy',
    value: function destroy() {
      _logger.logger.log('destroy');
      this.trigger(_events2.default.DESTROYING);
      this.detachMedia();
      this.coreComponents.concat(this.networkControllers).forEach(function (component) {
        component.destroy();
      });
      this.url = null;
      this.removeAllListeners();
      this._autoLevelCapping = -1;
    }

    /**
     * Attach a media element
     * @param {HTMLMediaElement} media
     */

  }, {
    key: 'attachMedia',
    value: function attachMedia(media) {
      _logger.logger.log('attachMedia');
      this.media = media;
      this.trigger(_events2.default.MEDIA_ATTACHING, { media: media });
    }

    /**
     * Detach from the media
     */

  }, {
    key: 'detachMedia',
    value: function detachMedia() {
      _logger.logger.log('detachMedia');
      this.trigger(_events2.default.MEDIA_DETACHING);
      this.media = null;
    }

    /**
     * Set the source URL. Can be relative or absolute.
     * @param {string} url
     */

  }, {
    key: 'loadSource',
    value: function loadSource(url) {
      url = URLToolkit.buildAbsoluteURL(window.location.href, url, { alwaysNormalize: true });
      _logger.logger.log('loadSource:' + url);
      this.url = url;
      // when attaching to a source URL, trigger a playlist load
      this.trigger(_events2.default.MANIFEST_LOADING, { url: url });
    }

    /**
     * Start loading data from the stream source.
     * Depending on default config, client starts loading automatically when a source is set.
     *
     * @param {number} startPosition Set the start position to stream from
     * @default -1 None (from earliest point)
     */

  }, {
    key: 'startLoad',
    value: function startLoad() {
      var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

      _logger.logger.log('startLoad(' + startPosition + ')');
      this.networkControllers.forEach(function (controller) {
        controller.startLoad(startPosition);
      });
    }

    /**
     * Stop loading of any stream data.
     */

  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      _logger.logger.log('stopLoad');
      this.networkControllers.forEach(function (controller) {
        controller.stopLoad();
      });
    }

    /**
     * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)
     */

  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      _logger.logger.log('swapAudioCodec');
      this.streamController.swapAudioCodec();
    }

    /**
     * When the media-element fails, this allows to detach and then re-attach it
     * as one call (convenience method).
     *
     * Automatic recovery of media-errors by this process is configurable.
     */

  }, {
    key: 'recoverMediaError',
    value: function recoverMediaError() {
      _logger.logger.log('recoverMediaError');
      var media = this.media;
      this.detachMedia();
      this.attachMedia(media);
    }

    /**
     * @type {QualityLevel[]}
     */

  }, {
    key: 'levels',
    get: function get() {
      return this.levelController.levels;
    }

    /**
     * Index of quality level currently played
     * @type {number}
     */

  }, {
    key: 'currentLevel',
    get: function get() {
      return this.streamController.currentLevel;
    }

    /**
     * Set quality level index immediately .
     * This will flush the current buffer to replace the quality asap.
     * That means playback will interrupt at least shortly to re-buffer and re-sync eventually.
     * @type {number} -1 for automatic level selection
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set currentLevel:' + newLevel);
      this.loadLevel = newLevel;
      this.streamController.immediateLevelSwitch();
    }

    /**
     * Index of next quality level loaded as scheduled by stream controller.
     * @type {number}
     */

  }, {
    key: 'nextLevel',
    get: function get() {
      return this.streamController.nextLevel;
    }

    /**
     * Set quality level index for next loaded data.
     * This will switch the video quality asap, without interrupting playback.
     * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).
     * @type {number} -1 for automatic level selection
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set nextLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
      this.streamController.nextLevelSwitch();
    }

    /**
     * Return the quality level of the currently or last (of none is loaded currently) segment
     * @type {number}
     */

  }, {
    key: 'loadLevel',
    get: function get() {
      return this.levelController.level;
    }

    /**
     * Set quality level index for next loaded data in a conservative way.
     * This will switch the quality without flushing, but interrupt current loading.
     * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.
     * @type {number} newLevel -1 for automatic level selection
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set loadLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
    }

    /**
     * get next quality level loaded
     * @type {number}
     */

  }, {
    key: 'nextLoadLevel',
    get: function get() {
      return this.levelController.nextLoadLevel;
    }

    /**
     * Set quality level of next loaded segment in a fully "non-destructive" way.
     * Same as `loadLevel` but will wait for next switch (until current loading is done).
     * @type {number} level
     */
    ,
    set: function set(level) {
      this.levelController.nextLoadLevel = level;
    }

    /**
     * Return "first level": like a default level, if not set,
     * falls back to index of first level referenced in manifest
     * @type {number}
     */

  }, {
    key: 'firstLevel',
    get: function get() {
      return Math.max(this.levelController.firstLevel, this.minAutoLevel);
    }

    /**
     * Sets "first-level", see getter.
     * @type {number}
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set firstLevel:' + newLevel);
      this.levelController.firstLevel = newLevel;
    }

    /**
     * Return start level (level of first fragment that will be played back)
     * if not overrided by user, first level appearing in manifest will be used as start level
     * if -1 : automatic start level selection, playback will start from level matching download bandwidth
     * (determined from download of first segment)
     * @type {number}
     */

  }, {
    key: 'startLevel',
    get: function get() {
      return this.levelController.startLevel;
    }

    /**
     * set  start level (level of first fragment that will be played back)
     * if not overrided by user, first level appearing in manifest will be used as start level
     * if -1 : automatic start level selection, playback will start from level matching download bandwidth
     * (determined from download of first segment)
     * @type {number} newLevel
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set startLevel:' + newLevel);
      var hls = this;
      // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel
      if (newLevel !== -1) {
        newLevel = Math.max(newLevel, hls.minAutoLevel);
      }

      hls.levelController.startLevel = newLevel;
    }

    /**
     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
     * @type {number}
     */

  }, {
    key: 'autoLevelCapping',
    get: function get() {
      return this._autoLevelCapping;
    }

    /**
     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
     * @type {number}
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set autoLevelCapping:' + newLevel);
      this._autoLevelCapping = newLevel;
    }

    /**
     * True when automatic level selection enabled
     * @type {boolean}
     */

  }, {
    key: 'autoLevelEnabled',
    get: function get() {
      return this.levelController.manualLevel === -1;
    }

    /**
     * Level set manually (if any)
     * @type {number}
     */

  }, {
    key: 'manualLevel',
    get: function get() {
      return this.levelController.manualLevel;
    }

    /**
     * min level selectable in auto mode according to config.minAutoBitrate
     * @type {number}
     */

  }, {
    key: 'minAutoLevel',
    get: function get() {
      var hls = this,
          levels = hls.levels,
          minAutoBitrate = hls.config.minAutoBitrate,
          len = levels ? levels.length : 0;
      for (var i = 0; i < len; i++) {
        var levelNextBitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate;
        if (levelNextBitrate > minAutoBitrate) {
          return i;
        }
      }
      return 0;
    }

    /**
     * max level selectable in auto mode according to autoLevelCapping
     * @type {number}
     */

  }, {
    key: 'maxAutoLevel',
    get: function get() {
      var hls = this;
      var levels = hls.levels;
      var autoLevelCapping = hls.autoLevelCapping;
      var maxAutoLevel = void 0;
      if (autoLevelCapping === -1 && levels && levels.length) {
        maxAutoLevel = levels.length - 1;
      } else {
        maxAutoLevel = autoLevelCapping;
      }

      return maxAutoLevel;
    }

    /**
     * next automatically selected quality level
     * @type {number}
     */

  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var hls = this;
      // ensure next auto level is between  min and max auto level
      return Math.min(Math.max(hls.abrController.nextAutoLevel, hls.minAutoLevel), hls.maxAutoLevel);
    }

    /**
     * this setter is used to force next auto level.
     * this is useful to force a switch down in auto mode:
     * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
     * forced value is valid for one fragment. upon succesful frag loading at forced level,
     * this value will be resetted to -1 by ABR controller.
     * @type {number}
     */
    ,
    set: function set(nextLevel) {
      var hls = this;
      hls.abrController.nextAutoLevel = Math.max(hls.minAutoLevel, nextLevel);
    }

    /**
     * @type {AudioTrack[]}
     */

  }, {
    key: 'audioTracks',
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTracks : [];
    }

    /**
     * index of the selected audio track (index in audio track lists)
     * @type {number}
     */

  }, {
    key: 'audioTrack',
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTrack : -1;
    }

    /**
     * selects an audio track, based on its index in audio track lists
     * @type {number}
     */
    ,
    set: function set(audioTrackId) {
      var audioTrackController = this.audioTrackController;
      if (audioTrackController) {
        audioTrackController.audioTrack = audioTrackId;
      }
    }

    /**
     * @type {Seconds}
     */

  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this.streamController.liveSyncPosition;
    }

    /**
     * get alternate subtitle tracks list from playlist
     * @type {SubtitleTrack[]}
     */

  }, {
    key: 'subtitleTracks',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
    }

    /**
     * index of the selected subtitle track (index in subtitle track lists)
     * @type {number}
     */

  }, {
    key: 'subtitleTrack',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
    }

    /**
     * select an subtitle track, based on its index in subtitle track lists
     * @type{number}
     */
    ,
    set: function set(subtitleTrackId) {
      var subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleTrack = subtitleTrackId;
      }
    }

    /**
     * @type {boolean}
     */

  }, {
    key: 'subtitleDisplay',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
    }

    /**
     * Enable/disable subtitle display rendering
     * @type {boolean}
     */
    ,
    set: function set(value) {
      var subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleDisplay = value;
      }
    }
  }]);

  return Hls;
}(_observer.Observer);

exports.default = Hls;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/is-supported.js":
/*!************************************!*\
  !*** ./src/hls.js/is-supported.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSupported = isSupported;

var _mediasourceHelper = __webpack_require__(/*! ./utils/mediasource-helper */ "./src/hls.js/utils/mediasource-helper.js");

function isSupported() {
  var mediaSource = (0, _mediasourceHelper.getMediaSource)();
  var sourceBuffer = window.SourceBuffer || window.WebKitSourceBuffer;
  var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === 'function' && mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');

  // if SourceBuffer is exposed ensure its API is valid
  // safari and old version of Chrome doe not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible
  var sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';
  return !!isTypeSupported && !!sourceBufferValidAPI;
}

/***/ }),

/***/ "./src/hls.js/loader/fragment-loader.js":
/*!**********************************************!*\
  !*** ./src/hls.js/loader/fragment-loader.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Fragment Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FragmentLoader = function (_EventHandler) {
  _inherits(FragmentLoader, _EventHandler);

  function FragmentLoader(hls) {
    _classCallCheck(this, FragmentLoader);

    var _this = _possibleConstructorReturn(this, (FragmentLoader.__proto__ || Object.getPrototypeOf(FragmentLoader)).call(this, hls, _events2.default.FRAG_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(FragmentLoader, [{
    key: 'destroy',
    value: function destroy() {
      var loaders = this.loaders;
      for (var loaderName in loaders) {
        var loader = loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};

      _get(FragmentLoader.prototype.__proto__ || Object.getPrototypeOf(FragmentLoader.prototype), 'destroy', this).call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loaders = this.loaders,
          config = this.hls.config,
          FragmentILoader = config.fLoader,
          DefaultILoader = config.loader;

      // reset fragment state
      frag.loaded = 0;

      var loader = loaders[type];
      if (loader) {
        _logger.logger.warn('abort previous fragment loader for type: ' + type);
        loader.abort();
      }

      loader = loaders[type] = frag.loader = config.fLoader ? new FragmentILoader(config) : new DefaultILoader(config);

      var loaderContext = void 0,
          loaderConfig = void 0,
          loaderCallbacks = void 0;

      loaderContext = { url: frag.url, frag: frag, responseType: 'arraybuffer', progressData: false };

      var start = frag.byteRangeStartOffset,
          end = frag.byteRangeEndOffset;

      if (Number.isFinite(start) && Number.isFinite(end)) {
        loaderContext.rangeStart = start;
        loaderContext.rangeEnd = end;
      }

      loaderConfig = {
        timeout: config.fragLoadingTimeOut,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: config.fragLoadingMaxRetryTimeout
      };

      loaderCallbacks = {
        onSuccess: this.loadsuccess.bind(this),
        onError: this.loaderror.bind(this),
        onTimeout: this.loadtimeout.bind(this),
        onProgress: this.loadprogress.bind(this)
      };

      loader.load(loaderContext, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var payload = response.data,
          frag = context.frag;
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.FRAG_LOADED, { payload: payload, frag: frag, stats: stats, networkDetails: networkDetails });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var frag = context.frag;
      var loader = frag.loader;
      if (loader) {
        loader.abort();
      }

      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response, networkDetails: networkDetails });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var frag = context.frag;
      var loader = frag.loader;
      if (loader) {
        loader.abort();
      }

      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag, networkDetails: networkDetails });
    }

    // data will be used for progressive parsing

  }, {
    key: 'loadprogress',
    value: function loadprogress(stats, context, data) {
      var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      // jshint ignore:line
      var frag = context.frag;
      frag.loaded = stats.loaded;
      this.hls.trigger(_events2.default.FRAG_LOAD_PROGRESS, { frag: frag, stats: stats, networkDetails: networkDetails });
    }
  }]);

  return FragmentLoader;
}(_eventHandler2.default);

exports.default = FragmentLoader;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/fragment.js":
/*!***************************************!*\
  !*** ./src/hls.js/loader/fragment.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "../../node_modules/url-toolkit/src/url-toolkit.js");

var URLToolkit = _interopRequireWildcard(_urlToolkit);

var _levelKey = __webpack_require__(/*! ./level-key */ "./src/hls.js/loader/level-key.js");

var _levelKey2 = _interopRequireDefault(_levelKey);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Fragment = function () {
  function Fragment() {
    var _elementaryStreams;

    _classCallCheck(this, Fragment);

    this._url = null;
    this._byteRange = null;
    this._decryptdata = null;
    this.tagList = [];
    this.programDateTime = null;
    this.rawProgramDateTime = null;

    // Holds the types of data this fragment supports
    this._elementaryStreams = (_elementaryStreams = {}, _defineProperty(_elementaryStreams, Fragment.ElementaryStreamTypes.AUDIO, false), _defineProperty(_elementaryStreams, Fragment.ElementaryStreamTypes.VIDEO, false), _elementaryStreams);
  }

  /**
   * `type` property for this._elementaryStreams
   *
   * @enum
   */


  _createClass(Fragment, [{
    key: 'addElementaryStream',


    /**
     * @param {ElementaryStreamType} type
     */
    value: function addElementaryStream(type) {
      this._elementaryStreams[type] = true;
    }

    /**
     * @param {ElementaryStreamType} type
     */

  }, {
    key: 'hasElementaryStream',
    value: function hasElementaryStream(type) {
      return this._elementaryStreams[type] === true;
    }

    /**
     * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
     * @returns {Uint8Array}
     */

  }, {
    key: 'createInitializationVector',
    value: function createInitializationVector(segmentNumber) {
      var uint8View = new Uint8Array(16);

      for (var i = 12; i < 16; i++) {
        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
      }

      return uint8View;
    }

    /**
     * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
     * @param levelkey - a playlist's encryption info
     * @param segmentNumber - the fragment's segment number
     * @returns {*} - an object to be applied as a fragment's decryptdata
     */

  }, {
    key: 'fragmentDecryptdataFromLevelkey',
    value: function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {
      var decryptdata = levelkey;

      if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {
        decryptdata = new _levelKey2.default();
        decryptdata.method = levelkey.method;
        decryptdata.baseuri = levelkey.baseuri;
        decryptdata.reluri = levelkey.reluri;
        decryptdata.iv = this.createInitializationVector(segmentNumber);
      }

      return decryptdata;
    }
  }, {
    key: 'url',
    get: function get() {
      if (!this._url && this.relurl) {
        this._url = URLToolkit.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: true });
      }

      return this._url;
    },
    set: function set(value) {
      this._url = value;
    }
  }, {
    key: 'byteRange',
    get: function get() {
      if (!this._byteRange && !this.rawByteRange) {
        return [];
      }

      if (this._byteRange) {
        return this._byteRange;
      }

      var byteRange = [];
      if (this.rawByteRange) {
        var params = this.rawByteRange.split('@', 2);
        if (params.length === 1) {
          var lastByteRangeEndOffset = this.lastByteRangeEndOffset;
          byteRange[0] = lastByteRangeEndOffset || 0;
        } else {
          byteRange[0] = parseInt(params[1]);
        }
        byteRange[1] = parseInt(params[0]) + byteRange[0];
        this._byteRange = byteRange;
      }
      return byteRange;
    }

    /**
     * @type {number}
     */

  }, {
    key: 'byteRangeStartOffset',
    get: function get() {
      return this.byteRange[0];
    }
  }, {
    key: 'byteRangeEndOffset',
    get: function get() {
      return this.byteRange[1];
    }
  }, {
    key: 'decryptdata',
    get: function get() {
      if (!this._decryptdata) {
        this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn);
      }

      return this._decryptdata;
    }
  }, {
    key: 'endProgramDateTime',
    get: function get() {
      if (!Number.isFinite(this.programDateTime)) {
        return null;
      }

      var duration = !Number.isFinite(this.duration) ? 0 : this.duration;

      return this.programDateTime + duration * 1000;
    }
  }, {
    key: 'encrypted',
    get: function get() {
      return !!(this.decryptdata && this.decryptdata.uri !== null && this.decryptdata.key === null);
    }
  }], [{
    key: 'ElementaryStreamTypes',
    get: function get() {
      return {
        AUDIO: 'audio',
        VIDEO: 'video'
      };
    }
  }]);

  return Fragment;
}();

exports.default = Fragment;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/key-loader.js":
/*!*****************************************!*\
  !*** ./src/hls.js/loader/key-loader.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Decrypt key Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var KeyLoader = function (_EventHandler) {
  _inherits(KeyLoader, _EventHandler);

  function KeyLoader(hls) {
    _classCallCheck(this, KeyLoader);

    var _this = _possibleConstructorReturn(this, (KeyLoader.__proto__ || Object.getPrototypeOf(KeyLoader)).call(this, hls, _events2.default.KEY_LOADING));

    _this.loaders = {};
    _this.decryptkey = null;
    _this.decrypturl = null;
    return _this;
  }

  _createClass(KeyLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onKeyLoading',
    value: function onKeyLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          decryptdata = frag.decryptdata,
          uri = decryptdata.uri;
      // if uri is different from previous one or if decrypt key not retrieved yet
      if (uri !== this.decrypturl || this.decryptkey === null) {
        var config = this.hls.config;

        if (loader) {
          _logger.logger.warn('abort previous key loader for type:' + type);
          loader.abort();
        }
        frag.loader = this.loaders[type] = new config.loader(config);
        this.decrypturl = uri;
        this.decryptkey = null;

        var loaderContext = void 0,
            loaderConfig = void 0,
            loaderCallbacks = void 0;
        loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };
        // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,
        // key-loader will trigger an error and rely on stream-controller to handle retry logic.
        // this will also align retry logic with fragment-loader
        loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
        loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
        frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);
      } else if (this.decryptkey) {
        // we already loaded this key, return it
        decryptdata.key = this.decryptkey;
        this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
      }
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var frag = context.frag;
      this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }

      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }

      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: frag });
    }
  }]);

  return KeyLoader;
}(_eventHandler2.default);

exports.default = KeyLoader;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/level-key.js":
/*!****************************************!*\
  !*** ./src/hls.js/loader/level-key.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "../../node_modules/url-toolkit/src/url-toolkit.js");

var URLToolkit = _interopRequireWildcard(_urlToolkit);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LevelKey = function () {
  function LevelKey() {
    _classCallCheck(this, LevelKey);

    this.method = null;
    this.key = null;
    this.iv = null;
    this._uri = null;
  }

  _createClass(LevelKey, [{
    key: 'uri',
    get: function get() {
      if (!this._uri && this.reluri) {
        this._uri = URLToolkit.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: true });
      }

      return this._uri;
    }
  }]);

  return LevelKey;
}();

exports.default = LevelKey;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/level.js":
/*!************************************!*\
  !*** ./src/hls.js/loader/level.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Level = function () {
  function Level(baseUrl) {
    _classCallCheck(this, Level);

    // Please keep properties in alphabetical order
    this.endCC = 0;
    this.endSN = 0;
    this.fragments = [];
    this.initSegment = null;
    this.live = true;
    this.needSidxRanges = false;
    this.startCC = 0;
    this.startSN = 0;
    this.startTimeOffset = null;
    this.targetduration = 0;
    this.totalduration = 0;
    this.type = null;
    this.url = baseUrl;
    this.version = null;
  }

  _createClass(Level, [{
    key: "hasProgramDateTime",
    get: function get() {
      return !!(this.fragments[0] && Number.isFinite(this.fragments[0].programDateTime));
    }
  }]);

  return Level;
}();

exports.default = Level;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/loader/m3u8-parser.js":
/*!******************************************!*\
  !*** ./src/hls.js/loader/m3u8-parser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "../../node_modules/url-toolkit/src/url-toolkit.js");

var URLToolkit = _interopRequireWildcard(_urlToolkit);

var _fragment = __webpack_require__(/*! ./fragment */ "./src/hls.js/loader/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _level = __webpack_require__(/*! ./level */ "./src/hls.js/loader/level.js");

var _level2 = _interopRequireDefault(_level);

var _levelKey = __webpack_require__(/*! ./level-key */ "./src/hls.js/loader/level-key.js");

var _levelKey2 = _interopRequireDefault(_levelKey);

var _attrList = __webpack_require__(/*! ../utils/attr-list */ "./src/hls.js/utils/attr-list.js");

var _attrList2 = _interopRequireDefault(_attrList);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _codecs = __webpack_require__(/*! ../utils/codecs */ "./src/hls.js/utils/codecs.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * M3U8 parser
 * @module
 */

// https://regex101.com is your friend
var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;

var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
/|(?!#)([\S+ ?]+)/.source, // segment URI, group 3 => the URI (note newline is not eaten)
/|#EXT-X-BYTERANGE:*(.+)/.source, // next segment's byterange, group 4 => range spec (x@y)
/|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, // next segment's program date/time group 5 => the datetime spec
/|#.*/.source // All other non-segment oriented tags will match with all groups empty
].join(''), 'g');

var LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)([^:]*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/;

var MP4_REGEX_SUFFIX = /\.(mp4|m4s|m4v|m4a)$/i;

var M3U8Parser = function () {
  function M3U8Parser() {
    _classCallCheck(this, M3U8Parser);
  }

  _createClass(M3U8Parser, null, [{
    key: 'findGroup',
    value: function findGroup(groups, mediaGroupId) {
      if (!groups) {
        return null;
      }

      var matchingGroup = null;

      for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        if (group.id === mediaGroupId) {
          matchingGroup = group;
        }
      }

      return matchingGroup;
    }
  }, {
    key: 'convertAVC1ToAVCOTI',
    value: function convertAVC1ToAVCOTI(codec) {
      var result = void 0,
          avcdata = codec.split('.');
      if (avcdata.length > 2) {
        result = avcdata.shift() + '.';
        result += parseInt(avcdata.shift()).toString(16);
        result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
      } else {
        result = codec;
      }
      return result;
    }
  }, {
    key: 'resolve',
    value: function resolve(url, baseUrl) {
      return URLToolkit.buildAbsoluteURL(baseUrl, url, { alwaysNormalize: true });
    }
  }, {
    key: 'parseMasterPlaylist',
    value: function parseMasterPlaylist(string, baseurl) {
      var levels = [],
          result = void 0;
      MASTER_PLAYLIST_REGEX.lastIndex = 0;

      function setCodecs(codecs, level) {
        ['video', 'audio'].forEach(function (type) {
          var filtered = codecs.filter(function (codec) {
            return (0, _codecs.isCodecType)(codec, type);
          });
          if (filtered.length) {
            var preferred = filtered.filter(function (codec) {
              return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;
            });
            level[type + 'Codec'] = preferred.length > 0 ? preferred[0] : filtered[0];

            // remove from list
            codecs = codecs.filter(function (codec) {
              return filtered.indexOf(codec) === -1;
            });
          }
        });

        level.unknownCodecs = codecs;
      }

      while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
        var level = {};

        var attrs = level.attrs = new _attrList2.default(result[1]);
        level.url = M3U8Parser.resolve(result[2], baseurl);

        var resolution = attrs.decimalResolution('RESOLUTION');
        if (resolution) {
          level.width = resolution.width;
          level.height = resolution.height;
        }
        level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');
        level.name = attrs.NAME;

        setCodecs([].concat((attrs.CODECS || '').split(/[ ,]+/)), level);

        if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) {
          level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);
        }

        levels.push(level);
      }
      return levels;
    }
  }, {
    key: 'parseMasterPlaylistMedia',
    value: function parseMasterPlaylistMedia(string, baseurl, type) {
      var audioGroups = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

      var result = void 0;
      var medias = [];
      var id = 0;
      MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
      while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
        var media = {};
        var attrs = new _attrList2.default(result[1]);
        if (attrs.TYPE === type) {
          media.groupId = attrs['GROUP-ID'];
          media.name = attrs.NAME;
          media.type = type;
          media.default = attrs.DEFAULT === 'YES';
          media.autoselect = attrs.AUTOSELECT === 'YES';
          media.forced = attrs.FORCED === 'YES';
          if (attrs.URI) {
            media.url = M3U8Parser.resolve(attrs.URI, baseurl);
          }

          media.lang = attrs.LANGUAGE;
          if (!media.name) {
            media.name = media.lang;
          }

          if (audioGroups.length) {
            var groupCodec = M3U8Parser.findGroup(audioGroups, media.groupId);
            media.audioCodec = groupCodec ? groupCodec.codec : audioGroups[0].codec;
          }
          media.id = id++;
          medias.push(media);
        }
      }
      return medias;
    }
  }, {
    key: 'parseLevelPlaylist',
    value: function parseLevelPlaylist(string, baseurl, id, type, levelUrlId) {
      var currentSN = 0;
      var totalduration = 0;
      var level = new _level2.default(baseurl);
      var levelkey = new _levelKey2.default();
      var cc = 0;
      var prevFrag = null;
      var frag = new _fragment2.default();
      var result = void 0;
      var i = void 0;

      var firstPdtIndex = null;

      LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;

      while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
        var duration = result[1];
        if (duration) {
          // INF
          frag.duration = parseFloat(duration);
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          var title = (' ' + result[2]).slice(1);
          frag.title = title || null;
          frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);
        } else if (result[3]) {
          // url
          if (Number.isFinite(frag.duration)) {
            var sn = currentSN++;
            frag.type = type;
            frag.start = totalduration;
            frag.levelkey = levelkey;
            frag.sn = sn;
            frag.level = id;
            frag.cc = cc;
            frag.urlId = levelUrlId;
            frag.baseurl = baseurl;
            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
            frag.relurl = (' ' + result[3]).slice(1);
            assignProgramDateTime(frag, prevFrag);

            level.fragments.push(frag);
            prevFrag = frag;
            totalduration += frag.duration;

            frag = new _fragment2.default();
          }
        } else if (result[4]) {
          // X-BYTERANGE
          frag.rawByteRange = (' ' + result[4]).slice(1);
          if (prevFrag) {
            var lastByteRangeEndOffset = prevFrag.byteRangeEndOffset;
            if (lastByteRangeEndOffset) {
              frag.lastByteRangeEndOffset = lastByteRangeEndOffset;
            }
          }
        } else if (result[5]) {
          // PROGRAM-DATE-TIME
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          frag.rawProgramDateTime = (' ' + result[5]).slice(1);
          frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);
          if (firstPdtIndex === null) {
            firstPdtIndex = level.fragments.length;
          }
        } else {
          result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
          for (i = 1; i < result.length; i++) {
            if (result[i] !== undefined) {
              break;
            }
          }

          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          var value1 = (' ' + result[i + 1]).slice(1);
          var value2 = (' ' + result[i + 2]).slice(1);

          switch (result[i]) {
            case '#':
              frag.tagList.push(value2 ? [value1, value2] : [value1]);
              break;
            case 'PLAYLIST-TYPE':
              level.type = value1.toUpperCase();
              break;
            case 'MEDIA-SEQUENCE':
              currentSN = level.startSN = parseInt(value1);
              break;
            case 'TARGETDURATION':
              level.targetduration = parseFloat(value1);
              break;
            case 'VERSION':
              level.version = parseInt(value1);
              break;
            case 'EXTM3U':
              break;
            case 'ENDLIST':
              level.live = false;
              break;
            case 'DIS':
              cc++;
              frag.tagList.push(['DIS']);
              break;
            case 'DISCONTINUITY-SEQ':
              cc = parseInt(value1);
              break;
            case 'KEY':
              // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
              var decryptparams = value1;
              var keyAttrs = new _attrList2.default(decryptparams);
              var decryptmethod = keyAttrs.enumeratedString('METHOD'),
                  decrypturi = keyAttrs.URI,
                  decryptiv = keyAttrs.hexadecimalInteger('IV');
              if (decryptmethod) {
                levelkey = new _levelKey2.default();
                if (decrypturi && ['AES-128', 'SAMPLE-AES', 'SAMPLE-AES-CENC'].indexOf(decryptmethod) >= 0) {
                  levelkey.method = decryptmethod;
                  // URI to get the key
                  levelkey.baseuri = baseurl;
                  levelkey.reluri = decrypturi;
                  levelkey.key = null;
                  // Initialization Vector (IV)
                  levelkey.iv = decryptiv;
                }
              }
              break;
            case 'START':
              var startParams = value1;
              var startAttrs = new _attrList2.default(startParams);
              var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
              // TIME-OFFSET can be 0
              if (Number.isFinite(startTimeOffset)) {
                level.startTimeOffset = startTimeOffset;
              }

              break;
            case 'MAP':
              var mapAttrs = new _attrList2.default(value1);
              frag.relurl = mapAttrs.URI;
              frag.rawByteRange = mapAttrs.BYTERANGE;
              frag.baseurl = baseurl;
              frag.level = id;
              frag.type = type;
              frag.sn = 'initSegment';
              level.initSegment = frag;
              frag = new _fragment2.default();
              frag.rawProgramDateTime = level.initSegment.rawProgramDateTime;
              break;
            default:
              _logger.logger.warn('line parsed but not handled: ' + result);
              break;
          }
        }
      }
      frag = prevFrag;
      // logger.log('found ' + level.fragments.length + ' fragments');
      if (frag && !frag.relurl) {
        level.fragments.pop();
        totalduration -= frag.duration;
      }
      level.totalduration = totalduration;
      level.averagetargetduration = totalduration / level.fragments.length;
      level.endSN = currentSN - 1;
      level.startCC = level.fragments[0] ? level.fragments[0].cc : 0;
      level.endCC = cc;

      if (!level.initSegment && level.fragments.length) {
        // this is a bit lurky but HLS really has no other way to tell us
        // if the fragments are TS or MP4, except if we download them :/
        // but this is to be able to handle SIDX.
        if (level.fragments.every(function (frag) {
          return MP4_REGEX_SUFFIX.test(frag.relurl);
        })) {
          _logger.logger.warn('MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX');

          frag = new _fragment2.default();
          frag.relurl = level.fragments[0].relurl;
          frag.baseurl = baseurl;
          frag.level = id;
          frag.type = type;
          frag.sn = 'initSegment';

          level.initSegment = frag;
          level.needSidxRanges = true;
        }
      }

      /**
       * Backfill any missing PDT values
         "If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after
         one or more Media Segment URIs, the client SHOULD extrapolate
         backward from that tag (using EXTINF durations and/or media
         timestamps) to associate dates with those segments."
       * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs
       * computed.
       */
      if (firstPdtIndex) {
        backfillProgramDateTimes(level.fragments, firstPdtIndex);
      }

      return level;
    }
  }]);

  return M3U8Parser;
}();

exports.default = M3U8Parser;


function backfillProgramDateTimes(fragments, startIndex) {
  var fragPrev = fragments[startIndex];
  for (var i = startIndex - 1; i >= 0; i--) {
    var frag = fragments[i];
    frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;
    fragPrev = frag;
  }
}

function assignProgramDateTime(frag, prevFrag) {
  if (frag.rawProgramDateTime) {
    frag.programDateTime = Date.parse(frag.rawProgramDateTime);
  } else if (prevFrag && prevFrag.programDateTime) {
    frag.programDateTime = prevFrag.endProgramDateTime;
  }

  if (!Number.isFinite(frag.programDateTime)) {
    frag.programDateTime = null;
    frag.rawProgramDateTime = null;
  }
}
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/playlist-loader.js":
/*!**********************************************!*\
  !*** ./src/hls.js/loader/playlist-loader.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _mp4demuxer = __webpack_require__(/*! ../demux/mp4demuxer */ "./src/hls.js/demux/mp4demuxer.js");

var _mp4demuxer2 = _interopRequireDefault(_mp4demuxer);

var _m3u8Parser = __webpack_require__(/*! ./m3u8-parser */ "./src/hls.js/loader/m3u8-parser.js");

var _m3u8Parser2 = _interopRequireDefault(_m3u8Parser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * PlaylistLoader - delegate for media manifest/playlist loading tasks. Takes care of parsing media to internal data-models.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Once loaded, dispatches events with parsed data-models of manifest/levels/audio/subtitle tracks.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Uses loader(s) set in config to do actual internal loading of resource tasks.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _window = window,
    performance = _window.performance;

/**
 * `type` property values for this loaders' context object
 * @enum
 *
 */

var ContextType = {
  MANIFEST: 'manifest',
  LEVEL: 'level',
  AUDIO_TRACK: 'audioTrack',
  SUBTITLE_TRACK: 'subtitleTrack'
};

/**
 * @enum {string}
 */
var LevelType = {
  MAIN: 'main',
  AUDIO: 'audio',
  SUBTITLE: 'subtitle'
};

/**
 * @constructor
 */

var PlaylistLoader = function (_EventHandler) {
  _inherits(PlaylistLoader, _EventHandler);

  /**
   * @constructs
   * @param {Hls} hls
   */
  function PlaylistLoader(hls) {
    _classCallCheck(this, PlaylistLoader);

    var _this = _possibleConstructorReturn(this, (PlaylistLoader.__proto__ || Object.getPrototypeOf(PlaylistLoader)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.LEVEL_LOADING, _events2.default.AUDIO_TRACK_LOADING, _events2.default.SUBTITLE_TRACK_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(PlaylistLoader, [{
    key: 'createInternalLoader',


    /**
     * Returns defaults or configured loader-type overloads (pLoader and loader config params)
     * Default loader is XHRLoader (see utils)
     * @param {object} context
     * @returns {XHRLoader} or other compatible configured overload
     */
    value: function createInternalLoader(context) {
      var config = this.hls.config;
      var PLoader = config.pLoader;
      var Loader = config.loader;
      var InternalLoader = PLoader || Loader;

      var loader = new InternalLoader(config);

      context.loader = loader;
      this.loaders[context.type] = loader;

      return loader;
    }
  }, {
    key: 'getInternalLoader',
    value: function getInternalLoader(context) {
      return this.loaders[context.type];
    }
  }, {
    key: 'resetInternalLoader',
    value: function resetInternalLoader(contextType) {
      if (this.loaders[contextType]) {
        delete this.loaders[contextType];
      }
    }

    /**
     * Call `destroy` on all internal loader instances mapped (one per context type)
     */

  }, {
    key: 'destroyInternalLoaders',
    value: function destroyInternalLoaders() {
      for (var contextType in this.loaders) {
        var loader = this.loaders[contextType];
        if (loader) {
          loader.destroy();
        }

        this.resetInternalLoader(contextType);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.destroyInternalLoaders();

      _get(PlaylistLoader.prototype.__proto__ || Object.getPrototypeOf(PlaylistLoader.prototype), 'destroy', this).call(this);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading(data) {
      this.load(data.url, { type: ContextType.MANIFEST, level: 0, id: null });
    }
  }, {
    key: 'onLevelLoading',
    value: function onLevelLoading(data) {
      this.load(data.url, { type: ContextType.LEVEL, level: data.level, id: data.id });
    }
  }, {
    key: 'onAudioTrackLoading',
    value: function onAudioTrackLoading(data) {
      this.load(data.url, { type: ContextType.AUDIO_TRACK, level: null, id: data.id });
    }
  }, {
    key: 'onSubtitleTrackLoading',
    value: function onSubtitleTrackLoading(data) {
      this.load(data.url, { type: ContextType.SUBTITLE_TRACK, level: null, id: data.id });
    }
  }, {
    key: 'load',
    value: function load(url, context) {
      var config = this.hls.config;

      _logger.logger.debug('Loading playlist of type ' + context.type + ', level: ' + context.level + ', id: ' + context.id);

      // Check if a loader for this context already exists
      var loader = this.getInternalLoader(context);
      if (loader) {
        var loaderContext = loader.context;
        if (loaderContext && loaderContext.url === url) {
          // same URL can't overlap
          _logger.logger.trace('playlist request ongoing');
          return false;
        } else {
          _logger.logger.warn('aborting previous loader for type: ' + context.type);
          loader.abort();
        }
      }

      var maxRetry = void 0,
          timeout = void 0,
          retryDelay = void 0,
          maxRetryDelay = void 0;

      // apply different configs for retries depending on
      // context (manifest, level, audio/subs playlist)
      switch (context.type) {
        case ContextType.MANIFEST:
          maxRetry = config.manifestLoadingMaxRetry;
          timeout = config.manifestLoadingTimeOut;
          retryDelay = config.manifestLoadingRetryDelay;
          maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
          break;
        case ContextType.LEVEL:
          // Disable internal loader retry logic, since we are managing retries in Level Controller
          maxRetry = 0;
          timeout = config.levelLoadingTimeOut;
          // TODO Introduce retry settings for audio-track and subtitle-track, it should not use level retry config
          break;
        default:
          maxRetry = config.levelLoadingMaxRetry;
          timeout = config.levelLoadingTimeOut;
          retryDelay = config.levelLoadingRetryDelay;
          maxRetryDelay = config.levelLoadingMaxRetryTimeout;
          break;
      }

      loader = this.createInternalLoader(context);

      context.url = url;
      context.responseType = context.responseType || ''; // FIXME: (should not be necessary to do this)

      var loaderConfig = {
        timeout: timeout,
        maxRetry: maxRetry,
        retryDelay: retryDelay,
        maxRetryDelay: maxRetryDelay
      };

      var loaderCallbacks = {
        onSuccess: this.loadsuccess.bind(this),
        onError: this.loaderror.bind(this),
        onTimeout: this.loadtimeout.bind(this)
      };

      _logger.logger.debug('Calling internal loader delegate for URL: ' + url);

      loader.load(context, loaderConfig, loaderCallbacks);

      return true;
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      if (context.isSidxRequest) {
        this._handleSidxRequest(response, context);
        this._handlePlaylistLoaded(response, stats, context, networkDetails);
        return;
      }

      this.resetInternalLoader(context.type);

      var string = response.data;

      stats.tload = performance.now();
      // stats.mtime = new Date(target.getResponseHeader('Last-Modified'));

      // Validate if it is an M3U8 at all
      if (string.indexOf('#EXTM3U') !== 0) {
        this._handleManifestParsingError(response, context, 'no EXTM3U delimiter', networkDetails);
        return;
      }

      // Check if chunk-list or master. handle empty chunk list case (first EXTINF not signaled, but TARGETDURATION present)
      if (string.indexOf('#EXTINF:') > 0 || string.indexOf('#EXT-X-TARGETDURATION:') > 0) {
        this._handleTrackOrLevelPlaylist(response, stats, context, networkDetails);
      } else {
        this._handleMasterPlaylist(response, stats, context, networkDetails);
      }
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      this._handleNetworkError(context, networkDetails, false, response);
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      this._handleNetworkError(context, networkDetails, true);
    }
  }, {
    key: '_handleMasterPlaylist',
    value: function _handleMasterPlaylist(response, stats, context, networkDetails) {
      var hls = this.hls;
      var string = response.data;

      var url = PlaylistLoader.getResponseUrl(response, context);

      var levels = _m3u8Parser2.default.parseMasterPlaylist(string, url);
      if (!levels.length) {
        this._handleManifestParsingError(response, context, 'no level found in manifest', networkDetails);
        return;
      }

      // multi level playlist, parse level info

      var audioGroups = levels.map(function (level) {
        return {
          id: level.attrs.AUDIO,
          codec: level.audioCodec
        };
      });

      var audioTracks = _m3u8Parser2.default.parseMasterPlaylistMedia(string, url, 'AUDIO', audioGroups);
      var subtitles = _m3u8Parser2.default.parseMasterPlaylistMedia(string, url, 'SUBTITLES');

      if (audioTracks.length) {
        // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
        var embeddedAudioFound = false;
        audioTracks.forEach(function (audioTrack) {
          if (!audioTrack.url) {
            embeddedAudioFound = true;
          }
        });

        // if no embedded audio track defined, but audio codec signaled in quality level,
        // we need to signal this main audio track this could happen with playlists with
        // alt audio rendition in which quality levels (main)
        // contains both audio+video. but with mixed audio track not signaled
        if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
          _logger.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');
          audioTracks.unshift({
            type: 'main',
            name: 'main'
          });
        }
      }

      hls.trigger(_events2.default.MANIFEST_LOADED, {
        levels: levels,
        audioTracks: audioTracks,
        subtitles: subtitles,
        url: url,
        stats: stats,
        networkDetails: networkDetails
      });
    }
  }, {
    key: '_handleTrackOrLevelPlaylist',
    value: function _handleTrackOrLevelPlaylist(response, stats, context, networkDetails) {
      var hls = this.hls;

      var id = context.id,
          level = context.level,
          type = context.type;


      var url = PlaylistLoader.getResponseUrl(response, context);

      var levelUrlId = Number.isFinite(id) ? id : 0;
      var levelId = Number.isFinite(level) ? level : levelUrlId;
      var levelType = PlaylistLoader.mapContextToLevelType(context);

      var levelDetails = _m3u8Parser2.default.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId);

      // set stats on level structure
      levelDetails.tload = stats.tload;

      // We have done our first request (Manifest-type) and receive
      // not a master playlist but a chunk-list (track/level)
      // We fire the manifest-loaded event anyway with the parsed level-details
      // by creating a single-level structure for it.
      if (type === ContextType.MANIFEST) {
        var singleLevel = {
          url: url,
          details: levelDetails
        };

        hls.trigger(_events2.default.MANIFEST_LOADED, {
          levels: [singleLevel],
          audioTracks: [],
          url: url,
          stats: stats,
          networkDetails: networkDetails
        });
      }

      // save parsing time
      stats.tparsed = performance.now();

      // in case we need SIDX ranges
      // return early after calling load for
      // the SIDX box.
      if (levelDetails.needSidxRanges) {
        var sidxUrl = levelDetails.initSegment.url;
        this.load(sidxUrl, {
          isSidxRequest: true,
          type: type,
          level: level,
          levelDetails: levelDetails,
          id: id,
          rangeStart: 0,
          rangeEnd: 2048,
          responseType: 'arraybuffer'
        });
        return;
      }

      // extend the context with the new levelDetails property
      context.levelDetails = levelDetails;

      this._handlePlaylistLoaded(response, stats, context, networkDetails);
    }
  }, {
    key: '_handleSidxRequest',
    value: function _handleSidxRequest(response, context) {
      var sidxInfo = _mp4demuxer2.default.parseSegmentIndex(new Uint8Array(response.data));
      // if provided fragment does not contain sidx, early return
      if (!sidxInfo) {
        return;
      }
      var sidxReferences = sidxInfo.references;
      var levelDetails = context.levelDetails;
      sidxReferences.forEach(function (segmentRef, index) {
        var segRefInfo = segmentRef.info;
        var frag = levelDetails.fragments[index];

        if (frag.byteRange.length === 0) {
          frag.rawByteRange = String(1 + segRefInfo.end - segRefInfo.start) + '@' + String(segRefInfo.start);
        }
      });
      levelDetails.initSegment.rawByteRange = String(sidxInfo.moovEndOffset) + '@0';
    }
  }, {
    key: '_handleManifestParsingError',
    value: function _handleManifestParsingError(response, context, reason, networkDetails) {
      this.hls.trigger(_events2.default.ERROR, {
        type: _errors.ErrorTypes.NETWORK_ERROR,
        details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR,
        fatal: true,
        url: response.url,
        reason: reason,
        networkDetails: networkDetails
      });
    }
  }, {
    key: '_handleNetworkError',
    value: function _handleNetworkError(context, networkDetails) {
      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var response = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      _logger.logger.info('A network error occured while loading a ' + context.type + '-type playlist');

      var details = void 0;
      var fatal = void 0;

      var loader = this.getInternalLoader(context);

      switch (context.type) {
        case ContextType.MANIFEST:
          details = timeout ? _errors.ErrorDetails.MANIFEST_LOAD_TIMEOUT : _errors.ErrorDetails.MANIFEST_LOAD_ERROR;
          fatal = true;
          break;
        case ContextType.LEVEL:
          details = timeout ? _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT : _errors.ErrorDetails.LEVEL_LOAD_ERROR;
          fatal = false;
          break;
        case ContextType.AUDIO_TRACK:
          details = timeout ? _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
          fatal = false;
          break;
        default:
          // details = ...?
          fatal = false;
      }

      if (loader) {
        loader.abort();
        this.resetInternalLoader(context.type);
      }

      var errorData = {
        type: _errors.ErrorTypes.NETWORK_ERROR,
        details: details,
        fatal: fatal,
        url: loader.url,
        loader: loader,
        context: context,
        networkDetails: networkDetails
      };

      if (response) {
        errorData.response = response;
      }

      this.hls.trigger(_events2.default.ERROR, errorData);
    }
  }, {
    key: '_handlePlaylistLoaded',
    value: function _handlePlaylistLoaded(response, stats, context, networkDetails) {
      var type = context.type,
          level = context.level,
          id = context.id,
          levelDetails = context.levelDetails;


      if (!levelDetails.targetduration) {
        this._handleManifestParsingError(response, context, 'invalid target duration', networkDetails);
        return;
      }

      var canHaveLevels = PlaylistLoader.canHaveQualityLevels(context.type);
      if (canHaveLevels) {
        this.hls.trigger(_events2.default.LEVEL_LOADED, {
          details: levelDetails,
          level: level || 0,
          id: id || 0,
          stats: stats,
          networkDetails: networkDetails
        });
      } else {
        switch (type) {
          case ContextType.AUDIO_TRACK:
            this.hls.trigger(_events2.default.AUDIO_TRACK_LOADED, {
              details: levelDetails,
              id: id,
              stats: stats,
              networkDetails: networkDetails
            });
            break;
          case ContextType.SUBTITLE_TRACK:
            this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADED, {
              details: levelDetails,
              id: id,
              stats: stats,
              networkDetails: networkDetails
            });
            break;
        }
      }
    }
  }], [{
    key: 'canHaveQualityLevels',


    /**
     * @param {ContextType} type
     * @returns {boolean}
     */
    value: function canHaveQualityLevels(type) {
      return type !== ContextType.AUDIO_TRACK && type !== ContextType.SUBTITLE_TRACK;
    }

    /**
     * Map context.type to LevelType
     * @param {{type: ContextType}} context
     * @returns {LevelType}
     */

  }, {
    key: 'mapContextToLevelType',
    value: function mapContextToLevelType(context) {
      var type = context.type;


      switch (type) {
        case ContextType.AUDIO_TRACK:
          return LevelType.AUDIO;
        case ContextType.SUBTITLE_TRACK:
          return LevelType.SUBTITLE;
        default:
          return LevelType.MAIN;
      }
    }
  }, {
    key: 'getResponseUrl',
    value: function getResponseUrl(response, context) {
      var url = response.url;
      // responseURL not supported on some browsers (it is used to detect URL redirection)
      // data-uri mode also not supported (but no need to detect redirection)
      if (url === undefined || url.indexOf('data:') === 0) {
        // fallback to initial URL
        url = context.url;
      }
      return url;
    }
  }, {
    key: 'ContextType',
    get: function get() {
      return ContextType;
    }
  }, {
    key: 'LevelType',
    get: function get() {
      return LevelType;
    }
  }]);

  return PlaylistLoader;
}(_eventHandler2.default);

exports.default = PlaylistLoader;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/observer.js":
/*!********************************!*\
  !*** ./src/hls.js/observer.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Observer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventemitter = __webpack_require__(/*! eventemitter3 */ "../../node_modules/eventemitter3/index.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class
 *
 * Simple adapter sub-class of Nodejs-like EventEmitter.
 *
 * We simply want to pass along the event-name itself
 * in every call to a handler, which is the purpose of our `trigger` method
 * extending the standard API.
 *
 */
var Observer = exports.Observer = function (_EventEmitter) {
  _inherits(Observer, _EventEmitter);

  function Observer() {
    _classCallCheck(this, Observer);

    return _possibleConstructorReturn(this, (Observer.__proto__ || Object.getPrototypeOf(Observer)).apply(this, arguments));
  }

  _createClass(Observer, [{
    key: 'trigger',

    /**
     *
     * @param {string} event
     * @param {any} data
     */
    value: function trigger(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      this.emit.apply(this, [event, event].concat(data));
    }
  }]);

  return Observer;
}(_eventemitter.EventEmitter);

/***/ }),

/***/ "./src/hls.js/remux/aac-helper.js":
/*!****************************************!*\
  !*** ./src/hls.js/remux/aac-helper.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  AAC helper
 */

var AAC = function () {
  function AAC() {
    _classCallCheck(this, AAC);
  }

  _createClass(AAC, null, [{
    key: 'getSilentFrame',
    value: function getSilentFrame(codec, channelCount) {
      switch (codec) {
        case 'mp4a.40.2':
          if (channelCount === 1) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
          } else if (channelCount === 2) {
            return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
          } else if (channelCount === 3) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
          } else if (channelCount === 4) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
          } else if (channelCount === 5) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
          } else if (channelCount === 6) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
          }

          break;
        // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
        default:
          if (channelCount === 1) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          } else if (channelCount === 2) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          } else if (channelCount === 3) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          }
          break;
      }
      return null;
    }
  }]);

  return AAC;
}();

exports.default = AAC;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/remux/mp4-generator.js":
/*!*******************************************!*\
  !*** ./src/hls.js/remux/mp4-generator.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generate MP4 Box
*/

var UINT32_MAX = Math.pow(2, 32) - 1;

var MP4 = function () {
  function MP4() {
    _classCallCheck(this, MP4);
  }

  _createClass(MP4, null, [{
    key: 'init',
    value: function init() {
      MP4.types = {
        avc1: [], // codingname
        avcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        '.mp3': [],
        mvex: [],
        mvhd: [],
        pasp: [],
        sdtp: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        tfdt: [],
        tfhd: [],
        traf: [],
        trak: [],
        trun: [],
        trex: [],
        tkhd: [],
        vmhd: [],
        smhd: []
      };

      var i = void 0;
      for (i in MP4.types) {
        if (MP4.types.hasOwnProperty(i)) {
          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
        }
      }

      var videoHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
      ]);

      var audioHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
      ]);

      MP4.HDLR_TYPES = {
        'video': videoHdlr,
        'audio': audioHdlr
      };

      var dref = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01, // entry_count
      0x00, 0x00, 0x00, 0x0c, // entry_size
      0x75, 0x72, 0x6c, 0x20, // 'url' type
      0x00, // version 0
      0x00, 0x00, 0x01 // entry_flags
      ]);

      var stco = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00 // entry_count
      ]);

      MP4.STTS = MP4.STSC = MP4.STCO = stco;

      MP4.STSZ = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // sample_size
      0x00, 0x00, 0x00, 0x00 // sample_count
      ]);
      MP4.VMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x01, // flags
      0x00, 0x00, // graphicsmode
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
      ]);
      MP4.SMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, // balance
      0x00, 0x00 // reserved
      ]);

      MP4.STSD = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01]); // entry_count

      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
      var minorVersion = new Uint8Array([0, 0, 0, 1]);

      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
    }
  }, {
    key: 'box',
    value: function box(type) {
      var payload = Array.prototype.slice.call(arguments, 1),
          size = 8,
          i = payload.length,
          len = i,
          result = void 0;
      // calculate the total size we need to allocate
      while (i--) {
        size += payload[i].byteLength;
      }

      result = new Uint8Array(size);
      result[0] = size >> 24 & 0xff;
      result[1] = size >> 16 & 0xff;
      result[2] = size >> 8 & 0xff;
      result[3] = size & 0xff;
      result.set(type, 4);
      // copy the payload into the result
      for (i = 0, size = 8; i < len; i++) {
        // copy payload[i] array @ offset size
        result.set(payload[i], size);
        size += payload[i].byteLength;
      }
      return result;
    }
  }, {
    key: 'hdlr',
    value: function hdlr(type) {
      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
    }
  }, {
    key: 'mdat',
    value: function mdat(data) {
      return MP4.box(MP4.types.mdat, data);
    }
  }, {
    key: 'mdhd',
    value: function mdhd(timescale, duration) {
      duration *= timescale;
      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.mdhd, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x55, 0xc4, // 'und' language (undetermined)
      0x00, 0x00]));
    }
  }, {
    key: 'mdia',
    value: function mdia(track) {
      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
    }
  }, {
    key: 'mfhd',
    value: function mfhd(sequenceNumber) {
      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
      sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF // sequence_number
      ]));
    }
  }, {
    key: 'minf',
    value: function minf(track) {
      if (track.type === 'audio') {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
      } else {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
      }
    }
  }, {
    key: 'moof',
    value: function moof(sn, baseMediaDecodeTime, track) {
      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
    }
    /**
    * @param tracks... (optional) {array} the tracks associated with this movie
    */

  }, {
    key: 'moov',
    value: function moov(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trak(tracks[i]);
      }

      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
    }
  }, {
    key: 'mvex',
    value: function mvex(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trex(tracks[i]);
      }

      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
    }
  }, {
    key: 'mvhd',
    value: function mvhd(timescale, duration) {
      duration *= timescale;
      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      var bytes = new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x01, 0x00, 0x00, // 1.0 rate
      0x01, 0x00, // 1.0 volume
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      0xff, 0xff, 0xff, 0xff // next_track_ID
      ]);
      return MP4.box(MP4.types.mvhd, bytes);
    }
  }, {
    key: 'sdtp',
    value: function sdtp(track) {
      var samples = track.samples || [],
          bytes = new Uint8Array(4 + samples.length),
          flags = void 0,
          i = void 0;
      // leave the full box header (4 bytes) all zero
      // write the sample table
      for (i = 0; i < samples.length; i++) {
        flags = samples[i].flags;
        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
      }

      return MP4.box(MP4.types.sdtp, bytes);
    }
  }, {
    key: 'stbl',
    value: function stbl(track) {
      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
    }
  }, {
    key: 'avc1',
    value: function avc1(track) {
      var sps = [],
          pps = [],
          i = void 0,
          data = void 0,
          len = void 0;
      // assemble the SPSs

      for (i = 0; i < track.sps.length; i++) {
        data = track.sps[i];
        len = data.byteLength;
        sps.push(len >>> 8 & 0xFF);
        sps.push(len & 0xFF);

        // SPS
        sps = sps.concat(Array.prototype.slice.call(data));
      }

      // assemble the PPSs
      for (i = 0; i < track.pps.length; i++) {
        data = track.pps[i];
        len = data.byteLength;
        pps.push(len >>> 8 & 0xFF);
        pps.push(len & 0xFF);

        pps = pps.concat(Array.prototype.slice.call(data));
      }

      var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version
      sps[3], // profile
      sps[4], // profile compat
      sps[5], // level
      0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
      0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
      ].concat(sps).concat([track.pps.length // numOfPictureParameterSets
      ]).concat(pps))),
          // "PPS"
      width = track.width,
          height = track.height,
          hSpacing = track.pixelRatio[0],
          vSpacing = track.pixelRatio[1];

      return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, // pre_defined
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      width >> 8 & 0xFF, width & 0xff, // width
      height >> 8 & 0xFF, height & 0xff, // height
      0x00, 0x48, 0x00, 0x00, // horizresolution
      0x00, 0x48, 0x00, 0x00, // vertresolution
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // frame_count
      0x12, 0x64, 0x61, 0x69, 0x6C, // dailymotion/hls.js
      0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname
      0x00, 0x18, // depth = 24
      0x11, 0x11]), // pre_defined = -1
      avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB
      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate
      0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate
      MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24, // hSpacing
      hSpacing >> 16 & 0xFF, hSpacing >> 8 & 0xFF, hSpacing & 0xFF, vSpacing >> 24, // vSpacing
      vSpacing >> 16 & 0xFF, vSpacing >> 8 & 0xFF, vSpacing & 0xFF])));
    }
  }, {
    key: 'esds',
    value: function esds(track) {
      var configlen = track.config.length;
      return new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags

      0x03, // descriptor_type
      0x17 + configlen, // length
      0x00, 0x01, // es_id
      0x00, // stream_priority

      0x04, // descriptor_type
      0x0f + configlen, // length
      0x40, // codec : mpeg4_audio
      0x15, // stream_type
      0x00, 0x00, 0x00, // buffer_size
      0x00, 0x00, 0x00, 0x00, // maxBitrate
      0x00, 0x00, 0x00, 0x00, // avgBitrate

      0x05 // descriptor_type
      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
    }
  }, {
    key: 'mp4a',
    value: function mp4a(track) {
      var samplerate = track.samplerate;
      return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      samplerate >> 8 & 0xFF, samplerate & 0xff, //
      0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
    }
  }, {
    key: 'mp3',
    value: function mp3(track) {
      var samplerate = track.samplerate;
      return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      samplerate >> 8 & 0xFF, samplerate & 0xff, //
      0x00, 0x00]));
    }
  }, {
    key: 'stsd',
    value: function stsd(track) {
      if (track.type === 'audio') {
        if (!track.isAAC && track.codec === 'mp3') {
          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
        }

        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
      } else {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
      }
    }
  }, {
    key: 'tkhd',
    value: function tkhd(track) {
      var id = track.id,
          duration = track.duration * track.timescale,
          width = track.width,
          height = track.height,
          upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)),
          lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.tkhd, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x07, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x00, // reserved
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, // layer
      0x00, 0x00, // alternate_group
      0x00, 0x00, // non-audio track volume
      0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
      height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
      ]));
    }
  }, {
    key: 'traf',
    value: function traf(track, baseMediaDecodeTime) {
      var sampleDependencyTable = MP4.sdtp(track),
          id = track.id,
          upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)),
          lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF]) // track_ID
      ), MP4.box(MP4.types.tfdt, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0XFF, upperWordBaseMediaDecodeTime >> 8 & 0XFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0XFF, lowerWordBaseMediaDecodeTime >> 8 & 0XFF, lowerWordBaseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
      20 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8), // mdat header
      sampleDependencyTable);
    }

    /**
     * Generate a track box.
     * @param track {object} a track definition
     * @return {Uint8Array} the track box
     */

  }, {
    key: 'trak',
    value: function trak(track) {
      track.duration = track.duration || 0xffffffff;
      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
    }
  }, {
    key: 'trex',
    value: function trex(track) {
      var id = track.id;
      return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x01, // default_sample_description_index
      0x00, 0x00, 0x00, 0x00, // default_sample_duration
      0x00, 0x00, 0x00, 0x00, // default_sample_size
      0x00, 0x01, 0x00, 0x01 // default_sample_flags
      ]));
    }
  }, {
    key: 'trun',
    value: function trun(track, offset) {
      var samples = track.samples || [],
          len = samples.length,
          arraylen = 12 + 16 * len,
          array = new Uint8Array(arraylen),
          i = void 0,
          sample = void 0,
          duration = void 0,
          size = void 0,
          flags = void 0,
          cts = void 0;
      offset += 8 + arraylen;
      array.set([0x00, // version 0
      0x00, 0x0f, 0x01, // flags
      len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
      offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
      ], 0);
      for (i = 0; i < len; i++) {
        sample = samples[i];
        duration = sample.duration;
        size = sample.size;
        flags = sample.flags;
        cts = sample.cts;
        array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
        size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
        cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
        ], 12 + 16 * i);
      }
      return MP4.box(MP4.types.trun, array);
    }
  }, {
    key: 'initSegment',
    value: function initSegment(tracks) {
      if (!MP4.types) {
        MP4.init();
      }

      var movie = MP4.moov(tracks),
          result = void 0;
      result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
      result.set(MP4.FTYP);
      result.set(movie, MP4.FTYP.byteLength);
      return result;
    }
  }]);

  return MP4;
}();

exports.default = MP4;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/remux/mp4-remuxer.js":
/*!*****************************************!*\
  !*** ./src/hls.js/remux/mp4-remuxer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * fMP4 remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _aacHelper = __webpack_require__(/*! ./aac-helper */ "./src/hls.js/remux/aac-helper.js");

var _aacHelper2 = _interopRequireDefault(_aacHelper);

var _mp4Generator = __webpack_require__(/*! ./mp4-generator */ "./src/hls.js/remux/mp4-generator.js");

var _mp4Generator2 = _interopRequireDefault(_mp4Generator);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 10 seconds
var MAX_SILENT_FRAME_DURATION = 10 * 1000;

var MP4Remuxer = function () {
  function MP4Remuxer(observer, config, typeSupported, vendor) {
    _classCallCheck(this, MP4Remuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    var userAgent = navigator.userAgent;
    this.isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');
    this.ISGenerated = false;
  }

  _createClass(MP4Remuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp(defaultTimeStamp) {
      this._initPTS = this._initDTS = defaultTimeStamp;
    }
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment() {
      this.ISGenerated = false;
    }
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      // generate Init Segment if needed
      if (!this.ISGenerated) {
        this.generateIS(audioTrack, videoTrack, timeOffset);
      }

      if (this.ISGenerated) {
        var nbAudioSamples = audioTrack.samples.length;
        var nbVideoSamples = videoTrack.samples.length;
        var audioTimeOffset = timeOffset;
        var videoTimeOffset = timeOffset;
        if (nbAudioSamples && nbVideoSamples) {
          // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)
          // if first audio DTS is not aligned with first video DTS then we need to take that into account
          // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small
          // drift between audio and video streams
          var audiovideoDeltaDts = (audioTrack.samples[0].pts - videoTrack.samples[0].pts) / videoTrack.inputTimeScale;
          audioTimeOffset += Math.max(0, audiovideoDeltaDts);
          videoTimeOffset += Math.max(0, -audiovideoDeltaDts);
        }
        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is
        // calculated in remuxAudio.
        // logger.log('nb AAC samples:' + audioTrack.samples.length);
        if (nbAudioSamples) {
          // if initSegment was generated without video samples, regenerate it again
          if (!audioTrack.timescale) {
            _logger.logger.warn('regenerate InitSegment as audio detected');
            this.generateIS(audioTrack, videoTrack, timeOffset);
          }
          var audioData = this.remuxAudio(audioTrack, audioTimeOffset, contiguous, accurateTimeOffset);
          // logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (nbVideoSamples) {
            var audioTrackLength = void 0;
            if (audioData) {
              audioTrackLength = audioData.endPTS - audioData.startPTS;
            }

            // if initSegment was generated without video samples, regenerate it again
            if (!videoTrack.timescale) {
              _logger.logger.warn('regenerate InitSegment as video detected');
              this.generateIS(audioTrack, videoTrack, timeOffset);
            }
            this.remuxVideo(videoTrack, videoTimeOffset, contiguous, audioTrackLength, accurateTimeOffset);
          }
        } else {
          // logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (nbVideoSamples) {
            var videoData = this.remuxVideo(videoTrack, videoTimeOffset, contiguous, 0, accurateTimeOffset);
            if (videoData && audioTrack.codec) {
              this.remuxEmptyAudio(audioTrack, audioTimeOffset, contiguous, videoData);
            }
          }
        }
      }
      // logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (id3Track.samples.length) {
        this.remuxID3(id3Track, timeOffset);
      }

      // logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (textTrack.samples.length) {
        this.remuxText(textTrack, timeOffset);
      }

      // notify end of parsing
      this.observer.trigger(_events2.default.FRAG_PARSED);
    }
  }, {
    key: 'generateIS',
    value: function generateIS(audioTrack, videoTrack, timeOffset) {
      var observer = this.observer,
          audioSamples = audioTrack.samples,
          videoSamples = videoTrack.samples,
          typeSupported = this.typeSupported,
          container = 'audio/mp4',
          tracks = {},
          data = { tracks: tracks },
          computePTSDTS = this._initPTS === undefined,
          initPTS = void 0,
          initDTS = void 0;

      if (computePTSDTS) {
        initPTS = initDTS = Infinity;
      }

      if (audioTrack.config && audioSamples.length) {
        // let's use audio sampling rate as MP4 time scale.
        // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)
        // using audio sampling rate here helps having an integer MP4 frame duration
        // this avoids potential rounding issue and AV sync issue
        audioTrack.timescale = audioTrack.samplerate;
        _logger.logger.log('audio sampling rate : ' + audioTrack.samplerate);
        if (!audioTrack.isAAC) {
          if (typeSupported.mpeg) {
            // Chrome and Safari
            container = 'audio/mpeg';
            audioTrack.codec = '';
          } else if (typeSupported.mp3) {
            // Firefox
            audioTrack.codec = 'mp3';
          }
        }
        tracks.audio = {
          container: container,
          codec: audioTrack.codec,
          initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : _mp4Generator2.default.initSegment([audioTrack]),
          metadata: {
            channelCount: audioTrack.channelCount
          }
        };
        if (computePTSDTS) {
          // remember first PTS of this demuxing context. for audio, PTS = DTS
          initPTS = initDTS = audioSamples[0].pts - audioTrack.inputTimeScale * timeOffset;
        }
      }

      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
        // let's use input time scale as MP4 video timescale
        // we use input time scale straight away to avoid rounding issues on frame duration / cts computation
        var inputTimeScale = videoTrack.inputTimeScale;
        videoTrack.timescale = inputTimeScale;
        tracks.video = {
          container: 'video/mp4',
          codec: videoTrack.codec,
          initSegment: _mp4Generator2.default.initSegment([videoTrack]),
          metadata: {
            width: videoTrack.width,
            height: videoTrack.height
          }
        };
        if (computePTSDTS) {
          initPTS = Math.min(initPTS, videoSamples[0].pts - inputTimeScale * timeOffset);
          initDTS = Math.min(initDTS, videoSamples[0].dts - inputTimeScale * timeOffset);
          this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });
        }
      }

      if (Object.keys(tracks).length) {
        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
        this.ISGenerated = true;
        if (computePTSDTS) {
          this._initPTS = initPTS;
          this._initDTS = initDTS;
        }
      } else {
        observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });
      }
    }
  }, {
    key: 'remuxVideo',
    value: function remuxVideo(track, timeOffset, contiguous, audioTrackLength, accurateTimeOffset) {
      var offset = 8;
      var mp4SampleDuration = void 0;
      var mdat = void 0;
      var moof = void 0;
      var firstPTS = void 0;
      var firstDTS = void 0;
      var lastPTS = void 0;
      var lastDTS = void 0;
      var timeScale = track.timescale;
      var inputSamples = track.samples;
      var outputSamples = [];
      var nbSamples = inputSamples.length;
      var ptsNormalize = this._PTSNormalize;
      var initPTS = this._initPTS;

      // if parsed fragment is contiguous with last one, let's use last DTS value as reference
      var nextAvcDts = this.nextAvcDts;

      var isSafari = this.isSafari;

      if (nbSamples === 0) {
        return;
      }

      // Safari does not like overlapping DTS on consecutive fragments. let's use nextAvcDts to overcome this if fragments are consecutive
      if (isSafari) {
        // also consider consecutive fragments as being contiguous (even if a level switch occurs),
        // for sake of clarity:
        // consecutive fragments are frags with
        //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
        //  - less than 200 ms PTS gaps (timeScale/5)
        contiguous |= inputSamples.length && nextAvcDts && (accurateTimeOffset && Math.abs(timeOffset - nextAvcDts / timeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAvcDts - initPTS) < timeScale / 5);
      }

      if (!contiguous) {
        // if not contiguous, let's use target timeOffset
        nextAvcDts = timeOffset * timeScale;
      }

      // PTS is coded on 33bits, and can loop from -2^32 to 2^32
      // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
      inputSamples.forEach(function (sample) {
        sample.pts = ptsNormalize(sample.pts - initPTS, nextAvcDts);
        sample.dts = ptsNormalize(sample.dts - initPTS, nextAvcDts);
      });

      // sort video samples by DTS then PTS then demux id order
      inputSamples.sort(function (a, b) {
        var deltadts = a.dts - b.dts;
        var deltapts = a.pts - b.pts;
        return deltadts || deltapts || a.id - b.id;
      });

      // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)
      var PTSDTSshift = inputSamples.reduce(function (prev, curr) {
        return Math.max(Math.min(prev, curr.pts - curr.dts), -18000);
      }, 0);
      if (PTSDTSshift < 0) {
        _logger.logger.warn('PTS < DTS detected in video samples, shifting DTS by ' + Math.round(PTSDTSshift / 90) + ' ms to overcome this issue');
        for (var i = 0; i < inputSamples.length; i++) {
          inputSamples[i].dts += PTSDTSshift;
        }
      }

      // compute first DTS and last DTS, normalize them against reference value
      var sample = inputSamples[0];
      firstDTS = Math.max(sample.dts, 0);
      firstPTS = Math.max(sample.pts, 0);

      // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
      var delta = Math.round((firstDTS - nextAvcDts) / 90);
      // if fragment are contiguous, detect hole/overlapping between fragments
      if (contiguous) {
        if (delta) {
          if (delta > 1) {
            _logger.logger.log('AVC:' + delta + ' ms hole between fragments detected,filling it');
          } else if (delta < -1) {
            _logger.logger.log('AVC:' + -delta + ' ms overlapping between fragments detected');
          }

          // remove hole/gap : set DTS to next expected DTS
          firstDTS = nextAvcDts;
          inputSamples[0].dts = firstDTS;
          // offset PTS as well, ensure that PTS is smaller or equal than new DTS
          firstPTS = Math.max(firstPTS - delta, nextAvcDts);
          inputSamples[0].pts = firstPTS;
          _logger.logger.log('Video/PTS/DTS adjusted: ' + Math.round(firstPTS / 90) + '/' + Math.round(firstDTS / 90) + ',delta:' + delta + ' ms');
        }
      }

      // compute lastPTS/lastDTS
      sample = inputSamples[inputSamples.length - 1];
      lastDTS = Math.max(sample.dts, 0);
      lastPTS = Math.max(sample.pts, 0, lastDTS);

      // on Safari let's signal the same sample duration for all samples
      // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
      // set this constant duration as being the avg delta between consecutive DTS.
      if (isSafari) {
        mp4SampleDuration = Math.round((lastDTS - firstDTS) / (inputSamples.length - 1));
      }

      var nbNalu = 0,
          naluLen = 0;
      for (var _i = 0; _i < nbSamples; _i++) {
        // compute total/avc sample length and nb of NAL units
        var _sample = inputSamples[_i],
            units = _sample.units,
            nbUnits = units.length,
            sampleLen = 0;
        for (var j = 0; j < nbUnits; j++) {
          sampleLen += units[j].data.length;
        }

        naluLen += sampleLen;
        nbNalu += nbUnits;
        _sample.length = sampleLen;

        // normalize PTS/DTS
        if (isSafari) {
          // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
          _sample.dts = firstDTS + _i * mp4SampleDuration;
        } else {
          // ensure sample monotonic DTS
          _sample.dts = Math.max(_sample.dts, firstDTS);
        }
        // ensure that computed value is greater or equal than sample DTS
        _sample.pts = Math.max(_sample.pts, _sample.dts);
      }

      /* concatenate the video data and construct the mdat in place
        (need 8 more bytes to fill length and mpdat type) */
      var mdatSize = naluLen + 4 * nbNalu + 8;
      try {
        mdat = new Uint8Array(mdatSize);
      } catch (err) {
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating video mdat ' + mdatSize });
        return;
      }
      var view = new DataView(mdat.buffer);
      view.setUint32(0, mdatSize);
      mdat.set(_mp4Generator2.default.types.mdat, 4);

      for (var _i2 = 0; _i2 < nbSamples; _i2++) {
        var avcSample = inputSamples[_i2],
            avcSampleUnits = avcSample.units,
            mp4SampleLength = 0,
            compositionTimeOffset = void 0;
        // convert NALU bitstream to MP4 format (prepend NALU with size field)
        for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {
          var unit = avcSampleUnits[_j],
              unitData = unit.data,
              unitDataLen = unit.data.byteLength;
          view.setUint32(offset, unitDataLen);
          offset += 4;
          mdat.set(unitData, offset);
          offset += unitDataLen;
          mp4SampleLength += 4 + unitDataLen;
        }

        if (!isSafari) {
          // expected sample duration is the Decoding Timestamp diff of consecutive samples
          if (_i2 < nbSamples - 1) {
            mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;
          } else {
            var config = this.config,
                lastFrameDuration = avcSample.dts - inputSamples[_i2 > 0 ? _i2 - 1 : _i2].dts;
            if (config.stretchShortVideoTrack) {
              // In some cases, a segment's audio track duration may exceed the video track duration.
              // Since we've already remuxed audio, and we know how long the audio track is, we look to
              // see if the delta to the next segment is longer than maxBufferHole.
              // If so, playback would potentially get stuck, so we artificially inflate
              // the duration of the last frame to minimize any potential gap between segments.
              var maxBufferHole = config.maxBufferHole,
                  gapTolerance = Math.floor(maxBufferHole * timeScale),
                  deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;
              if (deltaToFrameEnd > gapTolerance) {
                // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
                // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.
                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                if (mp4SampleDuration < 0) {
                  mp4SampleDuration = lastFrameDuration;
                }

                _logger.logger.log('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');
              } else {
                mp4SampleDuration = lastFrameDuration;
              }
            } else {
              mp4SampleDuration = lastFrameDuration;
            }
          }
          compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
        } else {
          compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / mp4SampleDuration));
        }

        // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
        // console.log(`avcSample.dts: ${avcSample.dts / 90}, avcSample.pts: ${avcSample.pts / 90}, mp4SampleDuration: ${mp4SampleDuration / 90}`, avcSample)
        outputSamples.push({
          size: mp4SampleLength,
          // constant duration
          duration: mp4SampleDuration,
          cts: compositionTimeOffset,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: avcSample.key ? 2 : 1,
            isNonSync: avcSample.key ? 0 : 1
          }
        });
      }
      // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
      this.nextAvcDts = lastDTS + mp4SampleDuration;
      var dropped = track.dropped;
      track.len = 0;
      track.nbNalu = 0;
      track.dropped = 0;
      if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
        var flags = outputSamples[0].flags;
        // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
        // https://code.google.com/p/chromium/issues/detail?id=229412
        flags.dependsOn = 2;
        flags.isNonSync = 0;
      }
      track.samples = outputSamples;
      moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS, track);
      track.samples = [];

      var data = {
        data1: moof,
        data2: mdat,
        startPTS: firstPTS / timeScale,
        endPTS: (lastPTS + mp4SampleDuration) / timeScale,
        startDTS: firstDTS / timeScale,
        endDTS: this.nextAvcDts / timeScale,
        type: 'video',
        hasAudio: false,
        hasVideo: true,
        nb: outputSamples.length,
        dropped: dropped
      };
      this.observer.trigger(_events2.default.FRAG_PARSING_DATA, data);
      return data;
    }
  }, {
    key: 'remuxAudio',
    value: function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset) {
      var inputTimeScale = track.inputTimeScale;
      var mp4timeScale = track.timescale;
      var scaleFactor = inputTimeScale / mp4timeScale;
      var mp4SampleDuration = track.isAAC ? 1024 : 1152;
      var inputSampleDuration = mp4SampleDuration * scaleFactor;
      var ptsNormalize = this._PTSNormalize;
      var initPTS = this._initPTS;
      var rawMPEG = !track.isAAC && this.typeSupported.mpeg;

      var offset = void 0,
          mp4Sample = void 0,
          fillFrame = void 0,
          mdat = void 0,
          moof = void 0,
          firstPTS = void 0,
          lastPTS = void 0,
          inputSamples = track.samples,
          outputSamples = [],
          nextAudioPts = this.nextAudioPts;

      // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
      // for sake of clarity:
      // consecutive fragments are frags with
      //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
      //  - less than 20 audio frames distance
      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
      // this helps ensuring audio continuity
      // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame
      contiguous |= inputSamples.length && nextAudioPts && (accurateTimeOffset && Math.abs(timeOffset - nextAudioPts / inputTimeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAudioPts - initPTS) < 20 * inputSampleDuration);

      // compute normalized PTS
      inputSamples.forEach(function (sample) {
        sample.pts = sample.dts = ptsNormalize(sample.pts - initPTS, timeOffset * inputTimeScale);
      });

      // filter out sample with negative PTS that are not playable anyway
      // if we don't remove these negative samples, they will shift all audio samples forward.
      // leading to audio overlap between current / next fragment
      inputSamples = inputSamples.filter(function (sample) {
        return sample.pts >= 0;
      });

      // in case all samples have negative PTS, and have been filtered out, return now
      if (inputSamples.length === 0) {
        return;
      }

      if (!contiguous) {
        if (!accurateTimeOffset) {
          // if frag are mot contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS
          nextAudioPts = inputSamples[0].pts;
        } else {
          // if timeOffset is accurate, let's use it as predicted next audio PTS
          nextAudioPts = timeOffset * inputTimeScale;
        }
      }

      // If the audio track is missing samples, the frames seem to get "left-shifted" within the
      // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
      // In an effort to prevent this from happening, we inject frames here where there are gaps.
      // When possible, we inject a silent frame; when that's not possible, we duplicate the last
      // frame.

      if (track.isAAC) {
        var maxAudioFramesDrift = this.config.maxAudioFramesDrift;
        for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length;) {
          // First, let's see how far off this frame is from where we expect it to be
          var sample = inputSamples[i],
              delta;
          var pts = sample.pts;
          delta = pts - nextPts;

          var duration = Math.abs(1000 * delta / inputTimeScale);

          // If we're overlapping by more than a duration, drop this sample
          if (delta <= -maxAudioFramesDrift * inputSampleDuration) {
            _logger.logger.warn('Dropping 1 audio frame @ ' + (nextPts / inputTimeScale).toFixed(3) + 's due to ' + Math.round(duration) + ' ms overlap.');
            inputSamples.splice(i, 1);
            track.len -= sample.unit.length;
            // Don't touch nextPtsNorm or i
          } // eslint-disable-line brace-style

          // Insert missing frames if:
          // 1: We're more than maxAudioFramesDrift frame away
          // 2: Not more than MAX_SILENT_FRAME_DURATION away
          // 3: currentTime (aka nextPtsNorm) is not 0
          else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && nextPts) {
              var missing = Math.round(delta / inputSampleDuration);
              _logger.logger.warn('Injecting ' + missing + ' audio frame @ ' + (nextPts / inputTimeScale).toFixed(3) + 's due to ' + Math.round(1000 * delta / inputTimeScale) + ' ms gap.');
              for (var j = 0; j < missing; j++) {
                var newStamp = Math.max(nextPts, 0);
                fillFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                if (!fillFrame) {
                  _logger.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');
                  fillFrame = sample.unit.subarray();
                }
                inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });
                track.len += fillFrame.length;
                nextPts += inputSampleDuration;
                i++;
              }

              // Adjust sample to next expected pts
              sample.pts = sample.dts = nextPts;
              nextPts += inputSampleDuration;
              i++;
            } else {
              // Otherwise, just adjust pts
              if (Math.abs(delta) > 0.1 * inputSampleDuration) {
                // logger.log(`Invalid frame delta ${Math.round(delta + inputSampleDuration)} at PTS ${Math.round(pts / 90)} (should be ${Math.round(inputSampleDuration)}).`);
              }
              sample.pts = sample.dts = nextPts;
              nextPts += inputSampleDuration;
              i++;
            }
        }
      }

      for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {
        var audioSample = inputSamples[_j2];
        var unit = audioSample.unit;
        var _pts = audioSample.pts;
        // logger.log(`Audio/PTS:${Math.round(pts/90)}`);
        // if not first sample
        if (lastPTS !== undefined) {
          mp4Sample.duration = Math.round((_pts - lastPTS) / scaleFactor);
        } else {
          var _delta = Math.round(1000 * (_pts - nextAudioPts) / inputTimeScale),
              numMissingFrames = 0;
          // if fragment are contiguous, detect hole/overlapping between fragments
          // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
          if (contiguous && track.isAAC) {
            // log delta
            if (_delta) {
              if (_delta > 0 && _delta < MAX_SILENT_FRAME_DURATION) {
                numMissingFrames = Math.round((_pts - nextAudioPts) / inputSampleDuration);
                _logger.logger.log(_delta + ' ms hole between AAC samples detected,filling it');
                if (numMissingFrames > 0) {
                  fillFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                  if (!fillFrame) {
                    fillFrame = unit.subarray();
                  }

                  track.len += numMissingFrames * fillFrame.length;
                }
                // if we have frame overlap, overlapping for more than half a frame duraion
              } else if (_delta < -12) {
                // drop overlapping audio frames... browser will deal with it
                _logger.logger.log('drop overlapping AAC sample, expected/parsed/delta:' + (nextAudioPts / inputTimeScale).toFixed(3) + 's/' + (_pts / inputTimeScale).toFixed(3) + 's/' + -_delta + 'ms');
                track.len -= unit.byteLength;
                continue;
              }
              // set PTS/DTS to expected PTS/DTS
              _pts = nextAudioPts;
            }
          }
          // remember first PTS of our audioSamples
          firstPTS = _pts;
          if (track.len > 0) {
            /* concatenate the audio data and construct the mdat in place
              (need 8 more bytes to fill length and mdat type) */
            var mdatSize = rawMPEG ? track.len : track.len + 8;
            offset = rawMPEG ? 0 : 8;
            try {
              mdat = new Uint8Array(mdatSize);
            } catch (err) {
              this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating audio mdat ' + mdatSize });
              return;
            }
            if (!rawMPEG) {
              var view = new DataView(mdat.buffer);
              view.setUint32(0, mdatSize);
              mdat.set(_mp4Generator2.default.types.mdat, 4);
            }
          } else {
            // no audio samples
            return;
          }
          for (var _i3 = 0; _i3 < numMissingFrames; _i3++) {
            fillFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
            if (!fillFrame) {
              _logger.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');
              fillFrame = unit.subarray();
            }
            mdat.set(fillFrame, offset);
            offset += fillFrame.byteLength;
            mp4Sample = {
              size: fillFrame.byteLength,
              cts: 0,
              duration: 1024,
              flags: {
                isLeading: 0,
                isDependedOn: 0,
                hasRedundancy: 0,
                degradPrio: 0,
                dependsOn: 1
              }
            };
            outputSamples.push(mp4Sample);
          }
        }
        mdat.set(unit, offset);
        var unitLen = unit.byteLength;
        offset += unitLen;
        // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');
        mp4Sample = {
          size: unitLen,
          cts: 0,
          duration: 0,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: 1
          }
        };
        outputSamples.push(mp4Sample);
        lastPTS = _pts;
      }
      var lastSampleDuration = 0;
      var nbSamples = outputSamples.length;
      // set last sample duration as being identical to previous sample
      if (nbSamples >= 2) {
        lastSampleDuration = outputSamples[nbSamples - 2].duration;
        mp4Sample.duration = lastSampleDuration;
      }
      if (nbSamples) {
        // next audio sample PTS should be equal to last sample PTS + duration
        this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSampleDuration;
        // logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
        track.len = 0;
        track.samples = outputSamples;
        if (rawMPEG) {
          moof = new Uint8Array();
        } else {
          moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstPTS / scaleFactor, track);
        }

        track.samples = [];
        var start = firstPTS / inputTimeScale;
        var end = nextAudioPts / inputTimeScale;
        var audioData = {
          data1: moof,
          data2: mdat,
          startPTS: start,
          endPTS: end,
          startDTS: start,
          endDTS: end,
          type: 'audio',
          hasAudio: true,
          hasVideo: false,
          nb: nbSamples
        };
        this.observer.trigger(_events2.default.FRAG_PARSING_DATA, audioData);
        return audioData;
      }
      return null;
    }
  }, {
    key: 'remuxEmptyAudio',
    value: function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
      var inputTimeScale = track.inputTimeScale,
          mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale,
          scaleFactor = inputTimeScale / mp4timeScale,
          nextAudioPts = this.nextAudioPts,


      // sync with video's timestamp
      startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS,
          endDTS = videoData.endDTS * inputTimeScale + this._initDTS,

      // one sample's duration value
      sampleDuration = 1024,
          frameDuration = scaleFactor * sampleDuration,


      // samples count of this segment's duration
      nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),


      // silent frame
      silentFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);

      _logger.logger.warn('remux empty Audio');
      // Can't remux if we can't generate a silent frame...
      if (!silentFrame) {
        _logger.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
        return;
      }

      var samples = [];
      for (var i = 0; i < nbSamples; i++) {
        var stamp = startDTS + i * frameDuration;
        samples.push({ unit: silentFrame, pts: stamp, dts: stamp });
        track.len += silentFrame.length;
      }
      track.samples = samples;

      this.remuxAudio(track, timeOffset, contiguous);
    }
  }, {
    key: 'remuxID3',
    value: function remuxID3(track) {
      var length = track.samples.length,
          sample = void 0;
      var inputTimeScale = track.inputTimeScale;
      var initPTS = this._initPTS;
      var initDTS = this._initDTS;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting id3 pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - initPTS) / inputTimeScale;
          sample.dts = (sample.dts - initDTS) / inputTimeScale;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_METADATA, {
          samples: track.samples
        });
      }

      track.samples = [];
    }
  }, {
    key: 'remuxText',
    value: function remuxText(track) {
      track.samples.sort(function (a, b) {
        return a.pts - b.pts;
      });

      var length = track.samples.length,
          sample = void 0;
      var inputTimeScale = track.inputTimeScale;
      var initPTS = this._initPTS;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting text pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - initPTS) / inputTimeScale;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_USERDATA, {
          samples: track.samples
        });
      }

      track.samples = [];
    }
  }, {
    key: '_PTSNormalize',
    value: function _PTSNormalize(value, reference) {
      var offset = void 0;
      if (reference === undefined) {
        return value;
      }

      if (reference < value) {
        // - 2^33
        offset = -8589934592;
      } else {
        // + 2^33
        offset = 8589934592;
      }
      /* PTS is 33bit (from 0 to 2^33 -1)
        if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
        PTS looping occured. fill the gap */
      while (Math.abs(value - reference) > 4294967296) {
        value += offset;
      }

      return value;
    }
  }]);

  return MP4Remuxer;
}();

exports.default = MP4Remuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/remux/passthrough-remuxer.js":
/*!*************************************************!*\
  !*** ./src/hls.js/remux/passthrough-remuxer.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * passthrough remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */


var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PassThroughRemuxer = function () {
  function PassThroughRemuxer(observer) {
    _classCallCheck(this, PassThroughRemuxer);

    this.observer = observer;
  }

  _createClass(PassThroughRemuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment() {}
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset, rawData) {
      var observer = this.observer;
      var streamType = '';
      if (audioTrack) {
        streamType += 'audio';
      }

      if (videoTrack) {
        streamType += 'video';
      }

      observer.trigger(_events2.default.FRAG_PARSING_DATA, {
        data1: rawData,
        startPTS: timeOffset,
        startDTS: timeOffset,
        type: streamType,
        hasAudio: !!audioTrack,
        hasVideo: !!videoTrack,
        nb: 1,
        dropped: 0
      });
      // notify end of parsing
      observer.trigger(_events2.default.FRAG_PARSED);
    }
  }]);

  return PassThroughRemuxer;
}();

exports.default = PassThroughRemuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/task-loop.js":
/*!*********************************!*\
  !*** ./src/hls.js/task-loop.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventHandler = __webpack_require__(/*! ./event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Sub-class specialization of EventHandler base class.
 *
 * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,
 * scheduled asynchroneously, avoiding recursive calls in the same tick.
 *
 * The task itself is implemented in `doTick`. It can be requested and called for single execution
 * using the `tick` method.
 *
 * It will be assured that the task execution method (`tick`) only gets called once per main loop "tick",
 * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.
 *
 * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,
 * and cancelled with `clearNextTick`.
 *
 * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).
 *
 * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.
 *
 * Further explanations:
 *
 * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously
 * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.
 *
 * When the task execution (`tick` method) is called in re-entrant way this is detected and
 * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further
 * task processing on the next main loop iteration (also known as "next tick" in the Node/JS runtime lingo).
 */

var TaskLoop = function (_EventHandler) {
  _inherits(TaskLoop, _EventHandler);

  function TaskLoop(hls) {
    var _ref;

    _classCallCheck(this, TaskLoop);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = TaskLoop.__proto__ || Object.getPrototypeOf(TaskLoop)).call.apply(_ref, [this, hls].concat(events)));

    _this._tickInterval = null;
    _this._tickTimer = null;
    _this._tickCallCount = 0;
    _this._boundTick = _this.tick.bind(_this);
    return _this;
  }

  /**
   * @override
   */


  _createClass(TaskLoop, [{
    key: 'onHandlerDestroying',
    value: function onHandlerDestroying() {
      // clear all timers before unregistering from event bus
      this.clearNextTick();
      this.clearInterval();
    }

    /**
     * @returns {boolean}
     */

  }, {
    key: 'hasInterval',
    value: function hasInterval() {
      return !!this._tickInterval;
    }

    /**
     * @returns {boolean}
     */

  }, {
    key: 'hasNextTick',
    value: function hasNextTick() {
      return !!this._tickTimer;
    }

    /**
     * @param {number} millis Interval time (ms)
     * @returns {boolean} True when interval has been scheduled, false when already scheduled (no effect)
     */

  }, {
    key: 'setInterval',
    value: function (_setInterval) {
      function setInterval(_x) {
        return _setInterval.apply(this, arguments);
      }

      setInterval.toString = function () {
        return _setInterval.toString();
      };

      return setInterval;
    }(function (millis) {
      if (!this._tickInterval) {
        this._tickInterval = setInterval(this._boundTick, millis);
        return true;
      }
      return false;
    })

    /**
     * @returns {boolean} True when interval was cleared, false when none was set (no effect)
     */

  }, {
    key: 'clearInterval',
    value: function (_clearInterval) {
      function clearInterval() {
        return _clearInterval.apply(this, arguments);
      }

      clearInterval.toString = function () {
        return _clearInterval.toString();
      };

      return clearInterval;
    }(function () {
      if (this._tickInterval) {
        clearInterval(this._tickInterval);
        this._tickInterval = null;
        return true;
      }
      return false;
    })

    /**
     * @returns {boolean} True when timeout was cleared, false when none was set (no effect)
     */

  }, {
    key: 'clearNextTick',
    value: function clearNextTick() {
      if (this._tickTimer) {
        clearTimeout(this._tickTimer);
        this._tickTimer = null;
        return true;
      }
      return false;
    }

    /**
     * Will call the subclass doTick implementation in this main loop tick
     * or in the next one (via setTimeout(,0)) in case it has already been called
     * in this tick (in case this is a re-entrant call).
     */

  }, {
    key: 'tick',
    value: function tick() {
      this._tickCallCount++;
      if (this._tickCallCount === 1) {
        this.doTick();
        // re-entrant call to tick from previous doTick call stack
        // -> schedule a call on the next main loop iteration to process this task processing request
        if (this._tickCallCount > 1) {
          // make sure only one timer exists at any time at max
          this.clearNextTick();
          this._tickTimer = setTimeout(this._boundTick, 0);
        }
        this._tickCallCount = 0;
      }
    }

    /**
     * For subclass to implement task logic
     * @abstract
     */

  }, {
    key: 'doTick',
    value: function doTick() {}
  }]);

  return TaskLoop;
}(_eventHandler2.default);

exports.default = TaskLoop;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/attr-list.js":
/*!***************************************!*\
  !*** ./src/hls.js/utils/attr-list.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/; // eslint-disable-line no-useless-escape
var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g; // eslint-disable-line no-useless-escape

// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js

var AttrList = function () {
  function AttrList(attrs) {
    _classCallCheck(this, AttrList);

    if (typeof attrs === 'string') {
      attrs = AttrList.parseAttrList(attrs);
    }

    for (var attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        this[attr] = attrs[attr];
      }
    }
  }

  _createClass(AttrList, [{
    key: 'decimalInteger',
    value: function decimalInteger(attrName) {
      var intValue = parseInt(this[attrName], 10);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }

      return intValue;
    }
  }, {
    key: 'hexadecimalInteger',
    value: function hexadecimalInteger(attrName) {
      if (this[attrName]) {
        var stringValue = (this[attrName] || '0x').slice(2);
        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;

        var value = new Uint8Array(stringValue.length / 2);
        for (var i = 0; i < stringValue.length / 2; i++) {
          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
        }

        return value;
      } else {
        return null;
      }
    }
  }, {
    key: 'hexadecimalIntegerAsNumber',
    value: function hexadecimalIntegerAsNumber(attrName) {
      var intValue = parseInt(this[attrName], 16);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }

      return intValue;
    }
  }, {
    key: 'decimalFloatingPoint',
    value: function decimalFloatingPoint(attrName) {
      return parseFloat(this[attrName]);
    }
  }, {
    key: 'enumeratedString',
    value: function enumeratedString(attrName) {
      return this[attrName];
    }
  }, {
    key: 'decimalResolution',
    value: function decimalResolution(attrName) {
      var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
      if (res === null) {
        return undefined;
      }

      return {
        width: parseInt(res[1], 10),
        height: parseInt(res[2], 10)
      };
    }
  }], [{
    key: 'parseAttrList',
    value: function parseAttrList(input) {
      var match = void 0,
          attrs = {};
      ATTR_LIST_REGEX.lastIndex = 0;
      while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
        var value = match[2],
            quote = '"';

        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
          value = value.slice(1, -1);
        }

        attrs[match[1]] = value;
      }
      return attrs;
    }
  }]);

  return AttrList;
}();

exports.default = AttrList;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/binary-search.js":
/*!*******************************************!*\
  !*** ./src/hls.js/utils/binary-search.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var BinarySearch = {
  /**
     * Searches for an item in an array which matches a certain condition.
     * This requires the condition to only match one item in the array,
     * and for the array to be ordered.
     *
     * @param {Array} list The array to search.
     * @param {Function} comparisonFunction
     *      Called and provided a candidate item as the first argument.
     *      Should return:
     *          > -1 if the item should be located at a lower index than the provided item.
     *          > 1 if the item should be located at a higher index than the provided item.
     *          > 0 if the item is the item you're looking for.
     *
     * @return {*} The object if it is found or null otherwise.
     */
  search: function search(list, comparisonFunction) {
    var minIndex = 0;
    var maxIndex = list.length - 1;
    var currentIndex = null;
    var currentElement = null;

    while (minIndex <= maxIndex) {
      currentIndex = (minIndex + maxIndex) / 2 | 0;
      currentElement = list[currentIndex];

      var comparisonResult = comparisonFunction(currentElement);
      if (comparisonResult > 0) {
        minIndex = currentIndex + 1;
      } else if (comparisonResult < 0) {
        maxIndex = currentIndex - 1;
      } else {
        return currentElement;
      }
    }

    return null;
  }
};

exports.default = BinarySearch;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/utils/buffer-helper.js":
/*!*******************************************!*\
  !*** ./src/hls.js/utils/buffer-helper.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module BufferHelper
 *
 * Providing methods dealing with buffer length retrieval for example.
 *
 * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.
 *
 * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered
*/

var BufferHelper = exports.BufferHelper = function () {
  function BufferHelper() {
    _classCallCheck(this, BufferHelper);
  }

  _createClass(BufferHelper, null, [{
    key: "isBuffered",

    /**
     * Return true if `media`'s buffered include `position`
     * @param {HTMLMediaElement|SourceBuffer} media
     * @param {number} position
     * @returns {boolean}
     */
    value: function isBuffered(media, position) {
      try {
        if (media) {
          var buffered = media.buffered;
          for (var i = 0; i < buffered.length; i++) {
            if (position >= buffered.start(i) && position <= buffered.end(i)) {
              return true;
            }
          }
        }
      } catch (error) {
        // this is to catch
        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
        // This SourceBuffer has been removed from the parent media source
      }
      return false;
    }
  }, {
    key: "bufferInfo",
    value: function bufferInfo(media, pos, maxHoleDuration) {
      try {
        if (media) {
          var vbuffered = media.buffered,
              buffered = [],
              i = void 0;
          for (i = 0; i < vbuffered.length; i++) {
            buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
          }

          return this.bufferedInfo(buffered, pos, maxHoleDuration);
        }
      } catch (error) {
        // this is to catch
        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
        // This SourceBuffer has been removed from the parent media source
      }
      return { len: 0, start: pos, end: pos, nextStart: undefined };
    }
  }, {
    key: "bufferedInfo",
    value: function bufferedInfo(buffered, pos, maxHoleDuration) {
      var buffered2 = [],

      // bufferStart and bufferEnd are buffer boundaries around current video position
      bufferLen = void 0,
          bufferStart = void 0,
          bufferEnd = void 0,
          bufferStartNext = void 0,
          i = void 0;
      // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
      buffered.sort(function (a, b) {
        var diff = a.start - b.start;
        if (diff) {
          return diff;
        } else {
          return b.end - a.end;
        }
      });
      // there might be some small holes between buffer time range
      // consider that holes smaller than maxHoleDuration are irrelevant and build another
      // buffer time range representations that discards those holes
      for (i = 0; i < buffered.length; i++) {
        var buf2len = buffered2.length;
        if (buf2len) {
          var buf2end = buffered2[buf2len - 1].end;
          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
          if (buffered[i].start - buf2end < maxHoleDuration) {
            // merge overlapping time ranges
            // update lastRange.end only if smaller than item.end
            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
            if (buffered[i].end > buf2end) {
              buffered2[buf2len - 1].end = buffered[i].end;
            }
          } else {
            // big hole
            buffered2.push(buffered[i]);
          }
        } else {
          // first value
          buffered2.push(buffered[i]);
        }
      }
      for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
        var start = buffered2[i].start,
            end = buffered2[i].end;
        // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
        if (pos + maxHoleDuration >= start && pos < end) {
          // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
          bufferStart = start;
          bufferEnd = end;
          bufferLen = bufferEnd - pos;
        } else if (pos + maxHoleDuration < start) {
          bufferStartNext = start;
          break;
        }
      }
      return { len: bufferLen, start: bufferStart, end: bufferEnd, nextStart: bufferStartNext };
    }
  }]);

  return BufferHelper;
}();

/***/ }),

/***/ "./src/hls.js/utils/cea-608-parser.js":
/*!********************************************!*\
  !*** ./src/hls.js/utils/cea-608-parser.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * This code was ported from the dash.js project at:
 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
 *
 * The original copyright appears below:
 *
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2015-2016, DASH Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  2. Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
     *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
     */

var specialCea608CharsCodes = {
  0x2a: 0xe1, // lowercase a, acute accent
  0x5c: 0xe9, // lowercase e, acute accent
  0x5e: 0xed, // lowercase i, acute accent
  0x5f: 0xf3, // lowercase o, acute accent
  0x60: 0xfa, // lowercase u, acute accent
  0x7b: 0xe7, // lowercase c with cedilla
  0x7c: 0xf7, // division symbol
  0x7d: 0xd1, // uppercase N tilde
  0x7e: 0xf1, // lowercase n tilde
  0x7f: 0x2588, // Full block
  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
  // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
  0x80: 0xae, // Registered symbol (R)
  0x81: 0xb0, // degree sign
  0x82: 0xbd, // 1/2 symbol
  0x83: 0xbf, // Inverted (open) question mark
  0x84: 0x2122, // Trademark symbol (TM)
  0x85: 0xa2, // Cents symbol
  0x86: 0xa3, // Pounds sterling
  0x87: 0x266a, // Music 8'th note
  0x88: 0xe0, // lowercase a, grave accent
  0x89: 0x20, // transparent space (regular)
  0x8a: 0xe8, // lowercase e, grave accent
  0x8b: 0xe2, // lowercase a, circumflex accent
  0x8c: 0xea, // lowercase e, circumflex accent
  0x8d: 0xee, // lowercase i, circumflex accent
  0x8e: 0xf4, // lowercase o, circumflex accent
  0x8f: 0xfb, // lowercase u, circumflex accent
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
  0x90: 0xc1, // capital letter A with acute
  0x91: 0xc9, // capital letter E with acute
  0x92: 0xd3, // capital letter O with acute
  0x93: 0xda, // capital letter U with acute
  0x94: 0xdc, // capital letter U with diaresis
  0x95: 0xfc, // lowercase letter U with diaeresis
  0x96: 0x2018, // opening single quote
  0x97: 0xa1, // inverted exclamation mark
  0x98: 0x2a, // asterisk
  0x99: 0x2019, // closing single quote
  0x9a: 0x2501, // box drawings heavy horizontal
  0x9b: 0xa9, // copyright sign
  0x9c: 0x2120, // Service mark
  0x9d: 0x2022, // (round) bullet
  0x9e: 0x201c, // Left double quotation mark
  0x9f: 0x201d, // Right double quotation mark
  0xa0: 0xc0, // uppercase A, grave accent
  0xa1: 0xc2, // uppercase A, circumflex
  0xa2: 0xc7, // uppercase C with cedilla
  0xa3: 0xc8, // uppercase E, grave accent
  0xa4: 0xca, // uppercase E, circumflex
  0xa5: 0xcb, // capital letter E with diaresis
  0xa6: 0xeb, // lowercase letter e with diaresis
  0xa7: 0xce, // uppercase I, circumflex
  0xa8: 0xcf, // uppercase I, with diaresis
  0xa9: 0xef, // lowercase i, with diaresis
  0xaa: 0xd4, // uppercase O, circumflex
  0xab: 0xd9, // uppercase U, grave accent
  0xac: 0xf9, // lowercase u, grave accent
  0xad: 0xdb, // uppercase U, circumflex
  0xae: 0xab, // left-pointing double angle quotation mark
  0xaf: 0xbb, // right-pointing double angle quotation mark
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
  0xb0: 0xc3, // Uppercase A, tilde
  0xb1: 0xe3, // Lowercase a, tilde
  0xb2: 0xcd, // Uppercase I, acute accent
  0xb3: 0xcc, // Uppercase I, grave accent
  0xb4: 0xec, // Lowercase i, grave accent
  0xb5: 0xd2, // Uppercase O, grave accent
  0xb6: 0xf2, // Lowercase o, grave accent
  0xb7: 0xd5, // Uppercase O, tilde
  0xb8: 0xf5, // Lowercase o, tilde
  0xb9: 0x7b, // Open curly brace
  0xba: 0x7d, // Closing curly brace
  0xbb: 0x5c, // Backslash
  0xbc: 0x5e, // Caret
  0xbd: 0x5f, // Underscore
  0xbe: 0x7c, // Pipe (vertical line)
  0xbf: 0x223c, // Tilde operator
  0xc0: 0xc4, // Uppercase A, umlaut
  0xc1: 0xe4, // Lowercase A, umlaut
  0xc2: 0xd6, // Uppercase O, umlaut
  0xc3: 0xf6, // Lowercase o, umlaut
  0xc4: 0xdf, // Esszett (sharp S)
  0xc5: 0xa5, // Yen symbol
  0xc6: 0xa4, // Generic currency sign
  0xc7: 0x2503, // Box drawings heavy vertical
  0xc8: 0xc5, // Uppercase A, ring
  0xc9: 0xe5, // Lowercase A, ring
  0xca: 0xd8, // Uppercase O, stroke
  0xcb: 0xf8, // Lowercase o, strok
  0xcc: 0x250f, // Box drawings heavy down and right
  0xcd: 0x2513, // Box drawings heavy down and left
  0xce: 0x2517, // Box drawings heavy up and right
  0xcf: 0x251b // Box drawings heavy up and left
};

/**
 * Utils
 */
var getCharForByte = function getCharForByte(byte) {
  var charCode = byte;
  if (specialCea608CharsCodes.hasOwnProperty(byte)) {
    charCode = specialCea608CharsCodes[byte];
  }

  return String.fromCharCode(charCode);
};

var NR_ROWS = 15,
    NR_COLS = 100;
// Tables to look up row from PAC data
var rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };
var rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };
var rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };
var rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };

var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];

/**
 * Simple logger class to be able to write with time-stamps and filter on level.
 */
var logger = {
  verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },
  time: null,
  verboseLevel: 0, // Only write errors
  setTime: function setTime(newTime) {
    this.time = newTime;
  },
  log: function log(severity, msg) {
    var minLevel = this.verboseFilter[severity];
    if (this.verboseLevel >= minLevel) {
      // console.log(this.time + ' [' + severity + '] ' + msg);
    }
  }
};

var numArrayToHexArray = function numArrayToHexArray(numArray) {
  var hexArray = [];
  for (var j = 0; j < numArray.length; j++) {
    hexArray.push(numArray[j].toString(16));
  }

  return hexArray;
};

var PenState = function () {
  function PenState(foreground, underline, italics, background, flash) {
    _classCallCheck(this, PenState);

    this.foreground = foreground || 'white';
    this.underline = underline || false;
    this.italics = italics || false;
    this.background = background || 'black';
    this.flash = flash || false;
  }

  _createClass(PenState, [{
    key: 'reset',
    value: function reset() {
      this.foreground = 'white';
      this.underline = false;
      this.italics = false;
      this.background = 'black';
      this.flash = false;
    }
  }, {
    key: 'setStyles',
    value: function setStyles(styles) {
      var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
      for (var i = 0; i < attribs.length; i++) {
        var style = attribs[i];
        if (styles.hasOwnProperty(style)) {
          this[style] = styles[style];
        }
      }
    }
  }, {
    key: 'isDefault',
    value: function isDefault() {
      return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;
    }
  }, {
    key: 'equals',
    value: function equals(other) {
      return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
    }
  }, {
    key: 'copy',
    value: function copy(newPenState) {
      this.foreground = newPenState.foreground;
      this.underline = newPenState.underline;
      this.italics = newPenState.italics;
      this.background = newPenState.background;
      this.flash = newPenState.flash;
    }
  }, {
    key: 'toString',
    value: function toString() {
      return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;
    }
  }]);

  return PenState;
}();

/**
 * Unicode character with styling and background.
 * @constructor
 */


var StyledUnicodeChar = function () {
  function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
    _classCallCheck(this, StyledUnicodeChar);

    this.uchar = uchar || ' '; // unicode character
    this.penState = new PenState(foreground, underline, italics, background, flash);
  }

  _createClass(StyledUnicodeChar, [{
    key: 'reset',
    value: function reset() {
      this.uchar = ' ';
      this.penState.reset();
    }
  }, {
    key: 'setChar',
    value: function setChar(uchar, newPenState) {
      this.uchar = uchar;
      this.penState.copy(newPenState);
    }
  }, {
    key: 'setPenState',
    value: function setPenState(newPenState) {
      this.penState.copy(newPenState);
    }
  }, {
    key: 'equals',
    value: function equals(other) {
      return this.uchar === other.uchar && this.penState.equals(other.penState);
    }
  }, {
    key: 'copy',
    value: function copy(newChar) {
      this.uchar = newChar.uchar;
      this.penState.copy(newChar.penState);
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      return this.uchar === ' ' && this.penState.isDefault();
    }
  }]);

  return StyledUnicodeChar;
}();

/**
 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
 * @constructor
 */


var Row = function () {
  function Row() {
    _classCallCheck(this, Row);

    this.chars = [];
    for (var i = 0; i < NR_COLS; i++) {
      this.chars.push(new StyledUnicodeChar());
    }

    this.pos = 0;
    this.currPenState = new PenState();
  }

  _createClass(Row, [{
    key: 'equals',
    value: function equals(other) {
      var equal = true;
      for (var i = 0; i < NR_COLS; i++) {
        if (!this.chars[i].equals(other.chars[i])) {
          equal = false;
          break;
        }
      }
      return equal;
    }
  }, {
    key: 'copy',
    value: function copy(other) {
      for (var i = 0; i < NR_COLS; i++) {
        this.chars[i].copy(other.chars[i]);
      }
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      var empty = true;
      for (var i = 0; i < NR_COLS; i++) {
        if (!this.chars[i].isEmpty()) {
          empty = false;
          break;
        }
      }
      return empty;
    }

    /**
       *  Set the cursor to a valid column.
       */

  }, {
    key: 'setCursor',
    value: function setCursor(absPos) {
      if (this.pos !== absPos) {
        this.pos = absPos;
      }

      if (this.pos < 0) {
        logger.log('ERROR', 'Negative cursor position ' + this.pos);
        this.pos = 0;
      } else if (this.pos > NR_COLS) {
        logger.log('ERROR', 'Too large cursor position ' + this.pos);
        this.pos = NR_COLS;
      }
    }

    /**
       * Move the cursor relative to current position.
       */

  }, {
    key: 'moveCursor',
    value: function moveCursor(relPos) {
      var newPos = this.pos + relPos;
      if (relPos > 1) {
        for (var i = this.pos + 1; i < newPos + 1; i++) {
          this.chars[i].setPenState(this.currPenState);
        }
      }
      this.setCursor(newPos);
    }

    /**
       * Backspace, move one step back and clear character.
       */

  }, {
    key: 'backSpace',
    value: function backSpace() {
      this.moveCursor(-1);
      this.chars[this.pos].setChar(' ', this.currPenState);
    }
  }, {
    key: 'insertChar',
    value: function insertChar(byte) {
      if (byte >= 0x90) {
        // Extended char
        this.backSpace();
      }
      var char = getCharForByte(byte);
      if (this.pos >= NR_COLS) {
        logger.log('ERROR', 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');
        return;
      }
      this.chars[this.pos].setChar(char, this.currPenState);
      this.moveCursor(1);
    }
  }, {
    key: 'clearFromPos',
    value: function clearFromPos(startPos) {
      var i = void 0;
      for (i = startPos; i < NR_COLS; i++) {
        this.chars[i].reset();
      }
    }
  }, {
    key: 'clear',
    value: function clear() {
      this.clearFromPos(0);
      this.pos = 0;
      this.currPenState.reset();
    }
  }, {
    key: 'clearToEndOfRow',
    value: function clearToEndOfRow() {
      this.clearFromPos(this.pos);
    }
  }, {
    key: 'getTextString',
    value: function getTextString() {
      var chars = [];
      var empty = true;
      for (var i = 0; i < NR_COLS; i++) {
        var char = this.chars[i].uchar;
        if (char !== ' ') {
          empty = false;
        }

        chars.push(char);
      }
      if (empty) {
        return '';
      } else {
        return chars.join('');
      }
    }
  }, {
    key: 'setPenStyles',
    value: function setPenStyles(styles) {
      this.currPenState.setStyles(styles);
      var currChar = this.chars[this.pos];
      currChar.setPenState(this.currPenState);
    }
  }]);

  return Row;
}();

/**
 * Keep a CEA-608 screen of 32x15 styled characters
 * @constructor
*/


var CaptionScreen = function () {
  function CaptionScreen() {
    _classCallCheck(this, CaptionScreen);

    this.rows = [];
    for (var i = 0; i < NR_ROWS; i++) {
      this.rows.push(new Row());
    } // Note that we use zero-based numbering (0-14)

    this.currRow = NR_ROWS - 1;
    this.nrRollUpRows = null;
    this.reset();
  }

  _createClass(CaptionScreen, [{
    key: 'reset',
    value: function reset() {
      for (var i = 0; i < NR_ROWS; i++) {
        this.rows[i].clear();
      }

      this.currRow = NR_ROWS - 1;
    }
  }, {
    key: 'equals',
    value: function equals(other) {
      var equal = true;
      for (var i = 0; i < NR_ROWS; i++) {
        if (!this.rows[i].equals(other.rows[i])) {
          equal = false;
          break;
        }
      }
      return equal;
    }
  }, {
    key: 'copy',
    value: function copy(other) {
      for (var i = 0; i < NR_ROWS; i++) {
        this.rows[i].copy(other.rows[i]);
      }
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      var empty = true;
      for (var i = 0; i < NR_ROWS; i++) {
        if (!this.rows[i].isEmpty()) {
          empty = false;
          break;
        }
      }
      return empty;
    }
  }, {
    key: 'backSpace',
    value: function backSpace() {
      var row = this.rows[this.currRow];
      row.backSpace();
    }
  }, {
    key: 'clearToEndOfRow',
    value: function clearToEndOfRow() {
      var row = this.rows[this.currRow];
      row.clearToEndOfRow();
    }

    /**
       * Insert a character (without styling) in the current row.
       */

  }, {
    key: 'insertChar',
    value: function insertChar(char) {
      var row = this.rows[this.currRow];
      row.insertChar(char);
    }
  }, {
    key: 'setPen',
    value: function setPen(styles) {
      var row = this.rows[this.currRow];
      row.setPenStyles(styles);
    }
  }, {
    key: 'moveCursor',
    value: function moveCursor(relPos) {
      var row = this.rows[this.currRow];
      row.moveCursor(relPos);
    }
  }, {
    key: 'setCursor',
    value: function setCursor(absPos) {
      logger.log('INFO', 'setCursor: ' + absPos);
      var row = this.rows[this.currRow];
      row.setCursor(absPos);
    }
  }, {
    key: 'setPAC',
    value: function setPAC(pacData) {
      logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
      var newRow = pacData.row - 1;
      if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
        newRow = this.nrRollUpRows - 1;
      }

      // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows
      if (this.nrRollUpRows && this.currRow !== newRow) {
        // clear all rows first
        for (var i = 0; i < NR_ROWS; i++) {
          this.rows[i].clear();
        }

        // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
        // topRowIndex - the start of rows to copy (inclusive index)
        var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
        // We only copy if the last position was already shown.
        // We use the cueStartTime value to check this.
        var lastOutputScreen = this.lastOutputScreen;
        if (lastOutputScreen) {
          var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
          if (prevLineTime && prevLineTime < logger.time) {
            for (var _i = 0; _i < this.nrRollUpRows; _i++) {
              this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);
            }
          }
        }
      }

      this.currRow = newRow;
      var row = this.rows[this.currRow];
      if (pacData.indent !== null) {
        var indent = pacData.indent;
        var prevPos = Math.max(indent - 1, 0);
        row.setCursor(pacData.indent);
        pacData.color = row.chars[prevPos].penState.foreground;
      }
      var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };
      this.setPen(styles);
    }

    /**
       * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
       */

  }, {
    key: 'setBkgData',
    value: function setBkgData(bkgData) {
      logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
      this.backSpace();
      this.setPen(bkgData);
      this.insertChar(0x20); // Space
    }
  }, {
    key: 'setRollUpRows',
    value: function setRollUpRows(nrRows) {
      this.nrRollUpRows = nrRows;
    }
  }, {
    key: 'rollUp',
    value: function rollUp() {
      if (this.nrRollUpRows === null) {
        logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
        return; // Not properly setup
      }
      logger.log('TEXT', this.getDisplayText());
      var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
      var topRow = this.rows.splice(topRowIndex, 1)[0];
      topRow.clear();
      this.rows.splice(this.currRow, 0, topRow);
      logger.log('INFO', 'Rolling up');
      // logger.log('TEXT', this.get_display_text())
    }

    /**
      * Get all non-empty rows with as unicode text.
      */

  }, {
    key: 'getDisplayText',
    value: function getDisplayText(asOneRow) {
      asOneRow = asOneRow || false;
      var displayText = [];
      var text = '';
      var rowNr = -1;
      for (var i = 0; i < NR_ROWS; i++) {
        var rowText = this.rows[i].getTextString();
        if (rowText) {
          rowNr = i + 1;
          if (asOneRow) {
            displayText.push('Row ' + rowNr + ': \'' + rowText + '\'');
          } else {
            displayText.push(rowText.trim());
          }
        }
      }
      if (displayText.length > 0) {
        if (asOneRow) {
          text = '[' + displayText.join(' | ') + ']';
        } else {
          text = displayText.join('\n');
        }
      }
      return text;
    }
  }, {
    key: 'getTextAndFormat',
    value: function getTextAndFormat() {
      return this.rows;
    }
  }]);

  return CaptionScreen;
}();

// var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];

var Cea608Channel = function () {
  function Cea608Channel(channelNumber, outputFilter) {
    _classCallCheck(this, Cea608Channel);

    this.chNr = channelNumber;
    this.outputFilter = outputFilter;
    this.mode = null;
    this.verbose = 0;
    this.displayedMemory = new CaptionScreen();
    this.nonDisplayedMemory = new CaptionScreen();
    this.lastOutputScreen = new CaptionScreen();
    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
    this.writeScreen = this.displayedMemory;
    this.mode = null;
    this.cueStartTime = null; // Keeps track of where a cue started.
  }

  _createClass(Cea608Channel, [{
    key: 'reset',
    value: function reset() {
      this.mode = null;
      this.displayedMemory.reset();
      this.nonDisplayedMemory.reset();
      this.lastOutputScreen.reset();
      this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
      this.writeScreen = this.displayedMemory;
      this.mode = null;
      this.cueStartTime = null;
      this.lastCueEndTime = null;
    }
  }, {
    key: 'getHandler',
    value: function getHandler() {
      return this.outputFilter;
    }
  }, {
    key: 'setHandler',
    value: function setHandler(newHandler) {
      this.outputFilter = newHandler;
    }
  }, {
    key: 'setPAC',
    value: function setPAC(pacData) {
      this.writeScreen.setPAC(pacData);
    }
  }, {
    key: 'setBkgData',
    value: function setBkgData(bkgData) {
      this.writeScreen.setBkgData(bkgData);
    }
  }, {
    key: 'setMode',
    value: function setMode(newMode) {
      if (newMode === this.mode) {
        return;
      }

      this.mode = newMode;
      logger.log('INFO', 'MODE=' + newMode);
      if (this.mode === 'MODE_POP-ON') {
        this.writeScreen = this.nonDisplayedMemory;
      } else {
        this.writeScreen = this.displayedMemory;
        this.writeScreen.reset();
      }
      if (this.mode !== 'MODE_ROLL-UP') {
        this.displayedMemory.nrRollUpRows = null;
        this.nonDisplayedMemory.nrRollUpRows = null;
      }
      this.mode = newMode;
    }
  }, {
    key: 'insertChars',
    value: function insertChars(chars) {
      for (var i = 0; i < chars.length; i++) {
        this.writeScreen.insertChar(chars[i]);
      }

      var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
      logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));
      if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
        logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
        this.outputDataUpdate();
      }
    }
  }, {
    key: 'ccRCL',
    value: function ccRCL() {
      // Resume Caption Loading (switch mode to Pop On)
      logger.log('INFO', 'RCL - Resume Caption Loading');
      this.setMode('MODE_POP-ON');
    }
  }, {
    key: 'ccBS',
    value: function ccBS() {
      // BackSpace
      logger.log('INFO', 'BS - BackSpace');
      if (this.mode === 'MODE_TEXT') {
        return;
      }

      this.writeScreen.backSpace();
      if (this.writeScreen === this.displayedMemory) {
        this.outputDataUpdate();
      }
    }
  }, {
    key: 'ccAOF',
    value: function ccAOF() {// Reserved (formerly Alarm Off)

    }
  }, {
    key: 'ccAON',
    value: function ccAON() {// Reserved (formerly Alarm On)

    }
  }, {
    key: 'ccDER',
    value: function ccDER() {
      // Delete to End of Row
      logger.log('INFO', 'DER- Delete to End of Row');
      this.writeScreen.clearToEndOfRow();
      this.outputDataUpdate();
    }
  }, {
    key: 'ccRU',
    value: function ccRU(nrRows) {
      // Roll-Up Captions-2,3,or 4 Rows
      logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
      this.writeScreen = this.displayedMemory;
      this.setMode('MODE_ROLL-UP');
      this.writeScreen.setRollUpRows(nrRows);
    }
  }, {
    key: 'ccFON',
    value: function ccFON() {
      // Flash On
      logger.log('INFO', 'FON - Flash On');
      this.writeScreen.setPen({ flash: true });
    }
  }, {
    key: 'ccRDC',
    value: function ccRDC() {
      // Resume Direct Captioning (switch mode to PaintOn)
      logger.log('INFO', 'RDC - Resume Direct Captioning');
      this.setMode('MODE_PAINT-ON');
    }
  }, {
    key: 'ccTR',
    value: function ccTR() {
      // Text Restart in text mode (not supported, however)
      logger.log('INFO', 'TR');
      this.setMode('MODE_TEXT');
    }
  }, {
    key: 'ccRTD',
    value: function ccRTD() {
      // Resume Text Display in Text mode (not supported, however)
      logger.log('INFO', 'RTD');
      this.setMode('MODE_TEXT');
    }
  }, {
    key: 'ccEDM',
    value: function ccEDM() {
      // Erase Displayed Memory
      logger.log('INFO', 'EDM - Erase Displayed Memory');
      this.displayedMemory.reset();
      this.outputDataUpdate(true);
    }
  }, {
    key: 'ccCR',
    value: function ccCR() {
      // Carriage Return
      logger.log('CR - Carriage Return');
      this.writeScreen.rollUp();
      this.outputDataUpdate(true);
    }
  }, {
    key: 'ccENM',
    value: function ccENM() {
      // Erase Non-Displayed Memory
      logger.log('INFO', 'ENM - Erase Non-displayed Memory');
      this.nonDisplayedMemory.reset();
    }
  }, {
    key: 'ccEOC',
    value: function ccEOC() {
      // End of Caption (Flip Memories)
      logger.log('INFO', 'EOC - End Of Caption');
      if (this.mode === 'MODE_POP-ON') {
        var tmp = this.displayedMemory;
        this.displayedMemory = this.nonDisplayedMemory;
        this.nonDisplayedMemory = tmp;
        this.writeScreen = this.nonDisplayedMemory;
        logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());
      }
      this.outputDataUpdate(true);
    }
  }, {
    key: 'ccTO',
    value: function ccTO(nrCols) {
      // Tab Offset 1,2, or 3 columns
      logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
      this.writeScreen.moveCursor(nrCols);
    }
  }, {
    key: 'ccMIDROW',
    value: function ccMIDROW(secondByte) {
      // Parse MIDROW command
      var styles = { flash: false };
      styles.underline = secondByte % 2 === 1;
      styles.italics = secondByte >= 0x2e;
      if (!styles.italics) {
        var colorIndex = Math.floor(secondByte / 2) - 0x10;
        var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
        styles.foreground = colors[colorIndex];
      } else {
        styles.foreground = 'white';
      }
      logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
      this.writeScreen.setPen(styles);
    }
  }, {
    key: 'outputDataUpdate',
    value: function outputDataUpdate() {
      var dispatch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var t = logger.time;
      if (t === null) {
        return;
      }

      if (this.outputFilter) {
        if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
          // Start of a new cue
          this.cueStartTime = t;
        } else {
          if (!this.displayedMemory.equals(this.lastOutputScreen)) {
            if (this.outputFilter.newCue) {
              this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);
              if (dispatch === true && this.outputFilter.dispatchCue) {
                this.outputFilter.dispatchCue();
              }
            }
            this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;
          }
        }
        this.lastOutputScreen.copy(this.displayedMemory);
      }
    }
  }, {
    key: 'cueSplitAtTime',
    value: function cueSplitAtTime(t) {
      if (this.outputFilter) {
        if (!this.displayedMemory.isEmpty()) {
          if (this.outputFilter.newCue) {
            this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
          }

          this.cueStartTime = t;
        }
      }
    }
  }]);

  return Cea608Channel;
}();

var Cea608Parser = function () {
  function Cea608Parser(field, out1, out2) {
    _classCallCheck(this, Cea608Parser);

    this.field = field || 1;
    this.outputs = [out1, out2];
    this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];
    this.currChNr = -1; // Will be 1 or 2
    this.lastCmdA = null; // First byte of last command
    this.lastCmdB = null; // Second byte of last command
    this.bufferedData = [];
    this.startTime = null;
    this.lastTime = null;
    this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };
  }

  _createClass(Cea608Parser, [{
    key: 'getHandler',
    value: function getHandler(index) {
      return this.channels[index].getHandler();
    }
  }, {
    key: 'setHandler',
    value: function setHandler(index, newHandler) {
      this.channels[index].setHandler(newHandler);
    }

    /**
       * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
       */

  }, {
    key: 'addData',
    value: function addData(t, byteList) {
      var cmdFound = void 0,
          a = void 0,
          b = void 0,
          charsFound = false;

      this.lastTime = t;
      logger.setTime(t);

      for (var i = 0; i < byteList.length; i += 2) {
        a = byteList[i] & 0x7f;
        b = byteList[i + 1] & 0x7f;
        if (a === 0 && b === 0) {
          this.dataCounters.padding += 2;
          continue;
        } else {
          logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
        }
        cmdFound = this.parseCmd(a, b);
        if (!cmdFound) {
          cmdFound = this.parseMidrow(a, b);
        }

        if (!cmdFound) {
          cmdFound = this.parsePAC(a, b);
        }

        if (!cmdFound) {
          cmdFound = this.parseBackgroundAttributes(a, b);
        }

        if (!cmdFound) {
          charsFound = this.parseChars(a, b);
          if (charsFound) {
            if (this.currChNr && this.currChNr >= 0) {
              var channel = this.channels[this.currChNr - 1];
              channel.insertChars(charsFound);
            } else {
              logger.log('WARNING', 'No channel found yet. TEXT-MODE?');
            }
          }
        }
        if (cmdFound) {
          this.dataCounters.cmd += 2;
        } else if (charsFound) {
          this.dataCounters.char += 2;
        } else {
          this.dataCounters.other += 2;
          logger.log('WARNING', 'Couldn\'t parse cleaned data ' + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
        }
      }
    }

    /**
       * Parse Command.
       * @returns {Boolean} Tells if a command was found
       */

  }, {
    key: 'parseCmd',
    value: function parseCmd(a, b) {
      var chNr = null;

      var cond1 = (a === 0x14 || a === 0x1C) && b >= 0x20 && b <= 0x2F;
      var cond2 = (a === 0x17 || a === 0x1F) && b >= 0x21 && b <= 0x23;
      if (!(cond1 || cond2)) {
        return false;
      }

      if (a === this.lastCmdA && b === this.lastCmdB) {
        this.lastCmdA = null;
        this.lastCmdB = null; // Repeated commands are dropped (once)
        logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
        return true;
      }

      if (a === 0x14 || a === 0x17) {
        chNr = 1;
      } else {
        chNr = 2;
      } // (a === 0x1C || a=== 0x1f)

      var channel = this.channels[chNr - 1];

      if (a === 0x14 || a === 0x1C) {
        if (b === 0x20) {
          channel.ccRCL();
        } else if (b === 0x21) {
          channel.ccBS();
        } else if (b === 0x22) {
          channel.ccAOF();
        } else if (b === 0x23) {
          channel.ccAON();
        } else if (b === 0x24) {
          channel.ccDER();
        } else if (b === 0x25) {
          channel.ccRU(2);
        } else if (b === 0x26) {
          channel.ccRU(3);
        } else if (b === 0x27) {
          channel.ccRU(4);
        } else if (b === 0x28) {
          channel.ccFON();
        } else if (b === 0x29) {
          channel.ccRDC();
        } else if (b === 0x2A) {
          channel.ccTR();
        } else if (b === 0x2B) {
          channel.ccRTD();
        } else if (b === 0x2C) {
          channel.ccEDM();
        } else if (b === 0x2D) {
          channel.ccCR();
        } else if (b === 0x2E) {
          channel.ccENM();
        } else if (b === 0x2F) {
          channel.ccEOC();
        }
      } else {
        // a == 0x17 || a == 0x1F
        channel.ccTO(b - 0x20);
      }
      this.lastCmdA = a;
      this.lastCmdB = b;
      this.currChNr = chNr;
      return true;
    }

    /**
       * Parse midrow styling command
       * @returns {Boolean}
       */

  }, {
    key: 'parseMidrow',
    value: function parseMidrow(a, b) {
      var chNr = null;

      if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {
        if (a === 0x11) {
          chNr = 1;
        } else {
          chNr = 2;
        }

        if (chNr !== this.currChNr) {
          logger.log('ERROR', 'Mismatch channel in midrow parsing');
          return false;
        }
        var channel = this.channels[chNr - 1];
        channel.ccMIDROW(b);
        logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
        return true;
      }
      return false;
    }
    /**
       * Parse Preable Access Codes (Table 53).
       * @returns {Boolean} Tells if PAC found
       */

  }, {
    key: 'parsePAC',
    value: function parsePAC(a, b) {
      var chNr = null;
      var row = null;

      var case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1F) && b >= 0x40 && b <= 0x7F;
      var case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5F;
      if (!(case1 || case2)) {
        return false;
      }

      if (a === this.lastCmdA && b === this.lastCmdB) {
        this.lastCmdA = null;
        this.lastCmdB = null;
        return true; // Repeated commands are dropped (once)
      }

      chNr = a <= 0x17 ? 1 : 2;

      if (b >= 0x40 && b <= 0x5F) {
        row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
      } else {
        // 0x60 <= b <= 0x7F
        row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
      }
      var pacData = this.interpretPAC(row, b);
      var channel = this.channels[chNr - 1];
      channel.setPAC(pacData);
      this.lastCmdA = a;
      this.lastCmdB = b;
      this.currChNr = chNr;
      return true;
    }

    /**
       * Interpret the second byte of the pac, and return the information.
       * @returns {Object} pacData with style parameters.
       */

  }, {
    key: 'interpretPAC',
    value: function interpretPAC(row, byte) {
      var pacIndex = byte;
      var pacData = { color: null, italics: false, indent: null, underline: false, row: row };

      if (byte > 0x5F) {
        pacIndex = byte - 0x60;
      } else {
        pacIndex = byte - 0x40;
      }

      pacData.underline = (pacIndex & 1) === 1;
      if (pacIndex <= 0xd) {
        pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
      } else if (pacIndex <= 0xf) {
        pacData.italics = true;
        pacData.color = 'white';
      } else {
        pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
      }
      return pacData; // Note that row has zero offset. The spec uses 1.
    }

    /**
       * Parse characters.
       * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
       */

  }, {
    key: 'parseChars',
    value: function parseChars(a, b) {
      var channelNr = null,
          charCodes = null,
          charCode1 = null;

      if (a >= 0x19) {
        channelNr = 2;
        charCode1 = a - 8;
      } else {
        channelNr = 1;
        charCode1 = a;
      }
      if (charCode1 >= 0x11 && charCode1 <= 0x13) {
        // Special character
        var oneCode = b;
        if (charCode1 === 0x11) {
          oneCode = b + 0x50;
        } else if (charCode1 === 0x12) {
          oneCode = b + 0x70;
        } else {
          oneCode = b + 0x90;
        }

        logger.log('INFO', 'Special char \'' + getCharForByte(oneCode) + '\' in channel ' + channelNr);
        charCodes = [oneCode];
      } else if (a >= 0x20 && a <= 0x7f) {
        charCodes = b === 0 ? [a] : [a, b];
      }
      if (charCodes) {
        var hexCodes = numArrayToHexArray(charCodes);
        logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
        this.lastCmdA = null;
        this.lastCmdB = null;
      }
      return charCodes;
    }

    /**
      * Parse extended background attributes as well as new foreground color black.
      * @returns{Boolean} Tells if background attributes are found
      */

  }, {
    key: 'parseBackgroundAttributes',
    value: function parseBackgroundAttributes(a, b) {
      var bkgData = void 0,
          index = void 0,
          chNr = void 0,
          channel = void 0;

      var case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;
      var case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;
      if (!(case1 || case2)) {
        return false;
      }

      bkgData = {};
      if (a === 0x10 || a === 0x18) {
        index = Math.floor((b - 0x20) / 2);
        bkgData.background = backgroundColors[index];
        if (b % 2 === 1) {
          bkgData.background = bkgData.background + '_semi';
        }
      } else if (b === 0x2d) {
        bkgData.background = 'transparent';
      } else {
        bkgData.foreground = 'black';
        if (b === 0x2f) {
          bkgData.underline = true;
        }
      }
      chNr = a < 0x18 ? 1 : 2;
      channel = this.channels[chNr - 1];
      channel.setBkgData(bkgData);
      this.lastCmdA = null;
      this.lastCmdB = null;
      return true;
    }

    /**
       * Reset state of parser and its channels.
       */

  }, {
    key: 'reset',
    value: function reset() {
      for (var i = 0; i < this.channels.length; i++) {
        if (this.channels[i]) {
          this.channels[i].reset();
        }
      }
      this.lastCmdA = null;
      this.lastCmdB = null;
    }

    /**
       * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
       */

  }, {
    key: 'cueSplitAtTime',
    value: function cueSplitAtTime(t) {
      for (var i = 0; i < this.channels.length; i++) {
        if (this.channels[i]) {
          this.channels[i].cueSplitAtTime(t);
        }
      }
    }
  }]);

  return Cea608Parser;
}();

exports.default = Cea608Parser;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/codecs.js":
/*!************************************!*\
  !*** ./src/hls.js/utils/codecs.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// from http://mp4ra.org/codecs.html
var sampleEntryCodesISO = {
  audio: {
    'a3ds': true,
    'ac-3': true,
    'ac-4': true,
    'alac': true,
    'alaw': true,
    'dra1': true,
    'dts+': true,
    'dts-': true,
    'dtsc': true,
    'dtse': true,
    'dtsh': true,
    'ec-3': true,
    'enca': true,
    'g719': true,
    'g726': true,
    'm4ae': true,
    'mha1': true,
    'mha2': true,
    'mhm1': true,
    'mhm2': true,
    'mlpa': true,
    'mp4a': true,
    'raw ': true,
    'Opus': true,
    'samr': true,
    'sawb': true,
    'sawp': true,
    'sevc': true,
    'sqcp': true,
    'ssmv': true,
    'twos': true,
    'ulaw': true
  },
  video: {
    'avc1': true,
    'avc2': true,
    'avc3': true,
    'avc4': true,
    'avcp': true,
    'drac': true,
    'dvav': true,
    'dvhe': true,
    'encv': true,
    'hev1': true,
    'hvc1': true,
    'mjp2': true,
    'mp4v': true,
    'mvc1': true,
    'mvc2': true,
    'mvc3': true,
    'mvc4': true,
    'resv': true,
    'rv60': true,
    's263': true,
    'svc1': true,
    'svc2': true,
    'vc-1': true,
    'vp08': true,
    'vp09': true
  }
};

function isCodecType(codec, type) {
  var typeCodes = sampleEntryCodesISO[type];
  return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;
}

function isCodecSupportedInMp4(codec, type) {
  return window.MediaSource.isTypeSupported((type || 'video') + '/mp4;codecs="' + codec + '"');
}

exports.isCodecType = isCodecType;
exports.isCodecSupportedInMp4 = isCodecSupportedInMp4;

/***/ }),

/***/ "./src/hls.js/utils/cues.js":
/*!**********************************!*\
  !*** ./src/hls.js/utils/cues.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.newCue = newCue;

var _vttparser = __webpack_require__(/*! ./vttparser */ "./src/hls.js/utils/vttparser.js");

function newCue(track, startTime, endTime, captionScreen) {
  var row = void 0;
  var cue = void 0;
  var indenting = void 0;
  var indent = void 0;
  var text = void 0;
  var VTTCue = window.VTTCue || window.TextTrackCue;

  for (var r = 0; r < captionScreen.rows.length; r++) {
    row = captionScreen.rows[r];
    indenting = true;
    indent = 0;
    text = '';

    if (!row.isEmpty()) {
      for (var c = 0; c < row.chars.length; c++) {
        if (row.chars[c].uchar.match(/\s/) && indenting) {
          indent++;
        } else {
          text += row.chars[c].uchar;
          indenting = false;
        }
      }
      // To be used for cleaning-up orphaned roll-up captions
      row.cueStartTime = startTime;

      // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
      if (startTime === endTime) {
        endTime += 0.0001;
      }

      cue = new VTTCue(startTime, endTime, (0, _vttparser.fixLineBreaks)(text.trim()));

      if (indent >= 16) {
        indent--;
      } else {
        indent++;
      }

      // VTTCue.line get's flakey when using controls, so let's now include line 13&14
      // also, drop line 1 since it's to close to the top
      if (navigator.userAgent.match(/Firefox\//)) {
        cue.line = r + 1;
      } else {
        cue.line = r > 7 ? r - 2 : r + 1;
      }

      cue.align = 'left';
      // Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break
      cue.position = Math.max(0, Math.min(100, 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0)));
      track.addCue(cue);
    }
  }
}

/***/ }),

/***/ "./src/hls.js/utils/discontinuities.js":
/*!*********************************************!*\
  !*** ./src/hls.js/utils/discontinuities.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findFirstFragWithCC = findFirstFragWithCC;
exports.findFragWithCC = findFragWithCC;
exports.shouldAlignOnDiscontinuities = shouldAlignOnDiscontinuities;
exports.findDiscontinuousReferenceFrag = findDiscontinuousReferenceFrag;
exports.adjustPts = adjustPts;
exports.alignStream = alignStream;
exports.alignDiscontinuities = alignDiscontinuities;
exports.alignPDT = alignPDT;

var _binarySearch = __webpack_require__(/*! ./binary-search */ "./src/hls.js/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function findFirstFragWithCC(fragments, cc) {
  var firstFrag = null;

  for (var i = 0; i < fragments.length; i += 1) {
    var currentFrag = fragments[i];
    if (currentFrag && currentFrag.cc === cc) {
      firstFrag = currentFrag;
      break;
    }
  }

  return firstFrag;
}

function findFragWithCC(fragments, CC) {
  return _binarySearch2.default.search(fragments, function (candidate) {
    if (candidate.cc < CC) {
      return 1;
    } else if (candidate.cc > CC) {
      return -1;
    } else {
      return 0;
    }
  });
}

function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {
  var shouldAlign = false;
  if (lastLevel && lastLevel.details && details) {
    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {
      shouldAlign = true;
    }
  }
  return shouldAlign;
}

// Find the first frag in the previous level which matches the CC of the first frag of the new level
function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
  var prevFrags = prevDetails.fragments;
  var curFrags = curDetails.fragments;

  if (!curFrags.length || !prevFrags.length) {
    _logger.logger.log('No fragments to align');
    return;
  }

  var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);

  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
    _logger.logger.log('No frag in previous level to align on');
    return;
  }

  return prevStartFrag;
}

function adjustPts(sliding, details) {
  details.fragments.forEach(function (frag) {
    if (frag) {
      var start = frag.start + sliding;
      frag.start = frag.startPTS = start;
      frag.endPTS = start + frag.duration;
    }
  });
  details.PTSKnown = true;
}

/**
 * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a
 * contiguous stream with the last fragments.
 * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to
 * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time
 * and an extra download.
 * @param lastFrag
 * @param lastLevel
 * @param details
 */
function alignStream(lastFrag, lastLevel, details) {
  alignDiscontinuities(lastFrag, details, lastLevel);
  if (!details.PTSKnown && lastLevel) {
    // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.
    // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same
    // discontinuity sequence.
    alignPDT(details, lastLevel.details);
  }
}

/**
 * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same
 * discontinuity sequence.
 * @param lastLevel - The details of the last loaded level
 * @param details - The details of the new level
 */
function alignDiscontinuities(lastFrag, details, lastLevel) {
  if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {
    var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);
    if (referenceFrag) {
      _logger.logger.log('Adjusting PTS using last level due to CC increase within current level');
      adjustPts(referenceFrag.start, details);
    }
  }
}

/**
 * Computes the PTS of a new level's fragments using the difference in Program Date Time from the last level.
 * @param details - The details of the new level
 * @param lastDetails - The details of the last loaded level
 */
function alignPDT(details, lastDetails) {
  if (lastDetails && lastDetails.fragments.length) {
    if (!details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {
      return;
    }
    // if last level sliding is 1000 and its first frag PROGRAM-DATE-TIME is 2017-08-20 1:10:00 AM
    // and if new details first frag PROGRAM DATE-TIME is 2017-08-20 1:10:08 AM
    // then we can deduce that playlist B sliding is 1000+8 = 1008s
    var lastPDT = lastDetails.fragments[0].programDateTime;
    var newPDT = details.fragments[0].programDateTime;
    // date diff is in ms. frag.start is in seconds
    var sliding = (newPDT - lastPDT) / 1000 + lastDetails.fragments[0].start;
    if (Number.isFinite(sliding)) {
      _logger.logger.log('adjusting PTS using programDateTime delta, sliding:' + sliding.toFixed(3));
      adjustPts(sliding, details);
    }
  }
}

/***/ }),

/***/ "./src/hls.js/utils/ewma-bandwidth-estimator.js":
/*!******************************************************!*\
  !*** ./src/hls.js/utils/ewma-bandwidth-estimator.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EWMA Bandwidth Estimator
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  - heavily inspired from shaka-player
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Tracks bandwidth samples and estimates available bandwidth.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Based on the minimum of two exponentially-weighted moving averages with
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * different half-lives.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _ewma = __webpack_require__(/*! ../utils/ewma */ "./src/hls.js/utils/ewma.js");

var _ewma2 = _interopRequireDefault(_ewma);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EwmaBandWidthEstimator = function () {
  function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
    _classCallCheck(this, EwmaBandWidthEstimator);

    this.hls = hls;
    this.defaultEstimate_ = defaultEstimate;
    this.minWeight_ = 0.001;
    this.minDelayMs_ = 50;
    this.slow_ = new _ewma2.default(slow);
    this.fast_ = new _ewma2.default(fast);
  }

  _createClass(EwmaBandWidthEstimator, [{
    key: 'sample',
    value: function sample(durationMs, numBytes) {
      durationMs = Math.max(durationMs, this.minDelayMs_);
      var bandwidth = 8000 * numBytes / durationMs,

      // console.log('instant bw:'+ Math.round(bandwidth));
      // we weight sample using loading duration....
      weight = durationMs / 1000;
      this.fast_.sample(weight, bandwidth);
      this.slow_.sample(weight, bandwidth);
    }
  }, {
    key: 'canEstimate',
    value: function canEstimate() {
      var fast = this.fast_;
      return fast && fast.getTotalWeight() >= this.minWeight_;
    }
  }, {
    key: 'getEstimate',
    value: function getEstimate() {
      if (this.canEstimate()) {
        // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
        // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
        // Take the minimum of these two estimates.  This should have the effect of
        // adapting down quickly, but up more slowly.
        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
      } else {
        return this.defaultEstimate_;
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }]);

  return EwmaBandWidthEstimator;
}();

exports.default = EwmaBandWidthEstimator;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/ewma.js":
/*!**********************************!*\
  !*** ./src/hls.js/utils/ewma.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */

var EWMA = function () {
  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  function EWMA(halfLife) {
    _classCallCheck(this, EWMA);

    // Larger values of alpha expire historical data more slowly.
    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
    this.estimate_ = 0;
    this.totalWeight_ = 0;
  }

  _createClass(EWMA, [{
    key: "sample",
    value: function sample(weight, value) {
      var adjAlpha = Math.pow(this.alpha_, weight);
      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
      this.totalWeight_ += weight;
    }
  }, {
    key: "getTotalWeight",
    value: function getTotalWeight() {
      return this.totalWeight_;
    }
  }, {
    key: "getEstimate",
    value: function getEstimate() {
      if (this.alpha_) {
        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
        return this.estimate_ / zeroFactor;
      } else {
        return this.estimate_;
      }
    }
  }]);

  return EWMA;
}();

exports.default = EWMA;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/utils/get-self-scope.js":
/*!********************************************!*\
  !*** ./src/hls.js/utils/get-self-scope.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSelfScope = getSelfScope;
function getSelfScope() {
  // see https://stackoverflow.com/a/11237259/589493
  if (typeof window === 'undefined') {
    /* eslint-disable-next-line no-undef */
    return self;
  } else {
    return window;
  }
}

/***/ }),

/***/ "./src/hls.js/utils/logger.js":
/*!************************************!*\
  !*** ./src/hls.js/utils/logger.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logger = exports.enableLogs = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _getSelfScope = __webpack_require__(/*! ./get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

function noop() {}

var fakeLogger = {
  trace: noop,
  debug: noop,
  log: noop,
  warn: noop,
  info: noop,
  error: noop
};

var exportedLogger = fakeLogger;

// let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }

function formatMsg(type, msg) {
  msg = '[' + type + '] > ' + msg;
  return msg;
}

var global = (0, _getSelfScope.getSelfScope)();

function consolePrintFn(type) {
  var func = global.console[type];
  if (func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args[0]) {
        args[0] = formatMsg(type, args[0]);
      }

      func.apply(global.console, args);
    };
  }
  return noop;
}

function exportLoggerFunctions(debugConfig) {
  for (var _len2 = arguments.length, functions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    functions[_key2 - 1] = arguments[_key2];
  }

  functions.forEach(function (type) {
    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
  });
}

var enableLogs = exports.enableLogs = function enableLogs(debugConfig) {
  if (debugConfig === true || (typeof debugConfig === 'undefined' ? 'undefined' : _typeof(debugConfig)) === 'object') {
    exportLoggerFunctions(debugConfig,
    // Remove out from list here to hard-disable a log-level
    // 'trace',
    'debug', 'log', 'info', 'warn', 'error');
    // Some browsers don't allow to use bind on console object anyway
    // fallback to default if needed
    try {
      exportedLogger.log();
    } catch (e) {
      exportedLogger = fakeLogger;
    }
  } else {
    exportedLogger = fakeLogger;
  }
};

var logger = exports.logger = exportedLogger;

/***/ }),

/***/ "./src/hls.js/utils/mediakeys-helper.js":
/*!**********************************************!*\
  !*** ./src/hls.js/utils/mediakeys-helper.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var requestMediaKeySystemAccess = function () {
  if (typeof window !== 'undefined' && window.navigator && window.navigator.requestMediaKeySystemAccess) {
    return window.navigator.requestMediaKeySystemAccess.bind(window.navigator);
  } else {
    return null;
  }
}();

exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess;

/***/ }),

/***/ "./src/hls.js/utils/mediasource-helper.js":
/*!************************************************!*\
  !*** ./src/hls.js/utils/mediasource-helper.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMediaSource = getMediaSource;
/**
 * MediaSource helper
 */

function getMediaSource() {
  if (typeof window !== 'undefined') {
    return window.MediaSource || window.WebKitMediaSource;
  }
}

/***/ }),

/***/ "./src/hls.js/utils/output-filter.js":
/*!*******************************************!*\
  !*** ./src/hls.js/utils/output-filter.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var OutputFilter = function () {
  function OutputFilter(timelineController, trackName) {
    _classCallCheck(this, OutputFilter);

    this.timelineController = timelineController;
    this.trackName = trackName;
    this.startTime = null;
    this.endTime = null;
    this.screen = null;
  }

  _createClass(OutputFilter, [{
    key: "dispatchCue",
    value: function dispatchCue() {
      if (this.startTime === null) {
        return;
      }

      this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen);
      this.startTime = null;
    }
  }, {
    key: "newCue",
    value: function newCue(startTime, endTime, screen) {
      if (this.startTime === null || this.startTime > startTime) {
        this.startTime = startTime;
      }

      this.endTime = endTime;
      this.screen = screen;
      this.timelineController.createCaptionsTrack(this.trackName);
    }
  }]);

  return OutputFilter;
}();

exports.default = OutputFilter;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/utils/texttrack-utils.js":
/*!*********************************************!*\
  !*** ./src/hls.js/utils/texttrack-utils.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sendAddTrackEvent = sendAddTrackEvent;
exports.clearCurrentCues = clearCurrentCues;
function sendAddTrackEvent(track, videoEl) {
  var event = null;
  try {
    event = new window.Event('addtrack');
  } catch (err) {
    // for IE11
    event = document.createEvent('Event');
    event.initEvent('addtrack', false, false);
  }
  event.track = track;
  videoEl.dispatchEvent(event);
}

function clearCurrentCues(track) {
  if (track && track.cues) {
    while (track.cues.length > 0) {
      track.removeCue(track.cues[0]);
    }
  }
}

/***/ }),

/***/ "./src/hls.js/utils/time-ranges.js":
/*!*****************************************!*\
  !*** ./src/hls.js/utils/time-ranges.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 *  TimeRanges to string helper
 */

var TimeRanges = {
  toString: function toString(r) {
    var log = '',
        len = r.length;
    for (var i = 0; i < len; i++) {
      log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';
    }

    return log;
  }
};

exports.default = TimeRanges;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/vttcue.js":
/*!************************************!*\
  !*** ./src/hls.js/utils/vttcue.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

exports.default = function () {
  if (typeof window !== 'undefined' && window.VTTCue) {
    return window.VTTCue;
  }

  var autoKeyword = 'auto';
  var directionSetting = {
    '': true,
    lr: true,
    rl: true
  };
  var alignSetting = {
    start: true,
    middle: true,
    end: true,
    left: true,
    right: true
  };

  function findDirectionSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }

    var dir = directionSetting[value.toLowerCase()];
    return dir ? value.toLowerCase() : false;
  }

  function findAlignSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }

    var align = alignSetting[value.toLowerCase()];
    return align ? value.toLowerCase() : false;
  }

  function extend(obj) {
    var i = 1;
    for (; i < arguments.length; i++) {
      var cobj = arguments[i];
      for (var p in cobj) {
        obj[p] = cobj[p];
      }
    }

    return obj;
  }

  function VTTCue(startTime, endTime, text) {
    var cue = this;
    var isIE8 = function () {
      if (typeof navigator === 'undefined') {
        return;
      }

      return (/MSIE\s8\.0/.test(navigator.userAgent)
      );
    }();
    var baseObj = {};

    if (isIE8) {
      cue = document.createElement('custom');
    } else {
      baseObj.enumerable = true;
    }

    /**
     * Shim implementation specific properties. These properties are not in
     * the spec.
     */

    // Lets us know when the VTTCue's data has changed in such a way that we need
    // to recompute its display state. This lets us compute its display state
    // lazily.
    cue.hasBeenReset = false;

    /**
     * VTTCue and TextTrackCue properties
     * http://dev.w3.org/html5/webvtt/#vttcue-interface
     */

    var _id = '';
    var _pauseOnExit = false;
    var _startTime = startTime;
    var _endTime = endTime;
    var _text = text;
    var _region = null;
    var _vertical = '';
    var _snapToLines = true;
    var _line = 'auto';
    var _lineAlign = 'start';
    var _position = 50;
    var _positionAlign = 'middle';
    var _size = 50;
    var _align = 'middle';

    Object.defineProperty(cue, 'id', extend({}, baseObj, {
      get: function get() {
        return _id;
      },
      set: function set(value) {
        _id = '' + value;
      }
    }));

    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {
      get: function get() {
        return _pauseOnExit;
      },
      set: function set(value) {
        _pauseOnExit = !!value;
      }
    }));

    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {
      get: function get() {
        return _startTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('Start time must be set to a number.');
        }

        _startTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {
      get: function get() {
        return _endTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('End time must be set to a number.');
        }

        _endTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'text', extend({}, baseObj, {
      get: function get() {
        return _text;
      },
      set: function set(value) {
        _text = '' + value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'region', extend({}, baseObj, {
      get: function get() {
        return _region;
      },
      set: function set(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {
      get: function get() {
        return _vertical;
      },
      set: function set(value) {
        var setting = findDirectionSetting(value);
        // Have to check for false because the setting an be an empty string.
        if (setting === false) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {
      get: function get() {
        return _snapToLines;
      },
      set: function set(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'line', extend({}, baseObj, {
      get: function get() {
        return _line;
      },
      set: function set(value) {
        if (typeof value !== 'number' && value !== autoKeyword) {
          throw new SyntaxError('An invalid number or illegal string was specified.');
        }

        _line = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {
      get: function get() {
        return _lineAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'position', extend({}, baseObj, {
      get: function get() {
        return _position;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Position must be between 0 and 100.');
        }

        _position = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {
      get: function get() {
        return _positionAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'size', extend({}, baseObj, {
      get: function get() {
        return _size;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Size must be between 0 and 100.');
        }

        _size = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'align', extend({}, baseObj, {
      get: function get() {
        return _align;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _align = setting;
        this.hasBeenReset = true;
      }
    }));

    /**
     * Other <track> spec defined properties
     */

    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
    cue.displayState = undefined;

    if (isIE8) {
      return cue;
    }
  }

  /**
   * VTTCue methods
   */

  VTTCue.prototype.getCueAsHTML = function () {
    // Assume WebVTT.convertCueToDOMTree is on the global.
    var WebVTT = window.WebVTT;
    return WebVTT.convertCueToDOMTree(window, this.text);
  };

  return VTTCue;
}();

module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/vttparser.js":
/*!***************************************!*\
  !*** ./src/hls.js/utils/vttparser.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fixLineBreaks = undefined;

var _vttcue = __webpack_require__(/*! ./vttcue */ "./src/hls.js/utils/vttcue.js");

var _vttcue2 = _interopRequireDefault(_vttcue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StringDecoder = function StringDecoder() {
  return {
    decode: function decode(data) {
      if (!data) {
        return '';
      }

      if (typeof data !== 'string') {
        throw new Error('Error - expected string data.');
      }

      return decodeURIComponent(encodeURIComponent(data));
    }
  };
}; /*
    * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716
    */

function VTTParser() {
  this.window = window;
  this.state = 'INITIAL';
  this.buffer = '';
  this.decoder = new StringDecoder();
  this.regionList = [];
}

// Try to parse input as a time stamp.
function parseTimeStamp(input) {
  function computeSeconds(h, m, s, f) {
    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
  }

  var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
  if (!m) {
    return null;
  }

  if (m[3]) {
    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
    return computeSeconds(m[1], m[2], m[3].replace(':', ''), m[4]);
  } else if (m[1] > 59) {
    // Timestamp takes the form of [hours]:[minutes].[milliseconds]
    // First position is hours as it's over 59.
    return computeSeconds(m[1], m[2], 0, m[4]);
  } else {
    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
    return computeSeconds(0, m[1], m[2], m[4]);
  }
}

// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings() {
  this.values = Object.create(null);
}

Settings.prototype = {
  // Only accept the first assignment to any key.
  set: function set(k, v) {
    if (!this.get(k) && v !== '') {
      this.values[k] = v;
    }
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function get(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }

    return this.has(k) ? this.values[k] : dflt;
  },
  // Check whether we have a value for a key.
  has: function has(k) {
    return k in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function alt(k, v, a) {
    for (var n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function integer(k, v) {
    if (/^-?\d+$/.test(v)) {
      // integer
      this.set(k, parseInt(v, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function percent(k, v) {
    var m = void 0;
    if (m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
      v = parseFloat(v);
      if (v >= 0 && v <= 100) {
        this.set(k, v);
        return true;
      }
    }
    return false;
  }
};

// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input, callback, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];
  for (var i in groups) {
    if (typeof groups[i] !== 'string') {
      continue;
    }

    var kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }

    var k = kv[0];
    var v = kv[1];
    callback(k, v);
  }
}

var defaults = new _vttcue2.default(0, 0, 0);
// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244
//  Safari doesn't yet support this change, but FF and Chrome do.
var center = defaults.align === 'middle' ? 'middle' : 'center';

function parseCue(input, cue, regionList) {
  // Remember the original input if we need to throw an error.
  var oInput = input;
  // 4.1 WebVTT timestamp
  function consumeTimeStamp() {
    var ts = parseTimeStamp(input);
    if (ts === null) {
      throw new Error('Malformed timestamp: ' + oInput);
    }

    // Remove time stamp from input.
    input = input.replace(/^[^\sa-zA-Z-]+/, '');
    return ts;
  }

  // 4.4.2 WebVTT cue settings
  function consumeCueSettings(input, cue) {
    var settings = new Settings();

    parseOptions(input, function (k, v) {
      switch (k) {
        case 'region':
          // Find the last region we parsed with the same region id.
          for (var i = regionList.length - 1; i >= 0; i--) {
            if (regionList[i].id === v) {
              settings.set(k, regionList[i].region);
              break;
            }
          }
          break;
        case 'vertical':
          settings.alt(k, v, ['rl', 'lr']);
          break;
        case 'line':
          var vals = v.split(','),
              vals0 = vals[0];
          settings.integer(k, vals0);
          if (settings.percent(k, vals0)) {
            settings.set('snapToLines', false);
          }

          settings.alt(k, vals0, ['auto']);
          if (vals.length === 2) {
            settings.alt('lineAlign', vals[1], ['start', center, 'end']);
          }

          break;
        case 'position':
          vals = v.split(',');
          settings.percent(k, vals[0]);
          if (vals.length === 2) {
            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);
          }

          break;
        case 'size':
          settings.percent(k, v);
          break;
        case 'align':
          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);
          break;
      }
    }, /:/, /\s/);

    // Apply default values for any missing fields.
    cue.region = settings.get('region', null);
    cue.vertical = settings.get('vertical', '');
    var line = settings.get('line', 'auto');
    if (line === 'auto' && defaults.line === -1) {
      // set numeric line number for Safari
      line = -1;
    }
    cue.line = line;
    cue.lineAlign = settings.get('lineAlign', 'start');
    cue.snapToLines = settings.get('snapToLines', true);
    cue.size = settings.get('size', 100);
    cue.align = settings.get('align', center);
    var position = settings.get('position', 'auto');
    if (position === 'auto' && defaults.position === 50) {
      // set numeric position for Safari
      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;
    }
    cue.position = position;
  }

  function skipWhitespace() {
    input = input.replace(/^\s+/, '');
  }

  // 4.1 WebVTT cue timings.
  skipWhitespace();
  cue.startTime = consumeTimeStamp(); // (1) collect cue start time
  skipWhitespace();
  if (input.substr(0, 3) !== '-->') {
    // (3) next characters must match '-->'
    throw new Error('Malformed time stamp (time stamps must be separated by \'-->\'): ' + oInput);
  }
  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp(); // (5) collect cue end time

  // 4.1 WebVTT cue settings list.
  skipWhitespace();
  consumeCueSettings(input, cue);
}

function fixLineBreaks(input) {
  return input.replace(/<br(?: \/)?>/gi, '\n');
}

VTTParser.prototype = {
  parse: function parse(data) {
    var self = this;

    // If there is no data then we won't decode it, but will just try to parse
    // whatever is in buffer already. This may occur in circumstances, for
    // example when flush() is called.
    if (data) {
      // Try to decode the data that we received.
      self.buffer += self.decoder.decode(data, { stream: true });
    }

    function collectNextLine() {
      var buffer = self.buffer;
      var pos = 0;

      buffer = fixLineBreaks(buffer);

      while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
        ++pos;
      }

      var line = buffer.substr(0, pos);
      // Advance the buffer early in case we fail below.
      if (buffer[pos] === '\r') {
        ++pos;
      }

      if (buffer[pos] === '\n') {
        ++pos;
      }

      self.buffer = buffer.substr(pos);
      return line;
    }

    // 3.2 WebVTT metadata header syntax
    function parseHeader(input) {
      parseOptions(input, function (k, v) {
        switch (k) {
          case 'Region':
            // 3.3 WebVTT region metadata header syntax
            // console.log('parse region', v);
            // parseRegion(v);
            break;
        }
      }, /:/);
    }

    // 5.1 WebVTT file parsing.
    try {
      var line = void 0;
      if (self.state === 'INITIAL') {
        // We can't start parsing until we have the first line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        line = collectNextLine();
        // strip of UTF-8 BOM if any
        // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8
        var m = line.match(/^()?WEBVTT([ \t].*)?$/);
        if (!m || !m[0]) {
          throw new Error('Malformed WebVTT signature.');
        }

        self.state = 'HEADER';
      }

      var alreadyCollectedLine = false;
      while (self.buffer) {
        // We can't parse a line until we have the full line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }

        switch (self.state) {
          case 'HEADER':
            // 13-18 - Allow a header (metadata) under the WEBVTT line.
            if (/:/.test(line)) {
              parseHeader(line);
            } else if (!line) {
              // An empty line terminates the header and starts the body (cues).
              self.state = 'ID';
            }
            continue;
          case 'NOTE':
            // Ignore NOTE blocks.
            if (!line) {
              self.state = 'ID';
            }

            continue;
          case 'ID':
            // Check for the start of NOTE blocks.
            if (/^NOTE($|[ \t])/.test(line)) {
              self.state = 'NOTE';
              break;
            }
            // 19-29 - Allow any number of line terminators, then initialize new cue values.
            if (!line) {
              continue;
            }

            self.cue = new _vttcue2.default(0, 0, '');
            self.state = 'CUE';
            // 30-39 - Check if self line contains an optional identifier or timing data.
            if (line.indexOf('-->') === -1) {
              self.cue.id = line;
              continue;
            }
          // Process line as start of a cue.
          /* falls through */
          case 'CUE':
            // 40 - Collect cue timings and settings.
            try {
              parseCue(line, self.cue, self.regionList);
            } catch (e) {
              // In case of an error ignore rest of the cue.
              self.cue = null;
              self.state = 'BADCUE';
              continue;
            }
            self.state = 'CUETEXT';
            continue;
          case 'CUETEXT':
            var hasSubstring = line.indexOf('-->') !== -1;
            // 34 - If we have an empty line then report the cue.
            // 35 - If we have the special substring '-->' then report the cue,
            // but do not collect the line as we need to process the current
            // one as a new cue.
            if (!line || hasSubstring && (alreadyCollectedLine = true)) {
              // We are done parsing self cue.
              if (self.oncue) {
                self.oncue(self.cue);
              }

              self.cue = null;
              self.state = 'ID';
              continue;
            }
            if (self.cue.text) {
              self.cue.text += '\n';
            }

            self.cue.text += line;
            continue;
          case 'BADCUE':
            // BADCUE
            // 54-62 - Collect and discard the remaining cue.
            if (!line) {
              self.state = 'ID';
            }

            continue;
        }
      }
    } catch (e) {
      // If we are currently parsing a cue, report what we have.
      if (self.state === 'CUETEXT' && self.cue && self.oncue) {
        self.oncue(self.cue);
      }

      self.cue = null;
      // Enter BADWEBVTT state if header was not parsed correctly otherwise
      // another exception occurred so enter BADCUE state.
      self.state = self.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';
    }
    return this;
  },
  flush: function flush() {
    var self = this;
    try {
      // Finish decoding the stream.
      self.buffer += self.decoder.decode();
      // Synthesize the end of the current cue or region.
      if (self.cue || self.state === 'HEADER') {
        self.buffer += '\n\n';
        self.parse();
      }
      // If we've flushed, parsed, and we're still on the INITIAL state then
      // that means we don't have enough of the stream to parse the first
      // line.
      if (self.state === 'INITIAL') {
        throw new Error('Malformed WebVTT signature.');
      }
    } catch (e) {
      throw e;
    }
    if (self.onflush) {
      self.onflush();
    }

    return this;
  }
};

exports.fixLineBreaks = fixLineBreaks;
exports.default = VTTParser;

/***/ }),

/***/ "./src/hls.js/utils/webvtt-parser.js":
/*!*******************************************!*\
  !*** ./src/hls.js/utils/webvtt-parser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vttparser = __webpack_require__(/*! ./vttparser */ "./src/hls.js/utils/vttparser.js");

var _vttparser2 = _interopRequireDefault(_vttparser);

var _id = __webpack_require__(/*! ../demux/id3 */ "./src/hls.js/demux/id3.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// String.prototype.startsWith is not supported in IE11
var startsWith = function startsWith(inputString, searchString, position) {
  return inputString.substr(position || 0, searchString.length) === searchString;
};

var cueString2millis = function cueString2millis(timeString) {
  var ts = parseInt(timeString.substr(-3));
  var secs = parseInt(timeString.substr(-6, 2));
  var mins = parseInt(timeString.substr(-9, 2));
  var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0;

  if (!Number.isFinite(ts) || !Number.isFinite(secs) || !Number.isFinite(mins) || !Number.isFinite(hours)) {
    return -1;
  }

  ts += 1000 * secs;
  ts += 60 * 1000 * mins;
  ts += 60 * 60 * 1000 * hours;

  return ts;
};

// From https://github.com/darkskyapp/string-hash
var hash = function hash(text) {
  var hash = 5381;
  var i = text.length;
  while (i) {
    hash = hash * 33 ^ text.charCodeAt(--i);
  }

  return (hash >>> 0).toString();
};

var calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {
  var currCC = vttCCs[cc];
  var prevCC = vttCCs[currCC.prevCC];

  // This is the first discontinuity or cues have been processed since the last discontinuity
  // Offset = current discontinuity time
  if (!prevCC || !prevCC.new && currCC.new) {
    vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
    currCC.new = false;
    return;
  }

  // There have been discontinuities since cues were last parsed.
  // Offset = time elapsed
  while (prevCC && prevCC.new) {
    vttCCs.ccOffset += currCC.start - prevCC.start;
    currCC.new = false;
    currCC = prevCC;
    prevCC = vttCCs[currCC.prevCC];
  }

  vttCCs.presentationOffset = presentationTime;
};

var WebVTTParser = {
  parse: function parse(vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) {
    // Convert byteArray into string, replacing any somewhat exotic linefeeds with "\n", then split on that character.
    var re = /\r\n|\n\r|\n|\r/g;
    // Uint8Array.prototype.reduce is not implemented in IE11
    var vttLines = (0, _id.utf8ArrayToStr)(new Uint8Array(vttByteArray)).trim().replace(re, '\n').split('\n');

    var cueTime = '00:00.000';
    var mpegTs = 0;
    var localTime = 0;
    var presentationTime = 0;
    var cues = [];
    var parsingError = void 0;
    var inHeader = true;
    // let VTTCue = VTTCue || window.TextTrackCue;

    // Create parser object using VTTCue with TextTrackCue fallback on certain browsers.
    var parser = new _vttparser2.default();

    parser.oncue = function (cue) {
      // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.
      var currCC = vttCCs[cc];
      var cueOffset = vttCCs.ccOffset;

      // Update offsets for new discontinuities
      if (currCC && currCC.new) {
        if (localTime !== undefined) {
          // When local time is provided, offset = discontinuity start time - local time
          cueOffset = vttCCs.ccOffset = currCC.start;
        } else {
          calculateOffset(vttCCs, cc, presentationTime);
        }
      }

      if (presentationTime) {
        // If we have MPEGTS, offset = presentation time + discontinuity offset
        cueOffset = presentationTime - vttCCs.presentationOffset;
      }

      cue.startTime += cueOffset - localTime;
      cue.endTime += cueOffset - localTime;

      // Create a unique hash id for a cue based on start/end times and text.
      // This helps timeline-controller to avoid showing repeated captions.
      cue.id = hash(cue.startTime.toString()) + hash(cue.endTime.toString()) + hash(cue.text);

      // Fix encoding of special characters. TODO: Test with all sorts of weird characters.
      cue.text = decodeURIComponent(encodeURIComponent(cue.text));
      if (cue.endTime > 0) {
        cues.push(cue);
      }
    };

    parser.onparsingerror = function (e) {
      parsingError = e;
    };

    parser.onflush = function () {
      if (parsingError && errorCallBack) {
        errorCallBack(parsingError);
        return;
      }
      callBack(cues);
    };

    // Go through contents line by line.
    vttLines.forEach(function (line) {
      if (inHeader) {
        // Look for X-TIMESTAMP-MAP in header.
        if (startsWith(line, 'X-TIMESTAMP-MAP=')) {
          // Once found, no more are allowed anyway, so stop searching.
          inHeader = false;
          // Extract LOCAL and MPEGTS.
          line.substr(16).split(',').forEach(function (timestamp) {
            if (startsWith(timestamp, 'LOCAL:')) {
              cueTime = timestamp.substr(6);
            } else if (startsWith(timestamp, 'MPEGTS:')) {
              mpegTs = parseInt(timestamp.substr(7));
            }
          });
          try {
            // Calculate subtitle offset in milliseconds.
            if (syncPTS + (vttCCs[cc].start * 90000 || 0) < 0) {
              syncPTS += 8589934592;
            }
            // Adjust MPEGTS by sync PTS.
            mpegTs -= syncPTS;
            // Convert cue time to seconds
            localTime = cueString2millis(cueTime) / 1000;
            // Convert MPEGTS to seconds from 90kHz.
            presentationTime = mpegTs / 90000;

            if (localTime === -1) {
              parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
            }
          } catch (e) {
            parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
          }
          // Return without parsing X-TIMESTAMP-MAP line.
          return;
        } else if (line === '') {
          inHeader = false;
        }
      }
      // Parse line by default.
      parser.parse(line + '\n');
    });

    parser.flush();
  }
};

exports.default = WebVTTParser;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/xhr-loader.js":
/*!****************************************!*\
  !*** ./src/hls.js/utils/xhr-loader.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * XHR based logger
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _window = window,
    performance = _window.performance,
    XMLHttpRequest = _window.XMLHttpRequest;

var XhrLoader = function () {
  function XhrLoader(config) {
    _classCallCheck(this, XhrLoader);

    if (config && config.xhrSetup) {
      this.xhrSetup = config.xhrSetup;
    }
  }

  _createClass(XhrLoader, [{
    key: 'destroy',
    value: function destroy() {
      this.abort();
      this.loader = null;
    }
  }, {
    key: 'abort',
    value: function abort() {
      var loader = this.loader;
      if (loader && loader.readyState !== 4) {
        this.stats.aborted = true;
        loader.abort();
      }

      window.clearTimeout(this.requestTimeout);
      this.requestTimeout = null;
      window.clearTimeout(this.retryTimeout);
      this.retryTimeout = null;
    }
  }, {
    key: 'load',
    value: function load(context, config, callbacks) {
      this.context = context;
      this.config = config;
      this.callbacks = callbacks;
      this.stats = { trequest: performance.now(), retry: 0 };
      this.retryDelay = config.retryDelay;
      this.loadInternal();
    }
  }, {
    key: 'loadInternal',
    value: function loadInternal() {
      var xhr = void 0,
          context = this.context;
      xhr = this.loader = new XMLHttpRequest();

      var stats = this.stats;
      stats.tfirst = 0;
      stats.loaded = 0;
      var xhrSetup = this.xhrSetup;

      try {
        if (xhrSetup) {
          try {
            xhrSetup(xhr, context.url);
          } catch (e) {
            // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader("Content-Language", "test");}
            // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN
            xhr.open('GET', context.url, true);
            xhrSetup(xhr, context.url);
          }
        }
        if (!xhr.readyState) {
          xhr.open('GET', context.url, true);
        }
      } catch (e) {
        // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
        this.callbacks.onError({ code: xhr.status, text: e.message }, context, xhr);
        return;
      }

      if (context.rangeEnd) {
        xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
      }

      xhr.onreadystatechange = this.readystatechange.bind(this);
      xhr.onprogress = this.loadprogress.bind(this);
      xhr.responseType = context.responseType;

      // setup timeout before we perform request
      this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
      xhr.send();
    }
  }, {
    key: 'readystatechange',
    value: function readystatechange(event) {
      var xhr = event.currentTarget,
          readyState = xhr.readyState,
          stats = this.stats,
          context = this.context,
          config = this.config;

      // don't proceed if xhr has been aborted
      if (stats.aborted) {
        return;
      }

      // >= HEADERS_RECEIVED
      if (readyState >= 2) {
        // clear xhr timeout and rearm it if readyState less than 4
        window.clearTimeout(this.requestTimeout);
        if (stats.tfirst === 0) {
          stats.tfirst = Math.max(performance.now(), stats.trequest);
        }

        if (readyState === 4) {
          var status = xhr.status;
          // http status between 200 to 299 are all successful
          if (status >= 200 && status < 300) {
            stats.tload = Math.max(stats.tfirst, performance.now());
            var data = void 0,
                len = void 0;
            if (context.responseType === 'arraybuffer') {
              data = xhr.response;
              len = data.byteLength;
            } else {
              data = xhr.responseText;
              len = data.length;
            }
            stats.loaded = stats.total = len;
            var response = { url: xhr.responseURL, data: data };
            this.callbacks.onSuccess(response, stats, context, xhr);
          } else {
            // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
            if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
              _logger.logger.error(status + ' while loading ' + context.url);
              this.callbacks.onError({ code: status, text: xhr.statusText }, context, xhr);
            } else {
              // retry
              _logger.logger.warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...');
              // aborts and resets internal state
              this.destroy();
              // schedule retry
              this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
              // set exponential backoff
              this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
              stats.retry++;
            }
          }
        } else {
          // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
          this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout);
        }
      }
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout() {
      _logger.logger.warn('timeout while loading ' + this.context.url);
      this.callbacks.onTimeout(this.stats, this.context, null);
    }
  }, {
    key: 'loadprogress',
    value: function loadprogress(event) {
      var xhr = event.currentTarget,
          stats = this.stats;

      stats.loaded = event.loaded;
      if (event.lengthComputable) {
        stats.total = event.total;
      }

      var onProgress = this.callbacks.onProgress;
      if (onProgress) {
        // third arg is to provide on progress data
        onProgress(stats, this.context, null, xhr);
      }
    }
  }]);

  return XhrLoader;
}();

exports.default = XhrLoader;
module.exports = exports['default'];

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _xgplayer = __webpack_require__(/*! xgplayer */ "xgplayer");

var _xgplayer2 = _interopRequireDefault(_xgplayer);

var _hls = __webpack_require__(/*! ./hls.js/hls */ "./src/hls.js/hls.js");

var _hls2 = _interopRequireDefault(_hls);

var _utils = __webpack_require__(/*! ./utils */ "./src/utils/index.js");

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HlsJsPlayer = function (_Player) {
  _inherits(HlsJsPlayer, _Player);

  function HlsJsPlayer(options) {
    _classCallCheck(this, HlsJsPlayer);

    var _this = _possibleConstructorReturn(this, (HlsJsPlayer.__proto__ || Object.getPrototypeOf(HlsJsPlayer)).call(this, options));

    _this.hlsOpts = options.hlsOpts || {};
    var util = _xgplayer2.default.util;
    var player = _this;
    _this.browser = _utils2.default.getBrowserVersion();
    if (player.config.useHls === undefined) {
      if (_xgplayer2.default.sniffer.device === 'mobile' && navigator.platform !== 'MacIntel' && navigator.platform !== 'Win32' || _this.browser.indexOf('Safari') > -1) {
        return _possibleConstructorReturn(_this);
      }
    } else if (!player.config.useHls) {
      return _possibleConstructorReturn(_this);
    }
    Number.isFinite = Number.isFinite || function (value) {
      return typeof value === "number" && isFinite(value);
    };

    var hls = void 0;
    hls = new _hls2.default(_this.hlsOpts);
    _this.hls = hls;

    Object.defineProperty(player, 'src', {
      get: function get() {
        return player.currentSrc;
      },
      set: function set(url) {
        util.removeClass(player.root, 'xgplayer-is-live');
        var liveDom = document.querySelector('.xgplayer-live');
        if (liveDom) {
          liveDom.parentNode.removeChild(liveDom);
        }
        // player.config.url = url
        var paused = player.paused;
        player.hls.stopLoad();
        player.hls.detachMedia();
        player.hls.destroy();
        player.hls = new _hls2.default(player.hlsOpts);
        player.register(url);
        if (!paused) {
          player.pause();
          player.once('pause', function () {
            player.hls.loadSource(url);
          });
          player.once('canplay', function () {
            player.play().catch(function (err) {});
          });
        } else {
          player.hls.loadSource(url);
        }
        player.hls.attachMedia(player.video);
        player.once('canplay', function () {
          player.currentTime = 0;
        });
      },

      configurable: true
    });
    _this.register(_this.config.url);
    _this.once('complete', function () {
      hls.attachMedia(player.video);
      player.once('canplay', function () {
        if (player.config.autoplay) {
          player.play().catch(function (err) {});
        }
      });
      if (player.config.isLive) {
        util.addClass(player.root, 'xgplayer-is-live');
        if (!util.findDom(player.root, '.xgplayer-live')) {
          var live = util.createDom('xg-live', '', {}, 'xgplayer-live');
          player.controls.appendChild(live);
        }
      }
    });
    _this.once('destroy', function () {
      hls.stopLoad();
    });
    return _this;
  }

  _createClass(HlsJsPlayer, [{
    key: 'register',
    value: function register(url) {
      var hls = this.hls;
      var util = _xgplayer2.default.util;
      var player = this;
      hls.on(_hls2.default.Events.MEDIA_ATTACHED, function () {
        hls.loadSource(url);
      });

      hls.on(_hls2.default.Events.LEVEL_LOADED, function (name, e) {
        if (!hls.inited) {
          hls.inited = true;
          if (e && e.details && e.details.live) {
            util.addClass(player.root, 'xgplayer-is-live');
            if (!util.findDom(player.root, '.xgplayer-live')) {
              var live = util.createDom('xg-live', '', {}, 'xgplayer-live');
              player.controls.appendChild(live);
            }
          }
        }
      });
      hls.on(_hls2.default.Events.ERROR, function (event, data) {
        player.emit('HLS_ERROR', {
          errorType: data.type,
          errorDetails: data.details,
          errorFatal: data.fatal
        });
        if (data.fatal) {
          switch (data.type) {
            case _hls2.default.ErrorTypes.NETWORK_ERROR:
              hls.startLoad();
              break;
            case _hls2.default.ErrorTypes.MEDIA_ERROR:
              hls.recoverMediaError();
              break;
            default:
              player.emit('error', data);
          }
        }
      });
      this._statistics();
    }
  }, {
    key: '_statistics',
    value: function _statistics() {
      var statsInfo = {
        speed: 0,
        playerType: "HlsPlayer"
      };

      var mediainfo = {
        videoDataRate: 0,
        audioDataRate: 0
      };
      var hls = this.hls;
      var player = this;

      hls.on(_hls2.default.Events.FRAG_LOAD_PROGRESS, function (flag, payload) {
        statsInfo.speed = payload.stats.loaded / 1000;
      });
      hls.on(_hls2.default.Events.FRAG_PARSING_DATA, function (flag, payload) {
        if (payload.type === 'video') {
          mediainfo.fps = parseInt(payload.nb / (payload.endPTS - payload.startPTS));
        }
      });

      hls.on(_hls2.default.Events.FRAG_PARSING_INIT_SEGMENT, function (flag, payload) {
        mediainfo.hasAudio = payload.tracks && payload.tracks.audio ? true : false;
        mediainfo.hasVideo = payload.tracks && payload.tracks.audio ? true : false;

        if (mediainfo.hasAudio) {
          var track = payload.tracks.audio;
          mediainfo.audioChannelCount = track.metadata && track.metadata.channelCount ? track.metadata.channelCount : 0;
          mediainfo.audioCodec = track.codec;
        }

        if (mediainfo.hasVideo) {
          var _track = payload.tracks.video;
          mediainfo.videoCodec = _track.codec;
          mediainfo.width = _track.metadata && _track.metadata.width ? _track.metadata.width : 0;
          mediainfo.height = _track.metadata && _track.metadata.height ? _track.metadata.height : 0;
        }
        mediainfo.duration = payload.frag && payload.frag.duration ? payload.frag.duration : 0;
        mediainfo.level = payload.frag && payload.frag.level ? payload.frag.level : 0;
        if (mediainfo.videoCodec || mediainfo.audioCodec) {
          mediainfo.mimeType = 'video/hls; codecs="' + mediainfo.videoCodec + ';' + mediainfo.audioCodec + '"';
        }

        player.mediainfo = mediainfo;
        player.emit("media_info", mediainfo);
      });

      this._statisticsTimmer = setInterval(function () {
        player.emit("statistics_info", statsInfo);
        statsInfo.speed = 0;
      }, 1000);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _get(HlsJsPlayer.prototype.__proto__ || Object.getPrototypeOf(HlsJsPlayer.prototype), 'destroy', this).call(this);
      clearInterval(this._statisticsTimmer);
    }
  }]);

  return HlsJsPlayer;
}(_xgplayer2.default);

HlsJsPlayer.isSupported = _hls2.default.isSupported;

exports.default = HlsJsPlayer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/utils/index.js":
/*!****************************!*\
  !*** ./src/utils/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var util = {};

util.getBrowserVersion = function () {
  var userAgent = navigator.userAgent; //userAgent
  if (userAgent.toLowerCase().indexOf("mobile") > -1) {
    return "Unknown";
  }
  if (userAgent.indexOf("Firefox") > -1) {
    var version = userAgent.match(/firefox\/[\d.]+/gi)[0].match(/[\d]+/)[0];
    return "Firefox " + version;
  } else if (userAgent.indexOf("Edge") > -1) {
    var _version = userAgent.match(/edge\/[\d.]+/gi)[0].match(/[\d]+/)[0];
    return "Edge " + _version;
  } else if (userAgent.indexOf("rv:11") > -1) {
    return "IE 11";
  } else if (userAgent.indexOf("Opera") > -1 || userAgent.indexOf("OPR") > -1) {
    if (userAgent.indexOf("Opera") > -1) {
      var _version2 = userAgent.match(/opera\/[\d.]+/gi)[0].match(/[\d]+/)[0];
      return "Opera " + _version2;
    }
    if (userAgent.indexOf("OPR") > -1) {
      var _version3 = userAgent.match(/opr\/[\d.]+/gi)[0].match(/[\d]+/)[0];
      return "Opera " + _version3;
    }
  } else if (userAgent.indexOf("Chrome") > -1) {
    var _version4 = userAgent.match(/chrome\/[\d.]+/gi)[0].match(/[\d]+/)[0];
    return "Chrome " + _version4;
  } else if (userAgent.indexOf("Safari") > -1) {
    var _version5 = userAgent.match(/safari\/[\d.]+/gi)[0].match(/[\d]+/)[0];
    return "Safari " + _version5;
  } else if (userAgent.indexOf("MSIE") > -1 || userAgent.indexOf("Trident") > -1) {
    if (userAgent.indexOf("MSIE") > -1) {
      var _version6 = userAgent.match(/msie [\d.]+/gi)[0].match(/[\d]+/)[0];
      return "IE " + _version6;
    }
    if (userAgent.indexOf("Trident") > -1) {
      var versionTrident = userAgent.match(/trident\/[\d.]+/gi)[0].match(/[\d]+/)[0];
      var _version7 = parseInt(versionTrident) + 4;
      return "IE " + _version7;
    }
  } else {
    return "Unknown";
  }
};

exports.default = util;
module.exports = exports["default"];

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./src/index.js */"./src/index.js");


/***/ }),

/***/ "xgplayer":
/*!*************************!*\
  !*** external "Player" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = window["Player"]; }());

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9IbHNKc1BsYXllci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8vVXNlcnMvbGVvbmFyZG8vRG9jdW1lbnRzL2Zyb250LWVuZC9wbGF5ZXIveGdwbGF5ZXIvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvL1VzZXJzL2xlb25hcmRvL0RvY3VtZW50cy9mcm9udC1lbmQvcGxheWVyL3hncGxheWVyL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy9Vc2Vycy9sZW9uYXJkby9Eb2N1bWVudHMvZnJvbnQtZW5kL3BsYXllci94Z3BsYXllci9ub2RlX21vZHVsZXMvdXJsLXRvb2xraXQvc3JjL3VybC10b29sa2l0LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy9Vc2Vycy9sZW9uYXJkby9Eb2N1bWVudHMvZnJvbnQtZW5kL3BsYXllci94Z3BsYXllci9ub2RlX21vZHVsZXMvd2Vid29ya2lmeS13ZWJwYWNrL2luZGV4LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb25maWcuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9iYXNlLXN0cmVhbS1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2ZyYWdtZW50LWZpbmRlcnMuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9nYXAtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9pZDMtdHJhY2stY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2xldmVsLWhlbHBlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9zdHJlYW0tY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9zdWJ0aXRsZS10cmFjay1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NyeXB0L2Flcy1jcnlwdG8uanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NyeXB0L2Flcy1kZWNyeXB0b3IuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NyeXB0L2RlY3J5cHRlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY3J5cHQvZmFzdC1hZXMta2V5LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9kZW11eC9hYWNkZW11eGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9kZW11eC9hZHRzLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9kZW11eC9kZW11eGVyLWlubGluZS5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZGVtdXgvZGVtdXhlci13b3JrZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2RlbXV4L2RlbXV4ZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2RlbXV4L2V4cC1nb2xvbWIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2RlbXV4L2lkMy5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZGVtdXgvbXAzZGVtdXhlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZGVtdXgvbXA0ZGVtdXhlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZGVtdXgvbXBlZ2F1ZGlvLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9kZW11eC9zYW1wbGUtYWVzLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9kZW11eC90c2RlbXV4ZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZXZlbnQtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZXZlbnRzLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9obHMuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2lzLXN1cHBvcnRlZC5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvbG9hZGVyL2ZyYWdtZW50LWxvYWRlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvbG9hZGVyL2ZyYWdtZW50LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9sb2FkZXIva2V5LWxvYWRlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvbG9hZGVyL2xldmVsLWtleS5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvbG9hZGVyL2xldmVsLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9sb2FkZXIvbTN1OC1wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2xvYWRlci9wbGF5bGlzdC1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL29ic2VydmVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9yZW11eC9hYWMtaGVscGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9yZW11eC9tcDQtZ2VuZXJhdG9yLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9yZW11eC9tcDQtcmVtdXhlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvdGFzay1sb29wLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9hdHRyLWxpc3QuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL2JpbmFyeS1zZWFyY2guanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL2J1ZmZlci1oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL2NlYS02MDgtcGFyc2VyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9jb2RlY3MuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL2N1ZXMuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL2Rpc2NvbnRpbnVpdGllcy5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9ld21hLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9nZXQtc2VsZi1zY29wZS5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvdXRpbHMvbG9nZ2VyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9tZWRpYWtleXMtaGVscGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL291dHB1dC1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL3RleHR0cmFjay11dGlscy5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvdXRpbHMvdGltZS1yYW5nZXMuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL3Z0dGN1ZS5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvdXRpbHMvdnR0cGFyc2VyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy93ZWJ2dHQtcGFyc2VyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy94aHItbG9hZGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL3V0aWxzL2luZGV4LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyL2V4dGVybmFsIFwiUGxheWVyXCIiXSwibmFtZXMiOlsiQ3VlcyIsImhsc0RlZmF1bHRDb25maWciLCJhdXRvU3RhcnRMb2FkIiwic3RhcnRQb3NpdGlvbiIsImRlZmF1bHRBdWRpb0NvZGVjIiwidW5kZWZpbmVkIiwiZGVidWciLCJjYXBMZXZlbE9uRlBTRHJvcCIsImNhcExldmVsVG9QbGF5ZXJTaXplIiwiaW5pdGlhbExpdmVNYW5pZmVzdFNpemUiLCJtYXhCdWZmZXJMZW5ndGgiLCJtYXhCdWZmZXJTaXplIiwibWF4QnVmZmVySG9sZSIsImxvd0J1ZmZlcldhdGNoZG9nUGVyaW9kIiwiaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kIiwibnVkZ2VPZmZzZXQiLCJudWRnZU1heFJldHJ5IiwibWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSIsImxpdmVTeW5jRHVyYXRpb25Db3VudCIsImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCIsIkluZmluaXR5IiwibGl2ZVN5bmNEdXJhdGlvbiIsImxpdmVNYXhMYXRlbmN5RHVyYXRpb24iLCJsaXZlRHVyYXRpb25JbmZpbml0eSIsImxpdmVCYWNrQnVmZmVyTGVuZ3RoIiwibWF4TWF4QnVmZmVyTGVuZ3RoIiwiZW5hYmxlV29ya2VyIiwiZW5hYmxlU29mdHdhcmVBRVMiLCJtYW5pZmVzdExvYWRpbmdUaW1lT3V0IiwibWFuaWZlc3RMb2FkaW5nTWF4UmV0cnkiLCJtYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5IiwibWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0Iiwic3RhcnRMZXZlbCIsImxldmVsTG9hZGluZ1RpbWVPdXQiLCJsZXZlbExvYWRpbmdNYXhSZXRyeSIsImxldmVsTG9hZGluZ1JldHJ5RGVsYXkiLCJsZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQiLCJmcmFnTG9hZGluZ1RpbWVPdXQiLCJmcmFnTG9hZGluZ01heFJldHJ5IiwiZnJhZ0xvYWRpbmdSZXRyeURlbGF5IiwiZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQiLCJzdGFydEZyYWdQcmVmZXRjaCIsImZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kIiwiZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQiLCJhcHBlbmRFcnJvck1heFJldHJ5IiwibG9hZGVyIiwiWGhyTG9hZGVyIiwiZkxvYWRlciIsInBMb2FkZXIiLCJ4aHJTZXR1cCIsImxpY2Vuc2VYaHJTZXR1cCIsImFickNvbnRyb2xsZXIiLCJBYnJDb250cm9sbGVyIiwiYnVmZmVyQ29udHJvbGxlciIsIkJ1ZmZlckNvbnRyb2xsZXIiLCJjYXBMZXZlbENvbnRyb2xsZXIiLCJDYXBMZXZlbENvbnRyb2xsZXIiLCJmcHNDb250cm9sbGVyIiwiRlBTQ29udHJvbGxlciIsInN0cmV0Y2hTaG9ydFZpZGVvVHJhY2siLCJtYXhBdWRpb0ZyYW1lc0RyaWZ0IiwiZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eSIsImFickV3bWFGYXN0TGl2ZSIsImFickV3bWFTbG93TGl2ZSIsImFickV3bWFGYXN0Vm9EIiwiYWJyRXdtYVNsb3dWb0QiLCJhYnJFd21hRGVmYXVsdEVzdGltYXRlIiwiYWJyQmFuZFdpZHRoRmFjdG9yIiwiYWJyQmFuZFdpZHRoVXBGYWN0b3IiLCJhYnJNYXhXaXRoUmVhbEJpdHJhdGUiLCJtYXhTdGFydmF0aW9uRGVsYXkiLCJtYXhMb2FkaW5nRGVsYXkiLCJtaW5BdXRvQml0cmF0ZSIsImVtZUVuYWJsZWQiLCJ3aWRldmluZUxpY2Vuc2VVcmwiLCJyZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jIiwicmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIiwic3VidGl0bGVTdHJlYW1Db250cm9sbGVyIiwiU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIiwic3VidGl0bGVUcmFja0NvbnRyb2xsZXIiLCJTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciIsInRpbWVsaW5lQ29udHJvbGxlciIsIlRpbWVsaW5lQ29udHJvbGxlciIsImN1ZUhhbmRsZXIiLCJlbmFibGVDRUE3MDhDYXB0aW9ucyIsImVuYWJsZVdlYlZUVCIsImNhcHRpb25zVGV4dFRyYWNrMUxhYmVsIiwiY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlIiwiY2FwdGlvbnNUZXh0VHJhY2syTGFiZWwiLCJjYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGUiLCJhdWRpb1N0cmVhbUNvbnRyb2xsZXIiLCJBdWRpb1N0cmVhbUNvbnRyb2xsZXIiLCJhdWRpb1RyYWNrQ29udHJvbGxlciIsIkF1ZGlvVHJhY2tDb250cm9sbGVyIiwiZW1lQ29udHJvbGxlciIsIkVNRUNvbnRyb2xsZXIiLCJ3aW5kb3ciLCJwZXJmb3JtYW5jZSIsImhscyIsIkV2ZW50IiwiRlJBR19MT0FESU5HIiwiRlJBR19MT0FERUQiLCJGUkFHX0JVRkZFUkVEIiwiRVJST1IiLCJsYXN0TG9hZGVkRnJhZ0xldmVsIiwiX25leHRBdXRvTGV2ZWwiLCJ0aW1lciIsIl9id0VzdGltYXRvciIsIm9uQ2hlY2siLCJfYWJhbmRvblJ1bGVzQ2hlY2siLCJiaW5kIiwiY2xlYXJUaW1lciIsIkV2ZW50SGFuZGxlciIsInByb3RvdHlwZSIsImRlc3Ryb3kiLCJjYWxsIiwiZGF0YSIsImZyYWciLCJ0eXBlIiwiZnJhZ0N1cnJlbnQiLCJzZXRJbnRlcnZhbCIsImNvbmZpZyIsImxldmVsIiwiaXNMaXZlIiwibGV2ZWxzIiwiZGV0YWlscyIsImxpdmUiLCJld21hRmFzdCIsImV3bWFTbG93IiwiRXdtYUJhbmRXaWR0aEVzdGltYXRvciIsInZpZGVvIiwibWVkaWEiLCJtaW5BdXRvTGV2ZWwiLCJzdGF0cyIsImFib3J0ZWQiLCJsb2dnZXIiLCJ3YXJuIiwicGF1c2VkIiwicGxheWJhY2tSYXRlIiwicmVhZHlTdGF0ZSIsImF1dG9MZXZlbCIsInJlcXVlc3REZWxheSIsIm5vdyIsInRyZXF1ZXN0IiwiTWF0aCIsImFicyIsImR1cmF0aW9uIiwibG9hZFJhdGUiLCJtYXgiLCJidyIsImxvYWRlZCIsImxldmVsQml0cmF0ZSIsInJlYWxCaXRyYXRlIiwiYml0cmF0ZSIsImV4cGVjdGVkTGVuIiwidG90YWwiLCJyb3VuZCIsInBvcyIsImN1cnJlbnRUaW1lIiwiZnJhZ0xvYWRlZERlbGF5IiwiYnVmZmVyU3RhcnZhdGlvbkRlbGF5IiwiQnVmZmVySGVscGVyIiwiYnVmZmVySW5mbyIsImVuZCIsImZyYWdMZXZlbE5leHRMb2FkZWREZWxheSIsIm5leHRMb2FkTGV2ZWwiLCJsZXZlbE5leHRCaXRyYXRlIiwidG9GaXhlZCIsInNhbXBsZSIsImFib3J0IiwidHJpZ2dlciIsIkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCIsIk51bWJlciIsImlzRmluaXRlIiwic24iLCJsb2FkZWRCeXRlcyIsImJ5dGVzIiwibG9hZGVkRHVyYXRpb24iLCJiaXRyYXRlVGVzdCIsInRwYXJzZWQiLCJ0YnVmZmVyZWQiLCJ0bG9hZCIsIm9uRnJhZ0J1ZmZlcmVkIiwiZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMiLCJsb2ciLCJ0Zmlyc3QiLCJid0VzdGltYXRlIiwiZ2V0RXN0aW1hdGUiLCJiaXRyYXRlVGVzdERlbGF5IiwiRXJyb3JEZXRhaWxzIiwiRlJBR19MT0FEX0VSUk9SIiwiRlJBR19MT0FEX1RJTUVPVVQiLCJjbGVhckludGVydmFsIiwiY3VycmVudExldmVsIiwiY3VycmVudEZyYWdEdXJhdGlvbiIsImN1cnJlbnRCdyIsIm1heEF1dG9MZXZlbCIsIm1heEZldGNoRHVyYXRpb24iLCJid0ZhY3RvciIsImJ3VXBGYWN0b3IiLCJpIiwibGV2ZWxJbmZvIiwibGV2ZWxEZXRhaWxzIiwiYXZnRHVyYXRpb24iLCJ0b3RhbGR1cmF0aW9uIiwiZnJhZ21lbnRzIiwibGVuZ3RoIiwiYWRqdXN0ZWRidyIsImZldGNoRHVyYXRpb24iLCJ0cmFjZSIsImZvcmNlZEF1dG9MZXZlbCIsImJ3RXN0aW1hdG9yIiwiY2FuRXN0aW1hdGUiLCJuZXh0QUJSQXV0b0xldmVsIiwiX25leHRBQlJBdXRvTGV2ZWwiLCJtaW4iLCJuZXh0TGV2ZWwiLCJhdmdidyIsImJlc3RMZXZlbCIsIl9maW5kQmVzdExldmVsIiwiTGV2ZWxIZWxwZXIiLCJUSUNLX0lOVEVSVkFMIiwiZnJhZ21lbnRUcmFja2VyIiwiTUVESUFfQVRUQUNIRUQiLCJNRURJQV9ERVRBQ0hJTkciLCJBVURJT19UUkFDS1NfVVBEQVRFRCIsIkFVRElPX1RSQUNLX1NXSVRDSElORyIsIkFVRElPX1RSQUNLX0xPQURFRCIsIktFWV9MT0FERUQiLCJGUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UIiwiRlJBR19QQVJTSU5HX0RBVEEiLCJGUkFHX1BBUlNFRCIsIkJVRkZFUl9SRVNFVCIsIkJVRkZFUl9DUkVBVEVEIiwiQlVGRkVSX0FQUEVOREVEIiwiQlVGRkVSX0ZMVVNIRUQiLCJJTklUX1BUU19GT1VORCIsImF1ZGlvQ29kZWNTd2FwIiwiX3N0YXRlIiwiU3RhdGUiLCJTVE9QUEVEIiwiaW5pdFBUUyIsIndhaXRpbmdGcmFnbWVudCIsInZpZGVvVHJhY2tDQyIsImRlbXV4ZXJJZCIsImlkIiwiY2MiLCJzdGF0ZSIsIldBSVRJTkdfSU5JVF9QVFMiLCJ0aWNrIiwidHJhY2tzIiwibGFzdEN1cnJlbnRUaW1lIiwic3RvcExvYWQiLCJmcmFnTG9hZEVycm9yIiwiSURMRSIsIlNUQVJUSU5HIiwibmV4dExvYWRQb3NpdGlvbiIsInRyYWNrIiwidHJhY2tEZXRhaWxzIiwiUEFVU0VEIiwiQlVGRkVSX0ZMVVNISU5HIiwiV0FJVElOR19UUkFDSyIsImxvYWRlZG1ldGFkYXRhIiwic3RhcnRGcmFnUmVxdWVzdGVkIiwibWVkaWFCdWZmZXIiLCJ2aWRlb0J1ZmZlciIsIm1haW5CdWZmZXJJbmZvIiwiYnVmZmVyTGVuIiwibGVuIiwiYnVmZmVyRW5kIiwiZnJhZ1ByZXZpb3VzIiwibWF4Q29uZmlnQnVmZmVyIiwibWF4QnVmTGVuIiwiYXVkaW9Td2l0Y2giLCJ0cmFja0lkIiwiX3N0cmVhbUVuZGVkIiwiQlVGRkVSX0VPUyIsIkVOREVEIiwiZnJhZ0xlbiIsInN0YXJ0IiwiUFRTS25vd24iLCJuZXh0U3RhcnQiLCJpbml0U2VnbWVudCIsImxvYWRJZHgiLCJmcmFnTG9hZElkeCIsIm5leHRCdWZmZXJlZCIsImZvdW5kRnJhZyIsImZyYWdOZXh0IiwiZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0IiwiY2FuZGlkYXRlIiwiY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlIiwiQmluYXJ5U2VhcmNoIiwic2VhcmNoIiwiZW5kU04iLCJzdGFydFNOIiwiZW5jcnlwdGVkIiwiS0VZX0xPQURJTkciLCJnZXRTdGF0ZSIsIkZyYWdtZW50U3RhdGUiLCJOT1RfTE9BREVEIiwiRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkiLCJyZXRyeURhdGUiLCJpc1NlZWtpbmciLCJzZWVraW5nIiwid2FpdGluZ0ZyYWciLCJ3YWl0aW5nRnJhZ0NDIiwib25GcmFnTG9hZGVkIiwiUEFSU0lORyIsIlBBUlNFRCIsIm9udnNlZWtpbmciLCJvbk1lZGlhU2Vla2luZyIsIm9udmVuZGVkIiwib25NZWRpYUVuZGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsInN0YXJ0TG9hZCIsImVuZGVkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9udnNlZWtlZCIsImF1ZGlvVHJhY2tzIiwiYWx0QXVkaW8iLCJ1cmwiLCJkZW11eGVyIiwibmV3RGV0YWlscyIsInNsaWRpbmciLCJjdXJEZXRhaWxzIiwibWVyZ2VEZXRhaWxzIiwic3RhcnRUaW1lT2Zmc2V0IiwiZnJhZ0xvYWRlZCIsImF1ZGlvQ29kZWMiLCJwYXlsb2FkIiwiYXBwZW5kZWQiLCJEZW11eGVyIiwiaW5pdFNlZ21lbnREYXRhIiwicGVuZGluZ0J1ZmZlcmluZyIsImFjY3VyYXRlVGltZU9mZnNldCIsInB1c2giLCJmcmFnTmV3IiwiYXVkaW8iLCJsZXZlbENvZGVjIiwiY29kZWMiLCJCVUZGRVJfQ09ERUNTIiwiY29udGFpbmVyIiwiYXBwZW5kT2JqIiwicGFyZW50IiwiY29udGVudCIsInBlbmRpbmdEYXRhIiwiQlVGRkVSX0FQUEVORElORyIsImVuZFBUUyIsInN0YXJ0UFRTIiwiZW5kRFRTIiwic3RhcnREVFMiLCJhZGRFbGVtZW50YXJ5U3RyZWFtIiwiRnJhZ21lbnQiLCJFbGVtZW50YXJ5U3RyZWFtVHlwZXMiLCJBVURJTyIsIm5iIiwidXBkYXRlRnJhZ1BUU0RUUyIsImFwcGVuZE9uQnVmZmVyRmx1c2giLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsIlBPU0lUSVZFX0lORklOSVRZIiwiQVVESU9fVFJBQ0tfU1dJVENIRUQiLCJFcnJvclR5cGVzIiwiTUVESUFfRVJST1IiLCJmYXRhbCIsImRhdGExIiwiZGF0YTIiLCJmb3JFYWNoIiwiYnVmZmVyIiwiX2NoZWNrQXBwZW5kZWRQYXJzZWQiLCJhdWRpb1RyYWNrIiwicGVuZGluZyIsIlRpbWVSYW5nZXMiLCJ0b1N0cmluZyIsImJ1ZmZlcmVkIiwibG9hZEVycm9yIiwiZGVsYXkiLCJwb3ciLCJlcnJvciIsIkFVRElPX1RSQUNLX0xPQURfRVJST1IiLCJBVURJT19UUkFDS19MT0FEX1RJTUVPVVQiLCJLRVlfTE9BRF9FUlJPUiIsIktFWV9MT0FEX1RJTUVPVVQiLCJCVUZGRVJfRlVMTF9FUlJPUiIsIm1lZGlhQnVmZmVyZWQiLCJpc0J1ZmZlcmVkIiwibmV4dFN0YXRlIiwicHJldmlvdXNTdGF0ZSIsIkJhc2VTdHJlYW1Db250cm9sbGVyIiwiTUFOSUZFU1RfTE9BRElORyIsIk1BTklGRVNUX1BBUlNFRCIsIkxFVkVMX0xPQURFRCIsIl90cmFja0lkIiwiX3NlbGVjdERlZmF1bHRUcmFjayIsInRyYWNrSWRCbGFja2xpc3QiLCJPYmplY3QiLCJjcmVhdGUiLCJhdWRpb0dyb3VwSWQiLCJoYXNJbnRlcnZhbCIsInVwZGF0ZVBlcmlvZE1zIiwidGFyZ2V0ZHVyYXRpb24iLCJncm91cElkIiwiYXVkaW9Hcm91cElkcyIsInVybElkIiwiX3NlbGVjdEluaXRpYWxBdWRpb1RyYWNrIiwiTkVUV09SS19FUlJPUiIsImNvbnRleHQiLCJfaGFuZGxlTG9hZEVycm9yIiwibmV3SWQiLCJfbG9hZFRyYWNrRGV0YWlsc0lmTmVlZGVkIiwiX3VwZGF0ZVRyYWNrIiwiY3VycmVudEF1ZGlvVHJhY2siLCJuYW1lIiwiZGVmYXVsdFRyYWNrcyIsImZpbHRlciIsImRlZmF1bHQiLCJ0cmFja0ZvdW5kIiwidHJhdmVyc2VUcmFja3MiLCJfc2V0QXVkaW9UcmFjayIsIl9uZWVkc1RyYWNrTG9hZGluZyIsIkFVRElPX1RSQUNLX0xPQURJTkciLCJwcmV2aW91c0lkIiwibGFuZ3VhZ2UiLCJuZXdUcmFjayIsIlRhc2tMb29wIiwiV0FJVElOR19MRVZFTCIsInJlbW92ZUZyYWdtZW50IiwiY2xlYXJOZXh0VGljayIsImJhY2t0cmFja2VkIiwiZnJhZ1N0YXRlIiwiUEFSVElBTCIsIk9LIiwidG9sZXJhbmNlIiwiZnJhZ1N0YXJ0T2Zmc2V0IiwiZnJhZ0VuZE9mZnNldCIsIk1lZGlhU291cmNlIiwiTUVESUFfQVRUQUNISU5HIiwiTEVWRUxfUFRTX1VQREFURUQiLCJMRVZFTF9VUERBVEVEIiwiX21zRHVyYXRpb24iLCJfbGV2ZWxEdXJhdGlvbiIsIl9sZXZlbFRhcmdldER1cmF0aW9uIiwiX2xpdmUiLCJfb2JqZWN0VXJsIiwiYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCIsIm9uc2J1ZSIsIm9uU0JVcGRhdGVFbmQiLCJvbnNiZSIsIm9uU0JVcGRhdGVFcnJvciIsInBlbmRpbmdUcmFja3MiLCJhdWRpb0J1ZmZlciIsInNvdXJjZUJ1ZmZlciIsImRlbHRhIiwidGltZXN0YW1wT2Zmc2V0IiwidXBkYXRpbmciLCJlcnIiLCJhdWRpb1RpbWVzdGFtcE9mZnNldCIsIm1zIiwibWVkaWFTb3VyY2UiLCJvbm1zbyIsIm9uTWVkaWFTb3VyY2VPcGVuIiwib25tc2UiLCJvbk1lZGlhU291cmNlRW5kZWQiLCJvbm1zYyIsIm9uTWVkaWFTb3VyY2VDbG9zZSIsInNyYyIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImVuZE9mU3RyZWFtIiwibWVzc2FnZSIsInJldm9rZU9iamVjdFVSTCIsInJlbW92ZUF0dHJpYnV0ZSIsImxvYWQiLCJmbHVzaFJhbmdlIiwic2VnbWVudHMiLCJNRURJQV9ERVRBQ0hFRCIsImNoZWNrUGVuZGluZ1RyYWNrcyIsInBlbmRpbmdUcmFja3NDb3VudCIsImtleXMiLCJjcmVhdGVTb3VyY2VCdWZmZXJzIiwiZG9BcHBlbmRpbmciLCJfbmVlZHNGbHVzaCIsImRvRmx1c2giLCJfbmVlZHNFb3MiLCJjaGVja0VvcyIsImFwcGVuZGluZyIsInJlZHVjZSIsImNvdW50ZXIiLCJzZWdtZW50IiwidGltZVJhbmdlcyIsInN0cmVhbVR5cGUiLCJfcGF1c2VkIiwic3RhcnRUaW1lIiwicGxheSIsImVuZFRpbWUiLCJ1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbiIsImZsdXNoTGl2ZUJhY2tCdWZmZXIiLCJldmVudCIsIkJVRkZFUl9BUFBFTkRJTkdfRVJST1IiLCJzYiIsInJlbW92ZVNvdXJjZUJ1ZmZlciIsInRyYWNrTmFtZSIsIm1pbWVUeXBlIiwiYWRkU291cmNlQnVmZmVyIiwiY29kZSIsIkJVRkZFUl9BRERfQ09ERUNfRVJST1IiLCJkYXRhVHlwZSIsInNib2JqIiwiZSIsImZsdXNoQnVmZmVyQ291bnRlciIsImJ1ZmZlclR5cGVzIiwidGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uIiwiaW5kZXgiLCJidWZmZXJUeXBlIiwicmVtb3ZlQnVmZmVyUmFuZ2UiLCJhdmVyYWdldGFyZ2V0ZHVyYXRpb24iLCJyYW5nZSIsImZsdXNoQnVmZmVyIiwic2hpZnQiLCJjb25zb2xlIiwiYXBwZW5kQnVmZmVyIiwiYXBwZW5kRXJyb3IiLCJ1bnNoaWZ0IiwiQlVGRkVSX0FQUEVORF9FUlJPUiIsInR5cGVJbiIsImJ1ZlN0YXJ0IiwiYnVmRW5kIiwicmVtb3ZlU3RhcnQiLCJyZW1vdmVFbmQiLCJyZW1vdmUiLCJGUFNfRFJPUF9MRVZFTF9DQVBQSU5HIiwiYXV0b0xldmVsQ2FwcGluZyIsImZpcnN0TGV2ZWwiLCJyZXN0cmljdGVkTGV2ZWxzIiwiX3N0b3BDYXBwaW5nIiwiaXNMZXZlbEFsbG93ZWQiLCJkcm9wcGVkTGV2ZWwiLCJIVE1MVmlkZW9FbGVtZW50IiwiX3N0YXJ0Q2FwcGluZyIsImxldmVsc0xlbmd0aCIsImdldE1heExldmVsIiwic3RyZWFtQ29udHJvbGxlciIsIm5leHRMZXZlbFN3aXRjaCIsImNhcExldmVsSW5kZXgiLCJ2YWxpZExldmVscyIsImdldE1heExldmVsQnlNZWRpYVNpemUiLCJtZWRpYVdpZHRoIiwibWVkaWFIZWlnaHQiLCJkZXRlY3RQbGF5ZXJTaXplIiwid2lkdGgiLCJjbGllbnRXaWR0aCIsIm9mZnNldFdpZHRoIiwiY29udGVudFNjYWxlRmFjdG9yIiwiaGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwiaW5kZXhPZiIsImF0R3JlYXRlc3RCYW5kaXdkdGgiLCJjdXJMZXZlbCIsIm1heExldmVsSW5kZXgiLCJwaXhlbFJhdGlvIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIlhNTEh0dHBSZXF1ZXN0IiwiTUFYX0xJQ0VOU0VfUkVRVUVTVF9GQUlMVVJFUyIsIktleVN5c3RlbXMiLCJXSURFVklORSIsIlBMQVlSRUFEWSIsImNyZWF0ZVdpZGV2aW5lTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyIsImF1ZGlvQ29kZWNzIiwidmlkZW9Db2RlY3MiLCJkcm1TeXN0ZW1PcHRpb25zIiwiYmFzZUNvbmZpZyIsInZpZGVvQ2FwYWJpbGl0aWVzIiwiY29udGVudFR5cGUiLCJnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zIiwia2V5U3lzdGVtIiwiRXJyb3IiLCJfd2lkZXZpbmVMaWNlbnNlVXJsIiwiX2xpY2Vuc2VYaHJTZXR1cCIsIl9lbWVFbmFibGVkIiwiX3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyIsIl9tZWRpYUtleXNMaXN0IiwiX21lZGlhIiwiX2hhc1NldE1lZGlhS2V5cyIsIl9pc01lZGlhRW5jcnlwdGVkIiwiX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50IiwiS0VZX1NZU1RFTV9FUlJPUiIsIktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCIsIm1lZGlhS2V5U3lzdGVtQ29uZmlncyIsInRoZW4iLCJtZWRpYUtleVN5c3RlbUFjY2VzcyIsIl9vbk1lZGlhS2V5U3lzdGVtQWNjZXNzT2J0YWluZWQiLCJjYXRjaCIsIm1lZGlhS2V5c0xpc3RJdGVtIiwibWVkaWFLZXlzIiwibWVkaWFLZXlzU2Vzc2lvbiIsIm1lZGlhS2V5c1Nlc3Npb25Jbml0aWFsaXplZCIsIm1lZGlhS2V5U3lzdGVtRG9tYWluIiwiY3JlYXRlTWVkaWFLZXlzIiwiX29uTWVkaWFLZXlzQ3JlYXRlZCIsImNyZWF0ZVNlc3Npb24iLCJfb25OZXdNZWRpYUtleVNlc3Npb24iLCJrZXlTZXNzaW9uIiwic2Vzc2lvbklkIiwiX29uS2V5U2Vzc2lvbk1lc3NhZ2UiLCJfcmVxdWVzdExpY2Vuc2UiLCJ1cGRhdGUiLCJpbml0RGF0YVR5cGUiLCJpbml0RGF0YSIsIl9tZWRpYUVuY3J5cHRpb25Jbml0RGF0YVR5cGUiLCJfbWVkaWFFbmNyeXB0aW9uSW5pdERhdGEiLCJfYXR0ZW1wdFNldE1lZGlhS2V5cyIsIl9nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbiIsImtleXNMaXN0SXRlbSIsIktFWV9TWVNURU1fTk9fS0VZUyIsInNldE1lZGlhS2V5cyIsIktFWV9TWVNURU1fTk9fQUNDRVNTIiwiS0VZX1NZU1RFTV9OT19TRVNTSU9OIiwiZ2VuZXJhdGVSZXF1ZXN0Iiwia2V5TWVzc2FnZSIsImNhbGxiYWNrIiwieGhyIiwib3BlbiIsInJlc3BvbnNlVHlwZSIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsIl9vbkxpY2Vuc2VSZXF1ZXN0UmVhZHlTdGFnZUNoYW5nZSIsInN0YXR1cyIsInJlc3BvbnNlIiwic3RhdHVzVGV4dCIsImF0dGVtcHRzTGVmdCIsImNoYWxsZW5nZSIsImdldExpY2Vuc2VTZXJ2ZXJVcmwiLCJfY3JlYXRlTGljZW5zZVhociIsInNlbmQiLCJfZ2VuZXJhdGVMaWNlbnNlUmVxdWVzdENoYWxsZW5nZSIsIl9vbk1lZGlhRW5jcnlwdGVkIiwibWFwIiwidmlkZW9Db2RlYyIsIl9hdHRlbXB0S2V5U3lzdGVtQWNjZXNzIiwiaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSIsImdldFZpZGVvUGxheWJhY2tRdWFsaXR5IiwiY2hlY2tGUFNJbnRlcnZhbCIsImRlY29kZWRGcmFtZXMiLCJkcm9wcGVkRnJhbWVzIiwibGFzdFRpbWUiLCJjdXJyZW50UGVyaW9kIiwiY3VycmVudERyb3BwZWQiLCJsYXN0RHJvcHBlZEZyYW1lcyIsImN1cnJlbnREZWNvZGVkIiwibGFzdERlY29kZWRGcmFtZXMiLCJkcm9wcGVkRlBTIiwiRlBTX0RST1AiLCJ0b3RhbERyb3BwZWRGcmFtZXMiLCJ2aWRlb1BsYXliYWNrUXVhbGl0eSIsImNoZWNrRlBTIiwidG90YWxWaWRlb0ZyYW1lcyIsImRyb3BwZWRWaWRlb0ZyYW1lcyIsIndlYmtpdERlY29kZWRGcmFtZUNvdW50Iiwid2Via2l0RHJvcHBlZEZyYW1lQ291bnQiLCJmaW5kRnJhZ21lbnRCeVBEVCIsImZpbmRGcmFnbWVudEJ5UFRTIiwicGR0V2l0aGluVG9sZXJhbmNlVGVzdCIsIlBEVFZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwicHJvZ3JhbURhdGVUaW1lIiwiZW5kUHJvZ3JhbURhdGVUaW1lIiwic2VnIiwiZGVsdGFQVFMiLCJwZHRCdWZmZXJFbmQiLCJBUFBFTkRJTkciLCJGcmFnbWVudFRyYWNrZXIiLCJidWZmZXJQYWRkaW5nIiwicG9zaXRpb24iLCJsZXZlbFR5cGUiLCJidWZmZXJlZEZyYWdzIiwiZnJhZ21lbnRFbnRpdHkiLCJrZXkiLCJib2R5IiwiYnVmZmVyZWRGcmFnS2V5IiwicG9wIiwiZWxlbWVudGFyeVN0cmVhbSIsInRpbWVSYW5nZSIsImZyYWdtZW50VGltZXMiLCJ0aW1lIiwiZXNEYXRhIiwiaXNUaW1lQnVmZmVyZWQiLCJmcmFnbWVudCIsImZyYWdLZXkiLCJnZXRGcmFnbWVudEtleSIsImhhc0VsZW1lbnRhcnlTdHJlYW0iLCJnZXRCdWZmZXJlZFRpbWVzIiwiZnJhZ21lbnRQYXJ0aWFsIiwicGFydGlhbCIsInRpbWVQYWRkaW5nIiwiYmVzdEZyYWdtZW50IiwiYmVzdE92ZXJsYXAiLCJpc1BhcnRpYWwiLCJkZXRlY3RFdmljdGVkRnJhZ21lbnRzIiwiZGV0ZWN0UGFydGlhbEZyYWdtZW50cyIsInN0YWxsRGVib3VuY2VJbnRlcnZhbCIsImp1bXBUaHJlc2hvbGQiLCJHYXBDb250cm9sbGVyIiwic3RhbGxSZXBvcnRlZCIsInRub3ciLCJzdGFsbGVkIiwibnVkZ2VSZXRyeSIsInN0YWxsZWREdXJhdGlvbiIsIl9yZXBvcnRTdGFsbCIsIl90cnlGaXhCdWZmZXJTdGFsbCIsImdldFBhcnRpYWxGcmFnbWVudCIsIl90cnlTa2lwQnVmZmVySG9sZSIsIl90cnlOdWRnZUJ1ZmZlciIsIkJVRkZFUl9TVEFMTEVEX0VSUk9SIiwibGFzdEVuZFRpbWUiLCJCVUZGRVJfU0VFS19PVkVSX0hPTEUiLCJyZWFzb24iLCJ0YXJnZXRUaW1lIiwiQlVGRkVSX05VREdFX09OX1NUQUxMIiwiSUQzVHJhY2tDb250cm9sbGVyIiwiRlJBR19QQVJTSU5HX01FVEFEQVRBIiwiaWQzVHJhY2siLCJ0ZXh0VHJhY2tzIiwidGV4dFRyYWNrIiwia2luZCIsImxhYmVsIiwiYWRkVGV4dFRyYWNrIiwic2FtcGxlcyIsImdldElEM1RyYWNrIiwibW9kZSIsIkN1ZSIsIldlYktpdERhdGFDdWUiLCJWVFRDdWUiLCJUZXh0VHJhY2tDdWUiLCJmcmFtZXMiLCJJRDMiLCJnZXRJRDNGcmFtZXMiLCJwdHMiLCJqIiwiZnJhbWUiLCJpc1RpbWVTdGFtcEZyYW1lIiwiY3VlIiwidmFsdWUiLCJhZGRDdWUiLCJjaHJvbWVPckZpcmVmb3giLCJMZXZlbENvbnRyb2xsZXIiLCJNQU5JRkVTVF9MT0FERUQiLCJjYW5sb2FkIiwiY3VycmVudExldmVsSW5kZXgiLCJtYW51YWxMZXZlbEluZGV4IiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInRvTG93ZXJDYXNlIiwiY2xlYXJUaW1lb3V0IiwiX2xldmVscyIsImxldmVsUmV0cnlDb3VudCIsImxvYWRMZXZlbCIsImJpdHJhdGVTdGFydCIsImxldmVsU2V0IiwibGV2ZWxGcm9tU2V0IiwidmlkZW9Db2RlY0ZvdW5kIiwiYXVkaW9Db2RlY0ZvdW5kIiwiYXR0cmlidXRlcyIsImF0dHJzIiwiZnJhZ21lbnRFcnJvciIsIlNVQlRJVExFUyIsInNvcnQiLCJhIiwiYiIsIl9maXJzdExldmVsIiwic29tZSIsInQiLCJNQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SIiwibmV3TGV2ZWwiLCJsZXZlbFByb3BlcnRpZXMiLCJMRVZFTF9TV0lUQ0hJTkciLCJMRVZFTF9MT0FESU5HIiwiT1RIRVJfRVJST1IiLCJMRVZFTF9TV0lUQ0hfRVJST1IiLCJsZXZlbEVycm9yIiwibGV2ZWxJbmRleCIsIkxFVkVMX0xPQURfRVJST1IiLCJMRVZFTF9MT0FEX1RJTUVPVVQiLCJSRU1VWF9BTExPQ19FUlJPUiIsInJlY292ZXJMZXZlbCIsImVycm9yRXZlbnQiLCJlcnJvckRldGFpbHMiLCJyZWR1bmRhbnRMZXZlbHMiLCJzZXRUaW1lb3V0IiwibGV2ZWxSZXRyeSIsIm5leHRBdXRvTGV2ZWwiLCJyZWxvYWRJbnRlcnZhbCIsImxldmVsT2JqZWN0Iiwic2V0TGV2ZWxJbnRlcm5hbCIsIl9zdGFydExldmVsIiwiY29uZmlnU3RhcnRMZXZlbCIsImFkZEdyb3VwSWQiLCJ1cGRhdGVQVFMiLCJtZXJnZVN1YnRpdGxlUGxheWxpc3RzIiwibWFwRnJhZ21lbnRJbnRlcnNlY3Rpb24iLCJhZGp1c3RTbGlkaW5nIiwiY29tcHV0ZVJlbG9hZEludGVydmFsIiwidGV4dEdyb3VwSWRzIiwiZnJvbUlkeCIsInRvSWR4IiwiZnJhZ0Zyb20iLCJmcmFnVG8iLCJmcmFnVG9QVFMiLCJtYXhTdGFydFBUUyIsImRyaWZ0IiwiZnJhZ0lkeCIsIm9sZERldGFpbHMiLCJjY09mZnNldCIsIlBUU0ZyYWciLCJvbGRGcmFnIiwibmV3RnJhZyIsImRyb3BwZWQiLCJuZXdGcmFnbWVudHMiLCJvbGRQbGF5bGlzdCIsIm5ld1BsYXlsaXN0IiwicmVmZXJlbmNlU3RhcnQiLCJsYXN0SW5kZXgiLCJmcmFncyIsImludGVyc2VjdGlvbkZuIiwib2xkRnJhZ21lbnRzIiwiY3VycmVudFBsYXlsaXN0IiwibGFzdFJlcXVlc3RUaW1lIiwibWluUmVsb2FkSW50ZXJ2YWwiLCJTdHJlYW1Db250cm9sbGVyIiwiZ2FwQ29udHJvbGxlciIsImZvcmNlU3RhcnRMb2FkIiwiX2RvVGlja0lkbGUiLCJfY2hlY2tCdWZmZXIiLCJfY2hlY2tGcmFnbWVudENoYW5nZWQiLCJsZXZlbExhc3RMb2FkZWQiLCJfZmV0Y2hQYXlsb2FkT3JFb3MiLCJfZW5zdXJlRnJhZ21lbnRBdExpdmVQb2ludCIsIl9maW5kRnJhZ21lbnQiLCJfbG9hZEtleSIsIl9sb2FkRnJhZ21lbnQiLCJtYXhMYXRlbmN5IiwibGl2ZVN5bmNQb3NpdGlvbiIsImNvbXB1dGVMaXZlUG9zaXRpb24iLCJoYXNQcm9ncmFtRGF0ZVRpbWUiLCJ0YXJnZXRTTiIsImxvb2t1cFRvbGVyYW5jZSIsImN1clNOSWR4Iiwic2FtZUxldmVsIiwicHJldkZyYWciLCJuZXh0RnJhZyIsImF1dG9MZXZlbEVuYWJsZWQiLCJfcmVkdWNlTWF4QnVmZmVyTGVuZ3RoIiwiZ2V0QnVmZmVyZWRGcmFnIiwiUGxheWxpc3RMb2FkZXIiLCJMZXZlbFR5cGUiLCJNQUlOIiwiZnJhZ1BsYXlpbmdDdXJyZW50IiwiZnJhZ1BsYXlpbmciLCJGUkFHX0NIQU5HRUQiLCJmcmFnUGxheWluZ0xldmVsIiwiTEVWRUxfU1dJVENIRUQiLCJpbW1lZGlhdGVTd2l0Y2giLCJwcmV2aW91c2x5UGF1c2VkIiwicGF1c2UiLCJmbHVzaE1haW5CdWZmZXIiLCJmZXRjaGRlbGF5IiwibmV4dEJ1ZmZlcmVkRnJhZyIsIm5leHRMZXZlbElkIiwiZnJhZ0xhc3RLYnBzIiwiZm9sbG93aW5nQnVmZmVyZWRGcmFnIiwiZmx1c2hTY29wZSIsIm9uTWVkaWFTZWVrZWQiLCJyZW1vdmVBbGxGcmFnbWVudHMiLCJhYWMiLCJoZWFhYyIsImF1ZGlvQ29kZWNTd2l0Y2giLCJuZXdMZXZlbElkIiwibGFzdExldmVsIiwiX2dldEF1ZGlvQ29kZWMiLCJ1YSIsIm1ldGFkYXRhIiwiY2hhbm5lbENvdW50IiwiaGFzQXVkaW8iLCJoYXNWaWRlbyIsIlZJREVPIiwibWVkaWFUcmFjayIsImFsdGVybmF0ZSIsIm1pbkxlbmd0aCIsIl9zZWVrVG9TdGFydFBvcyIsImltbWVkaWF0ZUxldmVsU3dpdGNoRW5kIiwicG9sbCIsInRhcmdldExhdGVuY3kiLCJTVFJFQU1fU1RBVEVfVFJBTlNJVElPTiIsIl9saXZlU3luY1Bvc2l0aW9uIiwiU1VCVElUTEVfVFJBQ0tTX1VQREFURUQiLCJTVUJUSVRMRV9UUkFDS19TV0lUQ0giLCJTVUJUSVRMRV9UUkFDS19MT0FERUQiLCJTVUJUSVRMRV9GUkFHX1BST0NFU1NFRCIsInRyYWNrc0J1ZmZlcmVkIiwiY3VycmVudFRyYWNrSWQiLCJkZWNyeXB0ZXIiLCJEZWNyeXB0ZXIiLCJsYXN0QVZTdGFydCIsIl9vbk1lZGlhU2Vla2luZyIsInN1Y2Nlc3MiLCJmcmFnU3RhcnQiLCJmcmFnRW5kIiwic3VidGl0bGVUcmFja3MiLCJjdXJyZW50VHJhY2siLCJkZWNyeXB0RGF0YSIsImRlY3J5cHRkYXRhIiwiYnl0ZUxlbmd0aCIsIm1ldGhvZCIsImRlY3J5cHQiLCJpdiIsImRlY3J5cHRlZERhdGEiLCJGUkFHX0RFQ1JZUFRFRCIsInRzdGFydCIsInRkZWNyeXB0IiwiYnVmZmVyZWRJbmZvIiwiX2dldEJ1ZmZlcmVkIiwic3RvcHBlZCIsInN1YnRpdGxlRGlzcGxheSIsInF1ZXVlZERlZmF1bHRUcmFjayIsInN1YnRpdGxlVHJhY2siLCJ0cmFja0NoYW5nZUxpc3RlbmVyIiwiX29uVGV4dFRyYWNrc0NoYW5nZWQiLCJ1c2VUZXh0VHJhY2tQb2xsaW5nIiwic3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwiLCJzdWJ0aXRsZXMiLCJfY2xlYXJSZWxvYWRUaW1lciIsIl9sb2FkQ3VycmVudFRyYWNrIiwiU1VCVElUTEVfVFJBQ0tfTE9BRElORyIsImZpbHRlclN1YnRpdGxlVHJhY2tzIiwic2xpY2UiLCJvbGRUcmFjayIsIm5leHRUcmFjayIsInN1YnRpdGxlVHJhY2tJZCIsIl90b2dnbGVUcmFja01vZGVzIiwiX3NldFN1YnRpdGxlVHJhY2tJbnRlcm5hbCIsInRleHRUcmFja0xpc3QiLCJjYW5SZXVzZVZ0dFRleHRUcmFjayIsImluVXNlVHJhY2siLCJtYW5pZmVzdFRyYWNrIiwidGV4dFRyYWNrMSIsInRleHRUcmFjazIiLCJpbnRlcnNlY3Rpb24iLCJ4MSIsIngyIiwieTEiLCJ5MiIsIkZSQUdfUEFSU0lOR19VU0VSREFUQSIsImVuYWJsZWQiLCJ1bnBhcnNlZFZ0dEZyYWdzIiwiY3VlUmFuZ2VzIiwiY2FwdGlvbnNUcmFja3MiLCJjYXB0aW9uc1Byb3BlcnRpZXMiLCJsYW5ndWFnZUNvZGUiLCJjaGFubmVsMSIsIk91dHB1dEZpbHRlciIsImNoYW5uZWwyIiwiY2VhNjA4UGFyc2VyIiwiQ2VhNjA4UGFyc2VyIiwic2NyZWVuIiwicmFuZ2VzIiwibWVyZ2VkIiwiY3VlUmFuZ2UiLCJvdmVybGFwIiwibmV3Q3VlIiwiZXhpc3RpbmdUcmFjayIsImdldEV4aXN0aW5nVHJhY2siLCJjcmVhdGVUZXh0VHJhY2siLCJsYW5nIiwiX2NsZWFuVHJhY2tzIiwibGFzdFNuIiwicHJldkNDIiwidnR0Q0NzIiwicHJlc2VudGF0aW9uT2Zmc2V0IiwibmV3IiwiaW5Vc2VUcmFja3MiLCJjbG9zZWRDYXB0aW9ucyIsInJlc2V0IiwiX3BhcnNlVlRUcyIsIldlYlZUVFBhcnNlciIsInBhcnNlIiwiY3VlcyIsImdldEN1ZUJ5SWQiLCJ0ZXh0VHJhY2tDdWUiLCJ0ZXh0IiwiY2NkYXRhcyIsImV4dHJhY3RDZWE2MDhEYXRhIiwiYWRkRGF0YSIsImJ5dGVBcnJheSIsImNvdW50IiwidG1wQnl0ZSIsImNjYnl0ZTEiLCJjY2J5dGUyIiwiY2NWYWxpZCIsImNjVHlwZSIsImFjdHVhbENDQnl0ZXMiLCJBRVNDcnlwdG8iLCJzdWJ0bGUiLCJhZXNJViIsInJlbW92ZVBhZGRpbmciLCJvdXRwdXRCeXRlcyIsInBhZGRpbmdCeXRlcyIsIkRhdGFWaWV3IiwiZ2V0VWludDgiLCJBRVNEZWNyeXB0b3IiLCJyY29uIiwic3ViTWl4IiwiVWludDMyQXJyYXkiLCJpbnZTdWJNaXgiLCJzQm94IiwiaW52U0JveCIsImluaXRUYWJsZSIsImFycmF5QnVmZmVyIiwidmlldyIsIm5ld0FycmF5IiwiZ2V0VWludDMyIiwic3ViTWl4MCIsInN1Yk1peDEiLCJzdWJNaXgyIiwic3ViTWl4MyIsImludlN1Yk1peDAiLCJpbnZTdWJNaXgxIiwiaW52U3ViTWl4MiIsImludlN1Yk1peDMiLCJkIiwieCIsInhpIiwic3giLCJ4NCIsIng4Iiwia2V5QnVmZmVyIiwidWludDhBcnJheVRvVWludDMyQXJyYXlfIiwic2FtZUtleSIsIm9mZnNldCIsImtleVNpemUiLCJrc1Jvd3MiLCJrc1JvdyIsImludktzUm93Iiwia2V5U2NoZWR1bGUiLCJpbnZLZXlTY2hlZHVsZSIsInNib3giLCJwcmV2Iiwid29yZCIsImlucHV0QXJyYXlCdWZmZXIiLCJyZW1vdmVQS0NTN1BhZGRpbmciLCJuUm91bmRzIiwiaW52U0JPWCIsImluaXRWZWN0b3IiLCJpbml0VmVjdG9yMCIsImluaXRWZWN0b3IxIiwiaW5pdFZlY3RvcjIiLCJpbml0VmVjdG9yMyIsImlucHV0SW50MzIiLCJJbnQzMkFycmF5Iiwib3V0cHV0SW50MzIiLCJ0MCIsInQxIiwidDIiLCJ0MyIsInMwIiwiczEiLCJzMiIsInMzIiwiaW5wdXRXb3JkczAiLCJpbnB1dFdvcmRzMSIsImlucHV0V29yZHMyIiwiaW5wdXRXb3JkczMiLCJzd2FwV29yZCIsIm5ldHdvcmtUb0hvc3RPcmRlclN3YXAiLCJnbG9iYWwiLCJvYnNlcnZlciIsImxvZ0VuYWJsZWQiLCJicm93c2VyQ3J5cHRvIiwiY3J5cHRvIiwid2Via2l0U3VidGxlIiwiZGlzYWJsZVdlYkNyeXB0byIsImRlY3J5cHRvciIsImV4cGFuZEtleSIsImZhc3RBZXNLZXkiLCJGYXN0QUVTS2V5IiwiYWVzS2V5Iiwib25XZWJDcnlwdG9FcnJvciIsInJlc3VsdCIsIkZSQUdfREVDUllQVF9FUlJPUiIsImltcG9ydEtleSIsIkFEVFMiLCJBQUNEZW11eGVyIiwicmVtdXhlciIsIl9hdWRpb1RyYWNrIiwic2VxdWVuY2VOdW1iZXIiLCJpc0FBQyIsIm1hbmlmZXN0Q29kZWMiLCJpbnB1dFRpbWVTY2FsZSIsInRpbWVPZmZzZXQiLCJjb250aWd1b3VzIiwiaWQzRGF0YSIsImdldElEM0RhdGEiLCJ0aW1lc3RhbXAiLCJnZXRUaW1lU3RhbXAiLCJmcmFtZUluZGV4Iiwic3RhbXAiLCJpZDNTYW1wbGVzIiwiZHRzIiwiaXNIZWFkZXIiLCJpbml0VHJhY2tDb25maWciLCJhcHBlbmRGcmFtZSIsInJlbXV4IiwicHJvYmUiLCJnZXRBdWRpb0NvbmZpZyIsImlzSGVhZGVyUGF0dGVybiIsImdldEhlYWRlckxlbmd0aCIsImdldEZ1bGxGcmFtZUxlbmd0aCIsImdldEZyYW1lRHVyYXRpb24iLCJwYXJzZUZyYW1lSGVhZGVyIiwiYWR0c09iamVjdFR5cGUiLCJhZHRzU2FtcGxlaW5nSW5kZXgiLCJhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXgiLCJhZHRzQ2hhbmVsQ29uZmlnIiwiYWR0c1NhbXBsZWluZ1JhdGVzIiwiRlJBR19QQVJTSU5HX0VSUk9SIiwic2FtcGxlcmF0ZSIsImhlYWRlckxlbmd0aCIsImZyYW1lTGVuZ3RoIiwibmV3T2Zmc2V0IiwiZnJhbWVEdXJhdGlvbiIsImhlYWRlciIsImFhY1NhbXBsZSIsInVuaXQiLCJzdWJhcnJheSIsIkRhdGUiLCJEZW11eGVySW5saW5lIiwidHlwZVN1cHBvcnRlZCIsInZlbmRvciIsImRpc2NvbnRpbnVpdHkiLCJ0cmFja1N3aXRjaCIsImRlZmF1bHRJbml0UFRTIiwicHVzaERlY3J5cHRlZCIsIlVpbnQ4QXJyYXkiLCJtdXhDb25maWciLCJkZW11eCIsIlRTRGVtdXhlciIsIk1QNFJlbXV4ZXIiLCJNUDREZW11eGVyIiwiUGFzc1Rocm91Z2hSZW11eGVyIiwiTVAzRGVtdXhlciIsIm11eCIsInJlc2V0SW5pdFNlZ21lbnQiLCJyZXNldFRpbWVTdGFtcCIsInNldERlY3J5cHREYXRhIiwiYXBwZW5kIiwiRGVtdXhlcldvcmtlciIsInNlbGYiLCJFdmVudEVtaXR0ZXIiLCJlbWl0Iiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJmb3J3YXJkTWVzc2FnZSIsImV2IiwicG9zdE1lc3NhZ2UiLCJjbWQiLCJKU09OIiwib24iLCJ0cmFuc2ZlcmFibGUiLCJ3b3JrIiwiT2JzZXJ2ZXIiLCJtcDQiLCJpc1R5cGVTdXBwb3J0ZWQiLCJtcGVnIiwibXAzIiwiV29ya2VyIiwidyIsInJlcXVpcmUiLCJvbndtc2ciLCJvbldvcmtlck1lc3NhZ2UiLCJvbmVycm9yIiwiSU5URVJOQUxfRVhDRVBUSU9OIiwiZmlsZW5hbWUiLCJsaW5lbm8iLCJzdHJpbmdpZnkiLCJvYmplY3RVUkwiLCJ0ZXJtaW5hdGUiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJsYXN0RnJhZyIsIm5leHRTTiIsIkFycmF5QnVmZmVyIiwiRXhwR29sb21iIiwiYnl0ZXNBdmFpbGFibGUiLCJiaXRzQXZhaWxhYmxlIiwid29ya2luZ0J5dGVzIiwiYXZhaWxhYmxlQnl0ZXMiLCJzZXQiLCJza2lwQnl0ZXMiLCJsb2FkV29yZCIsInNpemUiLCJiaXRzIiwidmFsdSIsInJlYWRCaXRzIiwibGVhZGluZ1plcm9Db3VudCIsInNraXBMWiIsInNraXBCaXRzIiwiY2x6IiwicmVhZFVFRyIsImxhc3RTY2FsZSIsIm5leHRTY2FsZSIsImRlbHRhU2NhbGUiLCJyZWFkRUciLCJmcmFtZUNyb3BMZWZ0T2Zmc2V0IiwiZnJhbWVDcm9wUmlnaHRPZmZzZXQiLCJmcmFtZUNyb3BUb3BPZmZzZXQiLCJmcmFtZUNyb3BCb3R0b21PZmZzZXQiLCJwcm9maWxlSWRjIiwicHJvZmlsZUNvbXBhdCIsImxldmVsSWRjIiwibnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlIiwicGljV2lkdGhJbk1ic01pbnVzMSIsInBpY0hlaWdodEluTWFwVW5pdHNNaW51czEiLCJmcmFtZU1ic09ubHlGbGFnIiwic2NhbGluZ0xpc3RDb3VudCIsInJlYWRVQnl0ZSIsInJlYWRCb29sZWFuIiwic2tpcEVHIiwic2tpcFVFRyIsInNraXBTY2FsaW5nTGlzdCIsImNocm9tYUZvcm1hdElkYyIsInBpY09yZGVyQ250VHlwZSIsImFzcGVjdFJhdGlvSWRjIiwiY2VpbCIsImZyb250IiwiX3JlYWRTaXplIiwiaXNGb290ZXIiLCJfcmVhZFRpbWVTdGFtcCIsImluZm8iLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJmcmFtZURhdGEiLCJfZ2V0RnJhbWVEYXRhIiwiX2RlY29kZUZyYW1lIiwiX2RlY29kZVByaXZGcmFtZSIsIl9kZWNvZGVUZXh0RnJhbWUiLCJfZGVjb2RlVVJMRnJhbWUiLCJ0aW1lU3RhbXBGcmFtZSIsInB0czMzQml0Iiwib3duZXIiLCJfdXRmOEFycmF5VG9TdHIiLCJwcml2YXRlRGF0YSIsImRlc2NyaXB0aW9uIiwiYXJyYXkiLCJleGl0T25OdWxsIiwiYyIsImNoYXIyIiwiY2hhcjMiLCJvdXQiLCJ1dGY4QXJyYXlUb1N0ciIsIk1wZWdBdWRpbyIsIlVJTlQzMl9NQVgiLCJwYXJzZUluaXRTZWdtZW50IiwiYXVkaW92aWRlbyIsImdldFN0YXJ0RFRTIiwib2Zmc2V0U3RhcnREVFMiLCJmaW5kQm94IiwiYXBwbHkiLCJ2YWwiLCJwYXRoIiwicmVzdWx0cyIsInN1YnJlc3VsdHMiLCJlbmRib3giLCJyZWFkVWludDMyIiwiYmluMnN0ciIsImNvbmNhdCIsIm1vb3YiLCJtb292RW5kT2Zmc2V0Iiwic2lkeCIsInJlZmVyZW5jZXMiLCJ2ZXJzaW9uIiwidGltZXNjYWxlIiwiZWFybGllc3RQcmVzZW50YXRpb25UaW1lIiwiZmlyc3RPZmZzZXQiLCJzdGFydEJ5dGUiLCJyZWZlcmVuY2VzQ291bnQiLCJyZWFkVWludDE2IiwicmVmZXJlbmNlSW5kZXgiLCJyZWZlcmVuY2VJbmZvIiwicmVmZXJlbmNlU2l6ZSIsInJlZmVyZW5jZVR5cGUiLCJzdWJzZWdtZW50RHVyYXRpb24iLCJ0cmFrcyIsInRraGQiLCJ0cmFrIiwibWRoZCIsImhkbHIiLCJoZGxyVHlwZSIsImNvZGVjQm94IiwiY29kZWNUeXBlIiwidHJhZnMiLCJiYXNlVGltZXMiLCJ0cmFmIiwidGZoZCIsInNjYWxlIiwiYmFzZVRpbWUiLCJ0ZmR0IiwiYmFzZU1lZGlhRGVjb2RlVGltZSIsIndyaXRlVWludDMyIiwidXBwZXIiLCJmbG9vciIsImxvd2VyIiwiQml0cmF0ZXNNYXAiLCJTYW1wbGluZ1JhdGVNYXAiLCJTYW1wbGVzQ29lZmZpY2llbnRzIiwiQnl0ZXNJblNsb3QiLCJwYXJzZUhlYWRlciIsInNhbXBsZXNQZXJGcmFtZSIsInNhbXBsZVJhdGUiLCJoZWFkZXJCIiwiaGVhZGVyQyIsImhlYWRlckUiLCJoZWFkZXJGIiwiaGVhZGVyRyIsImNvbHVtbkluQml0cmF0ZXMiLCJiaXRSYXRlIiwiY29sdW1uSW5TYW1wbGVSYXRlcyIsInNhbXBsZUNvZWZmaWNpZW50IiwiYnl0ZXNJblNsb3QiLCJwYXJzZUludCIsIlNhbXBsZUFlc0RlY3J5cHRlciIsImRpc2NhcmRFUEIiLCJlbmNyeXB0ZWREYXRhIiwic2FtcGxlSW5kZXgiLCJzeW5jIiwiY3VyVW5pdCIsImVuY3J5cHRlZEJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJsb2NhbHRoaXMiLCJkZWNyeXB0QnVmZmVyIiwiZGVjcnlwdEFhY1NhbXBsZXMiLCJpc1N5bmMiLCJkZWNyeXB0QWFjU2FtcGxlIiwiZGVjb2RlZERhdGEiLCJlbmNyeXB0ZWREYXRhTGVuIiwiSW50OEFycmF5Iiwib3V0cHV0UG9zIiwiaW5wdXRQb3MiLCJ1bml0SW5kZXgiLCJnZXRBdmNFbmNyeXB0ZWREYXRhIiwiZ2V0QXZjRGVjcnlwdGVkVW5pdCIsImRlY3J5cHRBdmNTYW1wbGVzIiwiY3VyVW5pdHMiLCJ1bml0cyIsImRlY3J5cHRBdmNTYW1wbGUiLCJSZW11eGVyVHJhY2tJZENvbmZpZyIsImlkMyIsInNhbXBsZUFlcyIsInBtdFBhcnNlZCIsIl9wbXRJZCIsIl9hdmNUcmFjayIsImNyZWF0ZVRyYWNrIiwiX2lkM1RyYWNrIiwiX3R4dFRyYWNrIiwiYWFjT3ZlckZsb3ciLCJhYWNMYXN0UFRTIiwiYXZjU2FtcGxlIiwiX2R1cmF0aW9uIiwic3R0IiwicGlkIiwiYXRmIiwicGVzIiwidW5rbm93blBJRHMiLCJhdmNUcmFjayIsImF2Y0lkIiwiYXVkaW9JZCIsImlkM0lkIiwicG10SWQiLCJhdmNEYXRhIiwicGVzRGF0YSIsImF1ZGlvRGF0YSIsInBhcnNlUEFUIiwiX3BhcnNlUEFUIiwicGFyc2VQTVQiLCJfcGFyc2VQTVQiLCJwYXJzZVBFUyIsIl9wYXJzZVBFUyIsInBhcnNlQVZDUEVTIiwiX3BhcnNlQVZDUEVTIiwicGFyc2VBQUNQRVMiLCJfcGFyc2VBQUNQRVMiLCJwYXJzZU1QRUdQRVMiLCJfcGFyc2VNUEVHUEVTIiwicGFyc2VJRDNQRVMiLCJfcGFyc2VJRDNQRVMiLCJzeW5jT2Zmc2V0IiwiX3N5bmNPZmZzZXQiLCJwYXJzZWRQSURzIiwiYXZjIiwiZGVjcnlwdEFuZFJlbXV4IiwidmlkZW9UcmFjayIsImRlY3J5cHRBbmRSZW11eEF2YyIsIl9pbml0UFRTIiwiX2luaXREVFMiLCJtcGVnU3VwcG9ydGVkIiwiaXNTYW1wbGVBZXMiLCJzZWN0aW9uTGVuZ3RoIiwidGFibGVFbmQiLCJwcm9ncmFtSW5mb0xlbmd0aCIsInN0cmVhbSIsInBlc0ZsYWdzIiwicGVzUHJlZml4IiwicGVzTGVuIiwicGVzSGRyTGVuIiwicGVzUHRzIiwicGVzRHRzIiwicGF5bG9hZFN0YXJ0T2Zmc2V0IiwibmV3RGF0YSIsInNwbGljZSIsImRhdGFMZW4iLCJuYlNhbXBsZXMiLCJzcHMiLCJsYXN0IiwiX3BhcnNlQVZDTkFMdSIsImV4cEdvbG9tYkRlY29kZXIiLCJzcHNmb3VuZCIsInB1c2hBY2Nlc1VuaXQiLCJjcmVhdGVBVkNTYW1wbGUiLCJhdWRGb3VuZCIsInNsaWNlVHlwZSIsInJlYWRTbGljZVR5cGUiLCJwYXlsb2FkVHlwZSIsInBheWxvYWRTaXplIiwiZW5kT2ZDYXB0aW9ucyIsImNvdW50cnlDb2RlIiwicHJvdmlkZXJDb2RlIiwicmVhZFVTaG9ydCIsInVzZXJTdHJ1Y3R1cmUiLCJyZWFkVUludCIsInVzZXJEYXRhVHlwZSIsImZpcnN0Qnl0ZSIsInNlY29uZEJ5dGUiLCJ0b3RhbENDcyIsIl9pbnNlcnRTYW1wbGVJbk9yZGVyIiwicmVhZFNQUyIsImNvZGVjYXJyYXkiLCJjb2RlY3N0cmluZyIsImgiLCJwcHMiLCJhcnIiLCJsYXN0VW5pdCIsIm92ZXJmbG93IiwibmFsdVN0YXRlIiwibGFzdFN0YXRlIiwidW5pdFR5cGUiLCJsYXN0VW5pdFN0YXJ0IiwibGFzdFVuaXRUeXBlIiwiX2dldExhc3ROYWxVbml0IiwidG1wIiwiRVBCUG9zaXRpb25zIiwibmV3TGVuZ3RoIiwic291cmNlSW5kZXgiLCJuZXdQVFMiLCJzY2Fud2luZG93IiwiTVVYX0VSUk9SIiwiTUFOSUZFU1RfTE9BRF9FUlJPUiIsIk1BTklGRVNUX0xPQURfVElNRU9VVCIsIk1BTklGRVNUX1BBUlNJTkdfRVJST1IiLCJGT1JCSURERU5fRVZFTlRfTkFNRVMiLCJvbkV2ZW50IiwiZXZlbnRzIiwiaGFuZGxlZEV2ZW50cyIsInVzZUdlbmVyaWNIYW5kbGVyIiwicmVnaXN0ZXJMaXN0ZW5lcnMiLCJvbkhhbmRsZXJEZXN0cm95aW5nIiwidW5yZWdpc3Rlckxpc3RlbmVycyIsIm9uSGFuZGxlckRlc3Ryb3llZCIsImlzRXZlbnRIYW5kbGVyIiwib25FdmVudEdlbmVyaWMiLCJldmVudFRvRnVuY3Rpb24iLCJmdW5jTmFtZSIsInJlcGxhY2UiLCJjb25zdHJ1Y3RvciIsIkhsc0V2ZW50cyIsIkZSQUdfTE9BRF9QUk9HUkVTUyIsIkRFU1RST1lJTkciLCJVUkxUb29sa2l0IiwiSGxzIiwiX19WRVJTSU9OX18iLCJkZWZhdWx0Q29uZmlnIiwiRGVmYXVsdENvbmZpZyIsInByb3AiLCJfYXV0b0xldmVsQ2FwcGluZyIsInBsYXlMaXN0TG9hZGVyIiwiZnJhZ21lbnRMb2FkZXIiLCJGcmFnbWVudExvYWRlciIsImtleUxvYWRlciIsIktleUxvYWRlciIsImlkM1RyYWNrQ29udHJvbGxlciIsImxldmVsQ29udHJvbGxlciIsIm5ldHdvcmtDb250cm9sbGVycyIsIkNvbnRyb2xsZXIiLCJjb3JlQ29tcG9uZW50cyIsImRldGFjaE1lZGlhIiwiY29tcG9uZW50IiwiYnVpbGRBYnNvbHV0ZVVSTCIsImxvY2F0aW9uIiwiaHJlZiIsImFsd2F5c05vcm1hbGl6ZSIsImNvbnRyb2xsZXIiLCJzd2FwQXVkaW9Db2RlYyIsImF0dGFjaE1lZGlhIiwiaW1tZWRpYXRlTGV2ZWxTd2l0Y2giLCJtYW51YWxMZXZlbCIsImF1ZGlvVHJhY2tJZCIsImlzU3VwcG9ydGVkIiwiU291cmNlQnVmZmVyIiwiV2ViS2l0U291cmNlQnVmZmVyIiwic291cmNlQnVmZmVyVmFsaWRBUEkiLCJsb2FkZXJzIiwibG9hZGVyTmFtZSIsIkZyYWdtZW50SUxvYWRlciIsIkRlZmF1bHRJTG9hZGVyIiwibG9hZGVyQ29udGV4dCIsImxvYWRlckNvbmZpZyIsImxvYWRlckNhbGxiYWNrcyIsInByb2dyZXNzRGF0YSIsImJ5dGVSYW5nZVN0YXJ0T2Zmc2V0IiwiYnl0ZVJhbmdlRW5kT2Zmc2V0IiwicmFuZ2VTdGFydCIsInJhbmdlRW5kIiwidGltZW91dCIsIm1heFJldHJ5IiwicmV0cnlEZWxheSIsIm1heFJldHJ5RGVsYXkiLCJvblN1Y2Nlc3MiLCJsb2Fkc3VjY2VzcyIsIm9uRXJyb3IiLCJsb2FkZXJyb3IiLCJvblRpbWVvdXQiLCJsb2FkdGltZW91dCIsIm9uUHJvZ3Jlc3MiLCJsb2FkcHJvZ3Jlc3MiLCJuZXR3b3JrRGV0YWlscyIsIl91cmwiLCJfYnl0ZVJhbmdlIiwiX2RlY3J5cHRkYXRhIiwidGFnTGlzdCIsInJhd1Byb2dyYW1EYXRlVGltZSIsIl9lbGVtZW50YXJ5U3RyZWFtcyIsInNlZ21lbnROdW1iZXIiLCJ1aW50OFZpZXciLCJsZXZlbGtleSIsInVyaSIsIkxldmVsS2V5IiwiYmFzZXVyaSIsInJlbHVyaSIsImNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yIiwicmVsdXJsIiwiYmFzZXVybCIsInJhd0J5dGVSYW5nZSIsImJ5dGVSYW5nZSIsInBhcmFtcyIsInNwbGl0IiwibGFzdEJ5dGVSYW5nZUVuZE9mZnNldCIsImZyYWdtZW50RGVjcnlwdGRhdGFGcm9tTGV2ZWxrZXkiLCJkZWNyeXB0a2V5IiwiZGVjcnlwdHVybCIsIl91cmkiLCJMZXZlbCIsImJhc2VVcmwiLCJlbmRDQyIsIm5lZWRTaWR4UmFuZ2VzIiwic3RhcnRDQyIsIk1BU1RFUl9QTEFZTElTVF9SRUdFWCIsIk1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCIsIkxFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QiLCJSZWdFeHAiLCJzb3VyY2UiLCJqb2luIiwiTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyIsIk1QNF9SRUdFWF9TVUZGSVgiLCJNM1U4UGFyc2VyIiwiZ3JvdXBzIiwibWVkaWFHcm91cElkIiwibWF0Y2hpbmdHcm91cCIsImdyb3VwIiwiYXZjZGF0YSIsInN1YnN0ciIsInN0cmluZyIsInNldENvZGVjcyIsImNvZGVjcyIsImZpbHRlcmVkIiwicHJlZmVycmVkIiwibGFzdEluZGV4T2YiLCJ1bmtub3duQ29kZWNzIiwiZXhlYyIsIkF0dHJMaXN0IiwicmVzb2x2ZSIsInJlc29sdXRpb24iLCJkZWNpbWFsUmVzb2x1dGlvbiIsImRlY2ltYWxJbnRlZ2VyIiwiTkFNRSIsIkNPREVDUyIsImNvbnZlcnRBVkMxVG9BVkNPVEkiLCJhdWRpb0dyb3VwcyIsIm1lZGlhcyIsIlRZUEUiLCJERUZBVUxUIiwiYXV0b3NlbGVjdCIsIkFVVE9TRUxFQ1QiLCJmb3JjZWQiLCJGT1JDRUQiLCJVUkkiLCJMQU5HVUFHRSIsImdyb3VwQ29kZWMiLCJmaW5kR3JvdXAiLCJsZXZlbFVybElkIiwiY3VycmVudFNOIiwiZmlyc3RQZHRJbmRleCIsInBhcnNlRmxvYXQiLCJ0aXRsZSIsImFzc2lnblByb2dyYW1EYXRlVGltZSIsIm1hdGNoIiwidmFsdWUxIiwidmFsdWUyIiwidG9VcHBlckNhc2UiLCJkZWNyeXB0cGFyYW1zIiwia2V5QXR0cnMiLCJkZWNyeXB0bWV0aG9kIiwiZW51bWVyYXRlZFN0cmluZyIsImRlY3J5cHR1cmkiLCJkZWNyeXB0aXYiLCJoZXhhZGVjaW1hbEludGVnZXIiLCJzdGFydFBhcmFtcyIsInN0YXJ0QXR0cnMiLCJkZWNpbWFsRmxvYXRpbmdQb2ludCIsIm1hcEF0dHJzIiwiQllURVJBTkdFIiwiZXZlcnkiLCJiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMiLCJzdGFydEluZGV4IiwiZnJhZ1ByZXYiLCJDb250ZXh0VHlwZSIsIk1BTklGRVNUIiwiTEVWRUwiLCJBVURJT19UUkFDSyIsIlNVQlRJVExFX1RSQUNLIiwiU1VCVElUTEUiLCJQTG9hZGVyIiwiTG9hZGVyIiwiSW50ZXJuYWxMb2FkZXIiLCJjb250ZXh0VHlwZSIsInJlc2V0SW50ZXJuYWxMb2FkZXIiLCJkZXN0cm95SW50ZXJuYWxMb2FkZXJzIiwiZ2V0SW50ZXJuYWxMb2FkZXIiLCJjcmVhdGVJbnRlcm5hbExvYWRlciIsImlzU2lkeFJlcXVlc3QiLCJfaGFuZGxlU2lkeFJlcXVlc3QiLCJfaGFuZGxlUGxheWxpc3RMb2FkZWQiLCJfaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IiLCJfaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QiLCJfaGFuZGxlTWFzdGVyUGxheWxpc3QiLCJfaGFuZGxlTmV0d29ya0Vycm9yIiwiZ2V0UmVzcG9uc2VVcmwiLCJwYXJzZU1hc3RlclBsYXlsaXN0IiwicGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhIiwiZW1iZWRkZWRBdWRpb0ZvdW5kIiwibGV2ZWxJZCIsIm1hcENvbnRleHRUb0xldmVsVHlwZSIsInBhcnNlTGV2ZWxQbGF5bGlzdCIsInNpbmdsZUxldmVsIiwic2lkeFVybCIsInNpZHhJbmZvIiwicGFyc2VTZWdtZW50SW5kZXgiLCJzaWR4UmVmZXJlbmNlcyIsInNlZ21lbnRSZWYiLCJzZWdSZWZJbmZvIiwiZXJyb3JEYXRhIiwiY2FuSGF2ZUxldmVscyIsImNhbkhhdmVRdWFsaXR5TGV2ZWxzIiwiQUFDIiwiTVA0IiwidHlwZXMiLCJhdmMxIiwiYXZjQyIsImJ0cnQiLCJkaW5mIiwiZHJlZiIsImVzZHMiLCJmdHlwIiwibWRhdCIsIm1kaWEiLCJtZmhkIiwibWluZiIsIm1vb2YiLCJtcDRhIiwibXZleCIsIm12aGQiLCJwYXNwIiwic2R0cCIsInN0YmwiLCJzdGNvIiwic3RzYyIsInN0c2QiLCJzdHN6Iiwic3R0cyIsInRydW4iLCJ0cmV4Iiwidm1oZCIsInNtaGQiLCJoYXNPd25Qcm9wZXJ0eSIsImNoYXJDb2RlQXQiLCJ2aWRlb0hkbHIiLCJhdWRpb0hkbHIiLCJIRExSX1RZUEVTIiwiU1RUUyIsIlNUU0MiLCJTVENPIiwiU1RTWiIsIlZNSEQiLCJTTUhEIiwiU1RTRCIsIm1ham9yQnJhbmQiLCJhdmMxQnJhbmQiLCJtaW5vclZlcnNpb24iLCJGVFlQIiwiYm94IiwiRElORiIsImFyZ3VtZW50cyIsInVwcGVyV29yZER1cmF0aW9uIiwibG93ZXJXb3JkRHVyYXRpb24iLCJib3hlcyIsImZsYWdzIiwiZGVwZW5kc09uIiwiaXNEZXBlbmRlZE9uIiwiaGFzUmVkdW5kYW5jeSIsImF2Y2MiLCJoU3BhY2luZyIsInZTcGFjaW5nIiwiY29uZmlnbGVuIiwic2FtcGxlRGVwZW5kZW5jeVRhYmxlIiwidXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSIsImxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUiLCJhcnJheWxlbiIsImN0cyIsImlzTGVhZGluZyIsInBhZGRpbmdWYWx1ZSIsImlzTm9uU3luYyIsImRlZ3JhZFByaW8iLCJpbml0IiwibW92aWUiLCJNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OIiwiaXNTYWZhcmkiLCJJU0dlbmVyYXRlZCIsImRlZmF1bHRUaW1lU3RhbXAiLCJnZW5lcmF0ZUlTIiwibmJBdWRpb1NhbXBsZXMiLCJuYlZpZGVvU2FtcGxlcyIsImF1ZGlvVGltZU9mZnNldCIsInZpZGVvVGltZU9mZnNldCIsImF1ZGlvdmlkZW9EZWx0YUR0cyIsInJlbXV4QXVkaW8iLCJhdWRpb1RyYWNrTGVuZ3RoIiwicmVtdXhWaWRlbyIsInZpZGVvRGF0YSIsInJlbXV4RW1wdHlBdWRpbyIsInJlbXV4SUQzIiwicmVtdXhUZXh0IiwiYXVkaW9TYW1wbGVzIiwidmlkZW9TYW1wbGVzIiwiY29tcHV0ZVBUU0RUUyIsImluaXREVFMiLCJtcDRTYW1wbGVEdXJhdGlvbiIsImZpcnN0UFRTIiwiZmlyc3REVFMiLCJsYXN0UFRTIiwibGFzdERUUyIsInRpbWVTY2FsZSIsImlucHV0U2FtcGxlcyIsIm91dHB1dFNhbXBsZXMiLCJwdHNOb3JtYWxpemUiLCJfUFRTTm9ybWFsaXplIiwibmV4dEF2Y0R0cyIsImRlbHRhZHRzIiwiZGVsdGFwdHMiLCJQVFNEVFNzaGlmdCIsImN1cnIiLCJuYk5hbHUiLCJuYWx1TGVuIiwibmJVbml0cyIsInNhbXBsZUxlbiIsIm1kYXRTaXplIiwic2V0VWludDMyIiwiYXZjU2FtcGxlVW5pdHMiLCJtcDRTYW1wbGVMZW5ndGgiLCJjb21wb3NpdGlvblRpbWVPZmZzZXQiLCJ1bml0RGF0YSIsInVuaXREYXRhTGVuIiwibGFzdEZyYW1lRHVyYXRpb24iLCJnYXBUb2xlcmFuY2UiLCJkZWx0YVRvRnJhbWVFbmQiLCJuZXh0QXVkaW9QdHMiLCJtcDR0aW1lU2NhbGUiLCJzY2FsZUZhY3RvciIsImlucHV0U2FtcGxlRHVyYXRpb24iLCJyYXdNUEVHIiwibXA0U2FtcGxlIiwiZmlsbEZyYW1lIiwibmV4dFB0cyIsIm1pc3NpbmciLCJuZXdTdGFtcCIsImdldFNpbGVudEZyYW1lIiwiYXVkaW9TYW1wbGUiLCJudW1NaXNzaW5nRnJhbWVzIiwidW5pdExlbiIsImxhc3RTYW1wbGVEdXJhdGlvbiIsInNhbXBsZUR1cmF0aW9uIiwic2lsZW50RnJhbWUiLCJyZWZlcmVuY2UiLCJyYXdEYXRhIiwiX3RpY2tJbnRlcnZhbCIsIl90aWNrVGltZXIiLCJfdGlja0NhbGxDb3VudCIsIl9ib3VuZFRpY2siLCJtaWxsaXMiLCJkb1RpY2siLCJERUNJTUFMX1JFU09MVVRJT05fUkVHRVgiLCJBVFRSX0xJU1RfUkVHRVgiLCJwYXJzZUF0dHJMaXN0IiwiYXR0ciIsImF0dHJOYW1lIiwiaW50VmFsdWUiLCJNQVhfU0FGRV9JTlRFR0VSIiwic3RyaW5nVmFsdWUiLCJyZXMiLCJpbnB1dCIsInF1b3RlIiwibGlzdCIsImNvbXBhcmlzb25GdW5jdGlvbiIsIm1pbkluZGV4IiwibWF4SW5kZXgiLCJjdXJyZW50SW5kZXgiLCJjdXJyZW50RWxlbWVudCIsImNvbXBhcmlzb25SZXN1bHQiLCJtYXhIb2xlRHVyYXRpb24iLCJ2YnVmZmVyZWQiLCJidWZmZXJlZDIiLCJidWZmZXJTdGFydCIsImJ1ZmZlclN0YXJ0TmV4dCIsImRpZmYiLCJidWYybGVuIiwiYnVmMmVuZCIsInNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzIiwiZ2V0Q2hhckZvckJ5dGUiLCJieXRlIiwiY2hhckNvZGUiLCJOUl9ST1dTIiwiTlJfQ09MUyIsInJvd3NMb3dDaDEiLCJyb3dzSGlnaENoMSIsInJvd3NMb3dDaDIiLCJyb3dzSGlnaENoMiIsImJhY2tncm91bmRDb2xvcnMiLCJ2ZXJib3NlRmlsdGVyIiwidmVyYm9zZUxldmVsIiwic2V0VGltZSIsIm5ld1RpbWUiLCJzZXZlcml0eSIsIm1zZyIsIm1pbkxldmVsIiwibnVtQXJyYXlUb0hleEFycmF5IiwibnVtQXJyYXkiLCJoZXhBcnJheSIsIlBlblN0YXRlIiwiZm9yZWdyb3VuZCIsInVuZGVybGluZSIsIml0YWxpY3MiLCJiYWNrZ3JvdW5kIiwiZmxhc2giLCJzdHlsZXMiLCJhdHRyaWJzIiwic3R5bGUiLCJvdGhlciIsIm5ld1BlblN0YXRlIiwiU3R5bGVkVW5pY29kZUNoYXIiLCJ1Y2hhciIsInBlblN0YXRlIiwiY29weSIsImVxdWFscyIsIm5ld0NoYXIiLCJpc0RlZmF1bHQiLCJSb3ciLCJjaGFycyIsImN1cnJQZW5TdGF0ZSIsImVxdWFsIiwiZW1wdHkiLCJpc0VtcHR5IiwiYWJzUG9zIiwicmVsUG9zIiwibmV3UG9zIiwic2V0UGVuU3RhdGUiLCJzZXRDdXJzb3IiLCJtb3ZlQ3Vyc29yIiwic2V0Q2hhciIsImJhY2tTcGFjZSIsImNoYXIiLCJzdGFydFBvcyIsImNsZWFyRnJvbVBvcyIsInNldFN0eWxlcyIsImN1cnJDaGFyIiwiQ2FwdGlvblNjcmVlbiIsInJvd3MiLCJjdXJyUm93IiwibnJSb2xsVXBSb3dzIiwiY2xlYXIiLCJyb3ciLCJjbGVhclRvRW5kT2ZSb3ciLCJpbnNlcnRDaGFyIiwic2V0UGVuU3R5bGVzIiwicGFjRGF0YSIsIm5ld1JvdyIsInRvcFJvd0luZGV4IiwibGFzdE91dHB1dFNjcmVlbiIsInByZXZMaW5lVGltZSIsImN1ZVN0YXJ0VGltZSIsImluZGVudCIsInByZXZQb3MiLCJjb2xvciIsInNldFBlbiIsImJrZ0RhdGEiLCJuclJvd3MiLCJnZXREaXNwbGF5VGV4dCIsInRvcFJvdyIsImFzT25lUm93IiwiZGlzcGxheVRleHQiLCJyb3dOciIsInJvd1RleHQiLCJnZXRUZXh0U3RyaW5nIiwidHJpbSIsIkNlYTYwOENoYW5uZWwiLCJjaGFubmVsTnVtYmVyIiwib3V0cHV0RmlsdGVyIiwiY2hOciIsInZlcmJvc2UiLCJkaXNwbGF5ZWRNZW1vcnkiLCJub25EaXNwbGF5ZWRNZW1vcnkiLCJjdXJyUm9sbFVwUm93Iiwid3JpdGVTY3JlZW4iLCJsYXN0Q3VlRW5kVGltZSIsIm5ld0hhbmRsZXIiLCJzZXRQQUMiLCJzZXRCa2dEYXRhIiwibmV3TW9kZSIsIm91dHB1dERhdGFVcGRhdGUiLCJzZXRNb2RlIiwic2V0Um9sbFVwUm93cyIsInJvbGxVcCIsIm5yQ29scyIsImNvbG9ySW5kZXgiLCJjb2xvcnMiLCJkaXNwYXRjaCIsImRpc3BhdGNoQ3VlIiwiZmllbGQiLCJvdXQxIiwib3V0MiIsIm91dHB1dHMiLCJjaGFubmVscyIsImN1cnJDaE5yIiwibGFzdENtZEEiLCJsYXN0Q21kQiIsImJ1ZmZlcmVkRGF0YSIsImRhdGFDb3VudGVycyIsImdldEhhbmRsZXIiLCJzZXRIYW5kbGVyIiwiYnl0ZUxpc3QiLCJjbWRGb3VuZCIsImNoYXJzRm91bmQiLCJwYWRkaW5nIiwicGFyc2VDbWQiLCJwYXJzZU1pZHJvdyIsInBhcnNlUEFDIiwicGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyIsInBhcnNlQ2hhcnMiLCJjaGFubmVsIiwiaW5zZXJ0Q2hhcnMiLCJjb25kMSIsImNvbmQyIiwiY2NSQ0wiLCJjY0JTIiwiY2NBT0YiLCJjY0FPTiIsImNjREVSIiwiY2NSVSIsImNjRk9OIiwiY2NSREMiLCJjY1RSIiwiY2NSVEQiLCJjY0VETSIsImNjQ1IiLCJjY0VOTSIsImNjRU9DIiwiY2NUTyIsImNjTUlEUk9XIiwiY2FzZTEiLCJjYXNlMiIsImludGVycHJldFBBQyIsInBhY0luZGV4IiwiY2hhbm5lbE5yIiwiY2hhckNvZGVzIiwiY2hhckNvZGUxIiwib25lQ29kZSIsImhleENvZGVzIiwiY3VlU3BsaXRBdFRpbWUiLCJzYW1wbGVFbnRyeUNvZGVzSVNPIiwiaXNDb2RlY1R5cGUiLCJ0eXBlQ29kZXMiLCJpc0NvZGVjU3VwcG9ydGVkSW5NcDQiLCJjYXB0aW9uU2NyZWVuIiwiaW5kZW50aW5nIiwiciIsImxpbmUiLCJhbGlnbiIsImZpbmRGaXJzdEZyYWdXaXRoQ0MiLCJmaW5kRnJhZ1dpdGhDQyIsInNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMiLCJmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWciLCJhZGp1c3RQdHMiLCJhbGlnblN0cmVhbSIsImFsaWduRGlzY29udGludWl0aWVzIiwiYWxpZ25QRFQiLCJmaXJzdEZyYWciLCJjdXJyZW50RnJhZyIsIkNDIiwic2hvdWxkQWxpZ24iLCJwcmV2RGV0YWlscyIsInByZXZGcmFncyIsImN1ckZyYWdzIiwicHJldlN0YXJ0RnJhZyIsInJlZmVyZW5jZUZyYWciLCJsYXN0RGV0YWlscyIsImxhc3RQRFQiLCJuZXdQRFQiLCJzbG93IiwiZmFzdCIsImRlZmF1bHRFc3RpbWF0ZSIsImRlZmF1bHRFc3RpbWF0ZV8iLCJtaW5XZWlnaHRfIiwibWluRGVsYXlNc18iLCJzbG93XyIsIkVXTUEiLCJmYXN0XyIsImR1cmF0aW9uTXMiLCJudW1CeXRlcyIsImJhbmR3aWR0aCIsIndlaWdodCIsImdldFRvdGFsV2VpZ2h0IiwiaGFsZkxpZmUiLCJhbHBoYV8iLCJleHAiLCJlc3RpbWF0ZV8iLCJ0b3RhbFdlaWdodF8iLCJhZGpBbHBoYSIsInplcm9GYWN0b3IiLCJnZXRTZWxmU2NvcGUiLCJub29wIiwiZmFrZUxvZ2dlciIsImV4cG9ydGVkTG9nZ2VyIiwiZm9ybWF0TXNnIiwiY29uc29sZVByaW50Rm4iLCJmdW5jIiwiYXJncyIsImV4cG9ydExvZ2dlckZ1bmN0aW9ucyIsImRlYnVnQ29uZmlnIiwiZnVuY3Rpb25zIiwiZW5hYmxlTG9ncyIsImdldE1lZGlhU291cmNlIiwiV2ViS2l0TWVkaWFTb3VyY2UiLCJhZGRDdWVzIiwiY3JlYXRlQ2FwdGlvbnNUcmFjayIsInNlbmRBZGRUcmFja0V2ZW50IiwiY2xlYXJDdXJyZW50Q3VlcyIsInZpZGVvRWwiLCJkb2N1bWVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsInJlbW92ZUN1ZSIsImF1dG9LZXl3b3JkIiwiZGlyZWN0aW9uU2V0dGluZyIsImxyIiwicmwiLCJhbGlnblNldHRpbmciLCJtaWRkbGUiLCJsZWZ0IiwicmlnaHQiLCJmaW5kRGlyZWN0aW9uU2V0dGluZyIsImRpciIsImZpbmRBbGlnblNldHRpbmciLCJleHRlbmQiLCJvYmoiLCJjb2JqIiwicCIsImlzSUU4IiwiYmFzZU9iaiIsImNyZWF0ZUVsZW1lbnQiLCJlbnVtZXJhYmxlIiwiaGFzQmVlblJlc2V0IiwiX2lkIiwiX3BhdXNlT25FeGl0IiwiX3N0YXJ0VGltZSIsIl9lbmRUaW1lIiwiX3RleHQiLCJfcmVnaW9uIiwiX3ZlcnRpY2FsIiwiX3NuYXBUb0xpbmVzIiwiX2xpbmUiLCJfbGluZUFsaWduIiwiX3Bvc2l0aW9uIiwiX3Bvc2l0aW9uQWxpZ24iLCJfc2l6ZSIsIl9hbGlnbiIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiVHlwZUVycm9yIiwic2V0dGluZyIsIlN5bnRheEVycm9yIiwiZGlzcGxheVN0YXRlIiwiZ2V0Q3VlQXNIVE1MIiwiV2ViVlRUIiwiY29udmVydEN1ZVRvRE9NVHJlZSIsIlN0cmluZ0RlY29kZXIiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJWVFRQYXJzZXIiLCJkZWNvZGVyIiwicmVnaW9uTGlzdCIsInBhcnNlVGltZVN0YW1wIiwiY29tcHV0ZVNlY29uZHMiLCJtIiwicyIsImYiLCJTZXR0aW5ncyIsInZhbHVlcyIsImsiLCJ2IiwiZGZsdCIsImRlZmF1bHRLZXkiLCJoYXMiLCJhbHQiLCJuIiwiaW50ZWdlciIsInBlcmNlbnQiLCJwYXJzZU9wdGlvbnMiLCJrZXlWYWx1ZURlbGltIiwiZ3JvdXBEZWxpbSIsImt2IiwiZGVmYXVsdHMiLCJjZW50ZXIiLCJwYXJzZUN1ZSIsIm9JbnB1dCIsImNvbnN1bWVUaW1lU3RhbXAiLCJ0cyIsImNvbnN1bWVDdWVTZXR0aW5ncyIsInNldHRpbmdzIiwicmVnaW9uIiwidmFscyIsInZhbHMwIiwidmVydGljYWwiLCJsaW5lQWxpZ24iLCJzbmFwVG9MaW5lcyIsInNraXBXaGl0ZXNwYWNlIiwiZml4TGluZUJyZWFrcyIsImNvbGxlY3ROZXh0TGluZSIsImFscmVhZHlDb2xsZWN0ZWRMaW5lIiwiaGFzU3Vic3RyaW5nIiwib25jdWUiLCJmbHVzaCIsIm9uZmx1c2giLCJzdGFydHNXaXRoIiwiaW5wdXRTdHJpbmciLCJzZWFyY2hTdHJpbmciLCJjdWVTdHJpbmcybWlsbGlzIiwidGltZVN0cmluZyIsInNlY3MiLCJtaW5zIiwiaG91cnMiLCJoYXNoIiwiY2FsY3VsYXRlT2Zmc2V0IiwicHJlc2VudGF0aW9uVGltZSIsImN1cnJDQyIsInZ0dEJ5dGVBcnJheSIsInN5bmNQVFMiLCJjYWxsQmFjayIsImVycm9yQ2FsbEJhY2siLCJyZSIsInZ0dExpbmVzIiwiY3VlVGltZSIsIm1wZWdUcyIsImxvY2FsVGltZSIsInBhcnNpbmdFcnJvciIsImluSGVhZGVyIiwicGFyc2VyIiwiY3VlT2Zmc2V0Iiwib25wYXJzaW5nZXJyb3IiLCJyZXF1ZXN0VGltZW91dCIsInJldHJ5VGltZW91dCIsImNhbGxiYWNrcyIsInJldHJ5IiwibG9hZEludGVybmFsIiwic2V0UmVxdWVzdEhlYWRlciIsInJlYWR5c3RhdGVjaGFuZ2UiLCJvbnByb2dyZXNzIiwiY3VycmVudFRhcmdldCIsInJlc3BvbnNlVGV4dCIsInJlc3BvbnNlVVJMIiwibGVuZ3RoQ29tcHV0YWJsZSIsIkhsc0pzUGxheWVyIiwib3B0aW9ucyIsImhsc09wdHMiLCJ1dGlsIiwiUGxheWVyIiwicGxheWVyIiwiYnJvd3NlciIsInV0aWxzIiwiZ2V0QnJvd3NlclZlcnNpb24iLCJ1c2VIbHMiLCJzbmlmZmVyIiwiZGV2aWNlIiwicGxhdGZvcm0iLCJjdXJyZW50U3JjIiwicmVtb3ZlQ2xhc3MiLCJyb290IiwibGl2ZURvbSIsInF1ZXJ5U2VsZWN0b3IiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJyZWdpc3RlciIsIm9uY2UiLCJsb2FkU291cmNlIiwiY29uZmlndXJhYmxlIiwiYXV0b3BsYXkiLCJhZGRDbGFzcyIsImZpbmREb20iLCJjcmVhdGVEb20iLCJjb250cm9scyIsImFwcGVuZENoaWxkIiwiRXZlbnRzIiwiaW5pdGVkIiwiZXJyb3JUeXBlIiwiZXJyb3JGYXRhbCIsInJlY292ZXJNZWRpYUVycm9yIiwiX3N0YXRpc3RpY3MiLCJzdGF0c0luZm8iLCJzcGVlZCIsInBsYXllclR5cGUiLCJtZWRpYWluZm8iLCJ2aWRlb0RhdGFSYXRlIiwiYXVkaW9EYXRhUmF0ZSIsImZsYWciLCJmcHMiLCJhdWRpb0NoYW5uZWxDb3VudCIsIl9zdGF0aXN0aWNzVGltbWVyIiwidmVyc2lvblRyaWRlbnQiXSwibWFwcGluZ3MiOiI7O1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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SUFBMkIsQ0FBekM7QUFDQSxhQUFPLFFBQU14OUIsU0FBYjtBQUNEO0FBQ0YsR0FWTSxNQVVBO0FBQ0wsV0FBTyxTQUFQO0FBQ0Q7QUFDRixDQXpDRDs7a0JBMkNlNjZCLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdDZixhQUFhLG1DQUFtQyxFQUFFLEkiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBSZWZsZWN0QXBwbHkodGhpcy5saXN0ZW5lciwgdGhpcy50YXJnZXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiIsIi8vIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTgwOFxuXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4oZnVuY3Rpb24ocm9vdCkgeyBcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbiAgdmFyIFVSTF9SRUdFWCA9IC9eKCg/OlthLXpBLVowLTkrXFwtLl0rOik/KShcXC9cXC9bXlxcLz8jXSopPygoPzpbXlxcL1xcPyNdKlxcLykqLio/KT8/KDsuKj8pPyhcXD8uKj8pPygjLio/KT8kLztcbiAgdmFyIEZJUlNUX1NFR01FTlRfUkVHRVggPSAvXihbXlxcLz8jXSopKC4qKSQvO1xuICB2YXIgU0xBU0hfRE9UX1JFR0VYID0gLyg/OlxcL3xeKVxcLig/PVxcLykvZztcbiAgdmFyIFNMQVNIX0RPVF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuXFwuXFwvKD8hXFwuXFwuXFwvKS4qPyg/PVxcLykvZztcblxuICB2YXIgVVJMVG9vbGtpdCA9IHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgLy8gSWYgb3B0cy5hbHdheXNOb3JtYWxpemUgaXMgdHJ1ZSB0aGVuIHRoZSBwYXRoIHdpbGwgYWx3YXlzIGJlIG5vcm1hbGl6ZWQgZXZlbiB3aGVuIGl0IHN0YXJ0cyB3aXRoIC8gb3IgLy9cbiAgICAvLyBFLmdcbiAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gZmFsc2UgKGRlZmF1bHQsIHNwZWMgY29tcGxpYW50KVxuICAgIC8vIGh0dHA6Ly9hLmNvbS9iL2NkICsgL2UvZi8uLi9nID0+IGh0dHA6Ly9hLmNvbS9lL2YvLi4vZ1xuICAgIC8vIFdpdGggb3B0cy5hbHdheXNOb3JtYWxpemUgPSB0cnVlIChub3Qgc3BlYyBjb21wbGlhbnQpXG4gICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZ1xuICAgIGJ1aWxkQWJzb2x1dGVVUkw6IGZ1bmN0aW9uKGJhc2VVUkwsIHJlbGF0aXZlVVJMLCBvcHRzKSB7XG4gICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgIC8vIHJlbW92ZSBhbnkgcmVtYWluaW5nIHNwYWNlIGFuZCBDUkxGXG4gICAgICBiYXNlVVJMID0gYmFzZVVSTC50cmltKCk7XG4gICAgICByZWxhdGl2ZVVSTCA9IHJlbGF0aXZlVVJMLnRyaW0oKTtcbiAgICAgIGlmICghcmVsYXRpdmVVUkwpIHtcbiAgICAgICAgLy8gMmEpIElmIHRoZSBlbWJlZGRlZCBVUkwgaXMgZW50aXJlbHkgZW1wdHksIGl0IGluaGVyaXRzIHRoZVxuICAgICAgICAvLyBlbnRpcmUgYmFzZSBVUkwgKGkuZS4sIGlzIHNldCBlcXVhbCB0byB0aGUgYmFzZSBVUkwpXG4gICAgICAgIC8vIGFuZCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuICAgICAgICAgIHJldHVybiBiYXNlVVJMO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXNlUGFydHNGb3JOb3JtYWxpc2UgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xuICAgICAgICBpZiAoIWJhc2VQYXJ0c0Zvck5vcm1hbGlzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xuICAgICAgICB9XG4gICAgICAgIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZS5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKGJhc2VQYXJ0c0Zvck5vcm1hbGlzZS5wYXRoKTtcbiAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYmFzZVBhcnRzRm9yTm9ybWFsaXNlKTtcbiAgICAgIH1cbiAgICAgIHZhciByZWxhdGl2ZVBhcnRzID0gVVJMVG9vbGtpdC5wYXJzZVVSTChyZWxhdGl2ZVVSTCk7XG4gICAgICBpZiAoIXJlbGF0aXZlUGFydHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgcmVsYXRpdmUgVVJMLicpO1xuICAgICAgfVxuICAgICAgaWYgKHJlbGF0aXZlUGFydHMuc2NoZW1lKSB7XG4gICAgICAgIC8vIDJiKSBJZiB0aGUgZW1iZWRkZWQgVVJMIHN0YXJ0cyB3aXRoIGEgc2NoZW1lIG5hbWUsIGl0IGlzXG4gICAgICAgIC8vIGludGVycHJldGVkIGFzIGFuIGFic29sdXRlIFVSTCBhbmQgd2UgYXJlIGRvbmUuXG4gICAgICAgIGlmICghb3B0cy5hbHdheXNOb3JtYWxpemUpIHtcbiAgICAgICAgICByZXR1cm4gcmVsYXRpdmVVUkw7XG4gICAgICAgIH1cbiAgICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKHJlbGF0aXZlUGFydHMucGF0aCk7XG4gICAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKHJlbGF0aXZlUGFydHMpO1xuICAgICAgfVxuICAgICAgdmFyIGJhc2VQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwoYmFzZVVSTCk7XG4gICAgICBpZiAoIWJhc2VQYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC4nKTtcbiAgICAgIH1cbiAgICAgIGlmICghYmFzZVBhcnRzLm5ldExvYyAmJiBiYXNlUGFydHMucGF0aCAmJiBiYXNlUGFydHMucGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICAgIC8vIElmIG5ldExvYyBtaXNzaW5nIGFuZCBwYXRoIGRvZXNuJ3Qgc3RhcnQgd2l0aCAnLycsIGFzc3VtZSBldmVydGhpbmcgYmVmb3JlIHRoZSBmaXJzdCAnLycgaXMgdGhlIG5ldExvY1xuICAgICAgICAvLyBUaGlzIGNhdXNlcyAnZXhhbXBsZS5jb20vYScgdG8gYmUgaGFuZGxlZCBhcyAnLy9leGFtcGxlLmNvbS9hJyBpbnN0ZWFkIG9mICcvZXhhbXBsZS5jb20vYSdcbiAgICAgICAgdmFyIHBhdGhQYXJ0cyA9IEZJUlNUX1NFR01FTlRfUkVHRVguZXhlYyhiYXNlUGFydHMucGF0aCk7XG4gICAgICAgIGJhc2VQYXJ0cy5uZXRMb2MgPSBwYXRoUGFydHNbMV07XG4gICAgICAgIGJhc2VQYXJ0cy5wYXRoID0gcGF0aFBhcnRzWzJdO1xuICAgICAgfVxuICAgICAgaWYgKGJhc2VQYXJ0cy5uZXRMb2MgJiYgIWJhc2VQYXJ0cy5wYXRoKSB7XG4gICAgICAgIGJhc2VQYXJ0cy5wYXRoID0gJy8nO1xuICAgICAgfVxuICAgICAgdmFyIGJ1aWx0UGFydHMgPSB7XG4gICAgICAgIC8vIDJjKSBPdGhlcndpc2UsIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIHNjaGVtZSBvZlxuICAgICAgICAvLyB0aGUgYmFzZSBVUkwuXG4gICAgICAgIHNjaGVtZTogYmFzZVBhcnRzLnNjaGVtZSxcbiAgICAgICAgbmV0TG9jOiByZWxhdGl2ZVBhcnRzLm5ldExvYyxcbiAgICAgICAgcGF0aDogbnVsbCxcbiAgICAgICAgcGFyYW1zOiByZWxhdGl2ZVBhcnRzLnBhcmFtcyxcbiAgICAgICAgcXVlcnk6IHJlbGF0aXZlUGFydHMucXVlcnksXG4gICAgICAgIGZyYWdtZW50OiByZWxhdGl2ZVBhcnRzLmZyYWdtZW50XG4gICAgICB9O1xuICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLm5ldExvYykge1xuICAgICAgICAvLyAzKSBJZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPG5ldF9sb2M+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuICAgICAgICAvLyBTdGVwIDcuICBPdGhlcndpc2UsIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIDxuZXRfbG9jPlxuICAgICAgICAvLyAoaWYgYW55KSBvZiB0aGUgYmFzZSBVUkwuXG4gICAgICAgIGJ1aWx0UGFydHMubmV0TG9jID0gYmFzZVBhcnRzLm5ldExvYztcbiAgICAgICAgLy8gNCkgSWYgdGhlIGVtYmVkZGVkIFVSTCBwYXRoIGlzIHByZWNlZGVkIGJ5IGEgc2xhc2ggXCIvXCIsIHRoZVxuICAgICAgICAvLyBwYXRoIGlzIG5vdCByZWxhdGl2ZSBhbmQgd2Ugc2tpcCB0byBTdGVwIDcuXG4gICAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xuICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5wYXRoKSB7XG4gICAgICAgICAgICAvLyA1KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgZW1wdHkgKGFuZCBub3QgcHJlY2VkZWQgYnkgYVxuICAgICAgICAgICAgLy8gc2xhc2gpLCB0aGVuIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIGJhc2UgVVJMIHBhdGhcbiAgICAgICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgLy8gNWEpIGlmIHRoZSBlbWJlZGRlZCBVUkwncyA8cGFyYW1zPiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHBhcmFtcz4gb2YgdGhlIGJhc2VcbiAgICAgICAgICAgIC8vIFVSTCAoaWYgYW55KSBhbmRcbiAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXJhbXMgPSBiYXNlUGFydHMucGFyYW1zO1xuICAgICAgICAgICAgICAvLyA1YikgaWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxxdWVyeT4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG4gICAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHF1ZXJ5PiBvZiB0aGUgYmFzZVxuICAgICAgICAgICAgICAvLyBVUkwgKGlmIGFueSkgYW5kIHdlIHNraXAgdG8gc3RlcCA3LlxuICAgICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucXVlcnkpIHtcbiAgICAgICAgICAgICAgICBidWlsdFBhcnRzLnF1ZXJ5ID0gYmFzZVBhcnRzLnF1ZXJ5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIDYpIFRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGJhc2UgVVJMJ3MgcGF0aCAoYW55dGhpbmdcbiAgICAgICAgICAgIC8vIGZvbGxvd2luZyB0aGUgcmlnaHRtb3N0IHNsYXNoIFwiL1wiLCBvciB0aGUgZW50aXJlIHBhdGggaWYgbm9cbiAgICAgICAgICAgIC8vIHNsYXNoIGlzIHByZXNlbnQpIGlzIHJlbW92ZWQgYW5kIHRoZSBlbWJlZGRlZCBVUkwncyBwYXRoIGlzXG4gICAgICAgICAgICAvLyBhcHBlbmRlZCBpbiBpdHMgcGxhY2UuXG4gICAgICAgICAgICB2YXIgYmFzZVVSTFBhdGggPSBiYXNlUGFydHMucGF0aDtcbiAgICAgICAgICAgIHZhciBuZXdQYXRoID0gYmFzZVVSTFBhdGguc3Vic3RyaW5nKDAsIGJhc2VVUkxQYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKSArIHJlbGF0aXZlUGFydHMucGF0aDtcbiAgICAgICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChuZXdQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChidWlsdFBhcnRzLnBhdGggPT09IG51bGwpIHtcbiAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gb3B0cy5hbHdheXNOb3JtYWxpemUgPyBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgocmVsYXRpdmVQYXJ0cy5wYXRoKSA6IHJlbGF0aXZlUGFydHMucGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKGJ1aWx0UGFydHMpO1xuICAgIH0sXG4gICAgcGFyc2VVUkw6IGZ1bmN0aW9uKHVybCkge1xuICAgICAgdmFyIHBhcnRzID0gVVJMX1JFR0VYLmV4ZWModXJsKTtcbiAgICAgIGlmICghcGFydHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWU6IHBhcnRzWzFdIHx8ICcnLFxuICAgICAgICBuZXRMb2M6IHBhcnRzWzJdIHx8ICcnLFxuICAgICAgICBwYXRoOiBwYXJ0c1szXSB8fCAnJyxcbiAgICAgICAgcGFyYW1zOiBwYXJ0c1s0XSB8fCAnJyxcbiAgICAgICAgcXVlcnk6IHBhcnRzWzVdIHx8ICcnLFxuICAgICAgICBmcmFnbWVudDogcGFydHNbNl0gfHwgJydcbiAgICAgIH07XG4gICAgfSxcbiAgICBub3JtYWxpemVQYXRoOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG9wZXJhdGlvbnMgYXJlXG4gICAgICAvLyB0aGVuIGFwcGxpZWQsIGluIG9yZGVyLCB0byB0aGUgbmV3IHBhdGg6XG4gICAgICAvLyA2YSkgQWxsIG9jY3VycmVuY2VzIG9mIFwiLi9cIiwgd2hlcmUgXCIuXCIgaXMgYSBjb21wbGV0ZSBwYXRoXG4gICAgICAvLyBzZWdtZW50LCBhcmUgcmVtb3ZlZC5cbiAgICAgIC8vIDZiKSBJZiB0aGUgcGF0aCBlbmRzIHdpdGggXCIuXCIgYXMgYSBjb21wbGV0ZSBwYXRoIHNlZ21lbnQsXG4gICAgICAvLyB0aGF0IFwiLlwiIGlzIHJlbW92ZWQuXG4gICAgICBwYXRoID0gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpLnJlcGxhY2UoU0xBU0hfRE9UX1JFR0VYLCAnJyk7XG4gICAgICAvLyA2YykgQWxsIG9jY3VycmVuY2VzIG9mIFwiPHNlZ21lbnQ+Ly4uL1wiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuICAgICAgLy8gY29tcGxldGUgcGF0aCBzZWdtZW50IG5vdCBlcXVhbCB0byBcIi4uXCIsIGFyZSByZW1vdmVkLlxuICAgICAgLy8gUmVtb3ZhbCBvZiB0aGVzZSBwYXRoIHNlZ21lbnRzIGlzIHBlcmZvcm1lZCBpdGVyYXRpdmVseSxcbiAgICAgIC8vIHJlbW92aW5nIHRoZSBsZWZ0bW9zdCBtYXRjaGluZyBwYXR0ZXJuIG9uIGVhY2ggaXRlcmF0aW9uLFxuICAgICAgLy8gdW50aWwgbm8gbWF0Y2hpbmcgcGF0dGVybiByZW1haW5zLlxuICAgICAgLy8gNmQpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIjxzZWdtZW50Pi8uLlwiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuICAgICAgLy8gY29tcGxldGUgcGF0aCBzZWdtZW50IG5vdCBlcXVhbCB0byBcIi4uXCIsIHRoYXRcbiAgICAgIC8vIFwiPHNlZ21lbnQ+Ly4uXCIgaXMgcmVtb3ZlZC5cbiAgICAgIHdoaWxlIChwYXRoLmxlbmd0aCAhPT0gKHBhdGggPSBwYXRoLnJlcGxhY2UoU0xBU0hfRE9UX0RPVF9SRUdFWCwgJycpKS5sZW5ndGgpIHt9IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgcmV0dXJuIHBhdGguc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbiAgICB9LFxuICAgIGJ1aWxkVVJMRnJvbVBhcnRzOiBmdW5jdGlvbihwYXJ0cykge1xuICAgICAgcmV0dXJuIHBhcnRzLnNjaGVtZSArIHBhcnRzLm5ldExvYyArIHBhcnRzLnBhdGggKyBwYXJ0cy5wYXJhbXMgKyBwYXJ0cy5xdWVyeSArIHBhcnRzLmZyYWdtZW50O1xuICAgIH1cbiAgfTtcblxuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBVUkxUb29sa2l0O1xuICBlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gVVJMVG9vbGtpdDsgfSk7XG4gIGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuICAgIGV4cG9ydHNbXCJVUkxUb29sa2l0XCJdID0gVVJMVG9vbGtpdDtcbiAgZWxzZVxuICAgIHJvb3RbXCJVUkxUb29sa2l0XCJdID0gVVJMVG9vbGtpdDtcbn0pKHRoaXMpO1xuLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiIsImZ1bmN0aW9uIHdlYnBhY2tCb290c3RyYXBGdW5jIChtb2R1bGVzKSB7XG4vKioqKioqLyAgLy8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gIHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovICAvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gIGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gICAgLy8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyAgICBpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovICAgICAgcmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovICAgIC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyAgICB2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyAgICAgIGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gICAgICBsOiBmYWxzZSxcbi8qKioqKiovICAgICAgZXhwb3J0czoge31cbi8qKioqKiovICAgIH07XG5cbi8qKioqKiovICAgIC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gICAgbW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovICAgIC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovICAgIG1vZHVsZS5sID0gdHJ1ZTtcblxuLyoqKioqKi8gICAgLy8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovICB9XG5cbi8qKioqKiovICAvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovICAvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovICAvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4vKioqKioqLyAgLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyAgICBpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gICAgICAgIGdldDogZ2V0dGVyXG4vKioqKioqLyAgICAgIH0pO1xuLyoqKioqKi8gICAgfVxuLyoqKioqKi8gIH07XG5cbi8qKioqKiovICAvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovICB9O1xuXG4vKioqKioqLyAgLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovICAgIHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gICAgICBmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gICAgICBmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gICAgcmV0dXJuIGdldHRlcjtcbi8qKioqKiovICB9O1xuXG4vKioqKioqLyAgLy8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4vKioqKioqLyAgLy8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuLyoqKioqKi8gIC8vIG9uIGVycm9yIGZ1bmN0aW9uIGZvciBhc3luYyBsb2FkaW5nXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5vZSA9IGZ1bmN0aW9uKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IHRocm93IGVycjsgfTtcblxuICB2YXIgZiA9IF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gRU5UUllfTU9EVUxFKVxuICByZXR1cm4gZi5kZWZhdWx0IHx8IGYgLy8gdHJ5IHRvIGNhbGwgZGVmYXVsdCBpZiBkZWZpbmVkIHRvIGFsc28gc3VwcG9ydCBiYWJlbCBlc21vZHVsZSBleHBvcnRzXG59XG5cbnZhciBtb2R1bGVOYW1lUmVxRXhwID0gJ1tcXFxcLnxcXFxcLXxcXFxcK3xcXFxcd3xcXC98QF0rJ1xudmFyIGRlcGVuZGVuY3lSZWdFeHAgPSAnXFxcXChcXFxccyooXFwvXFxcXCouKj9cXFxcKlxcLyk/XFxcXHMqLio/KCcgKyBtb2R1bGVOYW1lUmVxRXhwICsgJykuKj9cXFxcKScgLy8gYWRkaXRpb25hbCBjaGFycyB3aGVuIG91dHB1dC5wYXRoaW5mbyBpcyB0cnVlXG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI1OTM2NjEvMTMwNDQyXG5mdW5jdGlvbiBxdW90ZVJlZ0V4cCAoc3RyKSB7XG4gIHJldHVybiAoc3RyICsgJycpLnJlcGxhY2UoL1suPyorXiRbXFxdXFxcXCgpe318LV0vZywgJ1xcXFwkJicpXG59XG5cbmZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gIHJldHVybiAhaXNOYU4oMSAqIG4pOyAvLyAxICogbiBjb252ZXJ0cyBpbnRlZ2VycywgaW50ZWdlcnMgYXMgc3RyaW5nIChcIjEyM1wiKSwgMWUzIGFuZCBcIjFlM1wiIHRvIGludGVnZXJzIGFuZCBzdHJpbmdzIHRvIE5hTlxufVxuXG5mdW5jdGlvbiBnZXRNb2R1bGVEZXBlbmRlbmNpZXMgKHNvdXJjZXMsIG1vZHVsZSwgcXVldWVOYW1lKSB7XG4gIHZhciByZXR2YWwgPSB7fVxuICByZXR2YWxbcXVldWVOYW1lXSA9IFtdXG5cbiAgdmFyIGZuU3RyaW5nID0gbW9kdWxlLnRvU3RyaW5nKClcbiAgdmFyIHdyYXBwZXJTaWduYXR1cmUgPSBmblN0cmluZy5tYXRjaCgvXmZ1bmN0aW9uXFxzP1xcdypcXChcXHcrLFxccypcXHcrLFxccyooXFx3KylcXCkvKVxuICBpZiAoIXdyYXBwZXJTaWduYXR1cmUpIHJldHVybiByZXR2YWxcbiAgdmFyIHdlYnBhY2tSZXF1aXJlTmFtZSA9IHdyYXBwZXJTaWduYXR1cmVbMV1cblxuICAvLyBtYWluIGJ1bmRsZSBkZXBzXG4gIHZhciByZSA9IG5ldyBSZWdFeHAoJyhcXFxcXFxcXG58XFxcXFcpJyArIHF1b3RlUmVnRXhwKHdlYnBhY2tSZXF1aXJlTmFtZSkgKyBkZXBlbmRlbmN5UmVnRXhwLCAnZycpXG4gIHZhciBtYXRjaFxuICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhmblN0cmluZykpKSB7XG4gICAgaWYgKG1hdGNoWzNdID09PSAnZGxsLXJlZmVyZW5jZScpIGNvbnRpbnVlXG4gICAgcmV0dmFsW3F1ZXVlTmFtZV0ucHVzaChtYXRjaFszXSlcbiAgfVxuXG4gIC8vIGRsbCBkZXBzXG4gIHJlID0gbmV3IFJlZ0V4cCgnXFxcXCgnICsgcXVvdGVSZWdFeHAod2VicGFja1JlcXVpcmVOYW1lKSArICdcXFxcKFwiKGRsbC1yZWZlcmVuY2VcXFxccygnICsgbW9kdWxlTmFtZVJlcUV4cCArICcpKVwiXFxcXClcXFxcKScgKyBkZXBlbmRlbmN5UmVnRXhwLCAnZycpXG4gIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKGZuU3RyaW5nKSkpIHtcbiAgICBpZiAoIXNvdXJjZXNbbWF0Y2hbMl1dKSB7XG4gICAgICByZXR2YWxbcXVldWVOYW1lXS5wdXNoKG1hdGNoWzFdKVxuICAgICAgc291cmNlc1ttYXRjaFsyXV0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKG1hdGNoWzFdKS5tXG4gICAgfVxuICAgIHJldHZhbFttYXRjaFsyXV0gPSByZXR2YWxbbWF0Y2hbMl1dIHx8IFtdXG4gICAgcmV0dmFsW21hdGNoWzJdXS5wdXNoKG1hdGNoWzRdKVxuICB9XG5cbiAgLy8gY29udmVydCAxZTMgYmFjayB0byAxMDAwIC0gdGhpcyBjYW4gYmUgaW1wb3J0YW50IGFmdGVyIHVnbGlmeS1qcyBjb252ZXJ0ZWQgMTAwMCB0byAxZTNcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZXR2YWwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJldHZhbFtrZXlzW2ldXS5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGlzTnVtZXJpYyhyZXR2YWxba2V5c1tpXV1bal0pKSB7XG4gICAgICAgIHJldHZhbFtrZXlzW2ldXVtqXSA9IDEgKiByZXR2YWxba2V5c1tpXV1bal07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHZhbFxufVxuXG5mdW5jdGlvbiBoYXNWYWx1ZXNJblF1ZXVlcyAocXVldWVzKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocXVldWVzKVxuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc1ZhbHVlcywga2V5KSB7XG4gICAgcmV0dXJuIGhhc1ZhbHVlcyB8fCBxdWV1ZXNba2V5XS5sZW5ndGggPiAwXG4gIH0sIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBnZXRSZXF1aXJlZE1vZHVsZXMgKHNvdXJjZXMsIG1vZHVsZUlkKSB7XG4gIHZhciBtb2R1bGVzUXVldWUgPSB7XG4gICAgbWFpbjogW21vZHVsZUlkXVxuICB9XG4gIHZhciByZXF1aXJlZE1vZHVsZXMgPSB7XG4gICAgbWFpbjogW11cbiAgfVxuICB2YXIgc2Vlbk1vZHVsZXMgPSB7XG4gICAgbWFpbjoge31cbiAgfVxuXG4gIHdoaWxlIChoYXNWYWx1ZXNJblF1ZXVlcyhtb2R1bGVzUXVldWUpKSB7XG4gICAgdmFyIHF1ZXVlcyA9IE9iamVjdC5rZXlzKG1vZHVsZXNRdWV1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHF1ZXVlTmFtZSA9IHF1ZXVlc1tpXVxuICAgICAgdmFyIHF1ZXVlID0gbW9kdWxlc1F1ZXVlW3F1ZXVlTmFtZV1cbiAgICAgIHZhciBtb2R1bGVUb0NoZWNrID0gcXVldWUucG9wKClcbiAgICAgIHNlZW5Nb2R1bGVzW3F1ZXVlTmFtZV0gPSBzZWVuTW9kdWxlc1txdWV1ZU5hbWVdIHx8IHt9XG4gICAgICBpZiAoc2Vlbk1vZHVsZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSB8fCAhc291cmNlc1txdWV1ZU5hbWVdW21vZHVsZVRvQ2hlY2tdKSBjb250aW51ZVxuICAgICAgc2Vlbk1vZHVsZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSA9IHRydWVcbiAgICAgIHJlcXVpcmVkTW9kdWxlc1txdWV1ZU5hbWVdID0gcmVxdWlyZWRNb2R1bGVzW3F1ZXVlTmFtZV0gfHwgW11cbiAgICAgIHJlcXVpcmVkTW9kdWxlc1txdWV1ZU5hbWVdLnB1c2gobW9kdWxlVG9DaGVjaylcbiAgICAgIHZhciBuZXdNb2R1bGVzID0gZ2V0TW9kdWxlRGVwZW5kZW5jaWVzKHNvdXJjZXMsIHNvdXJjZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSwgcXVldWVOYW1lKVxuICAgICAgdmFyIG5ld01vZHVsZXNLZXlzID0gT2JqZWN0LmtleXMobmV3TW9kdWxlcylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3TW9kdWxlc0tleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXSA9IG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0gfHwgW11cbiAgICAgICAgbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXSA9IG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0uY29uY2F0KG5ld01vZHVsZXNbbmV3TW9kdWxlc0tleXNbal1dKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXF1aXJlZE1vZHVsZXNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobW9kdWxlSWQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIHNvdXJjZXMgPSB7XG4gICAgbWFpbjogX193ZWJwYWNrX21vZHVsZXNfX1xuICB9XG5cbiAgdmFyIHJlcXVpcmVkTW9kdWxlcyA9IG9wdGlvbnMuYWxsID8geyBtYWluOiBPYmplY3Qua2V5cyhzb3VyY2VzLm1haW4pIH0gOiBnZXRSZXF1aXJlZE1vZHVsZXMoc291cmNlcywgbW9kdWxlSWQpXG5cbiAgdmFyIHNyYyA9ICcnXG5cbiAgT2JqZWN0LmtleXMocmVxdWlyZWRNb2R1bGVzKS5maWx0ZXIoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0gIT09ICdtYWluJyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICB2YXIgZW50cnlNb2R1bGUgPSAwXG4gICAgd2hpbGUgKHJlcXVpcmVkTW9kdWxlc1ttb2R1bGVdW2VudHJ5TW9kdWxlXSkge1xuICAgICAgZW50cnlNb2R1bGUrK1xuICAgIH1cbiAgICByZXF1aXJlZE1vZHVsZXNbbW9kdWxlXS5wdXNoKGVudHJ5TW9kdWxlKVxuICAgIHNvdXJjZXNbbW9kdWxlXVtlbnRyeU1vZHVsZV0gPSAnKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgeyBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX187IH0pJ1xuICAgIHNyYyA9IHNyYyArICd2YXIgJyArIG1vZHVsZSArICcgPSAoJyArIHdlYnBhY2tCb290c3RyYXBGdW5jLnRvU3RyaW5nKCkucmVwbGFjZSgnRU5UUllfTU9EVUxFJywgSlNPTi5zdHJpbmdpZnkoZW50cnlNb2R1bGUpKSArICcpKHsnICsgcmVxdWlyZWRNb2R1bGVzW21vZHVsZV0ubWFwKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gJycgKyBKU09OLnN0cmluZ2lmeShpZCkgKyAnOiAnICsgc291cmNlc1ttb2R1bGVdW2lkXS50b1N0cmluZygpIH0pLmpvaW4oJywnKSArICd9KTtcXG4nXG4gIH0pXG5cbiAgc3JjID0gc3JjICsgJ25ldyAoKCcgKyB3ZWJwYWNrQm9vdHN0cmFwRnVuYy50b1N0cmluZygpLnJlcGxhY2UoJ0VOVFJZX01PRFVMRScsIEpTT04uc3RyaW5naWZ5KG1vZHVsZUlkKSkgKyAnKSh7JyArIHJlcXVpcmVkTW9kdWxlcy5tYWluLm1hcChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuICcnICsgSlNPTi5zdHJpbmdpZnkoaWQpICsgJzogJyArIHNvdXJjZXMubWFpbltpZF0udG9TdHJpbmcoKSB9KS5qb2luKCcsJykgKyAnfSkpKHNlbGYpOydcblxuICB2YXIgYmxvYiA9IG5ldyB3aW5kb3cuQmxvYihbc3JjXSwgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KVxuICBpZiAob3B0aW9ucy5iYXJlKSB7IHJldHVybiBibG9iIH1cblxuICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMXG5cbiAgdmFyIHdvcmtlclVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgdmFyIHdvcmtlciA9IG5ldyB3aW5kb3cuV29ya2VyKHdvcmtlclVybClcbiAgd29ya2VyLm9iamVjdFVSTCA9IHdvcmtlclVybFxuXG4gIHJldHVybiB3b3JrZXJcbn1cbiIsIi8qKlxuICogSExTIGNvbmZpZ1xuICovXG5cbmltcG9ydCBBYnJDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9hYnItY29udHJvbGxlcic7XG5pbXBvcnQgQnVmZmVyQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXInO1xuaW1wb3J0IENhcExldmVsQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvY2FwLWxldmVsLWNvbnRyb2xsZXInO1xuaW1wb3J0IEZQU0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyJztcbmltcG9ydCBYaHJMb2FkZXIgZnJvbSAnLi91dGlscy94aHItbG9hZGVyJztcbi8vIGltcG9ydCBGZXRjaExvYWRlciBmcm9tICcuL3V0aWxzL2ZldGNoLWxvYWRlcic7XG5cbmltcG9ydCBBdWRpb1RyYWNrQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlcic7XG5pbXBvcnQgQXVkaW9TdHJlYW1Db250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlcic7XG5cbmltcG9ydCAqIGFzIEN1ZXMgZnJvbSAnLi91dGlscy9jdWVzJztcbmltcG9ydCBUaW1lbGluZUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXInO1xuaW1wb3J0IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9zdWJ0aXRsZS10cmFjay1jb250cm9sbGVyJztcbmltcG9ydCB7IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciB9IGZyb20gJy4vY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgRU1FQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvZW1lLWNvbnRyb2xsZXInO1xuXG5pbXBvcnQgeyByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgfSBmcm9tICcuL3V0aWxzL21lZGlha2V5cy1oZWxwZXInO1xuXG5leHBvcnQgdmFyIGhsc0RlZmF1bHRDb25maWcgPSB7XG4gIGF1dG9TdGFydExvYWQ6IHRydWUsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgc3RhcnRQb3NpdGlvbjogLTEsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZGVmYXVsdEF1ZGlvQ29kZWM6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBkZWJ1ZzogZmFsc2UsIC8vIHVzZWQgYnkgbG9nZ2VyXG4gIGNhcExldmVsT25GUFNEcm9wOiBmYWxzZSwgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBjYXBMZXZlbFRvUGxheWVyU2l6ZTogZmFsc2UsIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgaW5pdGlhbExpdmVNYW5pZmVzdFNpemU6IDEsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4QnVmZmVyTGVuZ3RoOiAzMCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhCdWZmZXJTaXplOiA2MCAqIDEwMDAgKiAxMDAwLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEJ1ZmZlckhvbGU6IDAuNSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuXG4gIGxvd0J1ZmZlcldhdGNoZG9nUGVyaW9kOiAwLjUsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kOiAzLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG51ZGdlT2Zmc2V0OiAwLjEsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbnVkZ2VNYXhSZXRyeTogMywgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlOiAwLjI1LCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGxpdmVTeW5jRHVyYXRpb25Db3VudDogMywgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQ6IEluZmluaXR5LCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGxpdmVTeW5jRHVyYXRpb246IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbGl2ZUR1cmF0aW9uSW5maW5pdHk6IGZhbHNlLCAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIGxpdmVCYWNrQnVmZmVyTGVuZ3RoOiBJbmZpbml0eSwgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICBtYXhNYXhCdWZmZXJMZW5ndGg6IDYwMCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBlbmFibGVXb3JrZXI6IHRydWUsIC8vIHVzZWQgYnkgZGVtdXhlclxuICBlbmFibGVTb2Z0d2FyZUFFUzogdHJ1ZSwgLy8gdXNlZCBieSBkZWNyeXB0ZXJcbiAgbWFuaWZlc3RMb2FkaW5nVGltZU91dDogMTAwMDAsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5OiAxLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBtYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBzdGFydExldmVsOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgbGV2ZWwtY29udHJvbGxlclxuICBsZXZlbExvYWRpbmdUaW1lT3V0OiAxMDAwMCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgbGV2ZWxMb2FkaW5nTWF4UmV0cnk6IDQsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIGxldmVsTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIGxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIGZyYWdMb2FkaW5nVGltZU91dDogMjAwMDAsIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gIGZyYWdMb2FkaW5nTWF4UmV0cnk6IDYsIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gIGZyYWdMb2FkaW5nUmV0cnlEZWxheTogMTAwMCwgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLCAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBzdGFydEZyYWdQcmVmZXRjaDogZmFsc2UsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2Q6IDUwMDAsIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQ6IDAuMiwgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBhcHBlbmRFcnJvck1heFJldHJ5OiAzLCAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIGxvYWRlcjogWGhyTG9hZGVyLFxuICAvLyBsb2FkZXI6IEZldGNoTG9hZGVyLFxuICBmTG9hZGVyOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gIHBMb2FkZXI6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgeGhyU2V0dXA6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSB4aHItbG9hZGVyXG4gIGxpY2Vuc2VYaHJTZXR1cDogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIC8vIGZldGNoU2V0dXA6IHVuZGVmaW5lZCxcbiAgYWJyQ29udHJvbGxlcjogQWJyQ29udHJvbGxlcixcbiAgYnVmZmVyQ29udHJvbGxlcjogQnVmZmVyQ29udHJvbGxlcixcbiAgY2FwTGV2ZWxDb250cm9sbGVyOiBDYXBMZXZlbENvbnRyb2xsZXIsXG4gIGZwc0NvbnRyb2xsZXI6IEZQU0NvbnRyb2xsZXIsXG4gIHN0cmV0Y2hTaG9ydFZpZGVvVHJhY2s6IGZhbHNlLCAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXG4gIG1heEF1ZGlvRnJhbWVzRHJpZnQ6IDEsIC8vIHVzZWQgYnkgbXA0LXJlbXV4ZXJcbiAgZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eTogdHJ1ZSwgLy8gdXNlZCBieSB0cy1kZW11eGVyXG4gIGFickV3bWFGYXN0TGl2ZTogMywgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hU2xvd0xpdmU6IDksIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYUZhc3RWb0Q6IDMsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYVNsb3dWb0Q6IDksIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTogNWU1LCAvLyA1MDAga2JwcyAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJCYW5kV2lkdGhGYWN0b3I6IDAuOTUsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyQmFuZFdpZHRoVXBGYWN0b3I6IDAuNywgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJNYXhXaXRoUmVhbEJpdHJhdGU6IGZhbHNlLCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1heFN0YXJ2YXRpb25EZWxheTogNCwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtYXhMb2FkaW5nRGVsYXk6IDQsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWluQXV0b0JpdHJhdGU6IDAsIC8vIHVzZWQgYnkgaGxzXG4gIGVtZUVuYWJsZWQ6IGZhbHNlLCAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHdpZGV2aW5lTGljZW5zZVVybDogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmM6XG4gICAgICAgICAgICByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxufTtcblxuXG4gIGhsc0RlZmF1bHRDb25maWcuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyID0gU3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xuICBobHNEZWZhdWx0Q29uZmlnLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gU3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gIGhsc0RlZmF1bHRDb25maWcudGltZWxpbmVDb250cm9sbGVyID0gVGltZWxpbmVDb250cm9sbGVyO1xuICBobHNEZWZhdWx0Q29uZmlnLmN1ZUhhbmRsZXIgPSBDdWVzOyAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgaGxzRGVmYXVsdENvbmZpZy5lbmFibGVDRUE3MDhDYXB0aW9ucyA9IHRydWU7IC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICBobHNEZWZhdWx0Q29uZmlnLmVuYWJsZVdlYlZUVCA9IHRydWU7IC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICBobHNEZWZhdWx0Q29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhYmVsID0gJ0VuZ2xpc2gnOyAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgaGxzRGVmYXVsdENvbmZpZy5jYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGUgPSAnZW4nOyAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgaGxzRGVmYXVsdENvbmZpZy5jYXB0aW9uc1RleHRUcmFjazJMYWJlbCA9ICdTcGFuaXNoJzsgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gIGhsc0RlZmF1bHRDb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlID0gJ2VzJzsgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG5cblxuICBobHNEZWZhdWx0Q29uZmlnLmF1ZGlvU3RyZWFtQ29udHJvbGxlciA9IEF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcbiAgaGxzRGVmYXVsdENvbmZpZy5hdWRpb1RyYWNrQ29udHJvbGxlciA9IEF1ZGlvVHJhY2tDb250cm9sbGVyO1xuXG5cbiAgaGxzRGVmYXVsdENvbmZpZy5lbWVDb250cm9sbGVyID0gRU1FQ29udHJvbGxlcjtcblxuIiwiLypcbiAqIHNpbXBsZSBBQlIgQ29udHJvbGxlclxuICogIC0gY29tcHV0ZSBuZXh0IGxldmVsIGJhc2VkIG9uIGxhc3QgZnJhZ21lbnQgYncgaGV1cmlzdGljc1xuICogIC0gaW1wbGVtZW50IGFuIGFiYW5kb24gcnVsZXMgdHJpZ2dlcmVkIGlmIHdlIGhhdmUgbGVzcyB0aGFuIDIgZnJhZyBidWZmZXJlZCBhbmQgaWYgY29tcHV0ZWQgYncgc2hvd3MgdGhhdCB3ZSByaXNrIGJ1ZmZlciBzdGFsbGluZ1xuICovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7IEJ1ZmZlckhlbHBlciB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IHsgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgRXdtYUJhbmRXaWR0aEVzdGltYXRvciBmcm9tICcuLi91dGlscy9ld21hLWJhbmR3aWR0aC1lc3RpbWF0b3InO1xuXG5jb25zdCB7IHBlcmZvcm1hbmNlIH0gPSB3aW5kb3c7XG5cbmNsYXNzIEFickNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCBFdmVudC5GUkFHX0xPQURJTkcsXG4gICAgICBFdmVudC5GUkFHX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfQlVGRkVSRUQsXG4gICAgICBFdmVudC5FUlJPUik7XG4gICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gMDtcbiAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgdGhpcy5fYndFc3RpbWF0b3IgPSBudWxsO1xuICAgIHRoaXMub25DaGVjayA9IHRoaXMuX2FiYW5kb25SdWxlc0NoZWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIG9uRnJhZ0xvYWRpbmcgKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIGlmIChmcmFnLnR5cGUgPT09ICdtYWluJykge1xuICAgICAgaWYgKCF0aGlzLnRpbWVyKSB7XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbkNoZWNrLCAxMDApO1xuICAgICAgfVxuXG4gICAgICAvLyBsYXp5IGluaXQgb2YgQndFc3RpbWF0b3IsIHJhdGlvbmFsZSBpcyB0aGF0IHdlIHVzZSBkaWZmZXJlbnQgcGFyYW1zIGZvciBMaXZlL1ZvRFxuICAgICAgLy8gc28gd2UgbmVlZCB0byB3YWl0IGZvciBzdHJlYW0gbWFuaWZlc3QgLyBwbGF5bGlzdCB0eXBlIHRvIGluc3RhbnRpYXRlIGl0LlxuICAgICAgaWYgKCF0aGlzLl9id0VzdGltYXRvcikge1xuICAgICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAgICAgY29uc3QgY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBmcmFnLmxldmVsO1xuICAgICAgICBjb25zdCBpc0xpdmUgPSBobHMubGV2ZWxzW2xldmVsXS5kZXRhaWxzLmxpdmU7XG5cbiAgICAgICAgbGV0IGV3bWFGYXN0LCBld21hU2xvdztcbiAgICAgICAgaWYgKGlzTGl2ZSkge1xuICAgICAgICAgIGV3bWFGYXN0ID0gY29uZmlnLmFickV3bWFGYXN0TGl2ZTtcbiAgICAgICAgICBld21hU2xvdyA9IGNvbmZpZy5hYnJFd21hU2xvd0xpdmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXdtYUZhc3QgPSBjb25maWcuYWJyRXdtYUZhc3RWb0Q7XG4gICAgICAgICAgZXdtYVNsb3cgPSBjb25maWcuYWJyRXdtYVNsb3dWb0Q7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYndFc3RpbWF0b3IgPSBuZXcgRXdtYUJhbmRXaWR0aEVzdGltYXRvcihobHMsIGV3bWFTbG93LCBld21hRmFzdCwgY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9hYmFuZG9uUnVsZXNDaGVjayAoKSB7XG4gICAgLypcbiAgICAgIG1vbml0b3IgZnJhZ21lbnQgcmV0cmlldmFsIHRpbWUuLi5cbiAgICAgIHdlIGNvbXB1dGUgZXhwZWN0ZWQgdGltZSBvZiBhcnJpdmFsIG9mIHRoZSBjb21wbGV0ZSBmcmFnbWVudC5cbiAgICAgIHdlIGNvbXBhcmUgaXQgdG8gZXhwZWN0ZWQgdGltZSBvZiBidWZmZXIgc3RhcnZhdGlvblxuICAgICovXG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3QgdmlkZW8gPSBobHMubWVkaWE7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG5cbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsb2FkZXIgPSBmcmFnLmxvYWRlcjtcbiAgICBjb25zdCBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsO1xuXG4gICAgLy8gaWYgbG9hZGVyIGhhcyBiZWVuIGRlc3Ryb3llZCBvciBsb2FkaW5nIGhhcyBiZWVuIGFib3J0ZWQsIHN0b3AgdGltZXIgYW5kIHJldHVyblxuICAgIGlmICghbG9hZGVyIHx8IChsb2FkZXIuc3RhdHMgJiYgbG9hZGVyLnN0YXRzLmFib3J0ZWQpKSB7XG4gICAgICBsb2dnZXIud2FybignZnJhZyBsb2FkZXIgZGVzdHJveSBvciBhYm9ydGVkLCBkaXNhcm0gYWJhbmRvblJ1bGVzJyk7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXG4gICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBzdGF0cyA9IGxvYWRlci5zdGF0cztcbiAgICAvKiBvbmx5IG1vbml0b3IgZnJhZyByZXRyaWV2YWwgdGltZSBpZlxuICAgICh2aWRlbyBub3QgcGF1c2VkIE9SIGZpcnN0IGZyYWdtZW50IGJlaW5nIGxvYWRlZChyZWFkeSBzdGF0ZSA9PT0gSEFWRV9OT1RISU5HID0gMCkpIEFORCBhdXRvc3dpdGNoaW5nIGVuYWJsZWQgQU5EIG5vdCBsb3dlc3QgbGV2ZWwgKD0+IG1lYW5zIHRoYXQgd2UgaGF2ZSBzZXZlcmFsIGxldmVscykgKi9cbiAgICBpZiAodmlkZW8gJiYgc3RhdHMgJiYgKCghdmlkZW8ucGF1c2VkICYmICh2aWRlby5wbGF5YmFja1JhdGUgIT09IDApKSB8fCAhdmlkZW8ucmVhZHlTdGF0ZSkgJiYgZnJhZy5hdXRvTGV2ZWwgJiYgZnJhZy5sZXZlbCkge1xuICAgICAgbGV0IHJlcXVlc3REZWxheSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhdHMudHJlcXVlc3QsXG4gICAgICAgIHBsYXliYWNrUmF0ZSA9IE1hdGguYWJzKHZpZGVvLnBsYXliYWNrUmF0ZSk7XG4gICAgICAvLyBtb25pdG9yIGZyYWdtZW50IGxvYWQgcHJvZ3Jlc3MgYWZ0ZXIgaGFsZiBvZiBleHBlY3RlZCBmcmFnbWVudCBkdXJhdGlvbix0byBzdGFiaWxpemUgYml0cmF0ZVxuICAgICAgaWYgKHJlcXVlc3REZWxheSA+ICg1MDAgKiBmcmFnLmR1cmF0aW9uIC8gcGxheWJhY2tSYXRlKSkge1xuICAgICAgICBsZXQgbGV2ZWxzID0gaGxzLmxldmVscyxcbiAgICAgICAgICBsb2FkUmF0ZSA9IE1hdGgubWF4KDEsIHN0YXRzLmJ3ID8gc3RhdHMuYncgLyA4IDogc3RhdHMubG9hZGVkICogMTAwMCAvIHJlcXVlc3REZWxheSksIC8vIGJ5dGUvczsgYXQgbGVhc3QgMSBieXRlL3MgdG8gYXZvaWQgZGl2aXNpb24gYnkgemVyb1xuICAgICAgICAgIC8vIGNvbXB1dGUgZXhwZWN0ZWQgZnJhZ21lbnQgbGVuZ3RoIHVzaW5nIGZyYWcgZHVyYXRpb24gYW5kIGxldmVsIGJpdHJhdGUuIGFsc28gZW5zdXJlIHRoYXQgZXhwZWN0ZWQgbGVuIGlzIGd0ZSB0aGFuIGFscmVhZHkgbG9hZGVkIHNpemVcbiAgICAgICAgICBsZXZlbCA9IGxldmVsc1tmcmFnLmxldmVsXSxcbiAgICAgICAgICBsZXZlbEJpdHJhdGUgPSBsZXZlbC5yZWFsQml0cmF0ZSA/IE1hdGgubWF4KGxldmVsLnJlYWxCaXRyYXRlLCBsZXZlbC5iaXRyYXRlKSA6IGxldmVsLmJpdHJhdGUsXG4gICAgICAgICAgZXhwZWN0ZWRMZW4gPSBzdGF0cy50b3RhbCA/IHN0YXRzLnRvdGFsIDogTWF0aC5tYXgoc3RhdHMubG9hZGVkLCBNYXRoLnJvdW5kKGZyYWcuZHVyYXRpb24gKiBsZXZlbEJpdHJhdGUgLyA4KSksXG4gICAgICAgICAgcG9zID0gdmlkZW8uY3VycmVudFRpbWUsXG4gICAgICAgICAgZnJhZ0xvYWRlZERlbGF5ID0gKGV4cGVjdGVkTGVuIC0gc3RhdHMubG9hZGVkKSAvIGxvYWRSYXRlLFxuICAgICAgICAgIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9IChCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh2aWRlbywgcG9zLCBobHMuY29uZmlnLm1heEJ1ZmZlckhvbGUpLmVuZCAtIHBvcykgLyBwbGF5YmFja1JhdGU7XG4gICAgICAgIC8vIGNvbnNpZGVyIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBvbmx5IGlmIHdlIGhhdmUgbGVzcyB0aGFuIDIgZnJhZyBidWZmZXJlZCBBTkRcbiAgICAgICAgLy8gdGltZSB0byBmaW5pc2ggbG9hZGluZyBjdXJyZW50IGZyYWdtZW50IGlzIGJpZ2dlciB0aGFuIGJ1ZmZlciBzdGFydmF0aW9uIGRlbGF5XG4gICAgICAgIC8vIGllIGlmIHdlIHJpc2sgYnVmZmVyIHN0YXJ2YXRpb24gaWYgYncgZG9lcyBub3QgaW5jcmVhc2UgcXVpY2tseVxuICAgICAgICBpZiAoKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA8ICgyICogZnJhZy5kdXJhdGlvbiAvIHBsYXliYWNrUmF0ZSkpICYmIChmcmFnTG9hZGVkRGVsYXkgPiBidWZmZXJTdGFydmF0aW9uRGVsYXkpKSB7XG4gICAgICAgICAgbGV0IGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSwgbmV4dExvYWRMZXZlbDtcbiAgICAgICAgICAvLyBsZXRzIGl0ZXJhdGUgdGhyb3VnaCBsb3dlciBsZXZlbCBhbmQgdHJ5IHRvIGZpbmQgdGhlIGJpZ2dlc3Qgb25lIHRoYXQgY291bGQgYXZvaWQgcmVidWZmZXJpbmdcbiAgICAgICAgICAvLyB3ZSBzdGFydCBmcm9tIGN1cnJlbnQgbGV2ZWwgLSAxIGFuZCB3ZSBzdGVwIGRvd24gLCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2hpbmcgbGV2ZWxcbiAgICAgICAgICBmb3IgKG5leHRMb2FkTGV2ZWwgPSBmcmFnLmxldmVsIC0gMTsgbmV4dExvYWRMZXZlbCA+IG1pbkF1dG9MZXZlbDsgbmV4dExvYWRMZXZlbC0tKSB7XG4gICAgICAgICAgICAvLyBjb21wdXRlIHRpbWUgdG8gbG9hZCBuZXh0IGZyYWdtZW50IGF0IGxvd2VyIGxldmVsXG4gICAgICAgICAgICAvLyAwLjggOiBjb25zaWRlciBvbmx5IDgwJSBvZiBjdXJyZW50IGJ3IHRvIGJlIGNvbnNlcnZhdGl2ZVxuICAgICAgICAgICAgLy8gOCA9IGJpdHMgcGVyIGJ5dGUgKGJwcy9CcHMpXG4gICAgICAgICAgICBsZXQgbGV2ZWxOZXh0Qml0cmF0ZSA9IGxldmVsc1tuZXh0TG9hZExldmVsXS5yZWFsQml0cmF0ZSA/IE1hdGgubWF4KGxldmVsc1tuZXh0TG9hZExldmVsXS5yZWFsQml0cmF0ZSwgbGV2ZWxzW25leHRMb2FkTGV2ZWxdLmJpdHJhdGUpIDogbGV2ZWxzW25leHRMb2FkTGV2ZWxdLmJpdHJhdGU7XG4gICAgICAgICAgICBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPSBmcmFnLmR1cmF0aW9uICogbGV2ZWxOZXh0Qml0cmF0ZSAvICg4ICogMC44ICogbG9hZFJhdGUpO1xuICAgICAgICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA8IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgICAgICAgICAvLyB3ZSBmb3VuZCBhIGxvd2VyIGxldmVsIHRoYXQgYmUgcmVidWZmZXJpbmcgZnJlZSB3aXRoIGN1cnJlbnQgZXN0aW1hdGVkIGJ3ICFcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG9ubHkgZW1lcmdlbmN5IHN3aXRjaCBkb3duIGlmIGl0IHRha2VzIGxlc3MgdGltZSB0byBsb2FkIG5ldyBmcmFnbWVudCBhdCBsb3dlc3QgbGV2ZWwgaW5zdGVhZFxuICAgICAgICAgIC8vIG9mIGZpbmlzaGluZyBsb2FkaW5nIGN1cnJlbnQgb25lIC4uLlxuICAgICAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPCBmcmFnTG9hZGVkRGVsYXkpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBsb2FkaW5nIHRvbyBzbG93LCBhYm9ydCBmcmFnbWVudCBsb2FkaW5nIGFuZCBzd2l0Y2ggdG8gbGV2ZWwgJHtuZXh0TG9hZExldmVsfTpmcmFnTG9hZGVkRGVsYXlbJHtuZXh0TG9hZExldmVsfV08ZnJhZ0xvYWRlZERlbGF5WyR7ZnJhZy5sZXZlbCAtIDF9XTtidWZmZXJTdGFydmF0aW9uRGVsYXk6JHtmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkudG9GaXhlZCgxKX08JHtmcmFnTG9hZGVkRGVsYXkudG9GaXhlZCgxKX06JHtidWZmZXJTdGFydmF0aW9uRGVsYXkudG9GaXhlZCgxKX1gKTtcbiAgICAgICAgICAgIC8vIGZvcmNlIG5leHQgbG9hZCBsZXZlbCBpbiBhdXRvIG1vZGVcbiAgICAgICAgICAgIGhscy5uZXh0TG9hZExldmVsID0gbmV4dExvYWRMZXZlbDtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBidyBlc3RpbWF0ZSBmb3IgdGhpcyBmcmFnbWVudCBiZWZvcmUgY2FuY2VsbGluZyBsb2FkICh0aGlzIHdpbGwgaGVscCByZWR1Y2luZyB0aGUgYncpXG4gICAgICAgICAgICB0aGlzLl9id0VzdGltYXRvci5zYW1wbGUocmVxdWVzdERlbGF5LCBzdGF0cy5sb2FkZWQpO1xuICAgICAgICAgICAgLy8gYWJvcnQgZnJhZ21lbnQgbG9hZGluZ1xuICAgICAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgICAvLyBzdG9wIGFiYW5kb24gcnVsZXMgdGltZXJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB7IGZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0cyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkZyYWdMb2FkZWQgKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIGlmIChmcmFnLnR5cGUgPT09ICdtYWluJyAmJiBOdW1iZXIuaXNGaW5pdGUoZnJhZy5zbikpIHtcbiAgICAgIC8vIHN0b3AgbW9uaXRvcmluZyBidyBvbmNlIGZyYWcgbG9hZGVkXG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIC8vIHN0b3JlIGxldmVsIGlkIGFmdGVyIHN1Y2Nlc3NmdWwgZnJhZ21lbnQgbG9hZFxuICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gZnJhZy5sZXZlbDtcbiAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXG4gICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG5cbiAgICAgIC8vIGNvbXB1dGUgbGV2ZWwgYXZlcmFnZSBiaXRyYXRlXG4gICAgICBpZiAodGhpcy5obHMuY29uZmlnLmFick1heFdpdGhSZWFsQml0cmF0ZSkge1xuICAgICAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgICAgbGV0IGxvYWRlZEJ5dGVzID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5ieXRlcyA6IDApICsgZGF0YS5zdGF0cy5sb2FkZWQ7XG4gICAgICAgIGxldCBsb2FkZWREdXJhdGlvbiA9IChsZXZlbC5sb2FkZWQgPyBsZXZlbC5sb2FkZWQuZHVyYXRpb24gOiAwKSArIGRhdGEuZnJhZy5kdXJhdGlvbjtcbiAgICAgICAgbGV2ZWwubG9hZGVkID0geyBieXRlczogbG9hZGVkQnl0ZXMsIGR1cmF0aW9uOiBsb2FkZWREdXJhdGlvbiB9O1xuICAgICAgICBsZXZlbC5yZWFsQml0cmF0ZSA9IE1hdGgucm91bmQoOCAqIGxvYWRlZEJ5dGVzIC8gbG9hZGVkRHVyYXRpb24pO1xuICAgICAgfVxuICAgICAgLy8gaWYgZnJhZ21lbnQgaGFzIGJlZW4gbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3QsXG4gICAgICBpZiAoZGF0YS5mcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIGxldCBzdGF0cyA9IGRhdGEuc3RhdHM7XG4gICAgICAgIHN0YXRzLnRwYXJzZWQgPSBzdGF0cy50YnVmZmVyZWQgPSBzdGF0cy50bG9hZDtcbiAgICAgICAgdGhpcy5vbkZyYWdCdWZmZXJlZChkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkZyYWdCdWZmZXJlZCAoZGF0YSkge1xuICAgIGNvbnN0IHN0YXRzID0gZGF0YS5zdGF0cztcbiAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIC8vIG9ubHkgdXBkYXRlIHN0YXRzIG9uIGZpcnN0IGZyYWcgYnVmZmVyaW5nXG4gICAgLy8gaWYgc2FtZSBmcmFnIGlzIGxvYWRlZCBtdWx0aXBsZSB0aW1lcywgaXQgbWlnaHQgYmUgaW4gYnJvd3NlciBjYWNoZSwgYW5kIGxvYWRlZCBxdWlja2x5XG4gICAgLy8gYW5kIGxlYWRpbmcgdG8gd3JvbmcgYncgZXN0aW1hdGlvblxuICAgIC8vIG9uIGJpdHJhdGUgdGVzdCwgYWxzbyBvbmx5IHVwZGF0ZSBzdGF0cyBvbmNlIChpZiB0bG9hZCA9IHRidWZmZXJlZCA9PSBvbiBGUkFHX0xPQURFRClcbiAgICBpZiAoc3RhdHMuYWJvcnRlZCAhPT0gdHJ1ZSAmJiBmcmFnLnR5cGUgPT09ICdtYWluJyAmJiBOdW1iZXIuaXNGaW5pdGUoZnJhZy5zbikgJiYgKCghZnJhZy5iaXRyYXRlVGVzdCB8fCBzdGF0cy50bG9hZCA9PT0gc3RhdHMudGJ1ZmZlcmVkKSkpIHtcbiAgICAgIC8vIHVzZSB0cGFyc2VkLXRyZXF1ZXN0IGluc3RlYWQgb2YgdGJ1ZmZlcmVkLXRyZXF1ZXN0IHRvIGNvbXB1dGUgZnJhZ0xvYWRpbmdQcm9jZXNzaW5nOyByYXRpb25hbGUgaXMgdGhhdCAgYnVmZmVyIGFwcGVuZGluZyBvbmx5IGhhcHBlbnMgb25jZSBtZWRpYSBpcyBhdHRhY2hlZFxuICAgICAgLy8gaW4gY2FzZSB3ZSB1c2UgY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoIHdoaWxlIG1lZGlhIGlzIG5vdCBhdHRhY2hlZCB5ZXQsIGZyYWdtZW50IG1pZ2h0IGJlIHBhcnNlZCB3aGlsZSBtZWRpYSBub3QgYXR0YWNoZWQgeWV0LCBidXQgaXQgd2lsbCBvbmx5IGJlIGJ1ZmZlcmVkIG9uIG1lZGlhIGF0dGFjaGVkXG4gICAgICAvLyBhcyBhIGNvbnNlcXVlbmNlIGl0IGNvdWxkIGhhcHBlbiByZWFsbHkgbGF0ZSBpbiB0aGUgcHJvY2Vzcy4gbWVhbmluZyB0aGF0IGFwcGVuZGluZyBkdXJhdGlvbiBtaWdodCBhcHBlYXJzIGh1Z2UgLi4uIGxlYWRpbmcgdG8gdW5kZXJlc3RpbWF0ZWQgdGhyb3VnaHB1dCBlc3RpbWF0aW9uXG4gICAgICBsZXQgZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMgPSBzdGF0cy50cGFyc2VkIC0gc3RhdHMudHJlcXVlc3Q7XG4gICAgICBsb2dnZXIubG9nKGBsYXRlbmN5L2xvYWRpbmcvcGFyc2luZy9hcHBlbmQva2Jwczoke01hdGgucm91bmQoc3RhdHMudGZpcnN0IC0gc3RhdHMudHJlcXVlc3QpfS8ke01hdGgucm91bmQoc3RhdHMudGxvYWQgLSBzdGF0cy50Zmlyc3QpfS8ke01hdGgucm91bmQoc3RhdHMudHBhcnNlZCAtIHN0YXRzLnRsb2FkKX0vJHtNYXRoLnJvdW5kKHN0YXRzLnRidWZmZXJlZCAtIHN0YXRzLnRwYXJzZWQpfS8ke01hdGgucm91bmQoOCAqIHN0YXRzLmxvYWRlZCAvIChzdGF0cy50YnVmZmVyZWQgLSBzdGF0cy50cmVxdWVzdCkpfWApO1xuICAgICAgdGhpcy5fYndFc3RpbWF0b3Iuc2FtcGxlKGZyYWdMb2FkaW5nUHJvY2Vzc2luZ01zLCBzdGF0cy5sb2FkZWQpO1xuICAgICAgc3RhdHMuYndFc3RpbWF0ZSA9IHRoaXMuX2J3RXN0aW1hdG9yLmdldEVzdGltYXRlKCk7XG4gICAgICAvLyBpZiBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdCwgKGhscy5zdGFydExldmVsID0gLTEpLCBzdG9yZSBiaXRyYXRlIHRlc3QgZGVsYXkgZHVyYXRpb25cbiAgICAgIGlmIChmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IGZyYWdMb2FkaW5nUHJvY2Vzc2luZ01zIC8gMTAwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25FcnJvciAoZGF0YSkge1xuICAgIC8vIHN0b3AgdGltZXIgaW4gY2FzZSBvZiBmcmFnIGxvYWRpbmcgZXJyb3JcbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNsZWFyVGltZXIgKCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgdGhpcy50aW1lciA9IG51bGw7XG4gIH1cblxuICAvLyByZXR1cm4gbmV4dCBhdXRvIGxldmVsXG4gIGdldCBuZXh0QXV0b0xldmVsICgpIHtcbiAgICBjb25zdCBmb3JjZWRBdXRvTGV2ZWwgPSB0aGlzLl9uZXh0QXV0b0xldmVsO1xuICAgIGNvbnN0IGJ3RXN0aW1hdG9yID0gdGhpcy5fYndFc3RpbWF0b3I7XG4gICAgLy8gaW4gY2FzZSBuZXh0IGF1dG8gbGV2ZWwgaGFzIGJlZW4gZm9yY2VkLCBhbmQgYncgbm90IGF2YWlsYWJsZSBvciBub3QgcmVsaWFibGUsIHJldHVybiBmb3JjZWQgdmFsdWVcbiAgICBpZiAoZm9yY2VkQXV0b0xldmVsICE9PSAtMSAmJiAoIWJ3RXN0aW1hdG9yIHx8ICFid0VzdGltYXRvci5jYW5Fc3RpbWF0ZSgpKSkge1xuICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIG5leHQgbGV2ZWwgdXNpbmcgQUJSIGxvZ2ljXG4gICAgbGV0IG5leHRBQlJBdXRvTGV2ZWwgPSB0aGlzLl9uZXh0QUJSQXV0b0xldmVsO1xuICAgIC8vIGlmIGZvcmNlZCBhdXRvIGxldmVsIGhhcyBiZWVuIGRlZmluZWQsIHVzZSBpdCB0byBjYXAgQUJSIGNvbXB1dGVkIHF1YWxpdHkgbGV2ZWxcbiAgICBpZiAoZm9yY2VkQXV0b0xldmVsICE9PSAtMSkge1xuICAgICAgbmV4dEFCUkF1dG9MZXZlbCA9IE1hdGgubWluKGZvcmNlZEF1dG9MZXZlbCwgbmV4dEFCUkF1dG9MZXZlbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRBQlJBdXRvTGV2ZWw7XG4gIH1cbiAgZ2V0IF9uZXh0QUJSQXV0b0xldmVsICgpIHtcbiAgICBsZXQgaGxzID0gdGhpcy5obHMsIG1heEF1dG9MZXZlbCA9IGhscy5tYXhBdXRvTGV2ZWwsIGxldmVscyA9IGhscy5sZXZlbHMsIGNvbmZpZyA9IGhscy5jb25maWcsIG1pbkF1dG9MZXZlbCA9IGhscy5taW5BdXRvTGV2ZWw7XG4gICAgY29uc3QgdmlkZW8gPSBobHMubWVkaWEsXG4gICAgICBjdXJyZW50TGV2ZWwgPSB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwsXG4gICAgICBjdXJyZW50RnJhZ0R1cmF0aW9uID0gdGhpcy5mcmFnQ3VycmVudCA/IHRoaXMuZnJhZ0N1cnJlbnQuZHVyYXRpb24gOiAwLFxuICAgICAgcG9zID0gKHZpZGVvID8gdmlkZW8uY3VycmVudFRpbWUgOiAwKSxcbiAgICAgIC8vIHBsYXliYWNrUmF0ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIHBsYXliYWNrIHJhdGU7IGlmIHZpZGVvLnBsYXliYWNrUmF0ZSBpcyAwLCB3ZSB1c2UgMSB0byBsb2FkIGFzXG4gICAgICAvLyBpZiB3ZSdyZSBwbGF5aW5nIGJhY2sgYXQgdGhlIG5vcm1hbCByYXRlLlxuICAgICAgcGxheWJhY2tSYXRlID0gKCh2aWRlbyAmJiAodmlkZW8ucGxheWJhY2tSYXRlICE9PSAwKSkgPyBNYXRoLmFicyh2aWRlby5wbGF5YmFja1JhdGUpIDogMS4wKSxcbiAgICAgIGF2Z2J3ID0gdGhpcy5fYndFc3RpbWF0b3IgPyB0aGlzLl9id0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpIDogY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUsXG4gICAgICAvLyBidWZmZXJTdGFydmF0aW9uRGVsYXkgaXMgdGhlIHdhbGwtY2xvY2sgdGltZSBsZWZ0IHVudGlsIHRoZSBwbGF5YmFjayBidWZmZXIgaXMgZXhoYXVzdGVkLlxuICAgICAgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gKEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHZpZGVvLCBwb3MsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKS5lbmQgLSBwb3MpIC8gcGxheWJhY2tSYXRlO1xuXG4gICAgLy8gRmlyc3QsIGxvb2sgdG8gc2VlIGlmIHdlIGNhbiBmaW5kIGEgbGV2ZWwgbWF0Y2hpbmcgd2l0aCBvdXIgYXZnIGJhbmR3aWR0aCBBTkQgdGhhdCBjb3VsZCBhbHNvIGd1YXJhbnRlZSBubyByZWJ1ZmZlcmluZyBhdCBhbGxcbiAgICBsZXQgYmVzdExldmVsID0gdGhpcy5fZmluZEJlc3RMZXZlbChjdXJyZW50TGV2ZWwsIGN1cnJlbnRGcmFnRHVyYXRpb24sIGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5LCBjb25maWcuYWJyQmFuZFdpZHRoRmFjdG9yLCBjb25maWcuYWJyQmFuZFdpZHRoVXBGYWN0b3IsIGxldmVscyk7XG4gICAgaWYgKGJlc3RMZXZlbCA+PSAwKSB7XG4gICAgICByZXR1cm4gYmVzdExldmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIudHJhY2UoJ3JlYnVmZmVyaW5nIGV4cGVjdGVkIHRvIGhhcHBlbiwgbGV0cyB0cnkgdG8gZmluZCBhIHF1YWxpdHkgbGV2ZWwgbWluaW1pemluZyB0aGUgcmVidWZmZXJpbmcnKTtcbiAgICAgIC8vIG5vdCBwb3NzaWJsZSB0byBnZXQgcmlkIG9mIHJlYnVmZmVyaW5nIC4uLiBsZXQncyB0cnkgdG8gZmluZCBsZXZlbCB0aGF0IHdpbGwgZ3VhcmFudGVlIGxlc3MgdGhhbiBtYXhTdGFydmF0aW9uRGVsYXkgb2YgcmVidWZmZXJpbmdcbiAgICAgIC8vIGlmIG5vIG1hdGNoaW5nIGxldmVsIGZvdW5kLCBsb2dpYyB3aWxsIHJldHVybiAwXG4gICAgICBsZXQgbWF4U3RhcnZhdGlvbkRlbGF5ID0gY3VycmVudEZyYWdEdXJhdGlvbiA/IE1hdGgubWluKGN1cnJlbnRGcmFnRHVyYXRpb24sIGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXkpIDogY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheSxcbiAgICAgICAgYndGYWN0b3IgPSBjb25maWcuYWJyQmFuZFdpZHRoRmFjdG9yLFxuICAgICAgICBid1VwRmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yO1xuICAgICAgaWYgKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9PT0gMCkge1xuICAgICAgICAvLyBpbiBjYXNlIGJ1ZmZlciBpcyBlbXB0eSwgbGV0J3MgY2hlY2sgaWYgcHJldmlvdXMgZnJhZ21lbnQgd2FzIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0XG4gICAgICAgIGxldCBiaXRyYXRlVGVzdERlbGF5ID0gdGhpcy5iaXRyYXRlVGVzdERlbGF5O1xuICAgICAgICBpZiAoYml0cmF0ZVRlc3REZWxheSkge1xuICAgICAgICAgIC8vIGlmIGl0IGlzIHRoZSBjYXNlLCB0aGVuIHdlIG5lZWQgdG8gYWRqdXN0IG91ciBtYXggc3RhcnZhdGlvbiBkZWxheSB1c2luZyBtYXhMb2FkaW5nRGVsYXkgY29uZmlnIHZhbHVlXG4gICAgICAgICAgLy8gbWF4IHZpZGVvIGxvYWRpbmcgZGVsYXkgdXNlZCBpbiAgYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiA6XG4gICAgICAgICAgLy8gaW4gdGhhdCBtb2RlIEFCUiBjb250cm9sbGVyIHdpbGwgZW5zdXJlIHRoYXQgdmlkZW8gbG9hZGluZyB0aW1lIChpZSB0aGUgdGltZSB0byBmZXRjaCB0aGUgZmlyc3QgZnJhZ21lbnQgYXQgbG93ZXN0IHF1YWxpdHkgbGV2ZWwgK1xuICAgICAgICAgIC8vIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmcmFnbWVudCBhdCB0aGUgYXBwcm9wcmlhdGUgcXVhbGl0eSBsZXZlbCBpcyBsZXNzIHRoYW4gYGBgbWF4TG9hZGluZ0RlbGF5YGBgIClcbiAgICAgICAgICAvLyBjYXAgbWF4TG9hZGluZ0RlbGF5IGFuZCBlbnN1cmUgaXQgaXMgbm90IGJpZ2dlciAndGhhbiBiaXRyYXRlIHRlc3QnIGZyYWcgZHVyYXRpb25cbiAgICAgICAgICBjb25zdCBtYXhMb2FkaW5nRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heExvYWRpbmdEZWxheSkgOiBjb25maWcubWF4TG9hZGluZ0RlbGF5O1xuICAgICAgICAgIG1heFN0YXJ2YXRpb25EZWxheSA9IG1heExvYWRpbmdEZWxheSAtIGJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICAgICAgbG9nZ2VyLnRyYWNlKGBiaXRyYXRlIHRlc3QgdG9vayAke01hdGgucm91bmQoMTAwMCAqIGJpdHJhdGVUZXN0RGVsYXkpfW1zLCBzZXQgZmlyc3QgZnJhZ21lbnQgbWF4IGZldGNoRHVyYXRpb24gdG8gJHtNYXRoLnJvdW5kKDEwMDAgKiBtYXhTdGFydmF0aW9uRGVsYXkpfSBtc2ApO1xuICAgICAgICAgIC8vIGRvbid0IHVzZSBjb25zZXJ2YXRpdmUgZmFjdG9yIG9uIGJpdHJhdGUgdGVzdFxuICAgICAgICAgIGJ3RmFjdG9yID0gYndVcEZhY3RvciA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJlc3RMZXZlbCA9IHRoaXMuX2ZpbmRCZXN0TGV2ZWwoY3VycmVudExldmVsLCBjdXJyZW50RnJhZ0R1cmF0aW9uLCBhdmdidywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSArIG1heFN0YXJ2YXRpb25EZWxheSwgYndGYWN0b3IsIGJ3VXBGYWN0b3IsIGxldmVscyk7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoYmVzdExldmVsLCAwKTtcbiAgICB9XG4gIH1cblxuICBfZmluZEJlc3RMZXZlbCAoY3VycmVudExldmVsLCBjdXJyZW50RnJhZ0R1cmF0aW9uLCBjdXJyZW50QncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBtYXhGZXRjaER1cmF0aW9uLCBid0ZhY3RvciwgYndVcEZhY3RvciwgbGV2ZWxzKSB7XG4gICAgZm9yIChsZXQgaSA9IG1heEF1dG9MZXZlbDsgaSA+PSBtaW5BdXRvTGV2ZWw7IGktLSkge1xuICAgICAgbGV0IGxldmVsSW5mbyA9IGxldmVsc1tpXTtcblxuICAgICAgaWYgKCFsZXZlbEluZm8pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBsZXZlbERldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscyxcbiAgICAgICAgYXZnRHVyYXRpb24gPSBsZXZlbERldGFpbHMgPyBsZXZlbERldGFpbHMudG90YWxkdXJhdGlvbiAvIGxldmVsRGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIDogY3VycmVudEZyYWdEdXJhdGlvbixcbiAgICAgICAgbGl2ZSA9IGxldmVsRGV0YWlscyA/IGxldmVsRGV0YWlscy5saXZlIDogZmFsc2UsXG4gICAgICAgIGFkanVzdGVkYnc7XG4gICAgICAvLyBmb2xsb3cgYWxnb3JpdGhtIGNhcHR1cmVkIGZyb20gc3RhZ2VmcmlnaHQgOlxuICAgICAgLy8gaHR0cHM6Ly9hbmRyb2lkLmdvb2dsZXNvdXJjZS5jb20vcGxhdGZvcm0vZnJhbWV3b3Jrcy9hdi8rL21hc3Rlci9tZWRpYS9saWJzdGFnZWZyaWdodC9odHRwbGl2ZS9MaXZlU2Vzc2lvbi5jcHBcbiAgICAgIC8vIFBpY2sgdGhlIGhpZ2hlc3QgYmFuZHdpZHRoIHN0cmVhbSBiZWxvdyBvciBlcXVhbCB0byBlc3RpbWF0ZWQgYmFuZHdpZHRoLlxuICAgICAgLy8gY29uc2lkZXIgb25seSA4MCUgb2YgdGhlIGF2YWlsYWJsZSBiYW5kd2lkdGgsIGJ1dCBpZiB3ZSBhcmUgc3dpdGNoaW5nIHVwLFxuICAgICAgLy8gYmUgZXZlbiBtb3JlIGNvbnNlcnZhdGl2ZSAoNzAlKSB0byBhdm9pZCBvdmVyZXN0aW1hdGluZyBhbmQgaW1tZWRpYXRlbHlcbiAgICAgIC8vIHN3aXRjaGluZyBiYWNrLlxuICAgICAgaWYgKGkgPD0gY3VycmVudExldmVsKSB7XG4gICAgICAgIGFkanVzdGVkYncgPSBid0ZhY3RvciAqIGN1cnJlbnRCdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkanVzdGVkYncgPSBid1VwRmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiaXRyYXRlID0gbGV2ZWxzW2ldLnJlYWxCaXRyYXRlID8gTWF0aC5tYXgobGV2ZWxzW2ldLnJlYWxCaXRyYXRlLCBsZXZlbHNbaV0uYml0cmF0ZSkgOiBsZXZlbHNbaV0uYml0cmF0ZSxcbiAgICAgICAgZmV0Y2hEdXJhdGlvbiA9IGJpdHJhdGUgKiBhdmdEdXJhdGlvbiAvIGFkanVzdGVkYnc7XG5cbiAgICAgIGxvZ2dlci50cmFjZShgbGV2ZWwvYWRqdXN0ZWRidy9iaXRyYXRlL2F2Z0R1cmF0aW9uL21heEZldGNoRHVyYXRpb24vZmV0Y2hEdXJhdGlvbjogJHtpfS8ke01hdGgucm91bmQoYWRqdXN0ZWRidyl9LyR7Yml0cmF0ZX0vJHthdmdEdXJhdGlvbn0vJHttYXhGZXRjaER1cmF0aW9ufS8ke2ZldGNoRHVyYXRpb259YCk7XG4gICAgICAvLyBpZiBhZGp1c3RlZCBidyBpcyBncmVhdGVyIHRoYW4gbGV2ZWwgYml0cmF0ZSBBTkRcbiAgICAgIGlmIChhZGp1c3RlZGJ3ID4gYml0cmF0ZSAmJlxuICAgICAgLy8gZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiB1bmtub3duIE9SIGxpdmUgc3RyZWFtIE9SIGZyYWdtZW50IGZldGNoRHVyYXRpb24gbGVzcyB0aGFuIG1heCBhbGxvd2VkIGZldGNoIGR1cmF0aW9uLCB0aGVuIHRoaXMgbGV2ZWwgbWF0Y2hlc1xuICAgICAgLy8gd2UgZG9uJ3QgYWNjb3VudCBmb3IgbWF4IEZldGNoIER1cmF0aW9uIGZvciBsaXZlIHN0cmVhbXMsIHRoaXMgaXMgdG8gYXZvaWQgc3dpdGNoaW5nIGRvd24gd2hlbiBuZWFyIHRoZSBlZGdlIG9mIGxpdmUgc2xpZGluZyB3aW5kb3cgLi4uXG4gICAgICAvLyBzcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBzdGFydExldmVsID0gLTEgKGJpdHJhdGVUZXN0KSBvbiBsaXZlIHN0cmVhbXMgOiBpbiB0aGF0IGNhc2Ugd2Ugc2hvdWxkIG5vdCBleGl0IGxvb3Agc28gdGhhdCBfZmluZEJlc3RMZXZlbCB3aWxsIHJldHVybiAtMVxuICAgICAgICAoIWZldGNoRHVyYXRpb24gfHzCoChsaXZlICYmICF0aGlzLmJpdHJhdGVUZXN0RGVsYXkpIHx8IGZldGNoRHVyYXRpb24gPCBtYXhGZXRjaER1cmF0aW9uKSkge1xuICAgICAgICAvLyBhcyB3ZSBhcmUgbG9vcGluZyBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0LCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGFjaGlldmFibGUgcXVhbGl0eSBsZXZlbFxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCB0aW1lIGJ1ZGdldCBldmVuIHdpdGggcXVhbGl0eSBsZXZlbCAwIC4uLiByZWJ1ZmZlcmluZyBtaWdodCBoYXBwZW5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBzZXQgbmV4dEF1dG9MZXZlbCAobmV4dExldmVsKSB7XG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBYnJDb250cm9sbGVyO1xuIiwiLypcbiAqIEF1ZGlvIFN0cmVhbSBDb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgQmluYXJ5U2VhcmNoIGZyb20gJy4uL3V0aWxzL2JpbmFyeS1zZWFyY2gnO1xuaW1wb3J0IHsgQnVmZmVySGVscGVyIH0gZnJvbSAnLi4vdXRpbHMvYnVmZmVyLWhlbHBlcic7XG5pbXBvcnQgRGVtdXhlciBmcm9tICcuLi9kZW11eC9kZW11eGVyJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0ICogYXMgTGV2ZWxIZWxwZXIgZnJvbSAnLi9sZXZlbC1oZWxwZXInO1xuaW1wb3J0IFRpbWVSYW5nZXMgZnJvbSAnLi4vdXRpbHMvdGltZS1yYW5nZXMnO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBmaW5kRnJhZ1dpdGhDQyB9IGZyb20gJy4uL3V0aWxzL2Rpc2NvbnRpbnVpdGllcyc7XG5pbXBvcnQgeyBGcmFnbWVudFN0YXRlIH0gZnJvbSAnLi9mcmFnbWVudC10cmFja2VyJztcbmltcG9ydCBGcmFnbWVudCBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xuaW1wb3J0IEJhc2VTdHJlYW1Db250cm9sbGVyLCB7IFN0YXRlIH0gZnJvbSAnLi9iYXNlLXN0cmVhbS1jb250cm9sbGVyJztcbmNvbnN0IHsgcGVyZm9ybWFuY2UgfSA9IHdpbmRvdztcblxuY29uc3QgVElDS19JTlRFUlZBTCA9IDEwMDsgLy8gaG93IG9mdGVuIHRvIHRpY2sgaW4gbXNcblxuY2xhc3MgQXVkaW9TdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgQmFzZVN0cmVhbUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzLCBmcmFnbWVudFRyYWNrZXIpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLU19VUERBVEVELFxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENISU5HLFxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfTE9BREVELFxuICAgICAgRXZlbnQuS0VZX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLFxuICAgICAgRXZlbnQuRlJBR19QQVJTRUQsXG4gICAgICBFdmVudC5FUlJPUixcbiAgICAgIEV2ZW50LkJVRkZFUl9SRVNFVCxcbiAgICAgIEV2ZW50LkJVRkZFUl9DUkVBVEVELFxuICAgICAgRXZlbnQuQlVGRkVSX0FQUEVOREVELFxuICAgICAgRXZlbnQuQlVGRkVSX0ZMVVNIRUQsXG4gICAgICBFdmVudC5JTklUX1BUU19GT1VORCk7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLl9zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgdGhpcy5pbml0UFRTID0gW107XG4gICAgdGhpcy53YWl0aW5nRnJhZ21lbnQgPSBudWxsO1xuICAgIHRoaXMudmlkZW9UcmFja0NDID0gbnVsbDtcbiAgfVxuXG4gIC8vIFNpZ25hbCB0aGF0IHZpZGVvIFBUUyB3YXMgZm91bmRcbiAgb25Jbml0UHRzRm91bmQgKGRhdGEpIHtcbiAgICBsZXQgZGVtdXhlcklkID0gZGF0YS5pZCwgY2MgPSBkYXRhLmZyYWcuY2MsIGluaXRQVFMgPSBkYXRhLmluaXRQVFM7XG4gICAgaWYgKGRlbXV4ZXJJZCA9PT0gJ21haW4nKSB7XG4gICAgICAvLyBBbHdheXMgdXBkYXRlIHRoZSBuZXcgSU5JVCBQVFNcbiAgICAgIC8vIENhbiBjaGFuZ2UgZHVlIGxldmVsIHN3aXRjaFxuICAgICAgdGhpcy5pbml0UFRTW2NjXSA9IGluaXRQVFM7XG4gICAgICB0aGlzLnZpZGVvVHJhY2tDQyA9IGNjO1xuICAgICAgbG9nZ2VyLmxvZyhgSW5pdFBUUyBmb3IgY2M6ICR7Y2N9IGZvdW5kIGZyb20gdmlkZW8gdHJhY2s6ICR7aW5pdFBUU31gKTtcblxuICAgICAgLy8gSWYgd2UgYXJlIHdhaXRpbmcgd2UgbmVlZCB0byBkZW11eC9yZW11eCB0aGUgd2FpdGluZyBmcmFnXG4gICAgICAvLyBXaXRoIHRoZSBuZXcgaW5pdFBUU1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfSU5JVF9QVFMpIHtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhcnRMb2FkIChzdGFydFBvc2l0aW9uKSB7XG4gICAgaWYgKHRoaXMudHJhY2tzKSB7XG4gICAgICBsZXQgbGFzdEN1cnJlbnRUaW1lID0gdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xuICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgICAgIGlmIChsYXN0Q3VycmVudFRpbWUgPiAwICYmIHN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYGF1ZGlvOm92ZXJyaWRlIHN0YXJ0UG9zaXRpb24gd2l0aCBsYXN0Q3VycmVudFRpbWUgQCR7bGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSB0aGlzLnN0YXJ0UG9zaXRpb24gPyB0aGlzLnN0YXJ0UG9zaXRpb24gOiBzdGFydFBvc2l0aW9uO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RBUlRJTkc7XG4gICAgICB9XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZTtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgfVxuICB9XG5cbiAgc2V0IHN0YXRlIChuZXh0U3RhdGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHRoaXMuX3N0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgbG9nZ2VyLmxvZyhgYXVkaW8gc3RyZWFtOiR7cHJldmlvdXNTdGF0ZX0tPiR7bmV4dFN0YXRlfWApO1xuICAgIH1cbiAgfVxuXG4gIGdldCBzdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG5cbiAgZG9UaWNrICgpIHtcbiAgICBsZXQgcG9zLCB0cmFjaywgdHJhY2tEZXRhaWxzLCBobHMgPSB0aGlzLmhscywgY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICAvLyBsb2dnZXIubG9nKCdhdWRpb1N0cmVhbTonICsgdGhpcy5zdGF0ZSk7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgY2FzZSBTdGF0ZS5FUlJPUjpcbiAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGluIGVycm9yIHN0YXRlIHRvIGF2b2lkIGJyZWFraW5nIGZ1cnRoZXIgLi4uXG4gICAgY2FzZSBTdGF0ZS5QQVVTRUQ6XG4gICAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpbiBwYXVzZWQgc3RhdGUgZWl0aGVyIC4uLlxuICAgIGNhc2UgU3RhdGUuQlVGRkVSX0ZMVVNISU5HOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTdGF0ZS5TVEFSVElORzpcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX1RSQUNLO1xuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTdGF0ZS5JRExFOlxuICAgICAgY29uc3QgdHJhY2tzID0gdGhpcy50cmFja3M7XG4gICAgICAvLyBhdWRpbyB0cmFja3Mgbm90IHJlY2VpdmVkID0+IGV4aXQgbG9vcFxuICAgICAgaWYgKCF0cmFja3MpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkRcbiAgICAgIC8vIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggZGlzYWJsZVxuICAgICAgLy8gZXhpdCBsb29wXG4gICAgICAvLyA9PiBpZiBtZWRpYSBub3QgYXR0YWNoZWQgYnV0IHN0YXJ0IGZyYWcgcHJlZmV0Y2ggaXMgZW5hYmxlZCBhbmQgc3RhcnQgZnJhZyBub3QgcmVxdWVzdGVkIHlldCwgd2Ugd2lsbCBub3QgZXhpdCBsb29wXG4gICAgICBpZiAoIXRoaXMubWVkaWEgJiZcbiAgICAgICAgICAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIGRldGVybWluZSBuZXh0IGNhbmRpZGF0ZSBmcmFnbWVudCB0byBiZSBsb2FkZWQsIGJhc2VkIG9uIGN1cnJlbnQgcG9zaXRpb24gYW5kXG4gICAgICAvLyAgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxuICAgICAgaWYgKHRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgcG9zID0gdGhpcy5tZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyA9IHRoaXMubmV4dExvYWRQb3NpdGlvbjtcbiAgICAgICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYSxcbiAgICAgICAgdmlkZW9CdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyID8gdGhpcy52aWRlb0J1ZmZlciA6IHRoaXMubWVkaWEsXG4gICAgICAgIGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgcG9zLCBjb25maWcubWF4QnVmZmVySG9sZSksXG4gICAgICAgIG1haW5CdWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odmlkZW9CdWZmZXIsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLFxuICAgICAgICBidWZmZXJMZW4gPSBidWZmZXJJbmZvLmxlbixcbiAgICAgICAgYnVmZmVyRW5kID0gYnVmZmVySW5mby5lbmQsXG4gICAgICAgIGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzLFxuICAgICAgICAvLyBlbnN1cmUgd2UgYnVmZmVyIGF0IGxlYXN0IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGggKGRlZmF1bHQgMzBzKSBvciBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoIChkZWZhdWx0OiA2MDBzKVxuICAgICAgICAvLyB3aGljaGV2ZXIgaXMgc21hbGxlci5cbiAgICAgICAgLy8gb25jZSB3ZSByZWFjaCB0aGF0IHRocmVzaG9sZCwgZG9uJ3QgYnVmZmVyIG1vcmUgdGhhbiB2aWRlbyAobWFpbkJ1ZmZlckluZm8ubGVuKVxuICAgICAgICBtYXhDb25maWdCdWZmZXIgPSBNYXRoLm1pbihjb25maWcubWF4QnVmZmVyTGVuZ3RoLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKSxcbiAgICAgICAgbWF4QnVmTGVuID0gTWF0aC5tYXgobWF4Q29uZmlnQnVmZmVyLCBtYWluQnVmZmVySW5mby5sZW4pLFxuICAgICAgICBhdWRpb1N3aXRjaCA9IHRoaXMuYXVkaW9Td2l0Y2gsXG4gICAgICAgIHRyYWNrSWQgPSB0aGlzLnRyYWNrSWQ7XG5cbiAgICAgICAgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50XG4gICAgICBpZiAoKGJ1ZmZlckxlbiA8IG1heEJ1ZkxlbiB8fCBhdWRpb1N3aXRjaCkgJiYgdHJhY2tJZCA8IHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgdHJhY2tEZXRhaWxzID0gdHJhY2tzW3RyYWNrSWRdLmRldGFpbHM7XG4gICAgICAgIC8vIGlmIHRyYWNrIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgdHJhY2sgcmV0cmlldmFsXG4gICAgICAgIGlmICh0eXBlb2YgdHJhY2tEZXRhaWxzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX1RSQUNLO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhdWRpb1N3aXRjaCAmJiB0aGlzLl9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCB0cmFja0RldGFpbHMpKSB7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRU9TLCB7IHR5cGU6ICdhdWRpbycgfSk7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVOREVEO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgZnJhZ21lbnQgaW5kZXgsIGNvbnRpZ3VvdXMgd2l0aCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgICAgIGxldCBmcmFnbWVudHMgPSB0cmFja0RldGFpbHMuZnJhZ21lbnRzLFxuICAgICAgICAgIGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoLFxuICAgICAgICAgIHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uc3RhcnQgKyBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdLmR1cmF0aW9uLFxuICAgICAgICAgIGZyYWc7XG5cbiAgICAgICAgICAvLyBXaGVuIHN3aXRjaGluZyBhdWRpbyB0cmFjaywgcmVsb2FkIGF1ZGlvIGFzIGNsb3NlIGFzIHBvc3NpYmxlIHRvIGN1cnJlbnRUaW1lXG4gICAgICAgIGlmIChhdWRpb1N3aXRjaCkge1xuICAgICAgICAgIGlmICh0cmFja0RldGFpbHMubGl2ZSAmJiAhdHJhY2tEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdzd2l0Y2hpbmcgYXVkaW90cmFjaywgbGl2ZSBzdHJlYW0sIHVua25vd24gUFRTLGxvYWQgZmlyc3QgZnJhZ21lbnQnKTtcbiAgICAgICAgICAgIGJ1ZmZlckVuZCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlckVuZCA9IHBvcztcbiAgICAgICAgICAgIC8vIGlmIGN1cnJlbnRUaW1lIChwb3MpIGlzIGxlc3MgdGhhbiBhbHQgYXVkaW8gcGxheWxpc3Qgc3RhcnQgdGltZSwgaXQgbWVhbnMgdGhhdCBhbHQgYXVkaW8gaXMgYWhlYWQgb2YgY3VycmVudFRpbWVcbiAgICAgICAgICAgIGlmICh0cmFja0RldGFpbHMuUFRTS25vd24gJiYgcG9zIDwgc3RhcnQpIHtcbiAgICAgICAgICAgICAgLy8gaWYgZXZlcnl0aGluZyBpcyBidWZmZXJlZCBmcm9tIHBvcyB0byBzdGFydCBvciBpZiBhdWRpbyBidWZmZXIgdXBmcm9udCwgbGV0J3Mgc2VlayB0byBzdGFydFxuICAgICAgICAgICAgICBpZiAoYnVmZmVySW5mby5lbmQgPiBzdGFydCB8fCBidWZmZXJJbmZvLm5leHRTdGFydCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ2FsdCBhdWRpbyB0cmFjayBhaGVhZCBvZiBtYWluIHRyYWNrLCBzZWVrIHRvIHN0YXJ0IG9mIGFsdCBhdWRpbyB0cmFjaycpO1xuICAgICAgICAgICAgICAgIHRoaXMubWVkaWEuY3VycmVudFRpbWUgPSBzdGFydCArIDAuMDU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFja0RldGFpbHMuaW5pdFNlZ21lbnQgJiYgIXRyYWNrRGV0YWlscy5pbml0U2VnbWVudC5kYXRhKSB7XG4gICAgICAgICAgZnJhZyA9IHRyYWNrRGV0YWlscy5pbml0U2VnbWVudDtcbiAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJyYWNlLXN0eWxlXG4gICAgICAgIC8vIGlmIGJ1ZmZlckVuZCBiZWZvcmUgc3RhcnQgb2YgcGxheWxpc3QsIGxvYWQgZmlyc3QgZnJhZ21lbnRcbiAgICAgICAgZWxzZSBpZiAoYnVmZmVyRW5kIDw9IHN0YXJ0KSB7XG4gICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgICBpZiAodGhpcy52aWRlb1RyYWNrQ0MgIT09IG51bGwgJiYgZnJhZy5jYyAhPT0gdGhpcy52aWRlb1RyYWNrQ0MpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB3ZSBmaW5kIGEgZnJhZ21lbnQgd2hpY2ggbWF0Y2hlcyB0aGUgY29udGludWl0eSBvZiB0aGUgdmlkZW8gdHJhY2tcbiAgICAgICAgICAgIGZyYWcgPSBmaW5kRnJhZ1dpdGhDQyhmcmFnbWVudHMsIHRoaXMudmlkZW9UcmFja0NDKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5saXZlICYmIGZyYWcubG9hZElkeCAmJiBmcmFnLmxvYWRJZHggPT09IHRoaXMuZnJhZ0xvYWRJZHgpIHtcbiAgICAgICAgICAgIC8vIHdlIGp1c3QgbG9hZGVkIHRoaXMgZmlyc3QgZnJhZ21lbnQsIGFuZCB3ZSBhcmUgc3RpbGwgbGFnZ2luZyBiZWhpbmQgdGhlIHN0YXJ0IG9mIHRoZSBsaXZlIHBsYXlsaXN0XG4gICAgICAgICAgICAvLyBsZXQncyBmb3JjZSBzZWVrIHRvIHN0YXJ0XG4gICAgICAgICAgICBjb25zdCBuZXh0QnVmZmVyZWQgPSBidWZmZXJJbmZvLm5leHRTdGFydCA/IGJ1ZmZlckluZm8ubmV4dFN0YXJ0IDogc3RhcnQ7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBubyBhbHQgYXVkaW8gYXZhaWxhYmxlIEBjdXJyZW50VGltZToke3RoaXMubWVkaWEuY3VycmVudFRpbWV9LCBzZWVraW5nIEAke25leHRCdWZmZXJlZCArIDAuMDV9YCk7XG4gICAgICAgICAgICB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lID0gbmV4dEJ1ZmZlcmVkICsgMC4wNTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGZvdW5kRnJhZztcbiAgICAgICAgICBsZXQgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgICAgIGNvbnN0IGZyYWdOZXh0ID0gZnJhZ1ByZXZpb3VzID8gZnJhZ21lbnRzW2ZyYWdQcmV2aW91cy5zbiAtIGZyYWdtZW50c1swXS5zbiArIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGxldCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QgPSAoY2FuZGlkYXRlKSA9PiB7XG4gICAgICAgICAgICAvLyBvZmZzZXQgc2hvdWxkIGJlIHdpdGhpbiBmcmFnbWVudCBib3VuZGFyeSAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRvIGNvcGUgd2l0aCBzaXR1YXRpb25zIGxpa2VcbiAgICAgICAgICAgIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXG4gICAgICAgICAgICAvLyBmcmFnW8OYXSA6IFswLDEwXVxuICAgICAgICAgICAgLy8gZnJhZ1sxXSA6IFsxMCwyMF1cbiAgICAgICAgICAgIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICBmcmFnIHN0YXJ0ICAgICAgICAgICAgICAgZnJhZyBzdGFydCtkdXJhdGlvblxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cbiAgICAgICAgICAgIC8vICAuLi4tLS0tLS0tLT48LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+PC0tLS0tLS0tLS4uLi5cbiAgICAgICAgICAgIC8vIHByZXZpb3VzIGZyYWcgICAgICAgICBtYXRjaGluZyBmcmFnbWVudCAgICAgICAgIG5leHQgZnJhZ1xuICAgICAgICAgICAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coYGxldmVsL3NuL3N0YXJ0L2VuZC9idWZFbmQ6JHtsZXZlbH0vJHtjYW5kaWRhdGUuc259LyR7Y2FuZGlkYXRlLnN0YXJ0fS8keyhjYW5kaWRhdGUuc3RhcnQrY2FuZGlkYXRlLmR1cmF0aW9uKX0vJHtidWZmZXJFbmR9YCk7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIGxvb2t1cCB0b2xlcmFuY2UgdG8gYmUgc21hbGwgZW5vdWdoIHRvIGRldGVjdCB0aGUgY3VycmVudCBzZWdtZW50IC0gZW5zdXJlcyB3ZSBkb24ndCBza2lwIG92ZXIgdmVyeSBzbWFsbCBzZWdtZW50c1xuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9IE1hdGgubWluKG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZS5kdXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoKGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSkgPD0gYnVmZmVyRW5kKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjYW5kaWRhdGUuc3RhcnQgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBidWZmZXJFbmQgJiYgY2FuZGlkYXRlLnN0YXJ0KSB7XG4gICAgICAgICAgICAgIC8vIGlmIG1heEZyYWdMb29rVXBUb2xlcmFuY2Ugd2lsbCBoYXZlIG5lZ2F0aXZlIHZhbHVlIHRoZW4gZG9uJ3QgcmV0dXJuIC0xIGZvciBmaXJzdCBlbGVtZW50XG4gICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChidWZmZXJFbmQgPCBlbmQpIHtcbiAgICAgICAgICAgIGlmIChidWZmZXJFbmQgPiBlbmQgLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcmVmZXIgdGhlIG5leHQgZnJhZ21lbnQgaWYgaXQncyB3aXRoaW4gdG9sZXJhbmNlXG4gICAgICAgICAgICBpZiAoZnJhZ05leHQgJiYgIWZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChmcmFnTmV4dCkpIHtcbiAgICAgICAgICAgICAgZm91bmRGcmFnID0gZnJhZ05leHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3VuZEZyYWcgPSBCaW5hcnlTZWFyY2guc2VhcmNoKGZyYWdtZW50cywgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVhY2ggZW5kIG9mIHBsYXlsaXN0XG4gICAgICAgICAgICBmb3VuZEZyYWcgPSBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm91bmRGcmFnKSB7XG4gICAgICAgICAgICBmcmFnID0gZm91bmRGcmFnO1xuICAgICAgICAgICAgc3RhcnQgPSBmb3VuZEZyYWcuc3RhcnQ7XG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaW5kIFNOIG1hdGNoaW5nIHdpdGggcG9zOicgKyAgYnVmZmVyRW5kICsgJzonICsgZnJhZy5zbik7XG4gICAgICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIGZyYWcubGV2ZWwgPT09IGZyYWdQcmV2aW91cy5sZXZlbCAmJiBmcmFnLnNuID09PSBmcmFnUHJldmlvdXMuc24pIHtcbiAgICAgICAgICAgICAgaWYgKGZyYWcuc24gPCB0cmFja0RldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWcuc24gKyAxIC0gdHJhY2tEZXRhaWxzLnN0YXJ0U05dO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFNOIGp1c3QgbG9hZGVkLCBsb2FkIG5leHQgb25lOiAke2ZyYWcuc259YCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhZyA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCcgICAgICBsb2FkaW5nIGZyYWcgJyArIGkgKycscG9zL2J1ZkVuZDonICsgcG9zLnRvRml4ZWQoMykgKyAnLycgKyBidWZmZXJFbmQudG9GaXhlZCgzKSk7XG4gICAgICAgICAgaWYgKGZyYWcuZW5jcnlwdGVkKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBMb2FkaW5nIGtleSBmb3IgJHtmcmFnLnNufSBvZiBbJHt0cmFja0RldGFpbHMuc3RhcnRTTn0gLCR7dHJhY2tEZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfWApO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLktFWV9MT0FESU5HO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuS0VZX0xPQURJTkcsIHsgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyAke2ZyYWcuc259LCBjYzogJHtmcmFnLmNjfSBvZiBbJHt0cmFja0RldGFpbHMuc3RhcnRTTn0gLCR7dHJhY2tEZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfSwgY3VycmVudFRpbWU6JHtwb3N9LGJ1ZmZlckVuZDoke2J1ZmZlckVuZC50b0ZpeGVkKDMpfWApO1xuICAgICAgICAgICAgLy8gb25seSBsb2FkIGlmIGZyYWdtZW50IGlzIG5vdCBsb2FkZWQgb3IgaWYgaW4gYXVkaW8gc3dpdGNoXG4gICAgICAgICAgICAvLyB3ZSBmb3JjZSBhIGZyYWcgbG9hZGluZyBpbiBhdWRpbyBzd2l0Y2ggYXMgZnJhZ21lbnQgdHJhY2tlciBtaWdodCBub3QgaGF2ZSBldmljdGVkIHByZXZpb3VzIGZyYWdzIGluIGNhc2Ugb2YgcXVpY2sgYXVkaW8gc3dpdGNoXG4gICAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICAgICAgICAgIGlmIChhdWRpb1N3aXRjaCB8fCB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnLnNuKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FESU5HLCB7IGZyYWcgfSk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFN0YXRlLldBSVRJTkdfVFJBQ0s6XG4gICAgICB0cmFjayA9IHRoaXMudHJhY2tzW3RoaXMudHJhY2tJZF07XG4gICAgICAvLyBjaGVjayBpZiBwbGF5bGlzdCBpcyBhbHJlYWR5IGxvYWRlZFxuICAgICAgaWYgKHRyYWNrICYmIHRyYWNrLmRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB2YXIgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XG4gICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICB2YXIgaXNTZWVraW5nID0gbWVkaWEgJiYgbWVkaWEuc2Vla2luZztcbiAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXG4gICAgICBpZiAoIXJldHJ5RGF0ZSB8fCAobm93ID49IHJldHJ5RGF0ZSkgfHwgaXNTZWVraW5nKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ2F1ZGlvU3RyZWFtQ29udHJvbGxlcjogcmV0cnlEYXRlIHJlYWNoZWQsIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUnKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFN0YXRlLldBSVRJTkdfSU5JVF9QVFM6XG4gICAgICBjb25zdCB2aWRlb1RyYWNrQ0MgPSB0aGlzLnZpZGVvVHJhY2tDQztcbiAgICAgIGlmICh0aGlzLmluaXRQVFNbdmlkZW9UcmFja0NDXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBFbnN1cmUgd2UgZG9uJ3QgZ2V0IHN0dWNrIGluIHRoZSBXQUlUSU5HX0lOSVRfUFRTIHN0YXRlIGlmIHRoZSB3YWl0aW5nIGZyYWcgQ0MgZG9lc24ndCBtYXRjaCBhbnkgaW5pdFBUU1xuICAgICAgY29uc3Qgd2FpdGluZ0ZyYWcgPSB0aGlzLndhaXRpbmdGcmFnbWVudDtcbiAgICAgIGlmICh3YWl0aW5nRnJhZykge1xuICAgICAgICBjb25zdCB3YWl0aW5nRnJhZ0NDID0gd2FpdGluZ0ZyYWcuZnJhZy5jYztcbiAgICAgICAgaWYgKHZpZGVvVHJhY2tDQyAhPT0gd2FpdGluZ0ZyYWdDQykge1xuICAgICAgICAgIHRyYWNrID0gdGhpcy50cmFja3NbdGhpcy50cmFja0lkXTtcbiAgICAgICAgICBpZiAodHJhY2suZGV0YWlscyAmJiB0cmFjay5kZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBXYWl0aW5nIGZyYWdtZW50IENDICgke3dhaXRpbmdGcmFnQ0N9KSBkb2VzIG5vdCBtYXRjaCB2aWRlbyB0cmFjayBDQyAoJHt2aWRlb1RyYWNrQ0N9KWApO1xuICAgICAgICAgICAgdGhpcy53YWl0aW5nRnJhZ21lbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgdGhpcy5vbkZyYWdMb2FkZWQodGhpcy53YWl0aW5nRnJhZ21lbnQpO1xuICAgICAgICAgIHRoaXMud2FpdGluZ0ZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU3RhdGUuU1RPUFBFRDpcbiAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElORzpcbiAgICBjYXNlIFN0YXRlLlBBUlNJTkc6XG4gICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgY2FzZSBTdGF0ZS5FTkRFRDpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoZWQgKGRhdGEpIHtcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbk1lZGlhU2Vla2luZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub252ZW5kZWQgPSB0aGlzLm9uTWVkaWFFbmRlZC5iaW5kKHRoaXMpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmICh0aGlzLnRyYWNrcyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCkge1xuICAgICAgdGhpcy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcgKCkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhICYmIG1lZGlhLmVuZGVkKSB7XG4gICAgICBsb2dnZXIubG9nKCdNU0UgZGV0YWNoaW5nIGFuZCB2aWRlbyBlbmRlZCwgcmVzZXQgc3RhcnRQb3NpdGlvbicpO1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252c2Vla2VkID0gdGhpcy5vbnZlbmRlZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgfVxuXG4gIG9uQXVkaW9UcmFja3NVcGRhdGVkIChkYXRhKSB7XG4gICAgbG9nZ2VyLmxvZygnYXVkaW8gdHJhY2tzIHVwZGF0ZWQnKTtcbiAgICB0aGlzLnRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3M7XG4gIH1cblxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcgKGRhdGEpIHtcbiAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgbGV0IGFsdEF1ZGlvID0gISFkYXRhLnVybDtcbiAgICB0aGlzLnRyYWNrSWQgPSBkYXRhLmlkO1xuXG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBVVNFRDtcbiAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XG4gICAgLy8gZGVzdHJveSB1c2VsZXNzIGRlbXV4ZXIgd2hlbiBzd2l0Y2hpbmcgYXVkaW8gdG8gbWFpblxuICAgIGlmICghYWx0QXVkaW8pIHtcbiAgICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3dpdGNoaW5nIHRvIGF1ZGlvIHRyYWNrLCBzdGFydCB0aW1lciBpZiBub3QgYWxyZWFkeSBzdGFydGVkXG4gICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xuICAgIH1cblxuICAgIC8vIHNob3VsZCB3ZSBzd2l0Y2ggdHJhY2tzID9cbiAgICBpZiAoYWx0QXVkaW8pIHtcbiAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSB0cnVlO1xuICAgICAgLy8gbWFpbiBhdWRpbyB0cmFjayBhcmUgaGFuZGxlZCBieSBzdHJlYW0tY29udHJvbGxlciwganVzdCBkbyBzb21ldGhpbmcgaWYgc3dpdGNoaW5nIHRvIGFsdCBhdWRpbyB0cmFja1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25BdWRpb1RyYWNrTG9hZGVkIChkYXRhKSB7XG4gICAgbGV0IG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHMsXG4gICAgICB0cmFja0lkID0gZGF0YS5pZCxcbiAgICAgIHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tJZF0sXG4gICAgICBkdXJhdGlvbiA9IG5ld0RldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgIHNsaWRpbmcgPSAwO1xuXG4gICAgbG9nZ2VyLmxvZyhgdHJhY2sgJHt0cmFja0lkfSBsb2FkZWQgWyR7bmV3RGV0YWlscy5zdGFydFNOfSwke25ld0RldGFpbHMuZW5kU059XSxkdXJhdGlvbjoke2R1cmF0aW9ufWApO1xuXG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgbGV0IGN1ckRldGFpbHMgPSB0cmFjay5kZXRhaWxzO1xuICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyB3ZSBhbHJlYWR5IGhhdmUgZGV0YWlscyBmb3IgdGhhdCBsZXZlbCwgbWVyZ2UgdGhlbVxuICAgICAgICBMZXZlbEhlbHBlci5tZXJnZURldGFpbHMoY3VyRGV0YWlscywgbmV3RGV0YWlscyk7XG4gICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyB0aGlzLmxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgY3VyRGV0YWlscyk7XG4gICAgICAgIGlmIChuZXdEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBhdWRpbyBwbGF5bGlzdCBzbGlkaW5nOiR7c2xpZGluZy50b0ZpeGVkKDMpfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgYXVkaW8gcGxheWxpc3QgLSBvdXRkYXRlZCBQVFMsIHVua25vd24gc2xpZGluZycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgYXVkaW8gcGxheWxpc3QgLSBmaXJzdCBsb2FkLCB1bmtub3duIHNsaWRpbmcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgIH1cbiAgICB0cmFjay5kZXRhaWxzID0gbmV3RGV0YWlscztcblxuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb25cbiAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICAgIGlmICh0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcbiAgICAgICAgbGV0IHN0YXJ0VGltZU9mZnNldCA9IG5ld0RldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBzdGFydCB0aW1lIG9mZnNldCBmb3VuZCBpbiBwbGF5bGlzdCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gdG8gJHtzdGFydFRpbWVPZmZzZXR9YCk7XG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICB9XG4gICAgLy8gb25seSBzd2l0Y2ggYmF0Y2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIHRyYWNrIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfVFJBQ0spIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uS2V5TG9hZGVkICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuS0VZX0xPQURJTkcpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnTG9hZGVkIChkYXRhKSB7XG4gICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgIGZyYWdMb2FkZWQgPSBkYXRhLmZyYWc7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyAmJlxuICAgICAgICBmcmFnQ3VycmVudCAmJlxuICAgICAgICBmcmFnTG9hZGVkLnR5cGUgPT09ICdhdWRpbycgJiZcbiAgICAgICAgZnJhZ0xvYWRlZC5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgZnJhZ0xvYWRlZC5zbiA9PT0gZnJhZ0N1cnJlbnQuc24pIHtcbiAgICAgIGxldCB0cmFjayA9IHRoaXMudHJhY2tzW3RoaXMudHJhY2tJZF0sXG4gICAgICAgIGRldGFpbHMgPSB0cmFjay5kZXRhaWxzLFxuICAgICAgICBkdXJhdGlvbiA9IGRldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgICAgdHJhY2tJZCA9IGZyYWdDdXJyZW50LmxldmVsLFxuICAgICAgICBzbiA9IGZyYWdDdXJyZW50LnNuLFxuICAgICAgICBjYyA9IGZyYWdDdXJyZW50LmNjLFxuICAgICAgICBhdWRpb0NvZGVjID0gdGhpcy5jb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgdHJhY2suYXVkaW9Db2RlYyB8fCAnbXA0YS40MC4yJyxcbiAgICAgICAgc3RhdHMgPSB0aGlzLnN0YXRzID0gZGF0YS5zdGF0cztcbiAgICAgIGlmIChzbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcblxuICAgICAgICBzdGF0cy50cGFyc2VkID0gc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGRldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSA9IGRhdGEucGF5bG9hZDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7IHN0YXRzOiBzdGF0cywgZnJhZzogZnJhZ0N1cnJlbnQsIGlkOiAnYXVkaW8nIH0pO1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTSU5HO1xuICAgICAgICAvLyB0cmFuc211eCB0aGUgTVBFRy1UUyBkYXRhIHRvIElTTy1CTUZGIHNlZ21lbnRzXG4gICAgICAgIHRoaXMuYXBwZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcih0aGlzLmhscywgJ2F1ZGlvJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHZpZGVvIGluaXRQVFNcbiAgICAgICAgLy8gSWYgbm90IHdlIG5lZWQgdG8gd2FpdCBmb3IgaXRcbiAgICAgICAgbGV0IGluaXRQVFMgPSB0aGlzLmluaXRQVFNbY2NdO1xuICAgICAgICBsZXQgaW5pdFNlZ21lbnREYXRhID0gZGV0YWlscy5pbml0U2VnbWVudCA/IGRldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSA6IFtdO1xuICAgICAgICBpZiAoZGV0YWlscy5pbml0U2VnbWVudCB8fCBpbml0UFRTICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgIGxvZ2dlci5sb2coYERlbXV4aW5nICR7c259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLHRyYWNrICR7dHJhY2tJZH1gKTtcbiAgICAgICAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcbiAgICAgICAgICBsZXQgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gZmFsc2U7IC8vIGRldGFpbHMuUFRTS25vd24gfHwgIWRldGFpbHMubGl2ZTtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIucHVzaChkYXRhLnBheWxvYWQsIGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgbnVsbCwgZnJhZ0N1cnJlbnQsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGluaXRQVFMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coYHVua25vd24gdmlkZW8gUFRTIGZvciBjb250aW51aXR5IGNvdW50ZXIgJHtjY30sIHdhaXRpbmcgZm9yIHZpZGVvIFBUUyBiZWZvcmUgZGVtdXhpbmcgYXVkaW8gZnJhZyAke3NufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICAgICAgdGhpcy53YWl0aW5nRnJhZ21lbnQgPSBkYXRhO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nSW5pdFNlZ21lbnQgKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgY29uc3QgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ2F1ZGlvJyAmJlxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICBsZXQgdHJhY2tzID0gZGF0YS50cmFja3MsIHRyYWNrO1xuXG4gICAgICAvLyBkZWxldGUgYW55IHZpZGVvIHRyYWNrIGZvdW5kIG9uIGF1ZGlvIGRlbXV4ZXJcbiAgICAgIGlmICh0cmFja3MudmlkZW8pIHtcbiAgICAgICAgZGVsZXRlIHRyYWNrcy52aWRlbztcbiAgICAgIH1cblxuICAgICAgLy8gaW5jbHVkZSBsZXZlbENvZGVjIGluIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3NcbiAgICAgIHRyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSB0cmFjay5jb2RlYztcbiAgICAgICAgdHJhY2suaWQgPSBkYXRhLmlkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9DT0RFQ1MsIHRyYWNrcyk7XG4gICAgICAgIGxvZ2dlci5sb2coYGF1ZGlvIHRyYWNrOmF1ZGlvLGNvbnRhaW5lcjoke3RyYWNrLmNvbnRhaW5lcn0sY29kZWNzW2xldmVsL3BhcnNlZF09WyR7dHJhY2subGV2ZWxDb2RlY30vJHt0cmFjay5jb2RlY31dYCk7XG4gICAgICAgIGxldCBpbml0U2VnbWVudCA9IHRyYWNrLmluaXRTZWdtZW50O1xuICAgICAgICBpZiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgICAgICBsZXQgYXBwZW5kT2JqID0geyB0eXBlOiAnYXVkaW8nLCBkYXRhOiBpbml0U2VnbWVudCwgcGFyZW50OiAnYXVkaW8nLCBjb250ZW50OiAnaW5pdFNlZ21lbnQnIH07XG4gICAgICAgICAgaWYgKHRoaXMuYXVkaW9Td2l0Y2gpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGEgPSBbYXBwZW5kT2JqXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICAvLyBhcm0gcGVuZGluZyBCdWZmZXJpbmcgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIGEgc2VnbWVudFxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywgYXBwZW5kT2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nRGF0YSAoZGF0YSkge1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBjb25zdCBmcmFnTmV3ID0gZGF0YS5mcmFnO1xuICAgIGlmIChmcmFnQ3VycmVudCAmJlxuICAgICAgICBkYXRhLmlkID09PSAnYXVkaW8nICYmXG4gICAgICAgIGRhdGEudHlwZSA9PT0gJ2F1ZGlvJyAmJlxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICBsZXQgdHJhY2tJZCA9IHRoaXMudHJhY2tJZCxcbiAgICAgICAgdHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja0lkXSxcbiAgICAgICAgaGxzID0gdGhpcy5obHM7XG5cbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGRhdGEuZW5kUFRTKSkge1xuICAgICAgICBkYXRhLmVuZFBUUyA9IGRhdGEuc3RhcnRQVFMgKyBmcmFnQ3VycmVudC5kdXJhdGlvbjtcbiAgICAgICAgZGF0YS5lbmREVFMgPSBkYXRhLnN0YXJ0RFRTICsgZnJhZ0N1cnJlbnQuZHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIGZyYWdDdXJyZW50LmFkZEVsZW1lbnRhcnlTdHJlYW0oRnJhZ21lbnQuRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPKTtcblxuICAgICAgbG9nZ2VyLmxvZyhgcGFyc2VkICR7ZGF0YS50eXBlfSxQVFM6WyR7ZGF0YS5zdGFydFBUUy50b0ZpeGVkKDMpfSwke2RhdGEuZW5kUFRTLnRvRml4ZWQoMyl9XSxEVFM6WyR7ZGF0YS5zdGFydERUUy50b0ZpeGVkKDMpfS8ke2RhdGEuZW5kRFRTLnRvRml4ZWQoMyl9XSxuYjoke2RhdGEubmJ9YCk7XG4gICAgICBMZXZlbEhlbHBlci51cGRhdGVGcmFnUFRTRFRTKHRyYWNrLmRldGFpbHMsIGZyYWdDdXJyZW50LCBkYXRhLnN0YXJ0UFRTLCBkYXRhLmVuZFBUUyk7XG5cbiAgICAgIGxldCBhdWRpb1N3aXRjaCA9IHRoaXMuYXVkaW9Td2l0Y2gsIG1lZGlhID0gdGhpcy5tZWRpYSwgYXBwZW5kT25CdWZmZXJGbHVzaCA9IGZhbHNlO1xuICAgICAgLy8gT25seSBmbHVzaCBhdWRpbyBmcm9tIG9sZCBhdWRpbyB0cmFja3Mgd2hlbiBQVFMgaXMga25vd24gb24gbmV3IGF1ZGlvIHRyYWNrXG4gICAgICBpZiAoYXVkaW9Td2l0Y2ggJiYgbWVkaWEpIHtcbiAgICAgICAgaWYgKG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICBsZXQgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgICAgICBsb2dnZXIubG9nKCdzd2l0Y2hpbmcgYXVkaW8gdHJhY2sgOiBjdXJyZW50VGltZTonICsgY3VycmVudFRpbWUpO1xuICAgICAgICAgIGlmIChjdXJyZW50VGltZSA+PSBkYXRhLnN0YXJ0UFRTKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdzd2l0Y2hpbmcgYXVkaW8gdHJhY2sgOiBmbHVzaGluZyBhbGwgYXVkaW8nKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hJTkcsIHsgc3RhcnRPZmZzZXQ6IDAsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0eXBlOiAnYXVkaW8nIH0pO1xuICAgICAgICAgICAgYXBwZW5kT25CdWZmZXJGbHVzaCA9IHRydWU7XG4gICAgICAgICAgICAvLyBMZXRzIGFubm91bmNlIHRoYXQgdGhlIGluaXRpYWwgYXVkaW8gdHJhY2sgc3dpdGNoIGZsdXNoIG9jY3VyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCwgeyBpZDogdHJhY2tJZCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTGV0cyBhbm5vdW5jZSB0aGF0IHRoZSBpbml0aWFsIGF1ZGlvIHRyYWNrIHN3aXRjaCBmbHVzaCBvY2N1clxuICAgICAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCwgeyBpZDogdHJhY2tJZCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgcGVuZGluZ0RhdGEgPSB0aGlzLnBlbmRpbmdEYXRhO1xuXG4gICAgICBpZiAoIXBlbmRpbmdEYXRhKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdBcHBhcmVudGx5IGF0dGVtcHQgdG8gZW5xdWV1ZSBtZWRpYSBwYXlsb2FkIHdpdGhvdXQgY29kZWMgaW5pdGlhbGl6YXRpb24gZGF0YSB1cGZyb250Jyk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IG51bGwsIGZhdGFsOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5hdWRpb1N3aXRjaCkge1xuICAgICAgICBbZGF0YS5kYXRhMSwgZGF0YS5kYXRhMl0uZm9yRWFjaChidWZmZXIgPT4ge1xuICAgICAgICAgIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcGVuZGluZ0RhdGEucHVzaCh7IHR5cGU6IGRhdGEudHlwZSwgZGF0YTogYnVmZmVyLCBwYXJlbnQ6ICdhdWRpbycsIGNvbnRlbnQ6ICdkYXRhJyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWFwcGVuZE9uQnVmZmVyRmx1c2ggJiYgcGVuZGluZ0RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgcGVuZGluZ0RhdGEuZm9yRWFjaChhcHBlbmRPYmogPT4ge1xuICAgICAgICAgICAgLy8gb25seSBhcHBlbmQgaW4gUEFSU0lORyBzdGF0ZSAocmF0aW9uYWxlIGlzIHRoYXQgYW4gYXBwZW5kaW5nIGVycm9yIGNvdWxkIGhhcHBlbiBzeW5jaHJvbm91c2x5IG9uIGZpcnN0IHNlZ21lbnQgYXBwZW5kaW5nKVxuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGl0IGlzIHVzZWxlc3MgdG8gYXBwZW5kIGZvbGxvd2luZyBzZWdtZW50c1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcbiAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCBhcHBlbmRPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGEgPSBbXTtcbiAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnUGFyc2VkIChkYXRhKSB7XG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcbiAgICAgICAgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgdGhpcy5zdGF0cy50cGFyc2VkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0VEO1xuICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgIH1cbiAgfVxuXG4gIG9uQnVmZmVyUmVzZXQgKCkge1xuICAgIC8vIHJlc2V0IHJlZmVyZW5jZSB0byBzb3VyY2VidWZmZXJzXG4gICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgfVxuXG4gIG9uQnVmZmVyQ3JlYXRlZCAoZGF0YSkge1xuICAgIGxldCBhdWRpb1RyYWNrID0gZGF0YS50cmFja3MuYXVkaW87XG4gICAgaWYgKGF1ZGlvVHJhY2spIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBhdWRpb1RyYWNrLmJ1ZmZlcjtcbiAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZGF0YS50cmFja3MudmlkZW8pIHtcbiAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSBkYXRhLnRyYWNrcy52aWRlby5idWZmZXI7XG4gICAgfVxuICB9XG5cbiAgb25CdWZmZXJBcHBlbmRlZCAoZGF0YSkge1xuICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ2F1ZGlvJykge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgaWYgKHN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8IHN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIGFwcGVuZGVkXG4gICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IChkYXRhLnBlbmRpbmcgPiAwKTtcbiAgICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jaGVja0FwcGVuZGVkUGFyc2VkICgpIHtcbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCAmJiAoIXRoaXMuYXBwZW5kZWQgfHwgIXRoaXMucGVuZGluZ0J1ZmZlcmluZykpIHtcbiAgICAgIGxldCBmcmFnID0gdGhpcy5mcmFnQ3VycmVudCwgc3RhdHMgPSB0aGlzLnN0YXRzLCBobHMgPSB0aGlzLmhscztcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgICAgc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZSQUdfQlVGRkVSRUQsIHsgc3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnLCBpZDogJ2F1ZGlvJyB9KTtcbiAgICAgICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgICAgICBsb2dnZXIubG9nKGBhdWRpbyBidWZmZXJlZCA6ICR7VGltZVJhbmdlcy50b1N0cmluZyhtZWRpYS5idWZmZXJlZCl9YCk7XG4gICAgICAgIGlmICh0aGlzLmF1ZGlvU3dpdGNoICYmIHRoaXMuYXBwZW5kZWQpIHtcbiAgICAgICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHsgaWQ6IHRoaXMudHJhY2tJZCB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IgKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBhdWRpbyBmcmFnbWVudFxuICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gJ2F1ZGlvJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgIC8vIGRvbid0IGhhbmRsZSBmcmFnIGVycm9yIG5vdCByZWxhdGVkIHRvIGF1ZGlvIGZyYWdtZW50XG4gICAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09ICdhdWRpbycpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGF0YS5mYXRhbCkge1xuICAgICAgICBsZXQgbG9hZEVycm9yID0gdGhpcy5mcmFnTG9hZEVycm9yO1xuICAgICAgICBpZiAobG9hZEVycm9yKSB7XG4gICAgICAgICAgbG9hZEVycm9yKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9hZEVycm9yID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICBpZiAobG9hZEVycm9yIDw9IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5KSB7XG4gICAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gbG9hZEVycm9yO1xuICAgICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dFxuICAgICAgICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5taW4oTWF0aC5wb3coMiwgbG9hZEVycm9yIC0gMSkgKiBjb25maWcuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LCBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQpO1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBBdWRpb1N0cmVhbUNvbnRyb2xsZXI6IGZyYWcgbG9hZGluZyBmYWlsZWQsIHJldHJ5IGluICR7ZGVsYXl9IG1zYCk7XG4gICAgICAgICAgdGhpcy5yZXRyeURhdGUgPSBwZXJmb3JtYW5jZS5ub3coKSArIGRlbGF5O1xuICAgICAgICAgIC8vIHJldHJ5IGxvYWRpbmcgc3RhdGVcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGBBdWRpb1N0cmVhbUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSByZWFjaGVzIG1heCByZXRyeSwgcmVkaXNwYXRjaCBhcyBmYXRhbCAuLi5gKTtcbiAgICAgICAgICAvLyBzd2l0Y2ggZXJyb3IgdG8gZmF0YWxcbiAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAvLyAgd2hlbiBpbiBFUlJPUiBzdGF0ZSwgZG9uJ3Qgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpbiBjYXNlIGEgbm9uLWZhdGFsIGVycm9yIGlzIHJlY2VpdmVkXG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgLy8gaWYgZmF0YWwgZXJyb3IsIHN0b3AgcHJvY2Vzc2luZywgb3RoZXJ3aXNlIG1vdmUgdG8gSURMRSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgIHRoaXMuc3RhdGUgPSBkYXRhLmZhdGFsID8gU3RhdGUuRVJST1IgOiBTdGF0ZS5JRExFO1xuICAgICAgICBsb2dnZXIud2FybihgQXVkaW9TdHJlYW1Db250cm9sbGVyOiAke2RhdGEuZGV0YWlsc30gd2hpbGUgbG9hZGluZyBmcmFnLCBub3cgc3dpdGNoaW5nIHRvICR7dGhpcy5zdGF0ZX0gc3RhdGUgLi4uYCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgIC8vIGlmIGluIGFwcGVuZGluZyBzdGF0ZVxuICAgICAgaWYgKGRhdGEucGFyZW50ID09PSAnYXVkaW8nICYmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8wqB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQpKSB7XG4gICAgICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlcixcbiAgICAgICAgICBjdXJyZW50VGltZSA9IHRoaXMubWVkaWEuY3VycmVudFRpbWUsXG4gICAgICAgICAgbWVkaWFCdWZmZXJlZCA9IG1lZGlhICYmIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLCBjdXJyZW50VGltZSkgJiYgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsIGN1cnJlbnRUaW1lICsgMC41KTtcbiAgICAgICAgICAvLyByZWR1Y2UgbWF4IGJ1ZiBsZW4gaWYgY3VycmVudCBwb3NpdGlvbiBpcyBidWZmZXJlZFxuICAgICAgICBpZiAobWVkaWFCdWZmZXJlZCkge1xuICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgIGlmIChjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoID49IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCBhcyBpdCBtaWdodCBiZSB0b28gaGlnaC4gd2UgZG8gdGhpcyB0byBhdm9pZCBsb29wIGZsdXNoaW5nIC4uLlxuICAgICAgICAgICAgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCAvPSAyO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYEF1ZGlvU3RyZWFtQ29udHJvbGxlcjogcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIHRvICR7Y29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aH1zYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLCBidXQgYnJvd3NlciBpcyBzdGlsbCBjb21wbGFpbmluZyBhYm91dCBidWZmZXIgZnVsbCBlcnJvclxuICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBvbiBJRS9FZGdlLCByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9wdWxsLzcwOFxuICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSBmbHVzaCB0aGUgd2hvbGUgYXVkaW8gYnVmZmVyIHRvIHJlY292ZXJcbiAgICAgICAgICBsb2dnZXIud2FybignQXVkaW9TdHJlYW1Db250cm9sbGVyOiBidWZmZXIgZnVsbCBlcnJvciBhbHNvIG1lZGlhLmN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgZmx1c2ggYXVkaW8gYnVmZmVyJyk7XG4gICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgLy8gZmx1c2ggZXZlcnl0aGluZ1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hJTkcsIHsgc3RhcnRPZmZzZXQ6IDAsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0eXBlOiAnYXVkaW8nIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgb25CdWZmZXJGbHVzaGVkICgpIHtcbiAgICBsZXQgcGVuZGluZ0RhdGEgPSB0aGlzLnBlbmRpbmdEYXRhO1xuICAgIGlmIChwZW5kaW5nRGF0YSAmJiBwZW5kaW5nRGF0YS5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci5sb2coJ0F1ZGlvU3RyZWFtQ29udHJvbGxlcjogYXBwZW5kaW5nIHBlbmRpbmcgYXVkaW8gZGF0YSBhZnRlciBidWZmZXIgZmx1c2hlZCcpO1xuICAgICAgcGVuZGluZ0RhdGEuZm9yRWFjaChhcHBlbmRPYmogPT4ge1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsIGFwcGVuZE9iaik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xuICAgICAgdGhpcy5wZW5kaW5nRGF0YSA9IFtdO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbW92ZSB0byBJRExFIG9uY2UgZmx1c2ggY29tcGxldGUuIHRoaXMgc2hvdWxkIHRyaWdnZXIgbmV3IGZyYWdtZW50IGxvYWRpbmdcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIGZyYWdcbiAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgQXVkaW9TdHJlYW1Db250cm9sbGVyO1xuIiwiaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgVGFza0xvb3AgZnJvbSAnLi4vdGFzay1sb29wJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuXG4vKipcbiAqIEBjbGFzcyBBdWRpb1RyYWNrQ29udHJvbGxlclxuICogQGltcGxlbWVudHMge0V2ZW50SGFuZGxlcn1cbiAqXG4gKiBIYW5kbGVzIG1haW4gbWFuaWZlc3QgYW5kIGF1ZGlvLXRyYWNrIG1ldGFkYXRhIGxvYWRlZCxcbiAqIG93bnMgYW5kIGV4cG9zZXMgdGhlIHNlbGVjdGFibGUgYXVkaW8tdHJhY2tzIGRhdGEtbW9kZWxzLlxuICpcbiAqIEV4cG9zZXMgaW50ZXJuYWwgaW50ZXJmYWNlIHRvIHNlbGVjdCBhdmFpbGFibGUgYXVkaW8tdHJhY2tzLlxuICpcbiAqIEhhbmRsZXMgZXJyb3JzIG9uIGxvYWRpbmcgYXVkaW8tdHJhY2sgcGxheWxpc3RzLiBNYW5hZ2VzIGZhbGxiYWNrIG1lY2hhbmlzbVxuICogd2l0aCByZWR1bmRhbnRzIHRyYWNrcyAoZ3JvdXAtSURzKS5cbiAqXG4gKiBIYW5kbGVzIGxldmVsLWxvYWRpbmcgYW5kIGdyb3VwLUlEIHN3aXRjaGVzIGZvciB2aWRlbyAoZmFsbGJhY2sgb24gdmlkZW8gbGV2ZWxzKSxcbiAqIGFuZCBldmVudHVhbGx5IGFkYXB0cyB0aGUgYXVkaW8tdHJhY2sgZ3JvdXAtSUQgdG8gbWF0Y2guXG4gKlxuICogQGZpcmVzIEFVRElPX1RSQUNLX0xPQURJTkdcbiAqIEBmaXJlcyBBVURJT19UUkFDS19TV0lUQ0hJTkdcbiAqIEBmaXJlcyBBVURJT19UUkFDS1NfVVBEQVRFRFxuICogQGZpcmVzIEVSUk9SXG4gKlxuICovXG5jbGFzcyBBdWRpb1RyYWNrQ29udHJvbGxlciBleHRlbmRzIFRhc2tMb29wIHtcbiAgY29uc3RydWN0b3IgKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURJTkcsXG4gICAgICBFdmVudC5NQU5JRkVTVF9QQVJTRUQsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19MT0FERUQsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCxcbiAgICAgIEV2ZW50LkxFVkVMX0xPQURFRCxcbiAgICAgIEV2ZW50LkVSUk9SXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQ3VycmVudGx5IHNlbGVjdGVkIGluZGV4IGluIGB0cmFja3NgXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSB0cmFja0lkXG4gICAgICovXG4gICAgdGhpcy5fdHJhY2tJZCA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBJZiBzaG91bGQgc2VsZWN0IHRyYWNrcyBhY2NvcmRpbmcgdG8gZGVmYXVsdCB0cmFjayBhdHRyaWJ1dGVcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufSBfc2VsZWN0RGVmYXVsdFRyYWNrXG4gICAgICovXG4gICAgdGhpcy5fc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBBbGwgdHJhY2tzIGF2YWlsYWJsZVxuICAgICAqIEBtZW1iZXIge0F1ZGlvVHJhY2tbXX1cbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIExpc3Qgb2YgYmxhY2tsaXN0ZWQgYXVkaW8gdHJhY2sgSURzICh0aGF0IGhhdmUgY2F1c2VkIGZhaWx1cmUpXG4gICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICovXG4gICAgdGhpcy50cmFja0lkQmxhY2tsaXN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBUaGUgY3VycmVudGx5IHJ1bm5pbmcgZ3JvdXAgSUQgZm9yIGF1ZGlvXG4gICAgICogKHdlIGdyYWIgdGhpcyBvbiBtYW5pZmVzdC1wYXJzZWQgYW5kIG5ldyBsZXZlbC1sb2FkZWQpXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuYXVkaW9Hcm91cElkID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBhdWRpbyB0cmFja3Mgb24gbmV3IG1hbmlmZXN0IGxvYWRpbmcuXG4gICAqL1xuICBvbk1hbmlmZXN0TG9hZGluZyAoKSB7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLl90cmFja0lkID0gLTE7XG4gICAgdGhpcy5fc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZSB0cmFja3MgZGF0YSBmcm9tIG1hbmlmZXN0IHBhcnNlZCBkYXRhLlxuICAgKlxuICAgKiBUcmlnZ2VyIEFVRElPX1RSQUNLU19VUERBVEVEIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICovXG4gIG9uTWFuaWZlc3RQYXJzZWQgKGRhdGEpIHtcbiAgICBjb25zdCB0cmFja3MgPSB0aGlzLnRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MgfHwgW107XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS1NfVVBEQVRFRCwgeyBhdWRpb1RyYWNrczogdHJhY2tzIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlIHRyYWNrIGRldGFpbHMgb2YgbG9hZGVkIHRyYWNrIGluIG91ciBkYXRhLW1vZGVsLlxuICAgKlxuICAgKiBTZXQtdXAgbWV0YWRhdGEgdXBkYXRlIGludGVydmFsIHRhc2sgZm9yIGxpdmUtbW9kZSBzdHJlYW1zLlxuICAgKlxuICAgKiBAcGFyYW0ge30gZGF0YVxuICAgKi9cbiAgb25BdWRpb1RyYWNrTG9hZGVkIChkYXRhKSB7XG4gICAgaWYgKGRhdGEuaWQgPj0gdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIud2FybignSW52YWxpZCBhdWRpbyB0cmFjayBpZDonLCBkYXRhLmlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2dnZXIubG9nKGBhdWRpb1RyYWNrICR7ZGF0YS5pZH0gbG9hZGVkYCk7XG5cbiAgICB0aGlzLnRyYWNrc1tkYXRhLmlkXS5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuXG4gICAgLy8gY2hlY2sgaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3RcbiAgICAvLyBhbmQgaWYgd2UgaGF2ZSBhbHJlYWR5IG91ciByZWxvYWQgaW50ZXJ2YWwgc2V0dXBcbiAgICBpZiAoZGF0YS5kZXRhaWxzLmxpdmUgJiYgIXRoaXMuaGFzSW50ZXJ2YWwoKSkge1xuICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCB3ZSB3aWxsIGhhdmUgdG8gcmVsb2FkIGl0IHBlcmlvZGljYWxseVxuICAgICAgLy8gc2V0IHJlbG9hZCBwZXJpb2QgdG8gcGxheWxpc3QgdGFyZ2V0IGR1cmF0aW9uXG4gICAgICBjb25zdCB1cGRhdGVQZXJpb2RNcyA9IGRhdGEuZGV0YWlscy50YXJnZXRkdXJhdGlvbiAqIDEwMDA7XG4gICAgICB0aGlzLnNldEludGVydmFsKHVwZGF0ZVBlcmlvZE1zKTtcbiAgICB9XG5cbiAgICBpZiAoIWRhdGEuZGV0YWlscy5saXZlICYmIHRoaXMuaGFzSW50ZXJ2YWwoKSkge1xuICAgICAgLy8gcGxheWxpc3QgaXMgbm90IGxpdmUgYW5kIHRpbWVyIGlzIHNjaGVkdWxlZDogY2FuY2VsIGl0XG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBpbnRlcm5hbCBncm91cCBJRCB0byBhbnkgYXVkaW8tdHJhY2sgd2UgbWF5IGhhdmUgc2V0IG1hbnVhbGx5XG4gICAqIG9yIGJlY2F1c2Ugb2YgYSBmYWlsdXJlLWhhbmRsaW5nIGZhbGxiYWNrLlxuICAgKlxuICAgKiBRdWFsaXR5LWxldmVscyBzaG91bGQgdXBkYXRlIHRvIHRoYXQgZ3JvdXAgSUQgaW4gdGhpcyBjYXNlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICovXG4gIG9uQXVkaW9UcmFja1N3aXRjaGVkIChkYXRhKSB7XG4gICAgY29uc3QgYXVkaW9Hcm91cElkID0gdGhpcy50cmFja3NbZGF0YS5pZF0uZ3JvdXBJZDtcbiAgICBpZiAoYXVkaW9Hcm91cElkICYmICh0aGlzLmF1ZGlvR3JvdXBJZCAhPT0gYXVkaW9Hcm91cElkKSkge1xuICAgICAgdGhpcy5hdWRpb0dyb3VwSWQgPSBhdWRpb0dyb3VwSWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBsZXZlbCBnZXRzIGxvYWRlZCwgaWYgaXQgaGFzIHJlZHVuZGFudCBhdWRpb0dyb3VwSWRzIChpbiB0aGUgc2FtZSBvcmRpbmFsaXR5IGFzIGl0J3MgcmVkdW5kYW50IFVSTHMpXG4gICAqIHdlIGFyZSBzZXR0aW5nIG91ciBhdWRpby1ncm91cCBJRCBpbnRlcm5hbGx5IHRvIHRoZSBvbmUgc2V0LCBpZiBpdCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZ3JvdXAgSUQgY3VycmVudGx5IHNldC5cbiAgICpcbiAgICogSWYgZ3JvdXAtSUQgZ290IHVwZGF0ZSwgd2UgcmUtc2VsZWN0IHRoZSBhcHByb3ByaWF0ZSBhdWRpby10cmFjayB3aXRoIHRoaXMgZ3JvdXAtSUQgbWF0Y2hpbmcgdGhlIGN1cnJlbnRseVxuICAgKiBzZWxlY3RlZCBvbmUgKGJhc2VkIG9uIE5BTUUgcHJvcGVydHkpLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICovXG4gIG9uTGV2ZWxMb2FkZWQgKGRhdGEpIHtcbiAgICAvLyBGSVhNRTogY3Jhc2hlcyBiZWNhdXNlIGN1cnJlbnRMZXZlbCBpcyB1bmRlZmluZWRcbiAgICAvLyBjb25zdCBsZXZlbEluZm8gPSB0aGlzLmhscy5sZXZlbHNbdGhpcy5obHMuY3VycmVudExldmVsXTtcblxuICAgIGNvbnN0IGxldmVsSW5mbyA9IHRoaXMuaGxzLmxldmVsc1tkYXRhLmxldmVsXTtcblxuICAgIGlmICghbGV2ZWxJbmZvLmF1ZGlvR3JvdXBJZHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhdWRpb0dyb3VwSWQgPSBsZXZlbEluZm8uYXVkaW9Hcm91cElkc1tsZXZlbEluZm8udXJsSWRdO1xuICAgIGlmICh0aGlzLmF1ZGlvR3JvdXBJZCAhPT0gYXVkaW9Hcm91cElkKSB7XG4gICAgICB0aGlzLmF1ZGlvR3JvdXBJZCA9IGF1ZGlvR3JvdXBJZDtcbiAgICAgIHRoaXMuX3NlbGVjdEluaXRpYWxBdWRpb1RyYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBuZXR3b3JrIGVycm9ycyBsb2FkaW5nIGF1ZGlvIHRyYWNrIG1hbmlmZXN0c1xuICAgKiBhbmQgYWxzbyBwYXVzaW5nIG9uIGFueSBuZXR3b2sgZXJyb3JzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Vycm9yRXZlbnREYXRhfSBkYXRhXG4gICAqL1xuICBvbkVycm9yIChkYXRhKSB7XG4gICAgLy8gT25seSBoYW5kbGUgbmV0d29yayBlcnJvcnNcbiAgICBpZiAoZGF0YS50eXBlICE9PSBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBmYXRhbCBuZXR3b3JrIGVycm9yLCBjYW5jZWwgdXBkYXRlIHRhc2tcbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgfVxuXG4gICAgLy8gSWYgbm90IGFuIGF1ZGlvLXRyYWNrIGxvYWRpbmcgZXJyb3IgZG9uJ3QgaGFuZGxlIGZ1cnRoZXJcbiAgICBpZiAoZGF0YS5kZXRhaWxzICE9PSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvZ2dlci53YXJuKCdOZXR3b3JrIGZhaWx1cmUgb24gYXVkaW8tdHJhY2sgaWQ6JywgZGF0YS5jb250ZXh0LmlkKTtcbiAgICB0aGlzLl9oYW5kbGVMb2FkRXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXVkaW9UcmFja1tdfSBBdWRpby10cmFjayBsaXN0IHdlIG93blxuICAgKi9cbiAgZ2V0IGF1ZGlvVHJhY2tzICgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3M7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn0gSW5kZXggaW50byBhdWRpby10cmFja3MgbGlzdCBvZiBjdXJyZW50bHkgc2VsZWN0ZWQgdHJhY2suXG4gICAqL1xuICBnZXQgYXVkaW9UcmFjayAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWNrSWQ7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGN1cnJlbnQgdHJhY2sgYnkgaW5kZXhcbiAgICovXG4gIHNldCBhdWRpb1RyYWNrIChuZXdJZCkge1xuICAgIHRoaXMuX3NldEF1ZGlvVHJhY2sobmV3SWQpO1xuICAgIC8vIElmIGF1ZGlvIHRyYWNrIGlzIHNlbGVjdGVkIGZyb20gQVBJIHRoZW4gZG9uJ3QgY2hvb3NlIGZyb20gdGhlIG1hbmlmZXN0IGRlZmF1bHQgdHJhY2tcbiAgICB0aGlzLl9zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbmV3SWRcbiAgICovXG4gIF9zZXRBdWRpb1RyYWNrIChuZXdJZCkge1xuICAgIC8vIG5vb3Agb24gc2FtZSBhdWRpbyB0cmFjayBpZCBhcyBhbHJlYWR5IHNldFxuICAgIGlmICh0aGlzLl90cmFja0lkID09PSBuZXdJZCAmJiB0aGlzLnRyYWNrc1t0aGlzLl90cmFja0lkXS5kZXRhaWxzKSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1NhbWUgaWQgYXMgY3VycmVudCBhdWRpby10cmFjayBwYXNzZWQsIGFuZCB0cmFjayBkZXRhaWxzIGF2YWlsYWJsZSAtPiBuby1vcCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgIGlmIChuZXdJZCA8IDAgfHwgbmV3SWQgPj0gdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIud2FybignSW52YWxpZCBpZCBwYXNzZWQgdG8gYXVkaW8tdHJhY2sgY29udHJvbGxlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSB0aGlzLnRyYWNrc1tuZXdJZF07XG5cbiAgICBsb2dnZXIubG9nKGBOb3cgc3dpdGNoaW5nIHRvIGF1ZGlvLXRyYWNrIGluZGV4ICR7bmV3SWR9YCk7XG5cbiAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICB0aGlzLl90cmFja0lkID0gbmV3SWQ7XG5cbiAgICBjb25zdCB7IHVybCwgdHlwZSwgaWQgfSA9IGF1ZGlvVHJhY2s7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHsgaWQsIHR5cGUsIHVybCB9KTtcbiAgICB0aGlzLl9sb2FkVHJhY2tEZXRhaWxzSWZOZWVkZWQoYXVkaW9UcmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkb1RpY2sgKCkge1xuICAgIHRoaXMuX3VwZGF0ZVRyYWNrKHRoaXMuX3RyYWNrSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBpbml0aWFsIHRyYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VsZWN0SW5pdGlhbEF1ZGlvVHJhY2sgKCkge1xuICAgIGxldCB0cmFja3MgPSB0aGlzLnRyYWNrcztcbiAgICBpZiAoIXRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50QXVkaW9UcmFjayA9IHRoaXMudHJhY2tzW3RoaXMuX3RyYWNrSWRdO1xuXG4gICAgbGV0IG5hbWUgPSBudWxsO1xuICAgIGlmIChjdXJyZW50QXVkaW9UcmFjaykge1xuICAgICAgbmFtZSA9IGN1cnJlbnRBdWRpb1RyYWNrLm5hbWU7XG4gICAgfVxuXG4gICAgLy8gUHJlLXNlbGVjdCBkZWZhdWx0IHRyYWNrcyBpZiB0aGVyZSBhcmUgYW55XG4gICAgaWYgKHRoaXMuX3NlbGVjdERlZmF1bHRUcmFjaykge1xuICAgICAgY29uc3QgZGVmYXVsdFRyYWNrcyA9IHRyYWNrcy5maWx0ZXIoKHRyYWNrKSA9PiB0cmFjay5kZWZhdWx0KTtcbiAgICAgIGlmIChkZWZhdWx0VHJhY2tzLmxlbmd0aCkge1xuICAgICAgICB0cmFja3MgPSBkZWZhdWx0VHJhY2tzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ05vIGRlZmF1bHQgYXVkaW8gdHJhY2tzIGRlZmluZWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgdHJhY2tGb3VuZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgdHJhdmVyc2VUcmFja3MgPSAoKSA9PiB7XG4gICAgICAvLyBTZWxlY3QgdHJhY2sgd2l0aCByaWdodCBncm91cCBJRFxuICAgICAgdHJhY2tzLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgIGlmICh0cmFja0ZvdW5kKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gbWF0Y2ggdGhlIChwcmUtKXNlbGVjdGVkIGdyb3VwIElEXG4gICAgICAgIC8vIGFuZCB0aGUgTkFNRSBvZiB0aGUgY3VycmVudCB0cmFjay5cbiAgICAgICAgaWYgKCghdGhpcy5hdWRpb0dyb3VwSWQgfHwgdHJhY2suZ3JvdXBJZCA9PT0gdGhpcy5hdWRpb0dyb3VwSWQpICYmXG4gICAgICAgICAgKCFuYW1lIHx8IG5hbWUgPT09IHRyYWNrLm5hbWUpKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcHJldmlvdXMgdHJhY2sgdHJ5IHRvIHN0YXkgd2l0aCB0aGUgc2FtZSBgTkFNRWAuXG4gICAgICAgICAgLy8gSXQgc2hvdWxkIGJlIHVuaXF1ZSBhY3Jvc3MgdHJhY2tzIG9mIHNhbWUgZ3JvdXAsIGFuZCBjb25zaXN0ZW50IHRocm91Z2ggcmVkdW5kYW50IHRyYWNrIGdyb3Vwcy5cbiAgICAgICAgICB0aGlzLl9zZXRBdWRpb1RyYWNrKHRyYWNrLmlkKTtcbiAgICAgICAgICB0cmFja0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRyYXZlcnNlVHJhY2tzKCk7XG5cbiAgICBpZiAoIXRyYWNrRm91bmQpIHtcbiAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgdHJhdmVyc2VUcmFja3MoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRyYWNrRm91bmQpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihgTm8gdHJhY2sgZm91bmQgZm9yIHJ1bm5pbmcgYXVkaW8gZ3JvdXAtSUQ6ICR7dGhpcy5hdWRpb0dyb3VwSWR9YCk7XG5cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1IsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBdWRpb1RyYWNrfSBhdWRpb1RyYWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgX25lZWRzVHJhY2tMb2FkaW5nIChhdWRpb1RyYWNrKSB7XG4gICAgY29uc3QgeyBkZXRhaWxzLCB1cmwgfSA9IGF1ZGlvVHJhY2s7XG5cbiAgICBpZiAoIWRldGFpbHMgfHwgZGV0YWlscy5saXZlKSB7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBmYWNlIGFuIGF1ZGlvIHRyYWNrIGVtYmVkZGVkIGluIG1haW4gcGxheWxpc3QgKGF1ZGlvIHRyYWNrIHdpdGhvdXQgVVJJIGF0dHJpYnV0ZSlcbiAgICAgIHJldHVybiAhIXVybDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBdWRpb1RyYWNrfSBhdWRpb1RyYWNrXG4gICAqL1xuICBfbG9hZFRyYWNrRGV0YWlsc0lmTmVlZGVkIChhdWRpb1RyYWNrKSB7XG4gICAgaWYgKHRoaXMuX25lZWRzVHJhY2tMb2FkaW5nKGF1ZGlvVHJhY2spKSB7XG4gICAgICBjb25zdCB7IHVybCwgaWQgfSA9IGF1ZGlvVHJhY2s7XG4gICAgICAvLyB0cmFjayBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICBsb2dnZXIubG9nKGBsb2FkaW5nIGF1ZGlvLXRyYWNrIHBsYXlsaXN0IGZvciBpZDogJHtpZH1gKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfTE9BRElORywgeyB1cmwsIGlkIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbmV3SWRcbiAgICovXG4gIF91cGRhdGVUcmFjayAobmV3SWQpIHtcbiAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICBpZiAobmV3SWQgPCAwIHx8IG5ld0lkID49IHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgIHRoaXMuX3RyYWNrSWQgPSBuZXdJZDtcbiAgICBsb2dnZXIubG9nKGB0cnlpbmcgdG8gdXBkYXRlIGF1ZGlvLXRyYWNrICR7bmV3SWR9YCk7XG4gICAgY29uc3QgYXVkaW9UcmFjayA9IHRoaXMudHJhY2tzW25ld0lkXTtcbiAgICB0aGlzLl9sb2FkVHJhY2tEZXRhaWxzSWZOZWVkZWQoYXVkaW9UcmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVMb2FkRXJyb3IgKCkge1xuICAgIC8vIEZpcnN0LCBsZXQncyBibGFjayBsaXN0IGN1cnJlbnQgdHJhY2sgaWRcbiAgICB0aGlzLnRyYWNrSWRCbGFja2xpc3RbdGhpcy5fdHJhY2tJZF0gPSB0cnVlO1xuXG4gICAgLy8gTGV0J3MgdHJ5IHRvIGZhbGwgYmFjayBvbiBhIGZ1bmN0aW9uYWwgYXVkaW8tdHJhY2sgd2l0aCB0aGUgc2FtZSBncm91cCBJRFxuICAgIGNvbnN0IHByZXZpb3VzSWQgPSB0aGlzLl90cmFja0lkO1xuICAgIGNvbnN0IHsgbmFtZSwgbGFuZ3VhZ2UsIGdyb3VwSWQgfSA9IHRoaXMudHJhY2tzW3ByZXZpb3VzSWRdO1xuXG4gICAgbG9nZ2VyLndhcm4oYExvYWRpbmcgZmFpbGVkIG9uIGF1ZGlvIHRyYWNrIGlkOiAke3ByZXZpb3VzSWR9LCBncm91cC1pZDogJHtncm91cElkfSwgbmFtZS9sYW5ndWFnZTogXCIke25hbWV9XCIgLyBcIiR7bGFuZ3VhZ2V9XCJgKTtcblxuICAgIC8vIEZpbmQgYSBub24tYmxhY2tsaXN0ZWQgdHJhY2sgSUQgd2l0aCB0aGUgc2FtZSBOQU1FXG4gICAgLy8gQXQgbGVhc3QgYSB0cmFjayB0aGF0IGlzIG5vdCBibGFja2xpc3RlZCwgdGh1cyBvbiBhbm90aGVyIGdyb3VwLUlELlxuICAgIGxldCBuZXdJZCA9IHByZXZpb3VzSWQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMudHJhY2tJZEJsYWNrbGlzdFtpXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld1RyYWNrID0gdGhpcy50cmFja3NbaV07XG4gICAgICBpZiAobmV3VHJhY2submFtZSA9PT0gbmFtZSkge1xuICAgICAgICBuZXdJZCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZXdJZCA9PT0gcHJldmlvdXNJZCkge1xuICAgICAgbG9nZ2VyLndhcm4oYE5vIGZhbGxiYWNrIGF1ZGlvLXRyYWNrIGZvdW5kIGZvciBuYW1lL2xhbmd1YWdlOiBcIiR7bmFtZX1cIiAvIFwiJHtsYW5ndWFnZX1cImApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvZ2dlci5sb2coJ0F0dGVtcHRpbmcgYXVkaW8tdHJhY2sgZmFsbGJhY2sgaWQ6JywgbmV3SWQsICdncm91cC1pZDonLCB0aGlzLnRyYWNrc1tuZXdJZF0uZ3JvdXBJZCk7XG5cbiAgICB0aGlzLl9zZXRBdWRpb1RyYWNrKG5ld0lkKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdWRpb1RyYWNrQ29udHJvbGxlcjtcbiIsImltcG9ydCBUYXNrTG9vcCBmcm9tICcuLi90YXNrLWxvb3AnO1xuaW1wb3J0IHsgRnJhZ21lbnRTdGF0ZSB9IGZyb20gJy4vZnJhZ21lbnQtdHJhY2tlcic7XG5pbXBvcnQgeyBCdWZmZXJIZWxwZXIgfSBmcm9tICcuLi91dGlscy9idWZmZXItaGVscGVyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmV4cG9ydCBjb25zdCBTdGF0ZSA9IHtcbiAgU1RPUFBFRDogJ1NUT1BQRUQnLFxuICBTVEFSVElORzogJ1NUQVJUSU5HJyxcbiAgSURMRTogJ0lETEUnLFxuICBQQVVTRUQ6ICdQQVVTRUQnLFxuICBLRVlfTE9BRElORzogJ0tFWV9MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HOiAnRlJBR19MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6ICdGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWScsXG4gIFdBSVRJTkdfVFJBQ0s6ICdXQUlUSU5HX1RSQUNLJyxcbiAgUEFSU0lORzogJ1BBUlNJTkcnLFxuICBQQVJTRUQ6ICdQQVJTRUQnLFxuICBCVUZGRVJfRkxVU0hJTkc6ICdCVUZGRVJfRkxVU0hJTkcnLFxuICBFTkRFRDogJ0VOREVEJyxcbiAgRVJST1I6ICdFUlJPUicsXG4gIFdBSVRJTkdfSU5JVF9QVFM6ICdXQUlUSU5HX0lOSVRfUFRTJyxcbiAgV0FJVElOR19MRVZFTDogJ1dBSVRJTkdfTEVWRUwnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIFRhc2tMb29wIHtcbiAgZG9UaWNrICgpIHt9XG5cbiAgc3RhcnRMb2FkICgpIHt9XG5cbiAgc3RvcExvYWQgKCkge1xuICAgIGxldCBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZykge1xuICAgICAgaWYgKGZyYWcubG9hZGVyKSB7XG4gICAgICAgIGZyYWcubG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgfVxuXG4gIF9zdHJlYW1FbmRlZCAoYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgY29uc3QgeyBmcmFnQ3VycmVudCwgZnJhZ21lbnRUcmFja2VyIH0gPSB0aGlzO1xuICAgIC8vIHdlIGp1c3QgZ290IGRvbmUgbG9hZGluZyB0aGUgZmluYWwgZnJhZ21lbnQgYW5kIHRoZXJlIGlzIG5vIG90aGVyIGJ1ZmZlcmVkIHJhbmdlIGFmdGVyIC4uLlxuICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGluIGNhc2UgdGhlcmUgYXJlIGFueSBidWZmZXJlZCByYW5nZXMgYWZ0ZXIsIGl0IG1lYW5zIHRoYXQgdGhlcmUgYXJlIHVuYnVmZmVyZWQgcG9ydGlvbiBpbiBiZXR3ZWVuXG4gICAgLy8gc28gd2Ugc2hvdWxkIG5vdCBzd2l0Y2ggdG8gRU5ERUQgaW4gdGhhdCBjYXNlLCB0byBiZSBhYmxlIHRvIGJ1ZmZlciB0aGVtXG4gICAgLy8gZG9udCBzd2l0Y2ggdG8gRU5ERUQgaWYgd2UgbmVlZCB0byBiYWNrdHJhY2sgbGFzdCBmcmFnbWVudFxuICAgIGlmICghbGV2ZWxEZXRhaWxzLmxpdmUgJiYgZnJhZ0N1cnJlbnQgJiYgIWZyYWdDdXJyZW50LmJhY2t0cmFja2VkICYmIGZyYWdDdXJyZW50LnNuID09PSBsZXZlbERldGFpbHMuZW5kU04gJiYgIWJ1ZmZlckluZm8ubmV4dFN0YXJ0KSB7XG4gICAgICBjb25zdCBmcmFnU3RhdGUgPSBmcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZ0N1cnJlbnQpO1xuICAgICAgcmV0dXJuIGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5PSztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgb25NZWRpYVNlZWtpbmcgKCkge1xuICAgIGNvbnN0IHsgY29uZmlnLCBtZWRpYSwgbWVkaWFCdWZmZXIsIHN0YXRlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IG51bGw7XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhQnVmZmVyIHx8IG1lZGlhLCBjdXJyZW50VGltZSwgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZSk7XG5cbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGN1cnJlbnRUaW1lKSkge1xuICAgICAgbG9nZ2VyLmxvZyhgbWVkaWEgc2Vla2luZyB0byAke2N1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcpIHtcbiAgICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBhcmUgc2Vla2luZyB0byBhIHVuYnVmZmVyZWQgYXJlYSBBTkQgaWYgZnJhZyBsb2FkaW5nIGlzIGluIHByb2dyZXNzXG4gICAgICBpZiAoYnVmZmVySW5mby5sZW4gPT09IDAgJiYgZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAgIGNvbnN0IGZyYWdTdGFydE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0IC0gdG9sZXJhbmNlO1xuICAgICAgICBjb25zdCBmcmFnRW5kT2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgKyBmcmFnQ3VycmVudC5kdXJhdGlvbiArIHRvbGVyYW5jZTtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2Ugc2VlayBwb3NpdGlvbiB3aWxsIGJlIG91dCBvZiBjdXJyZW50bHkgbG9hZGVkIGZyYWcgcmFuZ2UgOiBpZiBvdXQgY2FuY2VsIGZyYWcgbG9hZCwgaWYgaW4sIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgIGlmIChjdXJyZW50VGltZSA8IGZyYWdTdGFydE9mZnNldCB8fCBjdXJyZW50VGltZSA+IGZyYWdFbmRPZmZzZXQpIHtcbiAgICAgICAgICBpZiAoZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdzZWVraW5nIG91dHNpZGUgb2YgYnVmZmVyIHdoaWxlIGZyYWdtZW50IGxvYWQgaW4gcHJvZ3Jlc3MsIGNhbmNlbCBmcmFnbWVudCBsb2FkJyk7XG4gICAgICAgICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGxvYWQgbmV3IGZyYWdtZW50XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnc2Vla2luZyBvdXRzaWRlIG9mIGJ1ZmZlciBidXQgd2l0aGluIGN1cnJlbnRseSBsb2FkZWQgZnJhZ21lbnQgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICAvLyBpZiBzZWVraW5nIHRvIHVuYnVmZmVyZWQgYXJlYSwgY2xlYW4gdXAgZnJhZ1ByZXZpb3VzXG4gICAgICBpZiAoYnVmZmVySW5mby5sZW4gPT09IDApIHtcbiAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gY2hlY2sgZm9yIHBvdGVudGlhbCBuZXcgZnJhZ21lbnRcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgfVxuXG4gICAgLy8gaW4gY2FzZSBzZWVraW5nIG9jY3VycyBhbHRob3VnaCBubyBtZWRpYSBidWZmZXJlZCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gYW5kIG5leHRMb2FkUG9zaXRpb24gdG8gc2VlayB0YXJnZXRcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IGN1cnJlbnRUaW1lO1xuICAgIH1cblxuICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgcHJvY2Vzc2luZ1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25NZWRpYUVuZGVkICgpIHtcbiAgICAvLyByZXNldCBzdGFydFBvc2l0aW9uIGFuZCBsYXN0Q3VycmVudFRpbWUgdG8gcmVzdGFydCBwbGF5YmFjayBAIHN0cmVhbSBiZWdpbm5pbmdcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gIH1cblxuICBvbkhhbmRsZXJEZXN0cm95aW5nICgpIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgc3VwZXIub25IYW5kbGVyRGVzdHJveWluZygpO1xuICB9XG5cbiAgb25IYW5kbGVyRGVzdHJveWVkICgpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IG51bGw7XG4gIH1cbn1cbiIsIi8qXG4gKiBCdWZmZXIgQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBnZXRNZWRpYVNvdXJjZSB9IGZyb20gJy4uL3V0aWxzL21lZGlhc291cmNlLWhlbHBlcic7XG5cbmNvbnN0IE1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UoKTtcblxuY2xhc3MgQnVmZmVyQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hJTkcsXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXG4gICAgICBFdmVudC5NQU5JRkVTVF9QQVJTRUQsXG4gICAgICBFdmVudC5CVUZGRVJfUkVTRVQsXG4gICAgICBFdmVudC5CVUZGRVJfQVBQRU5ESU5HLFxuICAgICAgRXZlbnQuQlVGRkVSX0NPREVDUyxcbiAgICAgIEV2ZW50LkJVRkZFUl9FT1MsXG4gICAgICBFdmVudC5CVUZGRVJfRkxVU0hJTkcsXG4gICAgICBFdmVudC5MRVZFTF9QVFNfVVBEQVRFRCxcbiAgICAgIEV2ZW50LkxFVkVMX1VQREFURUQpO1xuXG4gICAgLy8gdGhlIHZhbHVlIHRoYXQgd2UgaGF2ZSBzZXQgbWVkaWFzb3VyY2UuZHVyYXRpb24gdG9cbiAgICAvLyAodGhlIGFjdHVhbCBkdXJhdGlvbiBtYXkgYmUgdHdlYWtlZCBzbGlnaGx5IGJ5IHRoZSBicm93c2VyKVxuICAgIHRoaXMuX21zRHVyYXRpb24gPSBudWxsO1xuICAgIC8vIHRoZSB2YWx1ZSB0aGF0IHdlIHdhbnQgdG8gc2V0IG1lZGlhU291cmNlLmR1cmF0aW9uIHRvXG4gICAgdGhpcy5fbGV2ZWxEdXJhdGlvbiA9IG51bGw7XG4gICAgLy8gdGhlIHRhcmdldCBkdXJhdGlvbiBvZiB0aGUgY3VycmVudCBtZWRpYSBwbGF5bGlzdFxuICAgIHRoaXMuX2xldmVsVGFyZ2V0RHVyYXRpb24gPSAxMDtcbiAgICAvLyBjdXJyZW50IHN0cmVhbSBzdGF0ZTogdHJ1ZSAtIGZvciBsaXZlIGJyb2FkY2FzdCwgZmFsc2UgLSBmb3IgVm9EIGNvbnRlbnRcbiAgICB0aGlzLl9saXZlID0gbnVsbDtcbiAgICAvLyBjYWNoZSB0aGUgc2VsZiBnZW5lcmF0ZWQgb2JqZWN0IHVybCB0byBkZXRlY3QgaGlqYWNrIG9mIHZpZGVvIHRhZ1xuICAgIHRoaXMuX29iamVjdFVybCA9IG51bGw7XG4gICAgLy8gVGhlIG51bWJlciBvZiBCVUZGRVJfQ09ERUMgZXZlbnRzIHJlY2VpdmVkIGJlZm9yZSBhbnkgc291cmNlQnVmZmVycyBhcmUgY3JlYXRlZFxuICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IDA7XG5cbiAgICAvLyBTb3VyY2UgQnVmZmVyIGxpc3RlbmVyc1xuICAgIHRoaXMub25zYnVlID0gdGhpcy5vblNCVXBkYXRlRW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbnNiZSA9IHRoaXMub25TQlVwZGF0ZUVycm9yLmJpbmQodGhpcyk7XG4gICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgdGhpcy50cmFja3MgPSB7fTtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgb25MZXZlbFB0c1VwZGF0ZWQgKGRhdGEpIHtcbiAgICBsZXQgdHlwZSA9IGRhdGEudHlwZTtcbiAgICBsZXQgYXVkaW9UcmFjayA9IHRoaXMudHJhY2tzLmF1ZGlvO1xuXG4gICAgLy8gQWRqdXN0aW5nIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YCAoZGVzaXJlZCBwb2ludCBpbiB0aGUgdGltZWxpbmUgd2hlcmUgdGhlIG5leHQgZnJhbWVzIHNob3VsZCBiZSBhcHBlbmRlZClcbiAgICAvLyBpbiBDaHJvbWUgYnJvd3NlciB3aGVuIHdlIGRldGVjdCBNUEVHIGF1ZGlvIGNvbnRhaW5lciBhbmQgdGltZSBkZWx0YSBiZXR3ZWVuIGxldmVsIFBUUyBhbmQgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgXG4gICAgLy8gaXMgZ3JlYXRlciB0aGFuIDEwMG1zICh0aGlzIGlzIGVub3VnaCB0byBoYW5kbGUgc2VlayBmb3IgVk9EIG9yIGxldmVsIGNoYW5nZSBmb3IgTElWRSB2aWRlb3MpLiBBdCB0aGUgdGltZSBvZiBjaGFuZ2Ugd2UgaXNzdWVcbiAgICAvLyBgU291cmNlQnVmZmVyLmFib3J0KClgIGFuZCBhZGp1c3RpbmcgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgIGlmIGBTb3VyY2VCdWZmZXIudXBkYXRpbmdgIGlzIGZhbHNlIG9yIGF3YWl0aW5nIGB1cGRhdGVlbmRgXG4gICAgLy8gZXZlbnQgaWYgU0IgaXMgaW4gdXBkYXRpbmcgc3RhdGUuXG4gICAgLy8gTW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8zMzIjaXNzdWVjb21tZW50LTI1Nzk4NjQ4NlxuXG4gICAgaWYgKHR5cGUgPT09ICdhdWRpbycgJiYgYXVkaW9UcmFjayAmJiBhdWRpb1RyYWNrLmNvbnRhaW5lciA9PT0gJ2F1ZGlvL21wZWcnKSB7IC8vIENocm9tZSBhdWRpbyBtcDMgdHJhY2tcbiAgICAgIGxldCBhdWRpb0J1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLmF1ZGlvO1xuICAgICAgbGV0IGRlbHRhID0gTWF0aC5hYnMoYXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0IC0gZGF0YS5zdGFydCk7XG5cbiAgICAgIC8vIGFkanVzdCB0aW1lc3RhbXAgb2Zmc2V0IGlmIHRpbWUgZGVsdGEgaXMgZ3JlYXRlciB0aGFuIDEwMG1zXG4gICAgICBpZiAoZGVsdGEgPiAwLjEpIHtcbiAgICAgICAgbGV0IHVwZGF0aW5nID0gYXVkaW9CdWZmZXIudXBkYXRpbmc7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhdWRpb0J1ZmZlci5hYm9ydCgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBsb2dnZXIud2FybignY2FuIG5vdCBhYm9ydCBhdWRpbyBidWZmZXI6ICcgKyBlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1cGRhdGluZykge1xuICAgICAgICAgIGxvZ2dlci53YXJuKCdjaGFuZ2UgbXBlZyBhdWRpbyB0aW1lc3RhbXAgb2Zmc2V0IGZyb20gJyArIGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCArICcgdG8gJyArIGRhdGEuc3RhcnQpO1xuICAgICAgICAgIGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCA9IGRhdGEuc3RhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldCA9IGRhdGEuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbk1hbmlmZXN0UGFyc2VkIChkYXRhKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBhbHQgYXVkaW8gMiBCVUZGRVJfQ09ERUNTIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZCwgb25lIHBlciBzdHJlYW0gY29udHJvbGxlclxuICAgIC8vIHNvdXJjZWJ1ZmZlcnMgd2lsbCBiZSBjcmVhdGVkIGFsbCBhdCBvbmNlIHdoZW4gdGhlIGV4cGVjdGVkIG5iIG9mIHRyYWNrcyB3aWxsIGJlIHJlYWNoZWRcbiAgICAvLyBpbiBjYXNlIGFsdCBhdWRpbyBpcyBub3QgdXNlZCwgb25seSBvbmUgQlVGRkVSX0NPREVDIGV2ZW50IHdpbGwgYmUgZmlyZWQgZnJvbSBtYWluIHN0cmVhbSBjb250cm9sbGVyXG4gICAgLy8gaXQgd2lsbCBjb250YWluIHRoZSBleHBlY3RlZCBuYiBvZiBzb3VyY2UgYnVmZmVycywgbm8gbmVlZCB0byBjb21wdXRlIGl0XG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gZGF0YS5hbHRBdWRpbyA/IDIgOiAxO1xuICAgIGxvZ2dlci5sb2coYCR7dGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkfSBidWZmZXJDb2RlYyBldmVudChzKSBleHBlY3RlZGApO1xuICB9XG5cbiAgb25NZWRpYUF0dGFjaGluZyAoZGF0YSkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgLy8gc2V0dXAgdGhlIG1lZGlhIHNvdXJjZVxuICAgICAgbGV0IG1zID0gdGhpcy5tZWRpYVNvdXJjZSA9IG5ldyBNZWRpYVNvdXJjZSgpO1xuICAgICAgLy8gTWVkaWEgU291cmNlIGxpc3RlbmVyc1xuICAgICAgdGhpcy5vbm1zbyA9IHRoaXMub25NZWRpYVNvdXJjZU9wZW4uYmluZCh0aGlzKTtcbiAgICAgIHRoaXMub25tc2UgPSB0aGlzLm9uTWVkaWFTb3VyY2VFbmRlZC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5vbm1zYyA9IHRoaXMub25NZWRpYVNvdXJjZUNsb3NlLmJpbmQodGhpcyk7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vbm1zbyk7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMub25tc2UpO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLm9ubXNjKTtcbiAgICAgIC8vIGxpbmsgdmlkZW8gYW5kIG1lZGlhIFNvdXJjZVxuICAgICAgbWVkaWEuc3JjID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobXMpO1xuICAgICAgLy8gY2FjaGUgdGhlIGxvY2FsbHkgZ2VuZXJhdGVkIG9iamVjdCB1cmxcbiAgICAgIHRoaXMuX29iamVjdFVybCA9IG1lZGlhLnNyYztcbiAgICB9XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nICgpIHtcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgZGV0YWNoaW5nJyk7XG4gICAgbGV0IG1zID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICBpZiAobXMpIHtcbiAgICAgIGlmIChtcy5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBlbmRPZlN0cmVhbSBjb3VsZCB0cmlnZ2VyIGV4Y2VwdGlvbiBpZiBhbnkgc291cmNlYnVmZmVyIGlzIGluIHVwZGF0aW5nIHN0YXRlXG4gICAgICAgICAgLy8gd2UgZG9uJ3QgcmVhbGx5IGNhcmUgYWJvdXQgY2hlY2tpbmcgc291cmNlYnVmZmVyIHN0YXRlIGhlcmUsXG4gICAgICAgICAgLy8gYXMgd2UgYXJlIGFueXdheSBkZXRhY2hpbmcgdGhlIE1lZGlhU291cmNlXG4gICAgICAgICAgLy8gbGV0J3MganVzdCBhdm9pZCB0aGlzIGV4Y2VwdGlvbiB0byBwcm9wYWdhdGVcbiAgICAgICAgICBtcy5lbmRPZlN0cmVhbSgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBsb2dnZXIud2Fybihgb25NZWRpYURldGFjaGluZzoke2Vyci5tZXNzYWdlfSB3aGlsZSBjYWxsaW5nIGVuZE9mU3RyZWFtYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1zLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLm9ubXNvKTtcbiAgICAgIG1zLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5vbm1zZSk7XG4gICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMub25tc2MpO1xuXG4gICAgICAvLyBEZXRhY2ggcHJvcGVybHkgdGhlIE1lZGlhU291cmNlIGZyb20gdGhlIEhUTUxNZWRpYUVsZW1lbnQgYXNcbiAgICAgIC8vIHN1Z2dlc3RlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vdzNjL21lZGlhLXNvdXJjZS9pc3N1ZXMvNTMuXG4gICAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLl9vYmplY3RVcmwpO1xuXG4gICAgICAgIC8vIGNsZWFuIHVwIHZpZGVvIHRhZyBzcmMgb25seSBpZiBpdCdzIG91ciBvd24gdXJsLiBzb21lIGV4dGVybmFsIGxpYnJhcmllcyBtaWdodFxuICAgICAgICAvLyBoaWphY2sgdGhlIHZpZGVvIHRhZyBhbmQgY2hhbmdlIGl0cyAnc3JjJyB3aXRob3V0IGRlc3Ryb3lpbmcgdGhlIEhscyBpbnN0YW5jZSBmaXJzdFxuICAgICAgICBpZiAodGhpcy5tZWRpYS5zcmMgPT09IHRoaXMuX29iamVjdFVybCkge1xuICAgICAgICAgIHRoaXMubWVkaWEucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgICB0aGlzLm1lZGlhLmxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIud2FybignbWVkaWEuc3JjIHdhcyBjaGFuZ2VkIGJ5IGEgdGhpcmQgcGFydHkgLSBza2lwIGNsZWFudXAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLm1lZGlhU291cmNlID0gbnVsbDtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy5fb2JqZWN0VXJsID0gbnVsbDtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgICAgdGhpcy50cmFja3MgPSB7fTtcbiAgICAgIHRoaXMuc291cmNlQnVmZmVyID0ge307XG4gICAgICB0aGlzLmZsdXNoUmFuZ2UgPSBbXTtcbiAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgIHRoaXMuYXBwZW5kZWQgPSAwO1xuICAgIH1cbiAgICB0aGlzLm9ubXNvID0gdGhpcy5vbm1zZSA9IHRoaXMub25tc2MgPSBudWxsO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTUVESUFfREVUQUNIRUQpO1xuICB9XG5cbiAgb25NZWRpYVNvdXJjZU9wZW4gKCkge1xuICAgIGxvZ2dlci5sb2coJ21lZGlhIHNvdXJjZSBvcGVuZWQnKTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50Lk1FRElBX0FUVEFDSEVELCB7IG1lZGlhOiB0aGlzLm1lZGlhIH0pO1xuICAgIGxldCBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICAvLyBvbmNlIHJlY2VpdmVkLCBkb24ndCBsaXN0ZW4gYW55bW9yZSB0byBzb3VyY2VvcGVuIGV2ZW50XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vbm1zbyk7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gIH1cblxuICBjaGVja1BlbmRpbmdUcmFja3MgKCkge1xuICAgIGxldCB7IGJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQsIHBlbmRpbmdUcmFja3MgfSA9IHRoaXM7XG4gICAgLy8gQ2hlY2sgaWYgd2UndmUgcmVjZWl2ZWQgYWxsIG9mIHRoZSBleHBlY3RlZCBidWZmZXJDb2RlYyBldmVudHMuIFdoZW4gbm9uZSByZW1haW4sIGNyZWF0ZSBhbGwgdGhlIHNvdXJjZUJ1ZmZlcnMgYXQgb25jZS5cbiAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSBNU0Ugc3BlYyBhbGxvd3MgaW1wbGVtZW50YXRpb25zIHRvIHRocm93IFF1b3RhRXhjZWVkZWRFcnJvcnMgaWYgY3JlYXRpbmcgbmV3IHNvdXJjZUJ1ZmZlcnMgYWZ0ZXJcbiAgICAvLyBkYXRhIGhhcyBiZWVuIGFwcGVuZGVkIHRvIGV4aXN0aW5nIG9uZXMuXG4gICAgLy8gMiB0cmFja3MgaXMgdGhlIG1heCAob25lIGZvciBhdWRpbywgb25lIGZvciB2aWRlbykuIElmIHdlJ3ZlIHJlYWNoIHRoaXMgbWF4IGdvIGFoZWFkIGFuZCBjcmVhdGUgdGhlIGJ1ZmZlcnMuXG5cbiAgICBjb25zdCBwZW5kaW5nVHJhY2tzQ291bnQgPSBPYmplY3Qua2V5cyhwZW5kaW5nVHJhY2tzKS5sZW5ndGg7XG4gICAgaWYgKChwZW5kaW5nVHJhY2tzQ291bnQgJiYgIWJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQpIHx8IHBlbmRpbmdUcmFja3NDb3VudCA9PT0gMikge1xuICAgICAgLy8gb2ssIGxldCdzIGNyZWF0ZSB0aGVtIG5vdyAhXG4gICAgICB0aGlzLmNyZWF0ZVNvdXJjZUJ1ZmZlcnMocGVuZGluZ1RyYWNrcyk7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICAgIC8vIGFwcGVuZCBhbnkgcGVuZGluZyBzZWdtZW50cyBub3cgIVxuICAgICAgdGhpcy5kb0FwcGVuZGluZygpO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFTb3VyY2VDbG9zZSAoKSB7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGNsb3NlZCcpO1xuICB9XG5cbiAgb25NZWRpYVNvdXJjZUVuZGVkICgpIHtcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgZW5kZWQnKTtcbiAgfVxuXG4gIG9uU0JVcGRhdGVFbmQgKCkge1xuICAgIC8vIHVwZGF0ZSB0aW1lc3RhbXBPZmZzZXRcbiAgICBpZiAodGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldCkge1xuICAgICAgbGV0IGF1ZGlvQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIuYXVkaW87XG4gICAgICBsb2dnZXIud2FybihgY2hhbmdlIG1wZWcgYXVkaW8gdGltZXN0YW1wIG9mZnNldCBmcm9tICR7YXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0fSB0byAke3RoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXR9YCk7XG4gICAgICBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgPSB0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0O1xuICAgICAgZGVsZXRlIHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX25lZWRzRmx1c2gpIHtcbiAgICAgIHRoaXMuZG9GbHVzaCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9uZWVkc0Vvcykge1xuICAgICAgdGhpcy5jaGVja0VvcygpO1xuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kaW5nID0gZmFsc2U7XG4gICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgIC8vIGNvdW50IG5iIG9mIHBlbmRpbmcgc2VnbWVudHMgd2FpdGluZyBmb3IgYXBwZW5kaW5nIG9uIHRoaXMgc291cmNlYnVmZmVyXG4gICAgbGV0IHBlbmRpbmcgPSB0aGlzLnNlZ21lbnRzLnJlZHVjZSgoY291bnRlciwgc2VnbWVudCkgPT4gKHNlZ21lbnQucGFyZW50ID09PSBwYXJlbnQpID8gY291bnRlciArIDEgOiBjb3VudGVyLCAwKTtcblxuICAgIC8vIHRoaXMuc291cmNlQnVmZmVyIGlzIGJldHRlciB0byB1c2UgdGhhbiBtZWRpYS5idWZmZXJlZCBhcyBpdCBpcyBjbG9zZXIgdG8gdGhlIFBUUyBkYXRhIGZyb20gdGhlIGZyYWdtZW50c1xuICAgIGxldCB0aW1lUmFuZ2VzID0ge307XG4gICAgY29uc3Qgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgZm9yIChsZXQgc3RyZWFtVHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgIHRpbWVSYW5nZXNbc3RyZWFtVHlwZV0gPSBzb3VyY2VCdWZmZXJbc3RyZWFtVHlwZV0uYnVmZmVyZWQ7XG4gICAgfVxuXG4gICAgLy8g5a+75om+5Y+v5pKt5pS+55qE6LW35aeL54K544CC5aaC5p6c5rKh5pyJ6Ieq5Yqo5pKt5pS+77yM6ZyA6KaB5omL5YqoU2Vla1xuICAgIGlmKHRoaXMuX3BhdXNlZCA9PT0gZmFsc2VcbiAgICAgICYmIHRpbWVSYW5nZXNbXCJ2aWRlb1wiXSAmJiB0aW1lUmFuZ2VzW1widmlkZW9cIl0ubGVuZ3RoID4gMFxuICAgICAgJiYgdGltZVJhbmdlc1tcImF1ZGlvXCJdICYmIHRpbWVSYW5nZXNbXCJhdWRpb1wiXS5sZW5ndGggPiAwKSB7XG5cbiAgICAgIGlmKHRpbWVSYW5nZXNbXCJ2aWRlb1wiXS5lbmQoMCkgLSB0aW1lUmFuZ2VzW1widmlkZW9cIl0uc3RhcnQoMCkgPiAxXG4gICAgICAmJiB0aW1lUmFuZ2VzW1wiYXVkaW9cIl0uZW5kKDApIC0gdGltZVJhbmdlc1tcImF1ZGlvXCJdLnN0YXJ0KDApID4gMSkge1xuICAgICAgICAvLyBTZWVrIHRvIHRoZSBwb2ludCB0aGF0IGNhbiBwbGF5O1xuICAgICAgICBsZXQgc3RhcnRUaW1lID0gTWF0aC5tYXgodGltZVJhbmdlc1tcInZpZGVvXCJdLnN0YXJ0KDApLHRpbWVSYW5nZXNbXCJhdWRpb1wiXS5zdGFydCgwKSlcbiAgICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5tZWRpYS5wbGF5KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzW1wiX3BhdXNlZFwiXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRyeSB0byBzZWVrIG1vcmVcbiAgICAgICAgbGV0IGVuZFRpbWUgPSBNYXRoLm1heCh0aW1lUmFuZ2VzW1widmlkZW9cIl0uZW5kKDApLHRpbWVSYW5nZXNbXCJhdWRpb1wiXS5lbmQoMCkpXG4gICAgICAgIHRoaXMubWVkaWEuY3VycmVudFRpbWUgPSBlbmRUaW1lO1xuICAgICAgICB0aGlzLm1lZGlhLnBsYXkoKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVOREVELCB7IHBhcmVudCwgcGVuZGluZywgdGltZVJhbmdlcyB9KTtcbiAgICAvLyBkb24ndCBhcHBlbmQgaW4gZmx1c2hpbmcgbW9kZVxuICAgIGlmICghdGhpcy5fbmVlZHNGbHVzaCkge1xuICAgICAgdGhpcy5kb0FwcGVuZGluZygpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcblxuICAgIC8vIGFwcGVuZGluZyBnb2VzIGZpcnN0XG4gICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgIHRoaXMuZmx1c2hMaXZlQmFja0J1ZmZlcigpO1xuICAgIH1cbiAgfVxuXG4gIG9uU0JVcGRhdGVFcnJvciAoZXZlbnQpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ3NvdXJjZUJ1ZmZlciBlcnJvcjonLCBldmVudCk7XG4gICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jc291cmNlYnVmZmVyLWFwcGVuZC1lcnJvclxuICAgIC8vIHRoaXMgZXJyb3IgbWlnaHQgbm90IGFsd2F5cyBiZSBmYXRhbCAoaXQgaXMgZmF0YWwgaWYgZGVjb2RlIGVycm9yIGlzIHNldCwgaW4gdGhhdCBjYXNlXG4gICAgLy8gaXQgd2lsbCBiZSBmb2xsb3dlZCBieSBhIG1lZGlhRWxlbWVudCBlcnJvciAuLi4pXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUiwgZmF0YWw6IGZhbHNlIH0pO1xuICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gZG8gbW9yZSB0aGFuIHRoYXQsIGFzIGFjY29yZGluIHRvIHRoZSBzcGVjLCB1cGRhdGVlbmQgd2lsbCBiZSBmaXJlZCBqdXN0IGFmdGVyXG4gIH1cblxuICBvbkJ1ZmZlclJlc2V0ICgpIHtcbiAgICBsZXQgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgZm9yIChsZXQgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgIGxldCBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubWVkaWFTb3VyY2UucmVtb3ZlU291cmNlQnVmZmVyKHNiKTtcbiAgICAgICAgc2IucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgdGhpcy5vbnNidWUpO1xuICAgICAgICBzYi5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMub25zYmUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc291cmNlQnVmZmVyID0ge307XG4gICAgdGhpcy5mbHVzaFJhbmdlID0gW107XG4gICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgIHRoaXMuYXBwZW5kZWQgPSAwO1xuICB9XG5cbiAgb25CdWZmZXJDb2RlY3MgKHRyYWNrcykge1xuICAgIC8vIGlmIHNvdXJjZSBidWZmZXIocykgbm90IGNyZWF0ZWQgeWV0LCBhcHBlbmRlZCBidWZmZXIgdHJhY2tzIGluIHRoaXMucGVuZGluZ1RyYWNrc1xuICAgIC8vIGlmIHNvdXJjZWJ1ZmZlcnMgYWxyZWFkeSBjcmVhdGVkLCBkbyBub3RoaW5nIC4uLlxuICAgIC8qKiDpnIDopoHmlL7ov4d0cmFja3MsIOacieaWsOeahHRyYWNr6ZyA6KaB6YeN5paw5YqgYnVmZmVyIOS9v+W+l+eUu+mdouWIsOi+vuaXtu+8jOWPr+S7peaSreaUvueUu+mdolxuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcikubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfSovXG5cbiAgICBPYmplY3Qua2V5cyh0cmFja3MpLmZvckVhY2godHJhY2tOYW1lID0+IHtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrc1t0cmFja05hbWVdID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgfSk7XG4gICAgY29uc3QgeyBtZWRpYVNvdXJjZSB9ID0gdGhpcztcbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSBNYXRoLm1heCh0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgLSAxLCAwKTtcbiAgICBpZiAobWVkaWFTb3VyY2UgJiYgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZVNvdXJjZUJ1ZmZlcnMgKHRyYWNrcykge1xuICAgIGxldCBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlciwgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIGZvciAobGV0IHRyYWNrTmFtZSBpbiB0cmFja3MpIHtcbiAgICAgIGlmICghc291cmNlQnVmZmVyW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICAgIC8vIHVzZSBsZXZlbENvZGVjIGFzIGZpcnN0IHByaW9yaXR5XG4gICAgICAgIGxldCBjb2RlYyA9IHRyYWNrLmxldmVsQ29kZWMgfHwgdHJhY2suY29kZWM7XG4gICAgICAgIGxldCBtaW1lVHlwZSA9IGAke3RyYWNrLmNvbnRhaW5lcn07Y29kZWNzPSR7Y29kZWN9YDtcbiAgICAgICAgbG9nZ2VyLmxvZyhgY3JlYXRpbmcgc291cmNlQnVmZmVyKCR7bWltZVR5cGV9KWApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCBzYiA9IHNvdXJjZUJ1ZmZlclt0cmFja05hbWVdID0gbWVkaWFTb3VyY2UuYWRkU291cmNlQnVmZmVyKG1pbWVUeXBlKTtcbiAgICAgICAgICBzYi5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCB0aGlzLm9uc2J1ZSk7XG4gICAgICAgICAgc2IuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLm9uc2JlKTtcbiAgICAgICAgICB0aGlzLnRyYWNrc1t0cmFja05hbWVdID0geyBjb2RlYzogY29kZWMsIGNvbnRhaW5lcjogdHJhY2suY29udGFpbmVyIH07XG4gICAgICAgICAgdHJhY2suYnVmZmVyID0gc2I7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmKGVyci5jb2RlID09IDIyKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKFwiRm91bmQgbmV3IHRyYWNrLCB0cnkgdG8gcmVidWlsZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gc2V0dXAgdGhlIG1lZGlhIHNvdXJjZVxuICAgICAgICAgICAgbGV0IG1zID0gdGhpcy5tZWRpYVNvdXJjZSA9IG5ldyBNZWRpYVNvdXJjZSgpO1xuICAgICAgICAgICAgLy8gTWVkaWEgU291cmNlIGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5vbm1zbyA9IHRoaXMub25NZWRpYVNvdXJjZU9wZW4uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub25tc2UgPSB0aGlzLm9uTWVkaWFTb3VyY2VFbmRlZC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbm1zYyA9IHRoaXMub25NZWRpYVNvdXJjZUNsb3NlLmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgIGZvcihsZXQgaT0wO2k8T2JqZWN0LmtleXModGhpcy50cmFja3MpLmxlbmd0aDtpKyspIHtcbiAgICAgICAgICAgICAgbGV0IHRyYWNrID0gdGhpcy50cmFja3NbT2JqZWN0LmtleXModGhpcy50cmFja3MpW2ldXTtcbiAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzW09iamVjdC5rZXlzKHRoaXMudHJhY2tzKVtpXV0gPSB0cmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhY2tzID0ge307XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xuICAgICAgICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25tc28pO1xuICAgICAgICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLm9ubXNlKTtcbiAgICAgICAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5vbm1zYyk7XG4gICAgICAgICAgICAvLyBsaW5rIHZpZGVvIGFuZCBtZWRpYSBTb3VyY2VcbiAgICAgICAgICAgIHRoaXMubWVkaWEuc3JjID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobXMpO1xuICAgICAgICAgICAgLy8gY2FjaGUgdGhlIGxvY2FsbHkgZ2VuZXJhdGVkIG9iamVjdCB1cmxcbiAgICAgICAgICAgIHRoaXMuX29iamVjdFVybCA9IG1lZGlhLnNyYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBlcnJvciB3aGlsZSB0cnlpbmcgdG8gYWRkIHNvdXJjZUJ1ZmZlcjoke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUiwgZmF0YWw6IGZhbHNlLCBlcnI6IGVyciwgbWltZVR5cGU6IG1pbWVUeXBlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0NSRUFURUQsIHsgdHJhY2tzOiB0cmFja3MgfSk7XG4gIH1cblxuICBvbkJ1ZmZlckFwcGVuZGluZyAoZGF0YSkge1xuICAgIGlmICghdGhpcy5fbmVlZHNGbHVzaCkge1xuICAgICAgaWYgKCF0aGlzLnNlZ21lbnRzKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBbIGRhdGEgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMucHVzaChkYXRhKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kb0FwcGVuZGluZygpO1xuICAgIH1cbiAgfVxuXG4gIG9uQnVmZmVyQXBwZW5kRmFpbCAoZGF0YSkge1xuICAgIGxvZ2dlci5lcnJvcignc291cmNlQnVmZmVyIGVycm9yOicsIGRhdGEuZXZlbnQpO1xuICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3NvdXJjZWJ1ZmZlci1hcHBlbmQtZXJyb3JcbiAgICAvLyB0aGlzIGVycm9yIG1pZ2h0IG5vdCBhbHdheXMgYmUgZmF0YWwgKGl0IGlzIGZhdGFsIGlmIGRlY29kZSBlcnJvciBpcyBzZXQsIGluIHRoYXQgY2FzZVxuICAgIC8vIGl0IHdpbGwgYmUgZm9sbG93ZWQgYnkgYSBtZWRpYUVsZW1lbnQgZXJyb3IgLi4uKVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSB9KTtcbiAgfVxuXG4gIC8vIG9uIEJVRkZFUl9FT1MgbWFyayBtYXRjaGluZyBzb3VyY2VidWZmZXIocykgYXMgZW5kZWQgYW5kIHRyaWdnZXIgY2hlY2tFb3MoKVxuICBvbkJ1ZmZlckVvcyAoZGF0YSkge1xuICAgIGxldCBzYiA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgIGxldCBkYXRhVHlwZSA9IGRhdGEudHlwZTtcbiAgICBmb3IgKGxldCB0eXBlIGluIHNiKSB7XG4gICAgICBpZiAoIWRhdGFUeXBlIHx8IHR5cGUgPT09IGRhdGFUeXBlKSB7XG4gICAgICAgIGlmICghc2JbdHlwZV0uZW5kZWQpIHtcbiAgICAgICAgICBzYlt0eXBlXS5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgJHt0eXBlfSBzb3VyY2VCdWZmZXIgbm93IEVPU2ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2hlY2tFb3MoKTtcbiAgfVxuXG4gIC8vIGlmIGFsbCBzb3VyY2UgYnVmZmVycyBhcmUgbWFya2VkIGFzIGVuZGVkLCBzaWduYWwgZW5kT2ZTdHJlYW0oKSB0byBNZWRpYVNvdXJjZS5cbiAgY2hlY2tFb3MgKCkge1xuICAgIGxldCBzYiA9IHRoaXMuc291cmNlQnVmZmVyLCBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgaWYgKCFtZWRpYVNvdXJjZSB8fCBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgIHRoaXMuX25lZWRzRW9zID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IHR5cGUgaW4gc2IpIHtcbiAgICAgIGxldCBzYm9iaiA9IHNiW3R5cGVdO1xuICAgICAgaWYgKCFzYm9iai5lbmRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzYm9iai51cGRhdGluZykge1xuICAgICAgICB0aGlzLl9uZWVkc0VvcyA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nZ2VyLmxvZygnYWxsIG1lZGlhIGRhdGEgYXJlIGF2YWlsYWJsZSwgc2lnbmFsIGVuZE9mU3RyZWFtKCkgdG8gTWVkaWFTb3VyY2UgYW5kIHN0b3AgbG9hZGluZyBmcmFnbWVudCcpO1xuICAgIC8vIE5vdGlmeSB0aGUgbWVkaWEgZWxlbWVudCB0aGF0IGl0IG5vdyBoYXMgYWxsIG9mIHRoZSBtZWRpYSBkYXRhXG4gICAgdHJ5IHtcbiAgICAgIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLndhcm4oJ2V4Y2VwdGlvbiB3aGlsZSBjYWxsaW5nIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCknKTtcbiAgICB9XG4gICAgdGhpcy5fbmVlZHNFb3MgPSBmYWxzZTtcbiAgfVxuXG4gIG9uQnVmZmVyRmx1c2hpbmcgKGRhdGEpIHtcbiAgICB0aGlzLmZsdXNoUmFuZ2UucHVzaCh7IHN0YXJ0OiBkYXRhLnN0YXJ0T2Zmc2V0LCBlbmQ6IGRhdGEuZW5kT2Zmc2V0LCB0eXBlOiBkYXRhLnR5cGUgfSk7XG4gICAgLy8gYXR0ZW1wdCBmbHVzaCBpbW1lZGlhdGVseVxuICAgIHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyID0gMDtcbiAgICB0aGlzLmRvRmx1c2goKTtcbiAgfVxuXG4gIGZsdXNoTGl2ZUJhY2tCdWZmZXIgKCkge1xuICAgIC8vIGNsZWFyIGJhY2sgYnVmZmVyIGZvciBsaXZlIG9ubHlcbiAgICBpZiAoIXRoaXMuX2xpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsaXZlQmFja0J1ZmZlckxlbmd0aCA9IHRoaXMuaGxzLmNvbmZpZy5saXZlQmFja0J1ZmZlckxlbmd0aDtcbiAgICBpZiAoIWlzRmluaXRlKGxpdmVCYWNrQnVmZmVyTGVuZ3RoKSB8fCBsaXZlQmFja0J1ZmZlckxlbmd0aCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IHRoaXMubWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3Qgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgY29uc3QgYnVmZmVyVHlwZXMgPSBPYmplY3Qua2V5cyhzb3VyY2VCdWZmZXIpO1xuICAgIGNvbnN0IHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbiA9IGN1cnJlbnRUaW1lIC0gTWF0aC5tYXgobGl2ZUJhY2tCdWZmZXJMZW5ndGgsIHRoaXMuX2xldmVsVGFyZ2V0RHVyYXRpb24pO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSBidWZmZXJUeXBlcy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICBjb25zdCBidWZmZXJUeXBlID0gYnVmZmVyVHlwZXNbaW5kZXhdLCBidWZmZXJlZCA9IHNvdXJjZUJ1ZmZlcltidWZmZXJUeXBlXS5idWZmZXJlZDtcblxuICAgICAgLy8gd2hlbiB0YXJnZXQgYnVmZmVyIHN0YXJ0IGV4Y2VlZHMgYWN0dWFsIGJ1ZmZlciBzdGFydFxuICAgICAgaWYgKGJ1ZmZlcmVkLmxlbmd0aCA+IDAgJiYgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uID4gYnVmZmVyZWQuc3RhcnQoMCkpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGJ1ZmZlciB1cCB1bnRpbCBjdXJyZW50IHRpbWUgbWludXMgbWluaW11bSBiYWNrIGJ1ZmZlciBsZW5ndGggKHJlbW92aW5nIGJ1ZmZlciB0b28gY2xvc2UgdG8gY3VycmVudFxuICAgICAgICAvLyB0aW1lIHdpbGwgbGVhZCB0byBwbGF5YmFjayBmcmVlemluZylcbiAgICAgICAgLy8gY3JlZGl0cyBmb3IgbGV2ZWwgdGFyZ2V0IGR1cmF0aW9uIC0gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvaHR0cC1zdHJlYW1pbmcvYmxvYi8zMTMyOTMzYjZhYTk5ZGRlZmFiMjljMTA0NDc2MjRlZmQ2ZmQ2ZTUyL3NyYy9zZWdtZW50LWxvYWRlci5qcyNMOTFcbiAgICAgICAgdGhpcy5yZW1vdmVCdWZmZXJSYW5nZShidWZmZXJUeXBlLCBzb3VyY2VCdWZmZXJbYnVmZmVyVHlwZV0sIDAsIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25MZXZlbFVwZGF0ZWQgKHsgZGV0YWlscyB9KSB7XG4gICAgaWYgKGRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX2xldmVsRHVyYXRpb24gPSBkZXRhaWxzLnRvdGFsZHVyYXRpb24gKyBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgIHRoaXMuX2xldmVsVGFyZ2V0RHVyYXRpb24gPSBkZXRhaWxzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiB8fCBkZXRhaWxzLnRhcmdldGR1cmF0aW9uIHx8IDEwO1xuICAgICAgdGhpcy5fbGl2ZSA9IGRldGFpbHMubGl2ZTtcbiAgICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiB0byBjdXJyZW50IGxldmVsIGR1cmF0aW9uIG9yIG92ZXJyaWRlIHRvIEluZmluaXR5IGlmIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyXG4gICAqICdsaXZlRHVyYXRpb25JbmZpbml0eWAgaXMgc2V0IHRvIGB0cnVlYFxuICAgKiBNb3JlIGRldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8zNTVcbiAgICovXG4gIHVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uICgpIHtcbiAgICBsZXQgeyBjb25maWcgfSA9IHRoaXMuaGxzO1xuICAgIGxldCBkdXJhdGlvbjtcblxuICAgIGlmICh0aGlzLl9sZXZlbER1cmF0aW9uID09PSBudWxsIHx8XG4gICAgICAhdGhpcy5tZWRpYSB8fFxuICAgICAgIXRoaXMubWVkaWFTb3VyY2UgfHxcbiAgICAgICF0aGlzLnNvdXJjZUJ1ZmZlciB8fFxuICAgICAgdGhpcy5tZWRpYS5yZWFkeVN0YXRlID09PSAwIHx8XG4gICAgICB0aGlzLm1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IHR5cGUgaW4gdGhpcy5zb3VyY2VCdWZmZXIpIHtcbiAgICAgIGlmICh0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXS51cGRhdGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBjYW4ndCBzZXQgZHVyYXRpb24gd2hpbHN0IGEgYnVmZmVyIGlzIHVwZGF0aW5nXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkdXJhdGlvbiA9IHRoaXMubWVkaWEuZHVyYXRpb247XG4gICAgLy8gaW5pdGlhbGlzZSB0byB0aGUgdmFsdWUgdGhhdCB0aGUgbWVkaWEgc291cmNlIGlzIHJlcG9ydGluZ1xuICAgIGlmICh0aGlzLl9tc0R1cmF0aW9uID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9tc0R1cmF0aW9uID0gdGhpcy5tZWRpYVNvdXJjZS5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGl2ZSA9PT0gdHJ1ZSAmJiBjb25maWcubGl2ZUR1cmF0aW9uSW5maW5pdHkgPT09IHRydWUpIHtcbiAgICAgIC8vIE92ZXJyaWRlIGR1cmF0aW9uIHRvIEluZmluaXR5XG4gICAgICBsb2dnZXIubG9nKCdNZWRpYSBTb3VyY2UgZHVyYXRpb24gaXMgc2V0IHRvIEluZmluaXR5Jyk7XG4gICAgICB0aGlzLl9tc0R1cmF0aW9uID0gdGhpcy5tZWRpYVNvdXJjZS5kdXJhdGlvbiA9IEluZmluaXR5O1xuICAgIH0gZWxzZSBpZiAoKHRoaXMuX2xldmVsRHVyYXRpb24gPiB0aGlzLl9tc0R1cmF0aW9uICYmIHRoaXMuX2xldmVsRHVyYXRpb24gPiBkdXJhdGlvbikgfHwgIU51bWJlci5pc0Zpbml0ZShkdXJhdGlvbikpIHtcbiAgICAgIC8vIGxldmVsRHVyYXRpb24gd2FzIHRoZSBsYXN0IHZhbHVlIHdlIHNldC5cbiAgICAgIC8vIG5vdCB1c2luZyBtZWRpYVNvdXJjZS5kdXJhdGlvbiBhcyB0aGUgYnJvd3NlciBtYXkgdHdlYWsgdGhpcyB2YWx1ZVxuICAgICAgLy8gb25seSB1cGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIGlmIGl0cyB2YWx1ZSBpbmNyZWFzZSwgdGhpcyBpcyB0byBhdm9pZFxuICAgICAgLy8gZmx1c2hpbmcgYWxyZWFkeSBidWZmZXJlZCBwb3J0aW9uIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gcXVhbGl0eSBsZXZlbFxuICAgICAgbG9nZ2VyLmxvZyhgVXBkYXRpbmcgTWVkaWEgU291cmNlIGR1cmF0aW9uIHRvICR7dGhpcy5fbGV2ZWxEdXJhdGlvbi50b0ZpeGVkKDMpfWApO1xuICAgICAgdGhpcy5fbXNEdXJhdGlvbiA9IHRoaXMubWVkaWFTb3VyY2UuZHVyYXRpb24gPSB0aGlzLl9sZXZlbER1cmF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIGRvRmx1c2ggKCkge1xuICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgYnVmZmVyIHJhbmdlcyB0byBmbHVzaFxuICAgIHdoaWxlICh0aGlzLmZsdXNoUmFuZ2UubGVuZ3RoKSB7XG4gICAgICBsZXQgcmFuZ2UgPSB0aGlzLmZsdXNoUmFuZ2VbMF07XG4gICAgICAvLyBmbHVzaEJ1ZmZlciB3aWxsIGFib3J0IGFueSBidWZmZXIgYXBwZW5kIGluIHByb2dyZXNzIGFuZCBmbHVzaCBBdWRpby9WaWRlbyBCdWZmZXJcbiAgICAgIGlmICh0aGlzLmZsdXNoQnVmZmVyKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIHJhbmdlLnR5cGUpKSB7XG4gICAgICAgIC8vIHJhbmdlIGZsdXNoZWQsIHJlbW92ZSBmcm9tIGZsdXNoIGFycmF5XG4gICAgICAgIHRoaXMuZmx1c2hSYW5nZS5zaGlmdCgpO1xuICAgICAgICB0aGlzLmZsdXNoQnVmZmVyQ291bnRlciA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9uZWVkc0ZsdXNoID0gdHJ1ZTtcbiAgICAgICAgLy8gYXZvaWQgbG9vcGluZywgd2FpdCBmb3IgU0IgdXBkYXRlIGVuZCB0byByZXRyaWdnZXIgYSBmbHVzaFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmZsdXNoUmFuZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBldmVyeXRoaW5nIGZsdXNoZWRcbiAgICAgIHRoaXMuX25lZWRzRmx1c2ggPSBmYWxzZTtcblxuICAgICAgLy8gbGV0J3MgcmVjb21wdXRlIHRoaXMuYXBwZW5kZWQsIHdoaWNoIGlzIHVzZWQgdG8gYXZvaWQgZmx1c2ggbG9vcGluZ1xuICAgICAgbGV0IGFwcGVuZGVkID0gMDtcbiAgICAgIGxldCBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICAgICAgYXBwZW5kZWQgKz0gc291cmNlQnVmZmVyW3R5cGVdLmJ1ZmZlcmVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gZXJyb3IgY291bGQgYmUgdGhyb3duIHdoaWxlIGFjY2Vzc2luZyBidWZmZXJlZCwgaW4gY2FzZSBzb3VyY2VidWZmZXIgaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkIGZyb20gTWVkaWFTb3VyY2VcbiAgICAgICAgLy8gdGhpcyBpcyBoYXJtZXNzIGF0IHRoaXMgc3RhZ2UsIGNhdGNoIHRoaXMgdG8gYXZvaWQgcmVwb3J0aW5nIGFuIGludGVybmFsIGV4Y2VwdGlvblxuICAgICAgICBsb2dnZXIuZXJyb3IoJ2Vycm9yIHdoaWxlIGFjY2Vzc2luZyBzb3VyY2VCdWZmZXIuYnVmZmVyZWQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kZWQgPSBhcHBlbmRlZDtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNIRUQpO1xuICAgIH1cbiAgfVxuXG4gIGRvQXBwZW5kaW5nICgpIHtcblxuICAgIGxldCB7IGhscywgc2VnbWVudHMsIHNvdXJjZUJ1ZmZlciB9ID0gdGhpcztcbiAgICBpZiAoT2JqZWN0LmtleXMoc291cmNlQnVmZmVyKS5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhLmVycm9yKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCd0cnlpbmcgdG8gYXBwZW5kIGFsdGhvdWdoIGEgbWVkaWEgZXJyb3Igb2NjdXJlZCwgZmx1c2ggc2VnbWVudCBhbmQgYWJvcnQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYXBwZW5kaW5nKSB7XG4gICAgICAgIC8vIGxvZ2dlci5sb2coYHNiIGFwcGVuZGluZyBpbiBwcm9ncmVzc2ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2VnbWVudHMgJiYgc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBzZWdtZW50ID0gc2VnbWVudHMuc2hpZnQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgdHlwZSA9IHNlZ21lbnQudHlwZSwgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgICAgaWYgKHNiKSB7XG4gICAgICAgICAgICBpZiAoIXNiLnVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgIC8vIHJlc2V0IHNvdXJjZUJ1ZmZlciBlbmRlZCBmbGFnIGJlZm9yZSBhcHBlbmRpbmcgc2VnbWVudFxuICAgICAgICAgICAgICBzYi5lbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKGBhcHBlbmRpbmcgJHtzZWdtZW50LmNvbnRlbnR9ICR7dHlwZX0gU0IsIHNpemU6JHtzZWdtZW50LmRhdGEubGVuZ3RofSwgJHtzZWdtZW50LnBhcmVudH1gKTtcbiAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBzZWdtZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2FwcGVuZCBidWZmZXIgJywgc2VnbWVudClcbiAgICAgICAgICAgICAgc2IuYXBwZW5kQnVmZmVyKHNlZ21lbnQuZGF0YSk7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IgPSAwO1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZGVkKys7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlZ21lbnRzLnVuc2hpZnQoc2VnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugd2UgZG9uJ3QgaGF2ZSBhbnkgc291cmNlIGJ1ZmZlciBtYXRjaGluZyB3aXRoIHRoaXMgc2VnbWVudCB0eXBlLFxuICAgICAgICAgICAgLy8gaXQgbWVhbnMgdGhhdCBNZWRpYXNvdXJjZSBmYWlscyB0byBjcmVhdGUgc291cmNlYnVmZmVyXG4gICAgICAgICAgICAvLyBkaXNjYXJkIHRoaXMgc2VnbWVudCwgYW5kIHRyaWdnZXIgdXBkYXRlIGVuZFxuICAgICAgICAgICAgdGhpcy5vblNCVXBkYXRlRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIGFueSBlcnJvciBvY2N1cmVkIHdoaWxlIGFwcGVuZGluZywgcHV0IGJhY2sgc2VnbWVudCBpbiBzZWdtZW50cyB0YWJsZVxuICAgICAgICAgIGxvZ2dlci5lcnJvcihgZXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGFwcGVuZCBidWZmZXI6JHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICBzZWdtZW50cy51bnNoaWZ0KHNlZ21lbnQpO1xuICAgICAgICAgIGxldCBldmVudCA9IHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgcGFyZW50OiBzZWdtZW50LnBhcmVudCB9O1xuICAgICAgICAgIGlmIChlcnIuY29kZSAhPT0gMjIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZEVycm9yKSB7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IgPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBldmVudC5kZXRhaWxzID0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1I7XG4gICAgICAgICAgICAvKiB3aXRoIFVIRCBjb250ZW50LCB3ZSBjb3VsZCBnZXQgbG9vcCBvZiBxdW90YSBleGNlZWRlZCBlcnJvciB1bnRpbFxuICAgICAgICAgICAgICBicm93c2VyIGlzIGFibGUgdG8gZXZpY3Qgc29tZSBkYXRhIGZyb20gc291cmNlYnVmZmVyLiByZXRyeWluZyBoZWxwIHJlY292ZXJpbmcgdGhpc1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZEVycm9yID4gaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5KSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYGZhaWwgJHtobHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnl9IHRpbWVzIHRvIGFwcGVuZCBzZWdtZW50IGluIHNvdXJjZUJ1ZmZlcmApO1xuICAgICAgICAgICAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgICAgICAgICAgIGV2ZW50LmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIGV2ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV2ZW50LmZhdGFsID0gZmFsc2U7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFF1b3RhRXhjZWVkZWRFcnJvcjogaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNxdW90YWV4Y2VlZGVkZXJyb3JcbiAgICAgICAgICAgIC8vIGxldCdzIHN0b3AgYXBwZW5kaW5nIGFueSBzZWdtZW50cywgYW5kIHJlcG9ydCBCVUZGRVJfRlVMTF9FUlJPUiBlcnJvclxuICAgICAgICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgZXZlbnQuZGV0YWlscyA9IEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjtcbiAgICAgICAgICAgIGV2ZW50LmZhdGFsID0gZmFsc2U7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAgZmx1c2ggc3BlY2lmaWVkIGJ1ZmZlcmVkIHJhbmdlLFxuICAgIHJldHVybiB0cnVlIG9uY2UgcmFuZ2UgaGFzIGJlZW4gZmx1c2hlZC5cbiAgICBhcyBzb3VyY2VCdWZmZXIucmVtb3ZlKCkgaXMgYXN5bmNocm9ub3VzLCBmbHVzaEJ1ZmZlciB3aWxsIGJlIHJldHJpZ2dlcmVkIG9uIHNvdXJjZUJ1ZmZlciB1cGRhdGUgZW5kXG4gICovXG4gIGZsdXNoQnVmZmVyIChzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCB0eXBlSW4pIHtcbiAgICBsZXQgc2I7XG4gICAgY29uc3Qgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgaWYgKE9iamVjdC5rZXlzKHNvdXJjZUJ1ZmZlcikubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIubG9nKGBmbHVzaEJ1ZmZlcixwb3Mvc3RhcnQvZW5kOiAke3RoaXMubWVkaWEuY3VycmVudFRpbWUudG9GaXhlZCgzKX0vJHtzdGFydE9mZnNldH0vJHtlbmRPZmZzZXR9YCk7XG4gICAgICAvLyBzYWZlZ3VhcmQgdG8gYXZvaWQgaW5maW5pdGUgbG9vcGluZyA6IGRvbid0IHRyeSB0byBmbHVzaCBtb3JlIHRoYW4gdGhlIG5iIG9mIGFwcGVuZGVkIHNlZ21lbnRzXG4gICAgICBpZiAodGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIgPCB0aGlzLmFwcGVuZGVkKSB7XG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgc291cmNlYnVmZmVyIHR5cGUgaXMgZGVmaW5lZCAodHlwZUluKTogaWYgeWVzLCBsZXQncyBvbmx5IGZsdXNoIHRoaXMgb25lXG4gICAgICAgICAgLy8gaWYgbm8sIGxldCdzIGZsdXNoIGFsbCBzb3VyY2VidWZmZXJzXG4gICAgICAgICAgaWYgKHR5cGVJbiAmJiB0eXBlICE9PSB0eXBlSW4pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICAgIC8vIHdlIGFyZSBnb2luZyB0byBmbHVzaCBidWZmZXIsIG1hcmsgc291cmNlIGJ1ZmZlciBhcyAnbm90IGVuZGVkJ1xuICAgICAgICAgIHNiLmVuZGVkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKCFzYi51cGRhdGluZykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVtb3ZlQnVmZmVyUmFuZ2UodHlwZSwgc2IsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyKys7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2Nhbm5vdCBmbHVzaCwgc2IgdXBkYXRpbmcgaW4gcHJvZ3Jlc3MnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdhYm9ydCBmbHVzaGluZyB0b28gbWFueSByZXRyaWVzJyk7XG4gICAgICB9XG4gICAgICBsb2dnZXIubG9nKCdidWZmZXIgZmx1c2hlZCcpO1xuICAgIH1cbiAgICAvLyBldmVyeXRoaW5nIGZsdXNoZWQgIVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgZmlyc3QgYnVmZmVyZWQgcmFuZ2UgZnJvbSBwcm92aWRlZCBzb3VyY2UgYnVmZmVyIHRoYXQgbGllcyB3aXRoaW4gZ2l2ZW4gc3RhcnQgYW5kIGVuZCBvZmZzZXRzLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSBUeXBlIG9mIHRoZSBzb3VyY2UgYnVmZmVyLCBsb2dnaW5nIHB1cnBvc2VzIG9ubHkuXG4gICAqIEBwYXJhbSBzYiBUYXJnZXQgU291cmNlQnVmZmVyIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gc3RhcnRPZmZzZXRcbiAgICogQHBhcmFtIGVuZE9mZnNldFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIHNvdXJjZSBidWZmZXIgcmVtb3ZlIHJlcXVlc3RlZC5cbiAgICovXG4gIHJlbW92ZUJ1ZmZlclJhbmdlICh0eXBlLCBzYiwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIHRyeSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNiLmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBidWZTdGFydCA9IHNiLmJ1ZmZlcmVkLnN0YXJ0KGkpO1xuICAgICAgICBsZXQgYnVmRW5kID0gc2IuYnVmZmVyZWQuZW5kKGkpO1xuICAgICAgICBsZXQgcmVtb3ZlU3RhcnQgPSBNYXRoLm1heChidWZTdGFydCwgc3RhcnRPZmZzZXQpO1xuICAgICAgICBsZXQgcmVtb3ZlRW5kID0gTWF0aC5taW4oYnVmRW5kLCBlbmRPZmZzZXQpO1xuXG4gICAgICAgIC8qIHNvbWV0aW1lcyBzb3VyY2VidWZmZXIucmVtb3ZlKCkgZG9lcyBub3QgZmx1c2hcbiAgICAgICAgICB0aGUgZXhhY3QgZXhwZWN0ZWQgdGltZSByYW5nZS5cbiAgICAgICAgICB0byBhdm9pZCByb3VuZGluZyBpc3N1ZXMvaW5maW5pdGUgbG9vcCxcbiAgICAgICAgICBvbmx5IGZsdXNoIGJ1ZmZlciByYW5nZSBvZiBsZW5ndGggZ3JlYXRlciB0aGFuIDUwMG1zLlxuICAgICAgICAqL1xuICAgICAgICBpZiAoTWF0aC5taW4ocmVtb3ZlRW5kLCBidWZFbmQpIC0gcmVtb3ZlU3RhcnQgPiAwLjUpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBzYiByZW1vdmUgJHt0eXBlfSBbJHtyZW1vdmVTdGFydH0sJHtyZW1vdmVFbmR9XSwgb2YgWyR7YnVmU3RhcnR9LCR7YnVmRW5kfV0sIHBvczoke3RoaXMubWVkaWEuY3VycmVudFRpbWV9YCk7XG4gICAgICAgICAgc2IucmVtb3ZlKHJlbW92ZVN0YXJ0LCByZW1vdmVFbmQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdyZW1vdmVCdWZmZXJSYW5nZSBmYWlsZWQnLCBlcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1ZmZlckNvbnRyb2xsZXI7XG4iLCIvKlxuICogY2FwIHN0cmVhbSBsZXZlbCB0byBtZWRpYSBzaXplIGRpbWVuc2lvbiBjb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5cbmNsYXNzIENhcExldmVsQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLFxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNISU5HLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfUEFSU0VELFxuICAgICAgRXZlbnQuQlVGRkVSX0NPREVDUyxcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyk7XG5cbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdGhpcy5maXJzdExldmVsID0gbnVsbDtcbiAgICB0aGlzLmxldmVscyA9IFtdO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIHRoaXMudGltZXIgPSBudWxsO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICB0aGlzLl9zdG9wQ2FwcGluZygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRnBzRHJvcExldmVsQ2FwcGluZyAoZGF0YSkge1xuICAgIC8vIERvbid0IGFkZCBhIHJlc3RyaWN0ZWQgbGV2ZWwgbW9yZSB0aGFuIG9uY2VcbiAgICBpZiAoQ2FwTGV2ZWxDb250cm9sbGVyLmlzTGV2ZWxBbGxvd2VkKGRhdGEuZHJvcHBlZExldmVsLCB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMpKSB7XG4gICAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMucHVzaChkYXRhLmRyb3BwZWRMZXZlbCk7XG4gICAgfVxuICB9XG5cbiAgb25NZWRpYUF0dGFjaGluZyAoZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhIGluc3RhbmNlb2Ygd2luZG93LkhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgfVxuXG4gIG9uTWFuaWZlc3RQYXJzZWQgKGRhdGEpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IGRhdGEuZmlyc3RMZXZlbDtcbiAgICBpZiAoaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSAmJiBkYXRhLnZpZGVvKSB7XG4gICAgICAvLyBTdGFydCBjYXBwaW5nIGltbWVkaWF0ZWx5IGlmIHRoZSBtYW5pZmVzdCBoYXMgc2lnbmFsZWQgdmlkZW8gY29kZWNzXG4gICAgICB0aGlzLl9zdGFydENhcHBpbmcoKTtcbiAgICB9XG4gIH1cblxuICAvLyBPbmx5IGFjdGl2YXRlIGNhcHBpbmcgd2hlbiBwbGF5aW5nIGEgdmlkZW8gc3RyZWFtOyBvdGhlcndpc2UsIG11bHRpLWJpdHJhdGUgYXVkaW8tb25seSBzdHJlYW1zIHdpbGwgYmUgcmVzdHJpY3RlZFxuICAvLyB0byB0aGUgZmlyc3QgbGV2ZWxcbiAgb25CdWZmZXJDb2RlY3MgKGRhdGEpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAoaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSAmJiBkYXRhLnZpZGVvKSB7XG4gICAgICAvLyBJZiB0aGUgbWFuaWZlc3QgZGlkIG5vdCBzaWduYWwgYSB2aWRlbyBjb2RlYyBjYXBwaW5nIGhhcyBiZWVuIGRlZmVycmVkIHVudGlsIHdlJ3JlIGNlcnRhaW4gdmlkZW8gaXMgcHJlc2VudFxuICAgICAgdGhpcy5fc3RhcnRDYXBwaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgb25MZXZlbHNVcGRhdGVkIChkYXRhKSB7XG4gICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcgKCkge1xuICAgIHRoaXMuX3N0b3BDYXBwaW5nKCk7XG4gIH1cblxuICBkZXRlY3RQbGF5ZXJTaXplICgpIHtcbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgbGV0IGxldmVsc0xlbmd0aCA9IHRoaXMubGV2ZWxzID8gdGhpcy5sZXZlbHMubGVuZ3RoIDogMDtcbiAgICAgIGlmIChsZXZlbHNMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIGhscy5hdXRvTGV2ZWxDYXBwaW5nID0gdGhpcy5nZXRNYXhMZXZlbChsZXZlbHNMZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID4gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nKSB7XG4gICAgICAgICAgLy8gaWYgYXV0byBsZXZlbCBjYXBwaW5nIGhhcyBhIGhpZ2hlciB2YWx1ZSBmb3IgdGhlIHByZXZpb3VzIG9uZSwgZmx1c2ggdGhlIGJ1ZmZlciB1c2luZyBuZXh0TGV2ZWxTd2l0Y2hcbiAgICAgICAgICAvLyB1c3VhbGx5IGhhcHBlbiB3aGVuIHRoZSB1c2VyIGdvIHRvIHRoZSBmdWxsc2NyZWVuIG1vZGUuXG4gICAgICAgICAgaGxzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gaGxzLmF1dG9MZXZlbENhcHBpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgKiByZXR1cm5zIGxldmVsIHNob3VsZCBiZSB0aGUgb25lIHdpdGggdGhlIGRpbWVuc2lvbnMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHRoZSBtZWRpYSAocGxheWVyKSBkaW1lbnNpb25zIChzbyB0aGUgdmlkZW8gd2lsbCBiZSBkb3duc2NhbGVkKVxuICAqL1xuICBnZXRNYXhMZXZlbCAoY2FwTGV2ZWxJbmRleCkge1xuICAgIGlmICghdGhpcy5sZXZlbHMpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZExldmVscyA9IHRoaXMubGV2ZWxzLmZpbHRlcigobGV2ZWwsIGluZGV4KSA9PlxuICAgICAgQ2FwTGV2ZWxDb250cm9sbGVyLmlzTGV2ZWxBbGxvd2VkKGluZGV4LCB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMpICYmIGluZGV4IDw9IGNhcExldmVsSW5kZXhcbiAgICApO1xuXG4gICAgcmV0dXJuIENhcExldmVsQ29udHJvbGxlci5nZXRNYXhMZXZlbEJ5TWVkaWFTaXplKHZhbGlkTGV2ZWxzLCB0aGlzLm1lZGlhV2lkdGgsIHRoaXMubWVkaWFIZWlnaHQpO1xuICB9XG5cbiAgX3N0YXJ0Q2FwcGluZyAoKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIC8vIERvbid0IHJlc2V0IGNhcHBpbmcgaWYgc3RhcnRlZCB0d2ljZTsgdGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBtYW5pZmVzdCBzaWduYWxzIGEgdmlkZW8gY29kZWNcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHRoaXMuaGxzLmZpcnN0TGV2ZWwgPSB0aGlzLmdldE1heExldmVsKHRoaXMuZmlyc3RMZXZlbCk7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5kZXRlY3RQbGF5ZXJTaXplLmJpbmQodGhpcyksIDEwMDApO1xuICAgIHRoaXMuZGV0ZWN0UGxheWVyU2l6ZSgpO1xuICB9XG5cbiAgX3N0b3BDYXBwaW5nICgpIHtcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSBudWxsO1xuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgdGhpcy50aW1lciA9IGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBnZXQgbWVkaWFXaWR0aCAoKSB7XG4gICAgbGV0IHdpZHRoO1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHdpZHRoID0gbWVkaWEud2lkdGggfHwgbWVkaWEuY2xpZW50V2lkdGggfHwgbWVkaWEub2Zmc2V0V2lkdGg7XG4gICAgICB3aWR0aCAqPSBDYXBMZXZlbENvbnRyb2xsZXIuY29udGVudFNjYWxlRmFjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gd2lkdGg7XG4gIH1cblxuICBnZXQgbWVkaWFIZWlnaHQgKCkge1xuICAgIGxldCBoZWlnaHQ7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgaGVpZ2h0ID0gbWVkaWEuaGVpZ2h0IHx8IG1lZGlhLmNsaWVudEhlaWdodCB8fCBtZWRpYS5vZmZzZXRIZWlnaHQ7XG4gICAgICBoZWlnaHQgKj0gQ2FwTGV2ZWxDb250cm9sbGVyLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIGhlaWdodDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgY29udGVudFNjYWxlRmFjdG9yICgpIHtcbiAgICBsZXQgcGl4ZWxSYXRpbyA9IDE7XG4gICAgdHJ5IHtcbiAgICAgIHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBwaXhlbFJhdGlvO1xuICB9XG5cbiAgc3RhdGljIGlzTGV2ZWxBbGxvd2VkIChsZXZlbCwgcmVzdHJpY3RlZExldmVscyA9IFtdKSB7XG4gICAgcmV0dXJuIHJlc3RyaWN0ZWRMZXZlbHMuaW5kZXhPZihsZXZlbCkgPT09IC0xO1xuICB9XG5cbiAgc3RhdGljIGdldE1heExldmVsQnlNZWRpYVNpemUgKGxldmVscywgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghbGV2ZWxzIHx8IChsZXZlbHMgJiYgIWxldmVscy5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLy8gTGV2ZWxzIGNhbiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMgYnV0IGRpZmZlcmluZyBiYW5kd2lkdGhzIC0gc2luY2UgbGV2ZWxzIGFyZSBvcmRlcmVkLCB3ZSBjYW4gbG9vayB0byB0aGUgbmV4dFxuICAgIC8vIHRvIGRldGVybWluZSB3aGV0aGVyIHdlJ3ZlIGNob3NlbiB0aGUgZ3JlYXRlc3QgYmFuZHdpZHRoIGZvciB0aGUgbWVkaWEncyBkaW1lbnNpb25zXG4gICAgY29uc3QgYXRHcmVhdGVzdEJhbmRpd2R0aCA9IChjdXJMZXZlbCwgbmV4dExldmVsKSA9PiB7XG4gICAgICBpZiAoIW5leHRMZXZlbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1ckxldmVsLndpZHRoICE9PSBuZXh0TGV2ZWwud2lkdGggfHwgY3VyTGV2ZWwuaGVpZ2h0ICE9PSBuZXh0TGV2ZWwuaGVpZ2h0O1xuICAgIH07XG5cbiAgICAvLyBJZiB3ZSBydW4gdGhyb3VnaCB0aGUgbG9vcCB3aXRob3V0IGJyZWFraW5nLCB0aGUgbWVkaWEncyBkaW1lbnNpb25zIGFyZSBncmVhdGVyIHRoYW4gZXZlcnkgbGV2ZWwsIHNvIGRlZmF1bHQgdG9cbiAgICAvLyB0aGUgbWF4IGxldmVsXG4gICAgbGV0IG1heExldmVsSW5kZXggPSBsZXZlbHMubGVuZ3RoIC0gMTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICAgIGlmICgobGV2ZWwud2lkdGggPj0gd2lkdGggfHwgbGV2ZWwuaGVpZ2h0ID49IGhlaWdodCkgJiYgYXRHcmVhdGVzdEJhbmRpd2R0aChsZXZlbCwgbGV2ZWxzW2kgKyAxXSkpIHtcbiAgICAgICAgbWF4TGV2ZWxJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXhMZXZlbEluZGV4O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhcExldmVsQ29udHJvbGxlcjtcbiIsIi8qKlxuICogQGF1dGhvciBTdGVwaGFuIEhlc3NlIDxkaXNwYXJhdEBnbWFpbC5jb20+IHwgPHRjaGFrYWJhbUBnbWFpbC5jb20+XG4gKlxuICogRFJNIHN1cHBvcnQgZm9yIEhscy5qc1xuICovXG5cbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNvbnN0IHsgWE1MSHR0cFJlcXVlc3QgfSA9IHdpbmRvdztcblxuY29uc3QgTUFYX0xJQ0VOU0VfUkVRVUVTVF9GQUlMVVJFUyA9IDM7XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTmF2aWdhdG9yL3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1xuICovXG5jb25zdCBLZXlTeXN0ZW1zID0ge1xuICBXSURFVklORTogJ2NvbS53aWRldmluZS5hbHBoYScsXG4gIFBMQVlSRUFEWTogJ2NvbS5taWNyb3NvZnQucGxheXJlYWR5J1xufTtcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXVkaW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCBhdWRpbyBjb2RlY3MgdG8gc3VwcG9ydFxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB2aWRlb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIHZpZGVvIGNvZGVjcyB0byBzdXBwb3J0XG4gKiBAcGFyYW0ge29iamVjdH0gZHJtU3lzdGVtT3B0aW9ucyBPcHRpb25hbCBwYXJhbWV0ZXJzL3JlcXVpcmVtZW50cyBmb3IgdGhlIGtleS1zeXN0ZW1cbiAqIEByZXR1cm5zIHtBcnJheTxNZWRpYVN5c3RlbUNvbmZpZ3VyYXRpb24+fSBBbiBhcnJheSBvZiBzdXBwb3J0ZWQgY29uZmlndXJhdGlvbnNcbiAqL1xuXG5jb25zdCBjcmVhdGVXaWRldmluZU1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMgPSBmdW5jdGlvbiAoYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCBkcm1TeXN0ZW1PcHRpb25zKSB7IC8qIGpzaGludCBpZ25vcmU6bGluZSAqL1xuICBjb25zdCBiYXNlQ29uZmlnID0ge1xuICAgIC8vIGluaXREYXRhVHlwZXM6IFsna2V5aWRzJywgJ21wNCddLFxuICAgIC8vIGxhYmVsOiBcIlwiLFxuICAgIC8vIHBlcnNpc3RlbnRTdGF0ZTogXCJub3QtYWxsb3dlZFwiLCAvLyBvciBcInJlcXVpcmVkXCIgP1xuICAgIC8vIGRpc3RpbmN0aXZlSWRlbnRpZmllcjogXCJub3QtYWxsb3dlZFwiLCAvLyBvciBcInJlcXVpcmVkXCIgP1xuICAgIC8vIHNlc3Npb25UeXBlczogWyd0ZW1wb3JhcnknXSxcbiAgICB2aWRlb0NhcGFiaWxpdGllczogW1xuICAgICAgLy8geyBjb250ZW50VHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS40MkUwMUVcIicgfVxuICAgIF1cbiAgfTtcblxuICB2aWRlb0NvZGVjcy5mb3JFYWNoKChjb2RlYykgPT4ge1xuICAgIGJhc2VDb25maWcudmlkZW9DYXBhYmlsaXRpZXMucHVzaCh7XG4gICAgICBjb250ZW50VHlwZTogYHZpZGVvL21wNDsgY29kZWNzPVwiJHtjb2RlY31cImBcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIFtcbiAgICBiYXNlQ29uZmlnXG4gIF07XG59O1xuXG4vKipcbiAqIFRoZSBpZGVhIGhlcmUgaXMgdG8gaGFuZGxlIGtleS1zeXN0ZW0gKGFuZCB0aGVpciByZXNwZWN0aXZlIHBsYXRmb3Jtcykgc3BlY2lmaWMgY29uZmlndXJhdGlvbiBkaWZmZXJlbmNlc1xuICogaW4gb3JkZXIgdG8gd29yayB3aXRoIHRoZSBsb2NhbCByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgbWV0aG9kLlxuICpcbiAqIFdlIGNhbiBhbHNvIHJ1bGUtb3V0IHBsYXRmb3JtLXJlbGF0ZWQga2V5LXN5c3RlbSBzdXBwb3J0IGF0IHRoaXMgcG9pbnQgYnkgdGhyb3dpbmcgYW4gZXJyb3Igb3IgcmV0dXJuaW5nIG51bGwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVN5c3RlbSBJZGVudGlmaWVyIGZvciB0aGUga2V5LXN5c3RlbSwgc2VlIGBLZXlTeXN0ZW1zYCBlbnVtXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGF1ZGlvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgYXVkaW8gY29kZWNzIHRvIHN1cHBvcnRcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdmlkZW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCB2aWRlbyBjb2RlY3MgdG8gc3VwcG9ydFxuICogQHJldHVybnMge0FycmF5PE1lZGlhU3lzdGVtQ29uZmlndXJhdGlvbj4gfCBudWxsfSBBIG5vbi1lbXB0eSBBcnJheSBvZiBNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb24gb2JqZWN0cyBvciBgbnVsbGBcbiAqL1xuY29uc3QgZ2V0U3VwcG9ydGVkTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyA9IGZ1bmN0aW9uIChrZXlTeXN0ZW0sIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcykge1xuICBzd2l0Y2ggKGtleVN5c3RlbSkge1xuICBjYXNlIEtleVN5c3RlbXMuV0lERVZJTkU6XG4gICAgcmV0dXJuIGNyZWF0ZVdpZGV2aW5lTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpO1xuICBkZWZhdWx0OlxuICAgIHRocm93IEVycm9yKCdVbmtub3duIGtleS1zeXN0ZW06ICcgKyBrZXlTeXN0ZW0pO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gZGVhbCB3aXRoIGVuY3J5cHRlZCBtZWRpYSBleHRlbnNpb25zIChFTUUpXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbmNyeXB0ZWRfTWVkaWFfRXh0ZW5zaW9uc19BUElcbiAqXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBFTUVDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgLyoqXG4gICAgICogQGNvbnN0cnVjdHNcbiAgICAgKiBAcGFyYW0ge0hsc30gaGxzIE91ciBIbHMuanMgaW5zdGFuY2VcbiAgICAgKi9cbiAgY29uc3RydWN0b3IgKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSEVELFxuICAgICAgRXZlbnQuTUFOSUZFU1RfUEFSU0VEXG4gICAgKTtcblxuICAgIHRoaXMuX3dpZGV2aW5lTGljZW5zZVVybCA9IGhscy5jb25maWcud2lkZXZpbmVMaWNlbnNlVXJsO1xuICAgIHRoaXMuX2xpY2Vuc2VYaHJTZXR1cCA9IGhscy5jb25maWcubGljZW5zZVhoclNldHVwO1xuICAgIHRoaXMuX2VtZUVuYWJsZWQgPSBobHMuY29uZmlnLmVtZUVuYWJsZWQ7XG5cbiAgICB0aGlzLl9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgPSBobHMuY29uZmlnLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmM7XG5cbiAgICB0aGlzLl9tZWRpYUtleXNMaXN0ID0gW107XG4gICAgdGhpcy5fbWVkaWEgPSBudWxsO1xuXG4gICAgdGhpcy5faGFzU2V0TWVkaWFLZXlzID0gZmFsc2U7XG4gICAgdGhpcy5faXNNZWRpYUVuY3J5cHRlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5U3lzdGVtIElkZW50aWZpZXIgZm9yIHRoZSBrZXktc3lzdGVtLCBzZWUgYEtleVN5c3RlbXNgIGVudW1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBMaWNlbnNlIHNlcnZlciBVUkwgZm9yIGtleS1zeXN0ZW0gKGlmIGFueSBjb25maWd1cmVkLCBvdGhlcndpc2UgY2F1c2VzIGVycm9yKVxuICAgICAqL1xuICBnZXRMaWNlbnNlU2VydmVyVXJsIChrZXlTeXN0ZW0pIHtcbiAgICBsZXQgdXJsO1xuICAgIHN3aXRjaCAoa2V5U3lzdGVtKSB7XG4gICAgY2FzZSBLZXlTeXN0ZW1zLldJREVWSU5FOlxuICAgICAgdXJsID0gdGhpcy5fd2lkZXZpbmVMaWNlbnNlVXJsO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHVybCA9IG51bGw7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoIXVybCkge1xuICAgICAgbG9nZ2VyLmVycm9yKGBObyBsaWNlbnNlIHNlcnZlciBVUkwgY29uZmlndXJlZCBmb3Iga2V5LXN5c3RlbSBcIiR7a2V5U3lzdGVtfVwiYCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCxcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICAvKipcbiAgICAgKiBSZXF1ZXN0cyBhY2Nlc3Mgb2JqZWN0IGFuZCBhZGRzIGl0IHRvIG91ciBsaXN0IHVwb24gc3VjY2Vzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVN5c3RlbSBTeXN0ZW0gSUQgKHNlZSBgS2V5U3lzdGVtc2ApXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhdWRpb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIGF1ZGlvIGNvZGVjcyB0byBzdXBwb3J0XG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB2aWRlb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIHZpZGVvIGNvZGVjcyB0byBzdXBwb3J0XG4gICAgICovXG4gIF9hdHRlbXB0S2V5U3lzdGVtQWNjZXNzIChrZXlTeXN0ZW0sIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcykge1xuICAgIC8vIFRPRE86IGFkZCBvdGhlciBEUk0gXCJvcHRpb25zXCJcblxuICAgIGNvbnN0IG1lZGlhS2V5U3lzdGVtQ29uZmlncyA9IGdldFN1cHBvcnRlZE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpO1xuXG4gICAgaWYgKCFtZWRpYUtleVN5c3RlbUNvbmZpZ3MpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdDYW4gbm90IGNyZWF0ZSBjb25maWcgZm9yIGtleS1zeXN0ZW0gKG1heWJlIGJlY2F1c2UgcGxhdGZvcm0gaXMgbm90IHN1cHBvcnRlZCk6Jywga2V5U3lzdGVtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2dnZXIubG9nKCdSZXF1ZXN0aW5nIGVuY3J5cHRlZCBtZWRpYSBrZXktc3lzdGVtIGFjY2VzcycpO1xuXG4gICAgLy8gZXhwZWN0aW5nIGludGVyZmFjZSBsaWtlIHdpbmRvdy5uYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzXG4gICAgdGhpcy5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtLCBtZWRpYUtleVN5c3RlbUNvbmZpZ3MpXG4gICAgICAudGhlbigobWVkaWFLZXlTeXN0ZW1BY2Nlc3MpID0+IHtcbiAgICAgICAgdGhpcy5fb25NZWRpYUtleVN5c3RlbUFjY2Vzc09idGFpbmVkKGtleVN5c3RlbSwgbWVkaWFLZXlTeXN0ZW1BY2Nlc3MpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIG9idGFpbiBrZXktc3lzdGVtIFwiJHtrZXlTeXN0ZW19XCIgYWNjZXNzOmAsIGVycik7XG4gICAgICB9KTtcbiAgfVxuXG4gIGdldCByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgKCkge1xuICAgIGlmICghdGhpcy5fcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyBmdW5jdGlvbiBjb25maWd1cmVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcztcbiAgfVxuXG4gIC8qKlxuICAgICAqIEhhbmRsZXMgb2J0YWluaW5nIGFjY2VzcyB0byBhIGtleS1zeXN0ZW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlTeXN0ZW1cbiAgICAgKiBAcGFyYW0ge01lZGlhS2V5U3lzdGVtQWNjZXNzfSBtZWRpYUtleVN5c3RlbUFjY2VzcyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFLZXlTeXN0ZW1BY2Nlc3NcbiAgICAgKi9cbiAgX29uTWVkaWFLZXlTeXN0ZW1BY2Nlc3NPYnRhaW5lZCAoa2V5U3lzdGVtLCBtZWRpYUtleVN5c3RlbUFjY2Vzcykge1xuICAgIGxvZ2dlci5sb2coYEFjY2VzcyBmb3Iga2V5LXN5c3RlbSBcIiR7a2V5U3lzdGVtfVwiIG9idGFpbmVkYCk7XG5cbiAgICBjb25zdCBtZWRpYUtleXNMaXN0SXRlbSA9IHtcbiAgICAgIG1lZGlhS2V5czogbnVsbCxcbiAgICAgIG1lZGlhS2V5c1Nlc3Npb246IG51bGwsXG4gICAgICBtZWRpYUtleXNTZXNzaW9uSW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgbWVkaWFLZXlTeXN0ZW1BY2Nlc3M6IG1lZGlhS2V5U3lzdGVtQWNjZXNzLFxuICAgICAgbWVkaWFLZXlTeXN0ZW1Eb21haW46IGtleVN5c3RlbVxuICAgIH07XG5cbiAgICB0aGlzLl9tZWRpYUtleXNMaXN0LnB1c2gobWVkaWFLZXlzTGlzdEl0ZW0pO1xuXG4gICAgbWVkaWFLZXlTeXN0ZW1BY2Nlc3MuY3JlYXRlTWVkaWFLZXlzKClcbiAgICAgIC50aGVuKChtZWRpYUtleXMpID0+IHtcbiAgICAgICAgbWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzID0gbWVkaWFLZXlzO1xuXG4gICAgICAgIGxvZ2dlci5sb2coYE1lZGlhLWtleXMgY3JlYXRlZCBmb3Iga2V5LXN5c3RlbSBcIiR7a2V5U3lzdGVtfVwiYCk7XG5cbiAgICAgICAgdGhpcy5fb25NZWRpYUtleXNDcmVhdGVkKCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIG1lZGlhLWtleXM6JywgZXJyKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAgICogSGFuZGxlcyBrZXktY3JlYXRpb24gKHJlcHJlc2VudHMgYWNjZXNzIHRvIENETSkuIFdlIGFyZSBnb2luZyB0byBjcmVhdGUga2V5LXNlc3Npb25zIHVwb24gdGhpc1xuICAgICAqIGZvciBhbGwgZXhpc3Rpbmcga2V5cyB3aGVyZSBubyBzZXNzaW9uIGV4aXN0cyB5ZXQuXG4gICAgICovXG4gIF9vbk1lZGlhS2V5c0NyZWF0ZWQgKCkge1xuICAgIC8vIGNoZWNrIGZvciBhbGwga2V5LWxpc3QgaXRlbXMgaWYgYSBzZXNzaW9uIGV4aXN0cywgb3RoZXJ3aXNlLCBjcmVhdGUgb25lXG4gICAgdGhpcy5fbWVkaWFLZXlzTGlzdC5mb3JFYWNoKChtZWRpYUtleXNMaXN0SXRlbSkgPT4ge1xuICAgICAgaWYgKCFtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uKSB7XG4gICAgICAgIG1lZGlhS2V5c0xpc3RJdGVtLm1lZGlhS2V5c1Nlc3Npb24gPSBtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXMuY3JlYXRlU2Vzc2lvbigpO1xuICAgICAgICB0aGlzLl9vbk5ld01lZGlhS2V5U2Vzc2lvbihtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBrZXlTZXNzaW9uXG4gICAgICovXG4gIF9vbk5ld01lZGlhS2V5U2Vzc2lvbiAoa2V5U2Vzc2lvbikge1xuICAgIGxvZ2dlci5sb2coYE5ldyBrZXktc3lzdGVtIHNlc3Npb24gJHtrZXlTZXNzaW9uLnNlc3Npb25JZH1gKTtcblxuICAgIGtleVNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy5fb25LZXlTZXNzaW9uTWVzc2FnZShrZXlTZXNzaW9uLCBldmVudC5tZXNzYWdlKTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICBfb25LZXlTZXNzaW9uTWVzc2FnZSAoa2V5U2Vzc2lvbiwgbWVzc2FnZSkge1xuICAgIGxvZ2dlci5sb2coJ0dvdCBFTUUgbWVzc2FnZSBldmVudCwgY3JlYXRpbmcgbGljZW5zZSByZXF1ZXN0Jyk7XG5cbiAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZShtZXNzYWdlLCAoZGF0YSkgPT4ge1xuICAgICAgbG9nZ2VyLmxvZygnUmVjZWl2ZWQgbGljZW5zZSBkYXRhLCB1cGRhdGluZyBrZXktc2Vzc2lvbicpO1xuICAgICAga2V5U2Vzc2lvbi51cGRhdGUoZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICBfb25NZWRpYUVuY3J5cHRlZCAoaW5pdERhdGFUeXBlLCBpbml0RGF0YSkge1xuICAgIGxvZ2dlci5sb2coYE1lZGlhIGlzIGVuY3J5cHRlZCB1c2luZyBcIiR7aW5pdERhdGFUeXBlfVwiIGluaXQgZGF0YSB0eXBlYCk7XG5cbiAgICB0aGlzLl9pc01lZGlhRW5jcnlwdGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9tZWRpYUVuY3J5cHRpb25Jbml0RGF0YVR5cGUgPSBpbml0RGF0YVR5cGU7XG4gICAgdGhpcy5fbWVkaWFFbmNyeXB0aW9uSW5pdERhdGEgPSBpbml0RGF0YTtcblxuICAgIHRoaXMuX2F0dGVtcHRTZXRNZWRpYUtleXMoKTtcbiAgICB0aGlzLl9nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbigpO1xuICB9XG5cbiAgX2F0dGVtcHRTZXRNZWRpYUtleXMgKCkge1xuICAgIGlmICghdGhpcy5faGFzU2V0TWVkaWFLZXlzKSB7XG4gICAgICAvLyBGSVhNRTogc2VlIGlmIHdlIGNhbi93YW50L25lZWQtdG8gcmVhbGx5IHRvIGRlYWwgd2l0aCBzZXZlcmFsIHBvdGVudGlhbCBrZXktc2Vzc2lvbnM/XG4gICAgICBjb25zdCBrZXlzTGlzdEl0ZW0gPSB0aGlzLl9tZWRpYUtleXNMaXN0WzBdO1xuICAgICAgaWYgKCFrZXlzTGlzdEl0ZW0gfHwgIWtleXNMaXN0SXRlbS5tZWRpYUtleXMpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdGYXRhbDogTWVkaWEgaXMgZW5jcnlwdGVkIGJ1dCBubyBDRE0gYWNjZXNzIG9yIG5vIGtleXMgaGF2ZSBiZWVuIG9idGFpbmVkIHlldCcpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0tFWVMsXG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbG9nZ2VyLmxvZygnU2V0dGluZyBrZXlzIGZvciBlbmNyeXB0ZWQgbWVkaWEnKTtcblxuICAgICAgdGhpcy5fbWVkaWEuc2V0TWVkaWFLZXlzKGtleXNMaXN0SXRlbS5tZWRpYUtleXMpO1xuICAgICAgdGhpcy5faGFzU2V0TWVkaWFLZXlzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBfZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24gKCkge1xuICAgIC8vIEZJWE1FOiBzZWUgaWYgd2UgY2FuL3dhbnQvbmVlZC10byByZWFsbHkgdG8gZGVhbCB3aXRoIHNldmVyYWwgcG90ZW50aWFsIGtleS1zZXNzaW9ucz9cbiAgICBjb25zdCBrZXlzTGlzdEl0ZW0gPSB0aGlzLl9tZWRpYUtleXNMaXN0WzBdO1xuICAgIGlmICgha2V5c0xpc3RJdGVtKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhdGFsOiBNZWRpYSBpcyBlbmNyeXB0ZWQgYnV0IG5vdCBhbnkga2V5LXN5c3RlbSBhY2Nlc3MgaGFzIGJlZW4gb2J0YWluZWQgeWV0Jyk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fQUNDRVNTLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uSW5pdGlhbGl6ZWQpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdLZXktU2Vzc2lvbiBhbHJlYWR5IGluaXRpYWxpemVkIGJ1dCByZXF1ZXN0ZWQgYWdhaW4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlTZXNzaW9uID0ga2V5c0xpc3RJdGVtLm1lZGlhS2V5c1Nlc3Npb247XG4gICAgaWYgKCFrZXlTZXNzaW9uKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhdGFsOiBNZWRpYSBpcyBlbmNyeXB0ZWQgYnV0IG5vIGtleS1zZXNzaW9uIGV4aXN0aW5nJyk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fU0VTU0lPTixcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXREYXRhVHlwZSA9IHRoaXMuX21lZGlhRW5jcnlwdGlvbkluaXREYXRhVHlwZTtcbiAgICBjb25zdCBpbml0RGF0YSA9IHRoaXMuX21lZGlhRW5jcnlwdGlvbkluaXREYXRhO1xuXG4gICAgbG9nZ2VyLmxvZyhgR2VuZXJhdGluZyBrZXktc2Vzc2lvbiByZXF1ZXN0IGZvciBcIiR7aW5pdERhdGFUeXBlfVwiIGluaXQgZGF0YSB0eXBlYCk7XG5cbiAgICBrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbkluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgIGtleVNlc3Npb24uZ2VuZXJhdGVSZXF1ZXN0KGluaXREYXRhVHlwZSwgaW5pdERhdGEpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnS2V5LXNlc3Npb24gZ2VuZXJhdGlvbiBzdWNjZWVkZWQnKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcga2V5LXNlc3Npb24gcmVxdWVzdDonLCBlcnIpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX1NFU1NJT04sXG4gICAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIExpY2Vuc2Ugc2VydmVyIFVSTFxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGtleU1lc3NhZ2UgTWVzc2FnZSBkYXRhIGlzc3VlZCBieSBrZXktc3lzdGVtXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIHdoZW4gWEhSIGhhcyBzdWNjZWVkZWRcbiAgICAgKiBAcmV0dXJucyB7WE1MSHR0cFJlcXVlc3R9IFVuc2VudCAoYnV0IG9wZW5lZCBzdGF0ZSkgWEhSIG9iamVjdFxuICAgICAqL1xuICBfY3JlYXRlTGljZW5zZVhociAodXJsLCBrZXlNZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIGNvbnN0IGxpY2Vuc2VYaHJTZXR1cCA9IHRoaXMuX2xpY2Vuc2VYaHJTZXR1cDtcblxuICAgIHRyeSB7XG4gICAgICBpZiAobGljZW5zZVhoclNldHVwKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGljZW5zZVhoclNldHVwKHhociwgdXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGxldCdzIHRyeSB0byBvcGVuIGJlZm9yZSBydW5uaW5nIHNldHVwXG4gICAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCB1cmwsIHRydWUpO1xuICAgICAgICAgIGxpY2Vuc2VYaHJTZXR1cCh4aHIsIHVybCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmIGxpY2Vuc2VYaHJTZXR1cCBkaWQgbm90IHlldCBjYWxsIG9wZW4sIGxldCdzIGRvIGl0IG5vd1xuICAgICAgaWYgKCF4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgICB4aHIub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSUUxMSB0aHJvd3MgYW4gZXhjZXB0aW9uIG9uIHhoci5vcGVuIGlmIGF0dGVtcHRpbmcgdG8gYWNjZXNzIGFuIEhUVFAgcmVzb3VyY2Ugb3ZlciBIVFRQU1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBzZXR0aW5nIHVwIGtleS1zeXN0ZW0gbGljZW5zZSBYSFInLCBlKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9MSUNFTlNFX1JFUVVFU1RfRkFJTEVELFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9XG4gICAgICAgIHRoaXMuX29uTGljZW5zZVJlcXVlc3RSZWFkeVN0YWdlQ2hhbmdlLmJpbmQodGhpcywgeGhyLCB1cmwsIGtleU1lc3NhZ2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4geGhyO1xuICB9XG5cbiAgLyoqXG4gICAgICogQHBhcmFtIHtYTUxIdHRwUmVxdWVzdH0geGhyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBMaWNlbnNlIHNlcnZlciBVUkxcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBrZXlNZXNzYWdlIE1lc3NhZ2UgZGF0YSBpc3N1ZWQgYnkga2V5LXN5c3RlbVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCB3aGVuIFhIUiBoYXMgc3VjY2VlZGVkXG4gICAgICpcbiAgICAgKi9cbiAgX29uTGljZW5zZVJlcXVlc3RSZWFkeVN0YWdlQ2hhbmdlICh4aHIsIHVybCwga2V5TWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBzd2l0Y2ggKHhoci5yZWFkeVN0YXRlKSB7XG4gICAgY2FzZSA0OlxuICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XG4gICAgICAgIGxvZ2dlci5sb2coJ0xpY2Vuc2UgcmVxdWVzdCBzdWNjZWVkZWQnKTtcbiAgICAgICAgY2FsbGJhY2soeGhyLnJlc3BvbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgTGljZW5zZSBSZXF1ZXN0IFhIUiBmYWlsZWQgKCR7dXJsfSkuIFN0YXR1czogJHt4aHIuc3RhdHVzfSAoJHt4aHIuc3RhdHVzVGV4dH0pYCk7XG5cbiAgICAgICAgdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQrKztcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50IDw9IE1BWF9MSUNFTlNFX1JFUVVFU1RfRkFJTFVSRVMpIHtcbiAgICAgICAgICBjb25zdCBhdHRlbXB0c0xlZnQgPSBNQVhfTElDRU5TRV9SRVFVRVNUX0ZBSUxVUkVTIC0gdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgKyAxO1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBSZXRyeWluZyBsaWNlbnNlIHJlcXVlc3QsICR7YXR0ZW1wdHNMZWZ0fSBhdHRlbXB0cyBsZWZ0YCk7XG4gICAgICAgICAgdGhpcy5fcmVxdWVzdExpY2Vuc2Uoa2V5TWVzc2FnZSwgY2FsbGJhY2spO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCxcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBrZXlzTGlzdEl0ZW1cbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBrZXlNZXNzYWdlXG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBDaGFsbGVuZ2UgZGF0YSBwb3N0ZWQgdG8gbGljZW5zZSBzZXJ2ZXJcbiAgICAgKi9cbiAgX2dlbmVyYXRlTGljZW5zZVJlcXVlc3RDaGFsbGVuZ2UgKGtleXNMaXN0SXRlbSwga2V5TWVzc2FnZSkge1xuICAgIGxldCBjaGFsbGVuZ2U7XG5cbiAgICBpZiAoa2V5c0xpc3RJdGVtLm1lZGlhS2V5U3lzdGVtRG9tYWluID09PSBLZXlTeXN0ZW1zLlBMQVlSRUFEWSkge1xuICAgICAgbG9nZ2VyLmVycm9yKCdQbGF5UmVhZHkgaXMgbm90IHN1cHBvcnRlZCAoeWV0KScpO1xuXG4gICAgICAvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnRFZGdlL0RlbW9zL2Jsb2IvbWFzdGVyL2VtZS9zY3JpcHRzL2RlbW8uanNcbiAgICAgIC8qXG4gICAgICAgIGlmICh0aGlzLmxpY2Vuc2VUeXBlICE9PSB0aGlzLkxJQ0VOU0VfVFlQRV9XSURFVklORSkge1xuICAgICAgICAgICAgLy8gRm9yIFBsYXlSZWFkeSBDRE1zLCB3ZSBuZWVkIHRvIGRpZyB0aGUgQ2hhbGxlbmdlIG91dCBvZiB0aGUgWE1MLlxuICAgICAgICAgICAgdmFyIGtleU1lc3NhZ2VYbWwgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGtleU1lc3NhZ2UpKSwgJ2FwcGxpY2F0aW9uL3htbCcpO1xuICAgICAgICAgICAgaWYgKGtleU1lc3NhZ2VYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0NoYWxsZW5nZScpWzBdKSB7XG4gICAgICAgICAgICAgICAgY2hhbGxlbmdlID0gYXRvYihrZXlNZXNzYWdlWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdDaGFsbGVuZ2UnKVswXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93ICdDYW5ub3QgZmluZCA8Q2hhbGxlbmdlPiBpbiBrZXkgbWVzc2FnZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaGVhZGVyTmFtZXMgPSBrZXlNZXNzYWdlWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCduYW1lJyk7XG4gICAgICAgICAgICB2YXIgaGVhZGVyVmFsdWVzID0ga2V5TWVzc2FnZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmFsdWUnKTtcbiAgICAgICAgICAgIGlmIChoZWFkZXJOYW1lcy5sZW5ndGggIT09IGhlYWRlclZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnTWlzbWF0Y2hlZCBoZWFkZXIgPG5hbWU+Lzx2YWx1ZT4gcGFpciBpbiBrZXkgbWVzc2FnZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZXNbaV0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUsIGhlYWRlclZhbHVlc1tpXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICB9IGVsc2UgaWYgKGtleXNMaXN0SXRlbS5tZWRpYUtleVN5c3RlbURvbWFpbiA9PT0gS2V5U3lzdGVtcy5XSURFVklORSkge1xuICAgICAgLy8gRm9yIFdpZGV2aW5lIENETXMsIHRoZSBjaGFsbGVuZ2UgaXMgdGhlIGtleU1lc3NhZ2UuXG4gICAgICBjaGFsbGVuZ2UgPSBrZXlNZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ1Vuc3VwcG9ydGVkIGtleS1zeXN0ZW06Jywga2V5c0xpc3RJdGVtLm1lZGlhS2V5U3lzdGVtRG9tYWluKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbGxlbmdlO1xuICB9XG5cbiAgX3JlcXVlc3RMaWNlbnNlIChrZXlNZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIGxvZ2dlci5sb2coJ1JlcXVlc3RpbmcgY29udGVudCBsaWNlbnNlIGZvciBrZXktc3lzdGVtJyk7XG5cbiAgICBjb25zdCBrZXlzTGlzdEl0ZW0gPSB0aGlzLl9tZWRpYUtleXNMaXN0WzBdO1xuICAgIGlmICgha2V5c0xpc3RJdGVtKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhdGFsIGVycm9yOiBNZWRpYSBpcyBlbmNyeXB0ZWQgYnV0IG5vIGtleS1zeXN0ZW0gYWNjZXNzIGhhcyBiZWVuIG9idGFpbmVkIHlldCcpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0FDQ0VTUyxcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHVybCA9IHRoaXMuZ2V0TGljZW5zZVNlcnZlclVybChrZXlzTGlzdEl0ZW0ubWVkaWFLZXlTeXN0ZW1Eb21haW4pO1xuICAgIGNvbnN0IHhociA9IHRoaXMuX2NyZWF0ZUxpY2Vuc2VYaHIodXJsLCBrZXlNZXNzYWdlLCBjYWxsYmFjayk7XG5cbiAgICBsb2dnZXIubG9nKGBTZW5kaW5nIGxpY2Vuc2UgcmVxdWVzdCB0byBVUkw6ICR7dXJsfWApO1xuXG4gICAgeGhyLnNlbmQodGhpcy5fZ2VuZXJhdGVMaWNlbnNlUmVxdWVzdENoYWxsZW5nZShrZXlzTGlzdEl0ZW0sIGtleU1lc3NhZ2UpKTtcbiAgfVxuXG4gIG9uTWVkaWFBdHRhY2hlZCAoZGF0YSkge1xuICAgIGlmICghdGhpcy5fZW1lRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1lZGlhID0gZGF0YS5tZWRpYTtcblxuICAgIC8vIGtlZXAgcmVmZXJlbmNlIG9mIG1lZGlhXG4gICAgdGhpcy5fbWVkaWEgPSBtZWRpYTtcblxuICAgIC8vIEZJWE1FOiBhbHNvIGhhbmRsZSBkZXRhY2hpbmcgbWVkaWEgIVxuXG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5jcnlwdGVkJywgKGUpID0+IHtcbiAgICAgIHRoaXMuX29uTWVkaWFFbmNyeXB0ZWQoZS5pbml0RGF0YVR5cGUsIGUuaW5pdERhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgb25NYW5pZmVzdFBhcnNlZCAoZGF0YSkge1xuICAgIGlmICghdGhpcy5fZW1lRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGF1ZGlvQ29kZWNzID0gZGF0YS5sZXZlbHMubWFwKChsZXZlbCkgPT4gbGV2ZWwuYXVkaW9Db2RlYyk7XG4gICAgY29uc3QgdmlkZW9Db2RlY3MgPSBkYXRhLmxldmVscy5tYXAoKGxldmVsKSA9PiBsZXZlbC52aWRlb0NvZGVjKTtcblxuICAgIHRoaXMuX2F0dGVtcHRLZXlTeXN0ZW1BY2Nlc3MoS2V5U3lzdGVtcy5XSURFVklORSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFTUVDb250cm9sbGVyO1xuIiwiLypcbiAqIEZQUyBDb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jb25zdCB7IHBlcmZvcm1hbmNlIH0gPSB3aW5kb3c7XG5cbmNsYXNzIEZQU0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCBFdmVudC5NRURJQV9BVFRBQ0hJTkcpO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgfVxuXG4gICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gZmFsc2U7XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoaW5nIChkYXRhKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGlmIChjb25maWcuY2FwTGV2ZWxPbkZQU0Ryb3ApIHtcbiAgICAgIGNvbnN0IHZpZGVvID0gdGhpcy52aWRlbyA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xuICAgICAgaWYgKHR5cGVvZiB2aWRlby5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMuY2hlY2tGUFNJbnRlcnZhbC5iaW5kKHRoaXMpLCBjb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2QpO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrRlBTICh2aWRlbywgZGVjb2RlZEZyYW1lcywgZHJvcHBlZEZyYW1lcykge1xuICAgIGxldCBjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGlmIChkZWNvZGVkRnJhbWVzKSB7XG4gICAgICBpZiAodGhpcy5sYXN0VGltZSkge1xuICAgICAgICBsZXQgY3VycmVudFBlcmlvZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGltZSxcbiAgICAgICAgICBjdXJyZW50RHJvcHBlZCA9IGRyb3BwZWRGcmFtZXMgLSB0aGlzLmxhc3REcm9wcGVkRnJhbWVzLFxuICAgICAgICAgIGN1cnJlbnREZWNvZGVkID0gZGVjb2RlZEZyYW1lcyAtIHRoaXMubGFzdERlY29kZWRGcmFtZXMsXG4gICAgICAgICAgZHJvcHBlZEZQUyA9IDEwMDAgKiBjdXJyZW50RHJvcHBlZCAvIGN1cnJlbnRQZXJpb2QsXG4gICAgICAgICAgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZQU19EUk9QLCB7IGN1cnJlbnREcm9wcGVkOiBjdXJyZW50RHJvcHBlZCwgY3VycmVudERlY29kZWQ6IGN1cnJlbnREZWNvZGVkLCB0b3RhbERyb3BwZWRGcmFtZXM6IGRyb3BwZWRGcmFtZXMgfSk7XG4gICAgICAgIGlmIChkcm9wcGVkRlBTID4gMCkge1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2NoZWNrRlBTIDogZHJvcHBlZEZQUy9kZWNvZGVkRlBTOicgKyBkcm9wcGVkRlBTLygxMDAwICogY3VycmVudERlY29kZWQgLyBjdXJyZW50UGVyaW9kKSk7XG4gICAgICAgICAgaWYgKGN1cnJlbnREcm9wcGVkID4gaGxzLmNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZCAqIGN1cnJlbnREZWNvZGVkKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudExldmVsID0gaGxzLmN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdkcm9wIEZQUyByYXRpbyBncmVhdGVyIHRoYW4gbWF4IGFsbG93ZWQgdmFsdWUgZm9yIGN1cnJlbnRMZXZlbDogJyArIGN1cnJlbnRMZXZlbCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudExldmVsID4gMCAmJiAoaGxzLmF1dG9MZXZlbENhcHBpbmcgPT09IC0xIHx8IGhscy5hdXRvTGV2ZWxDYXBwaW5nID49IGN1cnJlbnRMZXZlbCkpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gY3VycmVudExldmVsIC0gMTtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlBTX0RST1BfTEVWRUxfQ0FQUElORywgeyBsZXZlbDogY3VycmVudExldmVsLCBkcm9wcGVkTGV2ZWw6IGhscy5jdXJyZW50TGV2ZWwgfSk7XG4gICAgICAgICAgICAgIGhscy5hdXRvTGV2ZWxDYXBwaW5nID0gY3VycmVudExldmVsO1xuICAgICAgICAgICAgICBobHMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIHRoaXMubGFzdERyb3BwZWRGcmFtZXMgPSBkcm9wcGVkRnJhbWVzO1xuICAgICAgdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyA9IGRlY29kZWRGcmFtZXM7XG4gICAgfVxuICB9XG5cbiAgY2hlY2tGUFNJbnRlcnZhbCAoKSB7XG4gICAgY29uc3QgdmlkZW8gPSB0aGlzLnZpZGVvO1xuICAgIGlmICh2aWRlbykge1xuICAgICAgaWYgKHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSkge1xuICAgICAgICBsZXQgdmlkZW9QbGF5YmFja1F1YWxpdHkgPSB2aWRlby5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpO1xuICAgICAgICB0aGlzLmNoZWNrRlBTKHZpZGVvLCB2aWRlb1BsYXliYWNrUXVhbGl0eS50b3RhbFZpZGVvRnJhbWVzLCB2aWRlb1BsYXliYWNrUXVhbGl0eS5kcm9wcGVkVmlkZW9GcmFtZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGVja0ZQUyh2aWRlbywgdmlkZW8ud2Via2l0RGVjb2RlZEZyYW1lQ291bnQsIHZpZGVvLndlYmtpdERyb3BwZWRGcmFtZUNvdW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRlBTQ29udHJvbGxlcjtcbiIsImltcG9ydCBCaW5hcnlTZWFyY2ggZnJvbSAnLi4vdXRpbHMvYmluYXJ5LXNlYXJjaCc7XG5cbi8qKlxuICogUmV0dXJucyBmaXJzdCBmcmFnbWVudCB3aG9zZSBlbmRQZHQgdmFsdWUgZXhjZWVkcyB0aGUgZ2l2ZW4gUERULlxuICogQHBhcmFtIHtBcnJheTxGcmFnbWVudD59IGZyYWdtZW50cyAtIFRoZSBhcnJheSBvZiBjYW5kaWRhdGUgZnJhZ21lbnRzXG4gKiBAcGFyYW0ge251bWJlcnxudWxsfSBbUERUVmFsdWUgPSBudWxsXSAtIFRoZSBQRFQgdmFsdWUgd2hpY2ggbXVzdCBiZSBleGNlZWRlZFxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQvZW5kIGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyB7KnxudWxsfSBmcmFnbWVudCAtIFRoZSBiZXN0IG1hdGNoaW5nIGZyYWdtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRnJhZ21lbnRCeVBEVCAoZnJhZ21lbnRzLCBQRFRWYWx1ZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZnJhZ21lbnRzKSB8fCAhZnJhZ21lbnRzLmxlbmd0aCB8fCAhTnVtYmVyLmlzRmluaXRlKFBEVFZhbHVlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gaWYgbGVzcyB0aGFuIHN0YXJ0XG4gIGlmIChQRFRWYWx1ZSA8IGZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChQRFRWYWx1ZSA+PSBmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdLmVuZFByb2dyYW1EYXRlVGltZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IG1heEZyYWdMb29rVXBUb2xlcmFuY2UgfHwgMDtcbiAgZm9yIChsZXQgc2VnID0gMDsgc2VnIDwgZnJhZ21lbnRzLmxlbmd0aDsgKytzZWcpIHtcbiAgICBsZXQgZnJhZyA9IGZyYWdtZW50c1tzZWddO1xuICAgIGlmIChwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0KFBEVFZhbHVlLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnKSkge1xuICAgICAgcmV0dXJuIGZyYWc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRmluZHMgYSBmcmFnbWVudCBiYXNlZCBvbiB0aGUgU04gb2YgdGhlIHByZXZpb3VzIGZyYWdtZW50OyBvciBiYXNlZCBvbiB0aGUgbmVlZHMgb2YgdGhlIGN1cnJlbnQgYnVmZmVyLlxuICogVGhpcyBtZXRob2QgY29tcGVuc2F0ZXMgZm9yIHNtYWxsIGJ1ZmZlciBnYXBzIGJ5IGFwcGx5aW5nIGEgdG9sZXJhbmNlIHRvIHRoZSBzdGFydCBvZiBhbnkgY2FuZGlkYXRlIGZyYWdtZW50LCB0aHVzXG4gKiBicmVha2luZyBhbnkgdHJhcHMgd2hpY2ggd291bGQgY2F1c2UgdGhlIHNhbWUgZnJhZ21lbnQgdG8gYmUgY29udGludW91c2x5IHNlbGVjdGVkIHdpdGhpbiBhIHNtYWxsIHJhbmdlLlxuICogQHBhcmFtIHsqfSBmcmFnUHJldmlvdXMgLSBUaGUgbGFzdCBmcmFnIHN1Y2Nlc3NmdWxseSBhcHBlbmRlZFxuICogQHBhcmFtIHtBcnJheTxGcmFnbWVudD59IGZyYWdtZW50cyAtIFRoZSBhcnJheSBvZiBjYW5kaWRhdGUgZnJhZ21lbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gW2J1ZmZlckVuZCA9IDBdIC0gVGhlIGVuZCBvZiB0aGUgY29udGlndW91cyBidWZmZXJlZCByYW5nZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5IHdpdGhpblxuICogQHBhcmFtIHtudW1iZXJ9IG1heEZyYWdMb29rVXBUb2xlcmFuY2UgLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQvZW5kIGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyB7Kn0gZm91bmRGcmFnIC0gVGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGcmFnbWVudEJ5UFRTIChmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgYnVmZmVyRW5kID0gMCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDApIHtcbiAgY29uc3QgZnJhZ05leHQgPSBmcmFnUHJldmlvdXMgPyBmcmFnbWVudHNbZnJhZ1ByZXZpb3VzLnNuIC0gZnJhZ21lbnRzWzBdLnNuICsgMV0gOiBudWxsO1xuICAvLyBQcmVmZXIgdGhlIG5leHQgZnJhZ21lbnQgaWYgaXQncyB3aXRoaW4gdG9sZXJhbmNlXG4gIGlmIChmcmFnTmV4dCAmJiAhZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZ05leHQpKSB7XG4gICAgcmV0dXJuIGZyYWdOZXh0O1xuICB9XG4gIHJldHVybiBCaW5hcnlTZWFyY2guc2VhcmNoKGZyYWdtZW50cywgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0LmJpbmQobnVsbCwgYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSk7XG59XG5cbi8qKlxuICogVGhlIHRlc3QgZnVuY3Rpb24gdXNlZCBieSB0aGUgZmluZEZyYWdtZW50QnlTbidzIEJpbmFyeVNlYXJjaCB0byBsb29rIGZvciB0aGUgYmVzdCBtYXRjaCB0byB0aGUgY3VycmVudCBidWZmZXIgY29uZGl0aW9ucy5cbiAqIEBwYXJhbSB7Kn0gY2FuZGlkYXRlIC0gVGhlIGZyYWdtZW50IHRvIHRlc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYnVmZmVyRW5kID0gMF0gLSBUaGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlcmVkIHJhbmdlIHRoZSBwbGF5aGVhZCBpcyBjdXJyZW50bHkgd2l0aGluXG4gKiBAcGFyYW0ge251bWJlcn0gW21heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwXSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMge251bWJlcn0gLSAwIGlmIGl0IG1hdGNoZXMsIDEgaWYgdG9vIGxvdywgLTEgaWYgdG9vIGhpZ2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCAoYnVmZmVyRW5kID0gMCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDAsIGNhbmRpZGF0ZSkge1xuICAvLyBvZmZzZXQgc2hvdWxkIGJlIHdpdGhpbiBmcmFnbWVudCBib3VuZGFyeSAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlXG4gIC8vIHRoaXMgaXMgdG8gY29wZSB3aXRoIHNpdHVhdGlvbnMgbGlrZVxuICAvLyBidWZmZXJFbmQgPSA5Ljk5MVxuICAvLyBmcmFnW8OYXSA6IFswLDEwXVxuICAvLyBmcmFnWzFdIDogWzEwLDIwXVxuICAvLyBidWZmZXJFbmQgaXMgd2l0aGluIGZyYWdbMF0gcmFuZ2UgLi4uIGFsdGhvdWdoIHdoYXQgd2UgYXJlIGV4cGVjdGluZyBpcyB0byByZXR1cm4gZnJhZ1sxXSBoZXJlXG4gIC8vICAgICAgICAgICAgICBmcmFnIHN0YXJ0ICAgICAgICAgICAgICAgZnJhZyBzdGFydCtkdXJhdGlvblxuICAvLyAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgLy8gICAgICAgICAgICAgIDwtLS0+ICAgICAgICAgICAgICAgICAgICAgICAgIDwtLS0+XG4gIC8vICAuLi4tLS0tLS0tLT48LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+PC0tLS0tLS0tLS4uLi5cbiAgLy8gcHJldmlvdXMgZnJhZyAgICAgICAgIG1hdGNoaW5nIGZyYWdtZW50ICAgICAgICAgbmV4dCBmcmFnXG4gIC8vICByZXR1cm4gLTEgICAgICAgICAgICAgcmV0dXJuIDAgICAgICAgICAgICAgICAgIHJldHVybiAxXG4gIC8vIGxvZ2dlci5sb2coYGxldmVsL3NuL3N0YXJ0L2VuZC9idWZFbmQ6JHtsZXZlbH0vJHtjYW5kaWRhdGUuc259LyR7Y2FuZGlkYXRlLnN0YXJ0fS8keyhjYW5kaWRhdGUuc3RhcnQrY2FuZGlkYXRlLmR1cmF0aW9uKX0vJHtidWZmZXJFbmR9YCk7XG4gIC8vIFNldCB0aGUgbG9va3VwIHRvbGVyYW5jZSB0byBiZSBzbWFsbCBlbm91Z2ggdG8gZGV0ZWN0IHRoZSBjdXJyZW50IHNlZ21lbnQgLSBlbnN1cmVzIHdlIGRvbid0IHNraXAgb3ZlciB2ZXJ5IHNtYWxsIHNlZ21lbnRzXG4gIGxldCBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMCkpO1xuICBpZiAoY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlIDw9IGJ1ZmZlckVuZCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5zdGFydCAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IGJ1ZmZlckVuZCAmJiBjYW5kaWRhdGUuc3RhcnQpIHtcbiAgICAvLyBpZiBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHdpbGwgaGF2ZSBuZWdhdGl2ZSB2YWx1ZSB0aGVuIGRvbid0IHJldHVybiAtMSBmb3IgZmlyc3QgZWxlbWVudFxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG4vKipcbiAqIFRoZSB0ZXN0IGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGZpbmRGcmFnbWVudEJ5UGR0J3MgQmluYXJ5U2VhcmNoIHRvIGxvb2sgZm9yIHRoZSBiZXN0IG1hdGNoIHRvIHRoZSBjdXJyZW50IGJ1ZmZlciBjb25kaXRpb25zLlxuICogVGhpcyBmdW5jdGlvbiB0ZXN0cyB0aGUgY2FuZGlkYXRlJ3MgcHJvZ3JhbSBkYXRlIHRpbWUgdmFsdWVzLCBhcyByZXByZXNlbnRlZCBpbiBVbml4IHRpbWVcbiAqIEBwYXJhbSB7Kn0gY2FuZGlkYXRlIC0gVGhlIGZyYWdtZW50IHRvIHRlc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGR0QnVmZmVyRW5kID0gMF0gLSBUaGUgVW5peCB0aW1lIHJlcHJlc2VudGluZyB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlcmVkIHJhbmdlXG4gKiBAcGFyYW0ge251bWJlcn0gW21heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwXSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgY29udGlndW91cywgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0IChwZHRCdWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZSkge1xuICBsZXQgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uICsgKGNhbmRpZGF0ZS5kZWx0YVBUUyA/IGNhbmRpZGF0ZS5kZWx0YVBUUyA6IDApKSAqIDEwMDA7XG4gIHJldHVybiBjYW5kaWRhdGUuZW5kUHJvZ3JhbURhdGVUaW1lIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gcGR0QnVmZmVyRW5kO1xufVxuIiwiaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuXG5leHBvcnQgY29uc3QgRnJhZ21lbnRTdGF0ZSA9IHtcbiAgTk9UX0xPQURFRDogJ05PVF9MT0FERUQnLFxuICBBUFBFTkRJTkc6ICdBUFBFTkRJTkcnLFxuICBQQVJUSUFMOiAnUEFSVElBTCcsXG4gIE9LOiAnT0snXG59O1xuXG5leHBvcnQgY2xhc3MgRnJhZ21lbnRUcmFja2VyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50LkJVRkZFUl9BUFBFTkRFRCxcbiAgICAgIEV2ZW50LkZSQUdfQlVGRkVSRUQsXG4gICAgICBFdmVudC5GUkFHX0xPQURFRFxuICAgICk7XG5cbiAgICB0aGlzLmJ1ZmZlclBhZGRpbmcgPSAwLjI7XG5cbiAgICB0aGlzLmZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy50aW1lUmFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnRpbWVSYW5nZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgRnJhZ21lbnQgdGhhdCBtYXRjaCB0aGUgcG9zaXRpb24gYW5kIGxldmVsVHlwZS5cbiAgICogSWYgbm90IGZvdW5kIGFueSBGcmFnbWVudCwgcmV0dXJuIG51bGxcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7TGV2ZWxUeXBlfSBsZXZlbFR5cGVcbiAgICogQHJldHVybnMge0ZyYWdtZW50fG51bGx9XG4gICAqL1xuICBnZXRCdWZmZXJlZEZyYWcgKHBvc2l0aW9uLCBsZXZlbFR5cGUpIHtcbiAgICBjb25zdCBmcmFnbWVudHMgPSB0aGlzLmZyYWdtZW50cztcbiAgICBjb25zdCBidWZmZXJlZEZyYWdzID0gT2JqZWN0LmtleXMoZnJhZ21lbnRzKS5maWx0ZXIoa2V5ID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAoZnJhZ21lbnRFbnRpdHkuYm9keS50eXBlICE9PSBsZXZlbFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZnJhZyA9IGZyYWdtZW50RW50aXR5LmJvZHk7XG4gICAgICByZXR1cm4gZnJhZy5zdGFydFBUUyA8PSBwb3NpdGlvbiAmJiBwb3NpdGlvbiA8PSBmcmFnLmVuZFBUUztcbiAgICB9KTtcbiAgICBpZiAoYnVmZmVyZWRGcmFncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9wdWxsLzE1NDUjZGlzY3Vzc2lvbl9yMTY2MjI5NTY2XG4gICAgICBjb25zdCBidWZmZXJlZEZyYWdLZXkgPSBidWZmZXJlZEZyYWdzLnBvcCgpO1xuICAgICAgcmV0dXJuIGZyYWdtZW50c1tidWZmZXJlZEZyYWdLZXldLmJvZHk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnRpYWwgZnJhZ21lbnRzIGVmZmVjdGVkIGJ5IGNvZGVkIGZyYW1lIGV2aWN0aW9uIHdpbGwgYmUgcmVtb3ZlZFxuICAgKiBUaGUgYnJvd3NlciB3aWxsIHVubG9hZCBwYXJ0cyBvZiB0aGUgYnVmZmVyIHRvIGZyZWUgdXAgbWVtb3J5IGZvciBuZXcgYnVmZmVyIGRhdGFcbiAgICogRnJhZ21lbnRzIHdpbGwgbmVlZCB0byBiZSByZWxvYWRlZCB3aGVuIHRoZSBidWZmZXIgaXMgZnJlZWQgdXAsIHJlbW92aW5nIHBhcnRpYWwgZnJhZ21lbnRzIHdpbGwgYWxsb3cgdGhlbSB0byByZWxvYWQoc2luY2UgdGhlcmUgbWlnaHQgYmUgcGFydHMgdGhhdCBhcmUgc3RpbGwgcGxheWFibGUpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbGVtZW50YXJ5U3RyZWFtIFRoZSBlbGVtZW50YXJ5U3RyZWFtIG9mIG1lZGlhIHRoaXMgaXMgKGVnLiB2aWRlby9hdWRpbylcbiAgICogQHBhcmFtIHtUaW1lUmFuZ2VzfSB0aW1lUmFuZ2UgVGltZVJhbmdlIG9iamVjdCBmcm9tIGEgc291cmNlQnVmZmVyXG4gICAqL1xuICBkZXRlY3RFdmljdGVkRnJhZ21lbnRzIChlbGVtZW50YXJ5U3RyZWFtLCB0aW1lUmFuZ2UpIHtcbiAgICBsZXQgZnJhZ21lbnRUaW1lcywgdGltZTtcbiAgICAvLyBDaGVjayBpZiBhbnkgZmxhZ2dlZCBmcmFnbWVudHMgaGF2ZSBiZWVuIHVubG9hZGVkXG4gICAgT2JqZWN0LmtleXModGhpcy5mcmFnbWVudHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNba2V5XTtcbiAgICAgIGlmIChmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBlc0RhdGEgPSBmcmFnbWVudEVudGl0eS5yYW5nZVtlbGVtZW50YXJ5U3RyZWFtXTtcbiAgICAgICAgaWYgKGVzRGF0YSkge1xuICAgICAgICAgIGZyYWdtZW50VGltZXMgPSBlc0RhdGEudGltZTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYWdtZW50VGltZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRpbWUgPSBmcmFnbWVudFRpbWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc1RpbWVCdWZmZXJlZCh0aW1lLnN0YXJ0UFRTLCB0aW1lLmVuZFBUUywgdGltZVJhbmdlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgLy8gVW5yZWdpc3RlciBwYXJ0aWFsIGZyYWdtZW50IGFzIGl0IG5lZWRzIHRvIGxvYWQgYWdhaW4gdG8gYmUgcmV1c2VkXG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZnJhZ21lbnQgcGFzc2VkIGluIGlzIGxvYWRlZCBpbiB0aGUgYnVmZmVyIHByb3Blcmx5XG4gICAqIFBhcnRpYWxseSBsb2FkZWQgZnJhZ21lbnRzIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyBhIHBhcnRpYWwgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGZyYWdtZW50IENoZWNrIHRoZSBmcmFnbWVudCBhZ2FpbnN0IGFsbCBzb3VyY2VCdWZmZXJzIGxvYWRlZFxuICAgKi9cbiAgZGV0ZWN0UGFydGlhbEZyYWdtZW50cyAoZnJhZ21lbnQpIHtcbiAgICBsZXQgZnJhZ0tleSA9IHRoaXMuZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgIGxldCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICAgIGlmIChmcmFnbWVudEVudGl0eSkge1xuICAgICAgZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgPSB0cnVlO1xuXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnRpbWVSYW5nZXMpLmZvckVhY2goZWxlbWVudGFyeVN0cmVhbSA9PiB7XG4gICAgICAgIGlmIChmcmFnbWVudC5oYXNFbGVtZW50YXJ5U3RyZWFtKGVsZW1lbnRhcnlTdHJlYW0pKSB7XG4gICAgICAgICAgbGV0IHRpbWVSYW5nZSA9IHRoaXMudGltZVJhbmdlc1tlbGVtZW50YXJ5U3RyZWFtXTtcbiAgICAgICAgICAvLyBDaGVjayBmb3IgbWFsZm9ybWVkIGZyYWdtZW50c1xuICAgICAgICAgIC8vIEdhcHMgbmVlZCB0byBiZSBjYWxjdWxhdGVkIGZvciBlYWNoIGVsZW1lbnRhcnlTdHJlYW1cbiAgICAgICAgICBmcmFnbWVudEVudGl0eS5yYW5nZVtlbGVtZW50YXJ5U3RyZWFtXSA9IHRoaXMuZ2V0QnVmZmVyZWRUaW1lcyhmcmFnbWVudC5zdGFydFBUUywgZnJhZ21lbnQuZW5kUFRTLCB0aW1lUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBnZXRCdWZmZXJlZFRpbWVzIChzdGFydFBUUywgZW5kUFRTLCB0aW1lUmFuZ2UpIHtcbiAgICBsZXQgZnJhZ21lbnRUaW1lcyA9IFtdO1xuICAgIGxldCBzdGFydFRpbWUsIGVuZFRpbWU7XG4gICAgbGV0IGZyYWdtZW50UGFydGlhbCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGFydFRpbWUgPSB0aW1lUmFuZ2Uuc3RhcnQoaSkgLSB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGlmIChzdGFydFBUUyA+PSBzdGFydFRpbWUgJiYgZW5kUFRTIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgLy8gRnJhZ21lbnQgaXMgZW50aXJlbHkgY29udGFpbmVkIGluIGJ1ZmZlclxuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSBvdGhlciB0aW1lUmFuZ2UgdGltZXMgc2luY2UgaXQncyBjb21wbGV0ZWx5IHBsYXlhYmxlXG4gICAgICAgIGZyYWdtZW50VGltZXMucHVzaCh7XG4gICAgICAgICAgc3RhcnRQVFM6IE1hdGgubWF4KHN0YXJ0UFRTLCB0aW1lUmFuZ2Uuc3RhcnQoaSkpLFxuICAgICAgICAgIGVuZFBUUzogTWF0aC5taW4oZW5kUFRTLCB0aW1lUmFuZ2UuZW5kKGkpKVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0UFRTIDwgZW5kVGltZSAmJiBlbmRQVFMgPiBzdGFydFRpbWUpIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGludGVyc2VjdGlvbiB3aXRoIGJ1ZmZlclxuICAgICAgICAvLyBHZXQgcGxheWFibGUgc2VjdGlvbnMgb2YgdGhlIGZyYWdtZW50XG4gICAgICAgIGZyYWdtZW50VGltZXMucHVzaCh7XG4gICAgICAgICAgc3RhcnRQVFM6IE1hdGgubWF4KHN0YXJ0UFRTLCB0aW1lUmFuZ2Uuc3RhcnQoaSkpLFxuICAgICAgICAgIGVuZFBUUzogTWF0aC5taW4oZW5kUFRTLCB0aW1lUmFuZ2UuZW5kKGkpKVxuICAgICAgICB9KTtcbiAgICAgICAgZnJhZ21lbnRQYXJ0aWFsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kUFRTIDw9IHN0YXJ0VGltZSkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSByZXN0IG9mIHRoZSB0aW1lUmFuZ2UgYXMgaXQgaXMgaW4gb3JkZXJcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRpbWU6IGZyYWdtZW50VGltZXMsXG4gICAgICBwYXJ0aWFsOiBmcmFnbWVudFBhcnRpYWxcbiAgICB9O1xuICB9XG5cbiAgZ2V0RnJhZ21lbnRLZXkgKGZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGAke2ZyYWdtZW50LnR5cGV9XyR7ZnJhZ21lbnQubGV2ZWx9XyR7ZnJhZ21lbnQudXJsSWR9XyR7ZnJhZ21lbnQuc259YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvciBhIGNlcnRhaW4gdGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBmcmFnbWVudCBSZXR1cm5zIGEgcGFydGlhbCBmcmFnbWVudCBhdCBhIHRpbWUgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBwYXJ0aWFsIGZyYWdtZW50XG4gICAqL1xuICBnZXRQYXJ0aWFsRnJhZ21lbnQgKHRpbWUpIHtcbiAgICBsZXQgdGltZVBhZGRpbmcsIHN0YXJ0VGltZSwgZW5kVGltZTtcbiAgICBsZXQgYmVzdEZyYWdtZW50ID0gbnVsbDtcbiAgICBsZXQgYmVzdE92ZXJsYXAgPSAwO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuZnJhZ21lbnRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAodGhpcy5pc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XG4gICAgICAgIHN0YXJ0VGltZSA9IGZyYWdtZW50RW50aXR5LmJvZHkuc3RhcnRQVFMgLSB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICAgIGVuZFRpbWUgPSBmcmFnbWVudEVudGl0eS5ib2R5LmVuZFBUUyArIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgICAgaWYgKHRpbWUgPj0gc3RhcnRUaW1lICYmIHRpbWUgPD0gZW5kVGltZSkge1xuICAgICAgICAgIC8vIFVzZSB0aGUgZnJhZ21lbnQgdGhhdCBoYXMgdGhlIG1vc3QgcGFkZGluZyBmcm9tIHN0YXJ0IGFuZCBlbmQgdGltZVxuICAgICAgICAgIHRpbWVQYWRkaW5nID0gTWF0aC5taW4odGltZSAtIHN0YXJ0VGltZSwgZW5kVGltZSAtIHRpbWUpO1xuICAgICAgICAgIGlmIChiZXN0T3ZlcmxhcCA8PSB0aW1lUGFkZGluZykge1xuICAgICAgICAgICAgYmVzdEZyYWdtZW50ID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgICAgICAgIGJlc3RPdmVybGFwID0gdGltZVBhZGRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGJlc3RGcmFnbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZnJhZ21lbnQgVGhlIGZyYWdtZW50IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybnMgdGhlIGZyYWdtZW50IHN0YXRlIHdoZW4gYSBmcmFnbWVudCBuZXZlciBsb2FkZWQgb3IgaWYgaXQgcGFydGlhbGx5IGxvYWRlZFxuICAgKi9cbiAgZ2V0U3RhdGUgKGZyYWdtZW50KSB7XG4gICAgbGV0IGZyYWdLZXkgPSB0aGlzLmdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICBsZXQgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICBsZXQgc3RhdGUgPSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQ7XG5cbiAgICBpZiAoZnJhZ21lbnRFbnRpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICBzdGF0ZSA9IEZyYWdtZW50U3RhdGUuQVBQRU5ESU5HO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzUGFydGlhbChmcmFnbWVudEVudGl0eSkgPT09IHRydWUpIHtcbiAgICAgICAgc3RhdGUgPSBGcmFnbWVudFN0YXRlLlBBUlRJQUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IEZyYWdtZW50U3RhdGUuT0s7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgaXNQYXJ0aWFsIChmcmFnbWVudEVudGl0eSkge1xuICAgIHJldHVybiBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9PT0gdHJ1ZSAmJlxuICAgICAgKChmcmFnbWVudEVudGl0eS5yYW5nZS52aWRlbyAhPT0gdW5kZWZpbmVkICYmIGZyYWdtZW50RW50aXR5LnJhbmdlLnZpZGVvLnBhcnRpYWwgPT09IHRydWUpIHx8XG4gICAgICAgIChmcmFnbWVudEVudGl0eS5yYW5nZS5hdWRpbyAhPT0gdW5kZWZpbmVkICYmIGZyYWdtZW50RW50aXR5LnJhbmdlLmF1ZGlvLnBhcnRpYWwgPT09IHRydWUpKTtcbiAgfVxuXG4gIGlzVGltZUJ1ZmZlcmVkIChzdGFydFBUUywgZW5kUFRTLCB0aW1lUmFuZ2UpIHtcbiAgICBsZXQgc3RhcnRUaW1lLCBlbmRUaW1lO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGFydFRpbWUgPSB0aW1lUmFuZ2Uuc3RhcnQoaSkgLSB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGlmIChzdGFydFBUUyA+PSBzdGFydFRpbWUgJiYgZW5kUFRTIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRQVFMgPD0gc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIHJlc3Qgb2YgdGhlIHRpbWVSYW5nZSBhcyBpdCBpcyBpbiBvcmRlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIGNvbXBsZXRlZFxuICAgKi9cbiAgb25GcmFnTG9hZGVkIChlKSB7XG4gICAgY29uc3QgZnJhZ21lbnQgPSBlLmZyYWc7XG4gICAgLy8gZG9uJ3QgdHJhY2sgaW5pdHNlZ21lbnQgKGZvciB3aGljaCBzbiBpcyBub3QgYSBudW1iZXIpXG4gICAgLy8gZG9uJ3QgdHJhY2sgZnJhZ3MgdXNlZCBmb3IgYml0cmF0ZVRlc3QsIHRoZXkncmUgaXJyZWxldmFudC5cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFnbWVudC5zbikgfHwgZnJhZ21lbnQuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmZyYWdtZW50c1t0aGlzLmdldEZyYWdtZW50S2V5KGZyYWdtZW50KV0gPSB7XG4gICAgICBib2R5OiBmcmFnbWVudCxcbiAgICAgIHJhbmdlOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgYnVmZmVyZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIHRoZSBidWZmZXIgaXMgdXBkYXRlZFxuICAgKi9cbiAgb25CdWZmZXJBcHBlbmRlZCAoZSkge1xuICAgIC8vIFN0b3JlIHRoZSBsYXRlc3QgdGltZVJhbmdlcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlclxuICAgIHRoaXMudGltZVJhbmdlcyA9IGUudGltZVJhbmdlcztcbiAgICBPYmplY3Qua2V5cyh0aGlzLnRpbWVSYW5nZXMpLmZvckVhY2goZWxlbWVudGFyeVN0cmVhbSA9PiB7XG4gICAgICBsZXQgdGltZVJhbmdlID0gdGhpcy50aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgdGhpcy5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKGVsZW1lbnRhcnlTdHJlYW0sIHRpbWVSYW5nZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgYWZ0ZXIgYSBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgc291cmNlIGJ1ZmZlclxuICAgKi9cbiAgb25GcmFnQnVmZmVyZWQgKGUpIHtcbiAgICB0aGlzLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoZS5mcmFnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBmcmFnbWVudCB0cmFja2VyIGhhcyB0aGUgZnJhZ21lbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmcmFnbWVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0ZyYWdtZW50IChmcmFnbWVudCkge1xuICAgIGNvbnN0IGZyYWdLZXkgPSB0aGlzLmdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV0gIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmcmFnbWVudCBmcm9tIGZyYWdtZW50IHRyYWNrZXIgdW50aWwgaXQgaXMgbG9hZGVkIGFnYWluXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmcmFnbWVudCBUaGUgZnJhZ21lbnQgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVGcmFnbWVudCAoZnJhZ21lbnQpIHtcbiAgICBsZXQgZnJhZ0tleSA9IHRoaXMuZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgIGRlbGV0ZSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGZyYWdtZW50cyBmcm9tIGZyYWdtZW50IHRyYWNrZXIuXG4gICAqL1xuICByZW1vdmVBbGxGcmFnbWVudHMgKCkge1xuICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQnVmZmVySGVscGVyIH0gZnJvbSAnLi4vdXRpbHMvYnVmZmVyLWhlbHBlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jb25zdCBzdGFsbERlYm91bmNlSW50ZXJ2YWwgPSAxMDAwO1xuY29uc3QganVtcFRocmVzaG9sZCA9IDAuNTsgLy8gdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgcmFuZ2UgZW5kXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhcENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnLCBtZWRpYSwgZnJhZ21lbnRUcmFja2VyLCBobHMpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwbGF5aGVhZCBpcyBzdHVjayB3aXRoaW4gYSBnYXAsIGFuZCBpZiBzbywgYXR0ZW1wdHMgdG8gZnJlZSBpdC5cbiAgICogQSBnYXAgaXMgYW4gdW5idWZmZXJlZCByYW5nZSBiZXR3ZWVuIHR3byBidWZmZXJlZCByYW5nZXMgKG9yIHRoZSBzdGFydCBhbmQgdGhlIGZpcnN0IGJ1ZmZlcmVkIHJhbmdlKS5cbiAgICogQHBhcmFtIGxhc3RDdXJyZW50VGltZVxuICAgKiBAcGFyYW0gYnVmZmVyZWRcbiAgICovXG4gIHBvbGwgKGxhc3RDdXJyZW50VGltZSwgYnVmZmVyZWQpIHtcbiAgICBjb25zdCB7IGNvbmZpZywgbWVkaWEgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBjb25zdCB0bm93ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgaWYgKGN1cnJlbnRUaW1lICE9PSBsYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgIC8vIFRoZSBwbGF5aGVhZCBpcyBub3cgbW92aW5nLCBidXQgd2FzIHByZXZpb3VzbHkgc3RhbGxlZFxuICAgICAgaWYgKHRoaXMuc3RhbGxSZXBvcnRlZCkge1xuICAgICAgICBsb2dnZXIud2FybihgcGxheWJhY2sgbm90IHN0dWNrIGFueW1vcmUgQCR7Y3VycmVudFRpbWV9LCBhZnRlciAke01hdGgucm91bmQodG5vdyAtIHRoaXMuc3RhbGxlZCl9bXNgKTtcbiAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgdGhpcy5udWRnZVJldHJ5ID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWVkaWEuZW5kZWQgfHwgIW1lZGlhLmJ1ZmZlcmVkLmxlbmd0aCB8fCBtZWRpYS5yZWFkeVN0YXRlID4gMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtZWRpYS5zZWVraW5nICYmIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLCBjdXJyZW50VGltZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGUgcGxheWhlYWQgaXNuJ3QgbW92aW5nIGJ1dCBpdCBzaG91bGQgYmVcbiAgICAvLyBBbGxvdyBzb21lIHNsYWNrIHRpbWUgdG8gZm9yIHNtYWxsIHN0YWxscyB0byByZXNvbHZlIHRoZW1zZWx2ZXNcbiAgICBjb25zdCBzdGFsbGVkRHVyYXRpb24gPSB0bm93IC0gdGhpcy5zdGFsbGVkO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICBpZiAoIXRoaXMuc3RhbGxlZCkge1xuICAgICAgdGhpcy5zdGFsbGVkID0gdG5vdztcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHN0YWxsZWREdXJhdGlvbiA+PSBzdGFsbERlYm91bmNlSW50ZXJ2YWwpIHtcbiAgICAgIC8vIFJlcG9ydCBzdGFsbGluZyBhZnRlciB0cnlpbmcgdG8gZml4XG4gICAgICB0aGlzLl9yZXBvcnRTdGFsbChidWZmZXJJbmZvLmxlbik7XG4gICAgfVxuXG4gICAgdGhpcy5fdHJ5Rml4QnVmZmVyU3RhbGwoYnVmZmVySW5mbywgc3RhbGxlZER1cmF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3RzIGFuZCBhdHRlbXB0cyB0byBmaXgga25vd24gYnVmZmVyIHN0YWxsaW5nIGlzc3Vlcy5cbiAgICogQHBhcmFtIGJ1ZmZlckluZm8gLSBUaGUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBidWZmZXIuXG4gICAqIEBwYXJhbSBzdGFsbGVkRHVyYXRpb24gLSBUaGUgYW1vdW50IG9mIHRpbWUgSGxzLmpzIGhhcyBiZWVuIHN0YWxsaW5nIGZvci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90cnlGaXhCdWZmZXJTdGFsbCAoYnVmZmVySW5mbywgc3RhbGxlZER1cmF0aW9uKSB7XG4gICAgY29uc3QgeyBjb25maWcsIGZyYWdtZW50VHJhY2tlciwgbWVkaWEgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcblxuICAgIGNvbnN0IHBhcnRpYWwgPSBmcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKTtcbiAgICBpZiAocGFydGlhbCkge1xuICAgICAgLy8gVHJ5IHRvIHNraXAgb3ZlciB0aGUgYnVmZmVyIGhvbGUgY2F1c2VkIGJ5IGEgcGFydGlhbCBmcmFnbWVudFxuICAgICAgLy8gVGhpcyBtZXRob2QgaXNuJ3QgbGltaXRlZCBieSB0aGUgc2l6ZSBvZiB0aGUgZ2FwIGJldHdlZW4gYnVmZmVyZWQgcmFuZ2VzXG4gICAgICB0aGlzLl90cnlTa2lwQnVmZmVySG9sZShwYXJ0aWFsKTtcbiAgICB9XG5cbiAgICBpZiAoYnVmZmVySW5mby5sZW4gPiBqdW1wVGhyZXNob2xkICYmIHN0YWxsZWREdXJhdGlvbiA+IGNvbmZpZy5oaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2QgKiAxMDAwKSB7XG4gICAgICAvLyBUcnkgdG8gbnVkZ2UgY3VycmVudFRpbWUgb3ZlciBhIGJ1ZmZlciBob2xlIGlmIHdlJ3ZlIGJlZW4gc3RhbGxpbmcgZm9yIHRoZSBjb25maWd1cmVkIGFtb3VudCBvZiBzZWNvbmRzXG4gICAgICAvLyBXZSBvbmx5IHRyeSB0byBqdW1wIHRoZSBob2xlIGlmIGl0J3MgdW5kZXIgdGhlIGNvbmZpZ3VyZWQgc2l6ZVxuICAgICAgLy8gUmVzZXQgc3RhbGxlZCBzbyB0byByZWFybSB3YXRjaGRvZyB0aW1lclxuICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgIHRoaXMuX3RyeU51ZGdlQnVmZmVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgQlVGRkVSX1NUQUxMRURfRVJST1IgZXZlbnQsIGJ1dCBvbmx5IG9uY2UgcGVyIHN0YWxsIHBlcmlvZC5cbiAgICogQHBhcmFtIGJ1ZmZlckxlbiAtIFRoZSBwbGF5aGVhZCBkaXN0YW5jZSBmcm9tIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyIHNlZ21lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVwb3J0U3RhbGwgKGJ1ZmZlckxlbikge1xuICAgIGNvbnN0IHsgaGxzLCBtZWRpYSwgc3RhbGxSZXBvcnRlZCB9ID0gdGhpcztcbiAgICBpZiAoIXN0YWxsUmVwb3J0ZWQpIHtcbiAgICAgIC8vIFJlcG9ydCBzdGFsbGVkIGVycm9yIG9uY2VcbiAgICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IHRydWU7XG4gICAgICBsb2dnZXIud2FybihgUGxheWJhY2sgc3RhbGxpbmcgYXQgQCR7bWVkaWEuY3VycmVudFRpbWV9IGR1ZSB0byBsb3cgYnVmZmVyYCk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgYnVmZmVyOiBidWZmZXJMZW5cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBmaXggYnVmZmVyIHN0YWxscyBieSBqdW1waW5nIG92ZXIga25vd24gZ2FwcyBjYXVzZWQgYnkgcGFydGlhbCBmcmFnbWVudHNcbiAgICogQHBhcmFtIHBhcnRpYWwgLSBUaGUgcGFydGlhbCBmcmFnbWVudCBmb3VuZCBhdCB0aGUgY3VycmVudCB0aW1lICh3aGVyZSBwbGF5YmFjayBpcyBzdGFsbGluZykuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdHJ5U2tpcEJ1ZmZlckhvbGUgKHBhcnRpYWwpIHtcbiAgICBjb25zdCB7IGhscywgbWVkaWEgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBsZXQgbGFzdEVuZFRpbWUgPSAwO1xuICAgIC8vIENoZWNrIGlmIGN1cnJlbnRUaW1lIGlzIGJldHdlZW4gdW5idWZmZXJlZCByZWdpb25zIG9mIHBhcnRpYWwgZnJhZ21lbnRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWRpYS5idWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHN0YXJ0VGltZSA9IG1lZGlhLmJ1ZmZlcmVkLnN0YXJ0KGkpO1xuICAgICAgaWYgKGN1cnJlbnRUaW1lID49IGxhc3RFbmRUaW1lICYmIGN1cnJlbnRUaW1lIDwgc3RhcnRUaW1lKSB7XG4gICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gTWF0aC5tYXgoc3RhcnRUaW1lLCBtZWRpYS5jdXJyZW50VGltZSArIDAuMSk7XG4gICAgICAgIGxvZ2dlci53YXJuKGBza2lwcGluZyBob2xlLCBhZGp1c3RpbmcgY3VycmVudFRpbWUgZnJvbSAke2N1cnJlbnRUaW1lfSB0byAke21lZGlhLmN1cnJlbnRUaW1lfWApO1xuICAgICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TRUVLX09WRVJfSE9MRSxcbiAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgcmVhc29uOiBgZnJhZ21lbnQgbG9hZGVkIHdpdGggYnVmZmVyIGhvbGVzLCBzZWVraW5nIGZyb20gJHtjdXJyZW50VGltZX0gdG8gJHttZWRpYS5jdXJyZW50VGltZX1gLFxuICAgICAgICAgIGZyYWc6IHBhcnRpYWxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxhc3RFbmRUaW1lID0gbWVkaWEuYnVmZmVyZWQuZW5kKGkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBmaXggYnVmZmVyIHN0YWxscyBieSBhZHZhbmNpbmcgdGhlIG1lZGlhRWxlbWVudCdzIGN1cnJlbnQgdGltZSBieSBhIHNtYWxsIGFtb3VudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90cnlOdWRnZUJ1ZmZlciAoKSB7XG4gICAgY29uc3QgeyBjb25maWcsIGhscywgbWVkaWEgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBjb25zdCBudWRnZVJldHJ5ID0gKHRoaXMubnVkZ2VSZXRyeSB8fCAwKSArIDE7XG4gICAgdGhpcy5udWRnZVJldHJ5ID0gbnVkZ2VSZXRyeTtcblxuICAgIGlmIChudWRnZVJldHJ5IDwgY29uZmlnLm51ZGdlTWF4UmV0cnkpIHtcbiAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBjdXJyZW50VGltZSArIG51ZGdlUmV0cnkgKiBjb25maWcubnVkZ2VPZmZzZXQ7XG4gICAgICBsb2dnZXIubG9nKGBhZGp1c3QgY3VycmVudFRpbWUgZnJvbSAke2N1cnJlbnRUaW1lfSB0byAke3RhcmdldFRpbWV9YCk7XG4gICAgICAvLyBwbGF5YmFjayBzdGFsbGVkIGluIGJ1ZmZlcmVkIGFyZWEgLi4uIGxldCdzIG51ZGdlIGN1cnJlbnRUaW1lIHRvIHRyeSB0byBvdmVyY29tZSB0aGlzXG4gICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHRhcmdldFRpbWU7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX05VREdFX09OX1NUQUxMLFxuICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZXJyb3IoYHN0aWxsIHN0dWNrIGluIGhpZ2ggYnVmZmVyIEAke2N1cnJlbnRUaW1lfSBhZnRlciAke2NvbmZpZy5udWRnZU1heFJldHJ5fSwgcmFpc2UgZmF0YWwgZXJyb3JgKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUixcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIGlkMyBtZXRhZGF0YSB0cmFjayBjb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgSUQzIGZyb20gJy4uL2RlbXV4L2lkMyc7XG5pbXBvcnQgeyBzZW5kQWRkVHJhY2tFdmVudCwgY2xlYXJDdXJyZW50Q3VlcyB9IGZyb20gJy4uL3V0aWxzL3RleHR0cmFjay11dGlscyc7XG5cbmNsYXNzIElEM1RyYWNrQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19NRVRBREFUQSk7XG4gICAgdGhpcy5pZDNUcmFjayA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1lZGlhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICAvLyBBZGQgSUQzIG1ldGF0YWRhdGEgdGV4dCB0cmFjay5cbiAgb25NZWRpYUF0dGFjaGVkIChkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG5cbiAgICB9XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nICgpIHtcbiAgICBjbGVhckN1cnJlbnRDdWVzKHRoaXMuaWQzVHJhY2spO1xuICAgIHRoaXMuaWQzVHJhY2sgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tZWRpYSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldElEM1RyYWNrICh0ZXh0VHJhY2tzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdGV4dFRyYWNrID0gdGV4dFRyYWNrc1tpXTtcbiAgICAgIGlmICh0ZXh0VHJhY2sua2luZCA9PT0gJ21ldGFkYXRhJyAmJiB0ZXh0VHJhY2subGFiZWwgPT09ICdpZDMnKSB7XG4gICAgICAgIC8vIHNlbmQgJ2FkZHRyYWNrJyB3aGVuIHJldXNpbmcgdGhlIHRleHRUcmFjayBmb3IgbWV0YWRhdGEsXG4gICAgICAgIC8vIHNhbWUgYXMgd2hhdCB3ZSBkbyBmb3IgY2FwdGlvbnNcbiAgICAgICAgc2VuZEFkZFRyYWNrRXZlbnQodGV4dFRyYWNrLCB0aGlzLm1lZGlhKTtcblxuICAgICAgICByZXR1cm4gdGV4dFRyYWNrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZWRpYS5hZGRUZXh0VHJhY2soJ21ldGFkYXRhJywgJ2lkMycpO1xuICB9XG5cbiAgb25GcmFnUGFyc2luZ01ldGFkYXRhIChkYXRhKSB7XG4gICAgY29uc3QgZnJhZ21lbnQgPSBkYXRhLmZyYWc7XG4gICAgY29uc3Qgc2FtcGxlcyA9IGRhdGEuc2FtcGxlcztcblxuICAgIC8vIGNyZWF0ZSB0cmFjayBkeW5hbWljYWxseVxuICAgIGlmICghdGhpcy5pZDNUcmFjaykge1xuICAgICAgdGhpcy5pZDNUcmFjayA9IHRoaXMuZ2V0SUQzVHJhY2sodGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcbiAgICAgIHRoaXMuaWQzVHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICAgIH1cblxuICAgIC8vIEF0dGVtcHQgdG8gcmVjcmVhdGUgU2FmYXJpIGZ1bmN0aW9uYWxpdHkgYnkgY3JlYXRpbmdcbiAgICAvLyBXZWJLaXREYXRhQ3VlIG9iamVjdHMgd2hlbiBhdmFpbGFibGUgYW5kIHN0b3JlIHRoZSBkZWNvZGVkXG4gICAgLy8gSUQzIGRhdGEgaW4gdGhlIHZhbHVlIHByb3BlcnR5IG9mIHRoZSBjdWVcbiAgICBsZXQgQ3VlID0gd2luZG93LldlYktpdERhdGFDdWUgfHwgd2luZG93LlZUVEN1ZSB8fCB3aW5kb3cuVGV4dFRyYWNrQ3VlO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmcmFtZXMgPSBJRDMuZ2V0SUQzRnJhbWVzKHNhbXBsZXNbaV0uZGF0YSk7XG4gICAgICBpZiAoZnJhbWVzKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHNhbXBsZXNbaV0ucHRzO1xuICAgICAgICBsZXQgZW5kVGltZSA9IGkgPCBzYW1wbGVzLmxlbmd0aCAtIDEgPyBzYW1wbGVzW2kgKyAxXS5wdHMgOiBmcmFnbWVudC5lbmRQVFM7XG5cbiAgICAgICAgLy8gR2l2ZSBhIHNsaWdodCBidW1wIHRvIHRoZSBlbmRUaW1lIGlmIGl0J3MgZXF1YWwgdG8gc3RhcnRUaW1lIHRvIGF2b2lkIGEgU3ludGF4RXJyb3IgaW4gSUVcbiAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gZW5kVGltZSkge1xuICAgICAgICAgIGVuZFRpbWUgKz0gMC4wMDAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmcmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBmcmFtZSA9IGZyYW1lc1tqXTtcbiAgICAgICAgICAvLyBTYWZhcmkgZG9lc24ndCBwdXQgdGhlIHRpbWVzdGFtcCBmcmFtZSBpbiB0aGUgVGV4dFRyYWNrXG4gICAgICAgICAgaWYgKCFJRDMuaXNUaW1lU3RhbXBGcmFtZShmcmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1ZSA9IG5ldyBDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCAnJyk7XG4gICAgICAgICAgICBjdWUudmFsdWUgPSBmcmFtZTtcbiAgICAgICAgICAgIHRoaXMuaWQzVHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElEM1RyYWNrQ29udHJvbGxlcjtcbiIsIi8qXG4gKiBMZXZlbCBDb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGlzQ29kZWNTdXBwb3J0ZWRJbk1wNCB9IGZyb20gJy4uL3V0aWxzL2NvZGVjcyc7XG5pbXBvcnQgeyBhZGRHcm91cElkLCBjb21wdXRlUmVsb2FkSW50ZXJ2YWwgfSBmcm9tICcuL2xldmVsLWhlbHBlcic7XG5cbmNvbnN0IHsgcGVyZm9ybWFuY2UgfSA9IHdpbmRvdztcbmxldCBjaHJvbWVPckZpcmVmb3g7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExldmVsQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FERUQsXG4gICAgICBFdmVudC5MRVZFTF9MT0FERUQsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCxcbiAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxuICAgICAgRXZlbnQuRVJST1IpO1xuXG4gICAgdGhpcy5jYW5sb2FkID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG51bGw7XG4gICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gLTE7XG4gICAgdGhpcy50aW1lciA9IG51bGw7XG5cbiAgICBjaHJvbWVPckZpcmVmb3ggPSAvY2hyb21lfGZpcmVmb3gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcgKCkge1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IC0xO1xuICB9XG5cbiAgY2xlYXJUaW1lciAoKSB7XG4gICAgaWYgKHRoaXMudGltZXIgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHN0YXJ0TG9hZCAoKSB7XG4gICAgbGV0IGxldmVscyA9IHRoaXMuX2xldmVscztcblxuICAgIHRoaXMuY2FubG9hZCA9IHRydWU7XG4gICAgdGhpcy5sZXZlbFJldHJ5Q291bnQgPSAwO1xuXG4gICAgLy8gY2xlYW4gdXAgbGl2ZSBsZXZlbCBkZXRhaWxzIHRvIGZvcmNlIHJlbG9hZCB0aGVtLCBhbmQgcmVzZXQgbG9hZCBlcnJvcnNcbiAgICBpZiAobGV2ZWxzKSB7XG4gICAgICBsZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgICAgIGlmIChsZXZlbERldGFpbHMgJiYgbGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICBsZXZlbC5kZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gc3BlZWQgdXAgbGl2ZSBwbGF5bGlzdCByZWZyZXNoIGlmIHRpbWVyIGV4aXN0c1xuICAgIGlmICh0aGlzLnRpbWVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmxvYWRMZXZlbCgpO1xuICAgIH1cbiAgfVxuXG4gIHN0b3BMb2FkICgpIHtcbiAgICB0aGlzLmNhbmxvYWQgPSBmYWxzZTtcbiAgfVxuXG4gIG9uTWFuaWZlc3RMb2FkZWQgKGRhdGEpIHtcbiAgICBsZXQgbGV2ZWxzID0gW107XG4gICAgbGV0IGF1ZGlvVHJhY2tzID0gW107XG4gICAgbGV0IGJpdHJhdGVTdGFydDtcbiAgICBsZXQgbGV2ZWxTZXQgPSB7fTtcbiAgICBsZXQgbGV2ZWxGcm9tU2V0ID0gbnVsbDtcbiAgICBsZXQgdmlkZW9Db2RlY0ZvdW5kID0gZmFsc2U7XG4gICAgbGV0IGF1ZGlvQ29kZWNGb3VuZCA9IGZhbHNlO1xuXG4gICAgLy8gcmVncm91cCByZWR1bmRhbnQgbGV2ZWxzIHRvZ2V0aGVyXG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbGV2ZWwuYXR0cnM7XG4gICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IGZhbHNlO1xuXG4gICAgICB2aWRlb0NvZGVjRm91bmQgPSB2aWRlb0NvZGVjRm91bmQgfHwgISFsZXZlbC52aWRlb0NvZGVjO1xuICAgICAgYXVkaW9Db2RlY0ZvdW5kID0gYXVkaW9Db2RlY0ZvdW5kIHx8ICEhbGV2ZWwuYXVkaW9Db2RlYztcblxuICAgICAgLy8gZXJhc2UgYXVkaW8gY29kZWMgaW5mbyBpZiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbXA0YS40MC4zNC5cbiAgICAgIC8vIGRlbXV4ZXIgd2lsbCBhdXRvZGV0ZWN0IGNvZGVjIGFuZCBmYWxsYmFjayB0byBtcGVnL2F1ZGlvXG4gICAgICBpZiAoY2hyb21lT3JGaXJlZm94ICYmIGxldmVsLmF1ZGlvQ29kZWMgJiYgbGV2ZWwuYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjM0JykgIT09IC0xKSB7XG4gICAgICAgIGxldmVsLmF1ZGlvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGxldmVsRnJvbVNldCA9IGxldmVsU2V0W2xldmVsLmJpdHJhdGVdOyAvLyBGSVhNRTogd2Ugd291bGQgYWxzbyBoYXZlIHRvIG1hdGNoIHRoZSByZXNvbHV0aW9uIGhlcmVcblxuICAgICAgaWYgKCFsZXZlbEZyb21TZXQpIHtcbiAgICAgICAgbGV2ZWwudXJsID0gW2xldmVsLnVybF07XG4gICAgICAgIGxldmVsLnVybElkID0gMDtcbiAgICAgICAgbGV2ZWxTZXRbbGV2ZWwuYml0cmF0ZV0gPSBsZXZlbDtcbiAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxGcm9tU2V0LnVybC5wdXNoKGxldmVsLnVybCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLkFVRElPKSB7XG4gICAgICAgICAgYXVkaW9Db2RlY0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBhZGRHcm91cElkKGxldmVsRnJvbVNldCB8fCBsZXZlbCwgJ2F1ZGlvJywgYXR0cmlidXRlcy5BVURJTyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMuU1VCVElUTEVTKSB7XG4gICAgICAgICAgYWRkR3JvdXBJZChsZXZlbEZyb21TZXQgfHwgbGV2ZWwsICd0ZXh0JywgYXR0cmlidXRlcy5TVUJUSVRMRVMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyByZW1vdmUgYXVkaW8tb25seSBsZXZlbCBpZiB3ZSBhbHNvIGhhdmUgbGV2ZWxzIHdpdGggYXVkaW8rdmlkZW8gY29kZWNzIHNpZ25hbGxlZFxuICAgIGlmICh2aWRlb0NvZGVjRm91bmQgJiYgYXVkaW9Db2RlY0ZvdW5kKSB7XG4gICAgICBsZXZlbHMgPSBsZXZlbHMuZmlsdGVyKCh7IHZpZGVvQ29kZWMgfSkgPT4gISF2aWRlb0NvZGVjKTtcbiAgICB9XG5cbiAgICAvLyBvbmx5IGtlZXAgbGV2ZWxzIHdpdGggc3VwcG9ydGVkIGF1ZGlvL3ZpZGVvIGNvZGVjc1xuICAgIGxldmVscyA9IGxldmVscy5maWx0ZXIoKHsgYXVkaW9Db2RlYywgdmlkZW9Db2RlYyB9KSA9PiB7XG4gICAgICByZXR1cm4gKCFhdWRpb0NvZGVjIHx8IGlzQ29kZWNTdXBwb3J0ZWRJbk1wNChhdWRpb0NvZGVjLCAnYXVkaW8nKSkgJiYgKCF2aWRlb0NvZGVjIHx8IGlzQ29kZWNTdXBwb3J0ZWRJbk1wNCh2aWRlb0NvZGVjLCAndmlkZW8nKSk7XG4gICAgfSk7XG5cbiAgICBpZiAoZGF0YS5hdWRpb1RyYWNrcykge1xuICAgICAgYXVkaW9UcmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzLmZpbHRlcih0cmFjayA9PiAhdHJhY2suYXVkaW9Db2RlYyB8fCBpc0NvZGVjU3VwcG9ydGVkSW5NcDQodHJhY2suYXVkaW9Db2RlYywgJ2F1ZGlvJykpO1xuICAgICAgLy8gUmVhc3NpZ24gaWQncyBhZnRlciBmaWx0ZXJpbmcgc2luY2UgdGhleSdyZSB1c2VkIGFzIGFycmF5IGluZGljZXNcbiAgICAgIGF1ZGlvVHJhY2tzLmZvckVhY2goKHRyYWNrLCBpbmRleCkgPT4ge1xuICAgICAgICB0cmFjay5pZCA9IGluZGV4O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGxldmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBzdGFydCBiaXRyYXRlIGlzIHRoZSBmaXJzdCBiaXRyYXRlIG9mIHRoZSBtYW5pZmVzdFxuICAgICAgYml0cmF0ZVN0YXJ0ID0gbGV2ZWxzWzBdLmJpdHJhdGU7XG4gICAgICAvLyBzb3J0IGxldmVsIG9uIGJpdHJhdGVcbiAgICAgIGxldmVscy5zb3J0KChhLCBiKSA9PiBhLmJpdHJhdGUgLSBiLmJpdHJhdGUpO1xuICAgICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzO1xuICAgICAgLy8gZmluZCBpbmRleCBvZiBmaXJzdCBsZXZlbCBpbiBzb3J0ZWQgbGV2ZWxzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGV2ZWxzW2ldLmJpdHJhdGUgPT09IGJpdHJhdGVTdGFydCkge1xuICAgICAgICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBpO1xuICAgICAgICAgIGxvZ2dlci5sb2coYG1hbmlmZXN0IGxvYWRlZCwke2xldmVscy5sZW5ndGh9IGxldmVsKHMpIGZvdW5kLCBmaXJzdCBiaXRyYXRlOiR7Yml0cmF0ZVN0YXJ0fWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEF1ZGlvIGlzIG9ubHkgYWx0ZXJuYXRlIGlmIG1hbmlmZXN0IGluY2x1ZGUgYSBVUkkgYWxvbmcgd2l0aCB0aGUgYXVkaW8gZ3JvdXAgdGFnXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50Lk1BTklGRVNUX1BBUlNFRCwge1xuICAgICAgICBsZXZlbHMsXG4gICAgICAgIGF1ZGlvVHJhY2tzLFxuICAgICAgICBmaXJzdExldmVsOiB0aGlzLl9maXJzdExldmVsLFxuICAgICAgICBzdGF0czogZGF0YS5zdGF0cyxcbiAgICAgICAgYXVkaW86IGF1ZGlvQ29kZWNGb3VuZCxcbiAgICAgICAgdmlkZW86IHZpZGVvQ29kZWNGb3VuZCxcbiAgICAgICAgYWx0QXVkaW86IGF1ZGlvVHJhY2tzLnNvbWUodCA9PiAhIXQudXJsKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsXG4gICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICB1cmw6IHRoaXMuaGxzLnVybCxcbiAgICAgICAgcmVhc29uOiAnbm8gbGV2ZWwgd2l0aCBjb21wYXRpYmxlIGNvZGVjcyBmb3VuZCBpbiBtYW5pZmVzdCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGdldCBsZXZlbHMgKCkge1xuICAgIHJldHVybiB0aGlzLl9sZXZlbHM7XG4gIH1cblxuICBnZXQgbGV2ZWwgKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICB9XG5cbiAgc2V0IGxldmVsIChuZXdMZXZlbCkge1xuICAgIGxldCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgaWYgKGxldmVscykge1xuICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1pbihuZXdMZXZlbCwgbGV2ZWxzLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKHRoaXMuY3VycmVudExldmVsSW5kZXggIT09IG5ld0xldmVsIHx8ICFsZXZlbHNbbmV3TGV2ZWxdLmRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5zZXRMZXZlbEludGVybmFsKG5ld0xldmVsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXRMZXZlbEludGVybmFsIChuZXdMZXZlbCkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuX2xldmVscztcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICBpZiAobmV3TGV2ZWwgPj0gMCAmJiBuZXdMZXZlbCA8IGxldmVscy5sZW5ndGgpIHtcbiAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICBpZiAodGhpcy5jdXJyZW50TGV2ZWxJbmRleCAhPT0gbmV3TGV2ZWwpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgc3dpdGNoaW5nIHRvIGxldmVsICR7bmV3TGV2ZWx9YCk7XG4gICAgICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSBuZXdMZXZlbDtcbiAgICAgICAgY29uc3QgbGV2ZWxQcm9wZXJ0aWVzID0gbGV2ZWxzW25ld0xldmVsXTtcbiAgICAgICAgbGV2ZWxQcm9wZXJ0aWVzLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX1NXSVRDSElORywgbGV2ZWxQcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW25ld0xldmVsXTtcbiAgICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG5cbiAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBsZXZlbFxuICAgICAgaWYgKCFsZXZlbERldGFpbHMgfHwgbGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgLy8gbGV2ZWwgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgICBsZXQgdXJsSWQgPSBsZXZlbC51cmxJZDtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfTE9BRElORywgeyB1cmw6IGxldmVsLnVybFt1cmxJZF0sIGxldmVsOiBuZXdMZXZlbCwgaWQ6IHVybElkIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbnZhbGlkIGxldmVsIGlkIGdpdmVuLCB0cmlnZ2VyIGVycm9yXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTEVWRUxfU1dJVENIX0VSUk9SLFxuICAgICAgICBsZXZlbDogbmV3TGV2ZWwsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgcmVhc29uOiAnaW52YWxpZCBsZXZlbCBpZHgnXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBnZXQgbWFudWFsTGV2ZWwgKCkge1xuICAgIHJldHVybiB0aGlzLm1hbnVhbExldmVsSW5kZXg7XG4gIH1cblxuICBzZXQgbWFudWFsTGV2ZWwgKG5ld0xldmVsKSB7XG4gICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gbmV3TGV2ZWw7XG4gICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cblxuICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gIH1cblxuICBnZXQgZmlyc3RMZXZlbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gIH1cblxuICBzZXQgZmlyc3RMZXZlbCAobmV3TGV2ZWwpIHtcbiAgICB0aGlzLl9maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICBnZXQgc3RhcnRMZXZlbCAoKSB7XG4gICAgLy8gaGxzLnN0YXJ0TGV2ZWwgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGNvbmZpZy5zdGFydExldmVsXG4gICAgLy8gaWYgbm9uZSBvZiB0aGVzZSB2YWx1ZXMgYXJlIGRlZmluZWQsIGZhbGxiYWNrIG9uIHRoaXMuX2ZpcnN0TGV2ZWwgKGZpcnN0IHF1YWxpdHkgbGV2ZWwgYXBwZWFyaW5nIGluIHZhcmlhbnQgbWFuaWZlc3QpXG4gICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IGNvbmZpZ1N0YXJ0TGV2ZWwgPSB0aGlzLmhscy5jb25maWcuc3RhcnRMZXZlbDtcbiAgICAgIGlmIChjb25maWdTdGFydExldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZ1N0YXJ0TGV2ZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0TGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgc2V0IHN0YXJ0TGV2ZWwgKG5ld0xldmVsKSB7XG4gICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgb25FcnJvciAoZGF0YSkge1xuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbGV2ZWxFcnJvciA9IGZhbHNlLCBmcmFnbWVudEVycm9yID0gZmFsc2U7XG4gICAgbGV0IGxldmVsSW5kZXg7XG5cbiAgICAvLyB0cnkgdG8gcmVjb3ZlciBub3QgZmF0YWwgZXJyb3JzXG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgIGxldmVsSW5kZXggPSBkYXRhLmZyYWcubGV2ZWw7XG4gICAgICBmcmFnbWVudEVycm9yID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgICAgbGV2ZWxJbmRleCA9IGRhdGEuY29udGV4dC5sZXZlbDtcbiAgICAgIGxldmVsRXJyb3IgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1I6XG4gICAgICBsZXZlbEluZGV4ID0gZGF0YS5sZXZlbDtcbiAgICAgIGxldmVsRXJyb3IgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGxldmVsSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5yZWNvdmVyTGV2ZWwoZGF0YSwgbGV2ZWxJbmRleCwgbGV2ZWxFcnJvciwgZnJhZ21lbnRFcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaCB0byBhIHJlZHVuZGFudCBzdHJlYW0gaWYgYW55IGF2YWlsYWJsZS5cbiAgICogSWYgcmVkdW5kYW50IHN0cmVhbSBpcyBub3QgYXZhaWxhYmxlLCBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgQUJSIG1vZGUgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVycm9yRXZlbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsSW5kZXggY3VycmVudCBsZXZlbCBpbmRleFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxldmVsRXJyb3JcbiAgICogQHBhcmFtIHtCb29sZWFufSBmcmFnbWVudEVycm9yXG4gICAqL1xuICAvLyBGSVhNRSBGaW5kIGEgYmV0dGVyIGFic3RyYWN0aW9uIHdoZXJlIGZyYWdtZW50L2xldmVsIHJldHJ5IG1hbmFnZW1lbnQgaXMgd2VsbCBkZWNvdXBsZWRcbiAgcmVjb3ZlckxldmVsIChlcnJvckV2ZW50LCBsZXZlbEluZGV4LCBsZXZlbEVycm9yLCBmcmFnbWVudEVycm9yKSB7XG4gICAgbGV0IHsgY29uZmlnIH0gPSB0aGlzLmhscztcbiAgICBsZXQgeyBkZXRhaWxzOiBlcnJvckRldGFpbHMgfSA9IGVycm9yRXZlbnQ7XG4gICAgbGV0IGxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIGxldCByZWR1bmRhbnRMZXZlbHMsIGRlbGF5LCBuZXh0TGV2ZWw7XG5cbiAgICBsZXZlbC5sb2FkRXJyb3IrKztcbiAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gZnJhZ21lbnRFcnJvcjtcblxuICAgIGlmIChsZXZlbEVycm9yKSB7XG4gICAgICBpZiAoKHRoaXMubGV2ZWxSZXRyeUNvdW50ICsgMSkgPD0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5KSB7XG4gICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIG1heCByZXRyeSB0aW1lb3V0XG4gICAgICAgIGRlbGF5ID0gTWF0aC5taW4oTWF0aC5wb3coMiwgdGhpcy5sZXZlbFJldHJ5Q291bnQpICogY29uZmlnLmxldmVsTG9hZGluZ1JldHJ5RGVsYXksIGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQpO1xuICAgICAgICAvLyBTY2hlZHVsZSBsZXZlbCByZWxvYWRcbiAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5sb2FkTGV2ZWwoKSwgZGVsYXkpO1xuICAgICAgICAvLyBib29sZWFuIHVzZWQgdG8gaW5mb3JtIHN0cmVhbSBjb250cm9sbGVyIG5vdCB0byBzd2l0Y2ggYmFjayB0byBJRExFIG9uIG5vbiBmYXRhbCBlcnJvclxuICAgICAgICBlcnJvckV2ZW50LmxldmVsUmV0cnkgPSB0cnVlO1xuICAgICAgICB0aGlzLmxldmVsUmV0cnlDb3VudCsrO1xuICAgICAgICBsb2dnZXIud2FybihgbGV2ZWwgY29udHJvbGxlciwgJHtlcnJvckRldGFpbHN9LCByZXRyeSBpbiAke2RlbGF5fSBtcywgY3VycmVudCByZXRyeSBjb3VudCBpcyAke3RoaXMubGV2ZWxSZXRyeUNvdW50fWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBsZXZlbCBjb250cm9sbGVyLCBjYW5ub3QgcmVjb3ZlciBmcm9tICR7ZXJyb3JEZXRhaWxzfSBlcnJvcmApO1xuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gbnVsbDtcbiAgICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICAvLyBzd2l0Y2ggZXJyb3IgdG8gZmF0YWxcbiAgICAgICAgZXJyb3JFdmVudC5mYXRhbCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcnkgYW55IHJlZHVuZGFudCBzdHJlYW1zIGlmIGF2YWlsYWJsZSBmb3IgYm90aCBlcnJvcnM6IGxldmVsIGFuZCBmcmFnbWVudFxuICAgIC8vIElmIGxldmVsLmxvYWRFcnJvciByZWFjaGVzIHJlZHVuZGFudExldmVscyBpdCBtZWFucyB0aGF0IHdlIHRyaWVkIHRoZW0gYWxsLCBubyBob3BlICA9PiBsZXQncyBzd2l0Y2ggZG93blxuICAgIGlmIChsZXZlbEVycm9yIHx8IGZyYWdtZW50RXJyb3IpIHtcbiAgICAgIHJlZHVuZGFudExldmVscyA9IGxldmVsLnVybC5sZW5ndGg7XG5cbiAgICAgIGlmIChyZWR1bmRhbnRMZXZlbHMgPiAxICYmIGxldmVsLmxvYWRFcnJvciA8IHJlZHVuZGFudExldmVscykge1xuICAgICAgICBsZXZlbC51cmxJZCA9IChsZXZlbC51cmxJZCArIDEpICUgcmVkdW5kYW50TGV2ZWxzO1xuICAgICAgICBsZXZlbC5kZXRhaWxzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCAke2Vycm9yRGV0YWlsc30gZm9yIGxldmVsICR7bGV2ZWxJbmRleH06IHN3aXRjaGluZyB0byByZWR1bmRhbnQgVVJMLWlkICR7bGV2ZWwudXJsSWR9YCk7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0N1cnJlbnQgYXVkaW8gdHJhY2sgZ3JvdXAgSUQ6JywgdGhpcy5obHMuYXVkaW9UcmFja3NbdGhpcy5obHMuYXVkaW9UcmFja10uZ3JvdXBJZCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdOZXcgdmlkZW8gcXVhbGl0eSBsZXZlbCBhdWRpbyBncm91cCBpZDonLCBsZXZlbC5hdHRycy5BVURJTyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZWFyY2ggZm9yIGF2YWlsYWJsZSBsZXZlbFxuICAgICAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ID09PSAtMSkge1xuICAgICAgICAgIC8vIFdoZW4gbG93ZXN0IGxldmVsIGhhcyBiZWVuIHJlYWNoZWQsIGxldCdzIHN0YXJ0IGh1bnQgZnJvbSB0aGUgdG9wXG4gICAgICAgICAgbmV4dExldmVsID0gKGxldmVsSW5kZXggPT09IDApID8gdGhpcy5fbGV2ZWxzLmxlbmd0aCAtIDEgOiBsZXZlbEluZGV4IC0gMTtcbiAgICAgICAgICBsb2dnZXIud2FybihgbGV2ZWwgY29udHJvbGxlciwgJHtlcnJvckRldGFpbHN9OiBzd2l0Y2ggdG8gJHtuZXh0TGV2ZWx9YCk7XG4gICAgICAgICAgdGhpcy5obHMubmV4dEF1dG9MZXZlbCA9IHRoaXMuY3VycmVudExldmVsSW5kZXggPSBuZXh0TGV2ZWw7XG4gICAgICAgIH0gZWxzZSBpZiAoZnJhZ21lbnRFcnJvcikge1xuICAgICAgICAgIC8vIEFsbG93IGZyYWdtZW50IHJldHJ5IGFzIGxvbmcgYXMgY29uZmlndXJhdGlvbiBhbGxvd3MuXG4gICAgICAgICAgLy8gcmVzZXQgdGhpcy5fbGV2ZWwgc28gdGhhdCBhbm90aGVyIGNhbGwgdG8gc2V0IGxldmVsKCkgd2lsbCB0cmlnZ2VyIGFnYWluIGEgZnJhZyBsb2FkXG4gICAgICAgICAgbG9nZ2VyLndhcm4oYGxldmVsIGNvbnRyb2xsZXIsICR7ZXJyb3JEZXRhaWxzfTogcmVsb2FkIGEgZnJhZ21lbnRgKTtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHJlc2V0IGVycm9ycyBvbiB0aGUgc3VjY2Vzc2Z1bCBsb2FkIG9mIGEgZnJhZ21lbnRcbiAgb25GcmFnTG9hZGVkICh7IGZyYWcgfSkge1xuICAgIGlmIChmcmFnICE9PSB1bmRlZmluZWQgJiYgZnJhZy50eXBlID09PSAnbWFpbicpIHtcbiAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5fbGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IGZhbHNlO1xuICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgICB0aGlzLmxldmVsUmV0cnlDb3VudCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25MZXZlbExvYWRlZCAoZGF0YSkge1xuICAgIGNvbnN0IHsgbGV2ZWwsIGRldGFpbHMgfSA9IGRhdGE7XG4gICAgLy8gb25seSBwcm9jZXNzIGxldmVsIGxvYWRlZCBldmVudHMgbWF0Y2hpbmcgd2l0aCBleHBlY3RlZCBsZXZlbFxuICAgIGlmIChsZXZlbCAhPT0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGN1ckxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsXTtcbiAgICAvLyByZXNldCBsZXZlbCBsb2FkIGVycm9yIGNvdW50ZXIgb24gc3VjY2Vzc2Z1bCBsZXZlbCBsb2FkZWQgb25seSBpZiB0aGVyZSBpcyBubyBpc3N1ZXMgd2l0aCBmcmFnbWVudHNcbiAgICBpZiAoIWN1ckxldmVsLmZyYWdtZW50RXJyb3IpIHtcbiAgICAgIGN1ckxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICB0aGlzLmxldmVsUmV0cnlDb3VudCA9IDA7XG4gICAgfVxuICAgIC8vIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0LCBhcm0gYSB0aW1lciB0byByZWxvYWQgaXRcbiAgICBpZiAoZGV0YWlscy5saXZlKSB7XG4gICAgICBjb25zdCByZWxvYWRJbnRlcnZhbCA9IGNvbXB1dGVSZWxvYWRJbnRlcnZhbChjdXJMZXZlbC5kZXRhaWxzLCBkZXRhaWxzLCBkYXRhLnN0YXRzLnRyZXF1ZXN0KTtcbiAgICAgIGxvZ2dlci5sb2coYGxpdmUgcGxheWxpc3QsIHJlbG9hZCBpbiAke01hdGgucm91bmQocmVsb2FkSW50ZXJ2YWwpfSBtc2ApO1xuICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5sb2FkTGV2ZWwoKSwgcmVsb2FkSW50ZXJ2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB9XG4gIH1cblxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hlZCAoZGF0YSkge1xuICAgIGNvbnN0IGF1ZGlvR3JvdXBJZCA9IHRoaXMuaGxzLmF1ZGlvVHJhY2tzW2RhdGEuaWRdLmdyb3VwSWQ7XG5cbiAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbdGhpcy5jdXJyZW50TGV2ZWxJbmRleF07XG4gICAgaWYgKCFjdXJyZW50TGV2ZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudExldmVsLmF1ZGlvR3JvdXBJZHMpIHtcbiAgICAgIGxldCB1cmxJZCA9IC0xO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjdXJyZW50TGV2ZWwuYXVkaW9Hcm91cElkc1tpXSA9PT0gYXVkaW9Hcm91cElkKSB7XG4gICAgICAgICAgdXJsSWQgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh1cmxJZCAhPT0gY3VycmVudExldmVsLnVybElkKSB7XG4gICAgICAgIGN1cnJlbnRMZXZlbC51cmxJZCA9IHVybElkO1xuICAgICAgICB0aGlzLnN0YXJ0TG9hZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxvYWRMZXZlbCAoKSB7XG4gICAgbG9nZ2VyLmRlYnVnKCdjYWxsIHRvIGxvYWRMZXZlbCcpO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudExldmVsSW5kZXggIT09IG51bGwgJiYgdGhpcy5jYW5sb2FkKSB7XG4gICAgICBjb25zdCBsZXZlbE9iamVjdCA9IHRoaXMuX2xldmVsc1t0aGlzLmN1cnJlbnRMZXZlbEluZGV4XTtcblxuICAgICAgaWYgKHR5cGVvZiBsZXZlbE9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgbGV2ZWxPYmplY3QudXJsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICAgICAgICBjb25zdCBpZCA9IGxldmVsT2JqZWN0LnVybElkO1xuICAgICAgICBjb25zdCB1cmwgPSBsZXZlbE9iamVjdC51cmxbaWRdO1xuXG4gICAgICAgIGxvZ2dlci5sb2coYEF0dGVtcHQgbG9hZGluZyBsZXZlbCBpbmRleCAke2xldmVsfSB3aXRoIFVSTC1pZCAke2lkfWApO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdDdXJyZW50IGF1ZGlvIHRyYWNrIGdyb3VwIElEOicsIHRoaXMuaGxzLmF1ZGlvVHJhY2tzW3RoaXMuaGxzLmF1ZGlvVHJhY2tdLmdyb3VwSWQpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnTmV3IHZpZGVvIHF1YWxpdHkgbGV2ZWwgYXVkaW8gZ3JvdXAgaWQ6JywgbGV2ZWxPYmplY3QuYXR0cnMuQVVESU8sIGxldmVsKTtcblxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX0xPQURJTkcsIHsgdXJsLCBsZXZlbCwgaWQgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IG5leHRMb2FkTGV2ZWwgKCkge1xuICAgIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggIT09IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5obHMubmV4dEF1dG9MZXZlbDtcbiAgICB9XG4gIH1cblxuICBzZXQgbmV4dExvYWRMZXZlbCAobmV4dExldmVsKSB7XG4gICAgdGhpcy5sZXZlbCA9IG5leHRMZXZlbDtcbiAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ID09PSAtMSkge1xuICAgICAgdGhpcy5obHMubmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQG1vZHVsZSBMZXZlbEhlbHBlclxuICpcbiAqIFByb3ZpZGluZyBtZXRob2RzIGRlYWxpbmcgd2l0aCBwbGF5bGlzdCBzbGlkaW5nIGFuZCBkcmlmdFxuICpcbiAqIFRPRE86IENyZWF0ZSBhbiBhY3R1YWwgYExldmVsYCBjbGFzcy9tb2RlbCB0aGF0IGRlYWxzIHdpdGggYWxsIHRoaXMgbG9naWMgaW4gYW4gb2JqZWN0LW9yaWVudGVkLW1hbm5lci5cbiAqXG4gKiAqL1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkR3JvdXBJZCAobGV2ZWwsIHR5cGUsIGlkKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICBjYXNlICdhdWRpbyc6XG4gICAgaWYgKCFsZXZlbC5hdWRpb0dyb3VwSWRzKSB7XG4gICAgICBsZXZlbC5hdWRpb0dyb3VwSWRzID0gW107XG4gICAgfVxuICAgIGxldmVsLmF1ZGlvR3JvdXBJZHMucHVzaChpZCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3RleHQnOlxuICAgIGlmICghbGV2ZWwudGV4dEdyb3VwSWRzKSB7XG4gICAgICBsZXZlbC50ZXh0R3JvdXBJZHMgPSBbXTtcbiAgICB9XG4gICAgbGV2ZWwudGV4dEdyb3VwSWRzLnB1c2goaWQpO1xuICAgIGJyZWFrO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVQVFMgKGZyYWdtZW50cywgZnJvbUlkeCwgdG9JZHgpIHtcbiAgbGV0IGZyYWdGcm9tID0gZnJhZ21lbnRzW2Zyb21JZHhdLCBmcmFnVG8gPSBmcmFnbWVudHNbdG9JZHhdLCBmcmFnVG9QVFMgPSBmcmFnVG8uc3RhcnRQVFM7XG4gIC8vIGlmIHdlIGtub3cgc3RhcnRQVFNbdG9JZHhdXG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoZnJhZ1RvUFRTKSkge1xuICAgIC8vIHVwZGF0ZSBmcmFnbWVudCBkdXJhdGlvbi5cbiAgICAvLyBpdCBoZWxwcyB0byBmaXggZHJpZnRzIGJldHdlZW4gcGxheWxpc3QgcmVwb3J0ZWQgZHVyYXRpb24gYW5kIGZyYWdtZW50IHJlYWwgZHVyYXRpb25cbiAgICBpZiAodG9JZHggPiBmcm9tSWR4KSB7XG4gICAgICBmcmFnRnJvbS5kdXJhdGlvbiA9IGZyYWdUb1BUUyAtIGZyYWdGcm9tLnN0YXJ0O1xuICAgICAgaWYgKGZyYWdGcm9tLmR1cmF0aW9uIDwgMCkge1xuICAgICAgICBsb2dnZXIud2FybihgbmVnYXRpdmUgZHVyYXRpb24gY29tcHV0ZWQgZm9yIGZyYWcgJHtmcmFnRnJvbS5zbn0sbGV2ZWwgJHtmcmFnRnJvbS5sZXZlbH0sIHRoZXJlIHNob3VsZCBiZSBzb21lIGR1cmF0aW9uIGRyaWZ0IGJldHdlZW4gcGxheWxpc3QgYW5kIGZyYWdtZW50IWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnVG8uZHVyYXRpb24gPSBmcmFnRnJvbS5zdGFydCAtIGZyYWdUb1BUUztcbiAgICAgIGlmIChmcmFnVG8uZHVyYXRpb24gPCAwKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBuZWdhdGl2ZSBkdXJhdGlvbiBjb21wdXRlZCBmb3IgZnJhZyAke2ZyYWdUby5zbn0sbGV2ZWwgJHtmcmFnVG8ubGV2ZWx9LCB0aGVyZSBzaG91bGQgYmUgc29tZSBkdXJhdGlvbiBkcmlmdCBiZXR3ZWVuIHBsYXlsaXN0IGFuZCBmcmFnbWVudCFgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gd2UgZG9udCBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICAgIGlmICh0b0lkeCA+IGZyb21JZHgpIHtcbiAgICAgIGZyYWdUby5zdGFydCA9IGZyYWdGcm9tLnN0YXJ0ICsgZnJhZ0Zyb20uZHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWdUby5zdGFydCA9IE1hdGgubWF4KGZyYWdGcm9tLnN0YXJ0IC0gZnJhZ1RvLmR1cmF0aW9uLCAwKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUZyYWdQVFNEVFMgKGRldGFpbHMsIGZyYWcsIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpIHtcbiAgLy8gdXBkYXRlIGZyYWcgUFRTL0RUU1xuICBsZXQgbWF4U3RhcnRQVFMgPSBzdGFydFBUUztcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnLnN0YXJ0UFRTKSkge1xuICAgIC8vIGRlbHRhIFBUUyBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlb1xuICAgIGxldCBkZWx0YVBUUyA9IE1hdGguYWJzKGZyYWcuc3RhcnRQVFMgLSBzdGFydFBUUyk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhZy5kZWx0YVBUUykpIHtcbiAgICAgIGZyYWcuZGVsdGFQVFMgPSBkZWx0YVBUUztcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZy5kZWx0YVBUUyA9IE1hdGgubWF4KGRlbHRhUFRTLCBmcmFnLmRlbHRhUFRTKTtcbiAgICB9XG5cbiAgICBtYXhTdGFydFBUUyA9IE1hdGgubWF4KHN0YXJ0UFRTLCBmcmFnLnN0YXJ0UFRTKTtcbiAgICBzdGFydFBUUyA9IE1hdGgubWluKHN0YXJ0UFRTLCBmcmFnLnN0YXJ0UFRTKTtcbiAgICBlbmRQVFMgPSBNYXRoLm1heChlbmRQVFMsIGZyYWcuZW5kUFRTKTtcbiAgICBzdGFydERUUyA9IE1hdGgubWluKHN0YXJ0RFRTLCBmcmFnLnN0YXJ0RFRTKTtcbiAgICBlbmREVFMgPSBNYXRoLm1heChlbmREVFMsIGZyYWcuZW5kRFRTKTtcbiAgfVxuXG4gIGNvbnN0IGRyaWZ0ID0gc3RhcnRQVFMgLSBmcmFnLnN0YXJ0O1xuICBmcmFnLnN0YXJ0ID0gZnJhZy5zdGFydFBUUyA9IHN0YXJ0UFRTO1xuICBmcmFnLm1heFN0YXJ0UFRTID0gbWF4U3RhcnRQVFM7XG4gIGZyYWcuZW5kUFRTID0gZW5kUFRTO1xuICBmcmFnLnN0YXJ0RFRTID0gc3RhcnREVFM7XG4gIGZyYWcuZW5kRFRTID0gZW5kRFRTO1xuICBmcmFnLmR1cmF0aW9uID0gZW5kUFRTIC0gc3RhcnRQVFM7XG5cbiAgY29uc3Qgc24gPSBmcmFnLnNuO1xuICAvLyBleGl0IGlmIHNuIG91dCBvZiByYW5nZVxuICBpZiAoIWRldGFpbHMgfHwgc24gPCBkZXRhaWxzLnN0YXJ0U04gfHwgc24gPiBkZXRhaWxzLmVuZFNOKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBsZXQgZnJhZ0lkeCwgZnJhZ21lbnRzLCBpO1xuICBmcmFnSWR4ID0gc24gLSBkZXRhaWxzLnN0YXJ0U047XG4gIGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAvLyB1cGRhdGUgZnJhZyByZWZlcmVuY2UgaW4gZnJhZ21lbnRzIGFycmF5XG4gIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGZyYWdtZW50cyBhcnJheSBtaWdodCBub3QgY29udGFpbiB0aGlzIGZyYWcgb2JqZWN0LlxuICAvLyB0aGlzIHdpbGwgaGFwcGVuIGlmIHBsYXlsaXN0IGhhcyBiZWVuIHJlZnJlc2hlZCBiZXR3ZWVuIGZyYWcgbG9hZGluZyBhbmQgY2FsbCB0byB1cGRhdGVGcmFnUFRTRFRTKClcbiAgLy8gaWYgd2UgZG9uJ3QgdXBkYXRlIGZyYWcsIHdlIHdvbid0IGJlIGFibGUgdG8gcHJvcGFnYXRlIFBUUyBpbmZvIG9uIHRoZSBwbGF5bGlzdFxuICAvLyByZXN1bHRpbmcgaW4gaW52YWxpZCBzbGlkaW5nIGNvbXB1dGF0aW9uXG4gIGZyYWdtZW50c1tmcmFnSWR4XSA9IGZyYWc7XG4gIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0tMSB0byBmcmFnIDBcbiAgZm9yIChpID0gZnJhZ0lkeDsgaSA+IDA7IGktLSkge1xuICAgIHVwZGF0ZVBUUyhmcmFnbWVudHMsIGksIGkgLSAxKTtcbiAgfVxuXG4gIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0gdG8gbGFzdCBmcmFnXG4gIGZvciAoaSA9IGZyYWdJZHg7IGkgPCBmcmFnbWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdXBkYXRlUFRTKGZyYWdtZW50cywgaSwgaSArIDEpO1xuICB9XG5cbiAgZGV0YWlscy5QVFNLbm93biA9IHRydWU7XG4gIHJldHVybiBkcmlmdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGV0YWlscyAob2xkRGV0YWlscywgbmV3RGV0YWlscykge1xuICAvLyBwb3RlbnRpYWxseSByZXRyaWV2ZSBjYWNoZWQgaW5pdHNlZ21lbnRcbiAgaWYgKG5ld0RldGFpbHMuaW5pdFNlZ21lbnQgJiYgb2xkRGV0YWlscy5pbml0U2VnbWVudCkge1xuICAgIG5ld0RldGFpbHMuaW5pdFNlZ21lbnQgPSBvbGREZXRhaWxzLmluaXRTZWdtZW50O1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgb2xkL25ldyBwbGF5bGlzdHMgaGF2ZSBmcmFnbWVudHMgaW4gY29tbW9uXG4gIC8vIGxvb3AgdGhyb3VnaCBvdmVybGFwcGluZyBTTiBhbmQgdXBkYXRlIHN0YXJ0UFRTICwgY2MsIGFuZCBkdXJhdGlvbiBpZiBhbnkgZm91bmRcbiAgbGV0IGNjT2Zmc2V0ID0gMDtcbiAgbGV0IFBUU0ZyYWc7XG4gIG1hcEZyYWdtZW50SW50ZXJzZWN0aW9uKG9sZERldGFpbHMsIG5ld0RldGFpbHMsIChvbGRGcmFnLCBuZXdGcmFnKSA9PiB7XG4gICAgY2NPZmZzZXQgPSBvbGRGcmFnLmNjIC0gbmV3RnJhZy5jYztcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKG9sZEZyYWcuc3RhcnRQVFMpKSB7XG4gICAgICBuZXdGcmFnLnN0YXJ0ID0gbmV3RnJhZy5zdGFydFBUUyA9IG9sZEZyYWcuc3RhcnRQVFM7XG4gICAgICBuZXdGcmFnLmVuZFBUUyA9IG9sZEZyYWcuZW5kUFRTO1xuICAgICAgbmV3RnJhZy5kdXJhdGlvbiA9IG9sZEZyYWcuZHVyYXRpb247XG4gICAgICBuZXdGcmFnLmJhY2t0cmFja2VkID0gb2xkRnJhZy5iYWNrdHJhY2tlZDtcbiAgICAgIG5ld0ZyYWcuZHJvcHBlZCA9IG9sZEZyYWcuZHJvcHBlZDtcbiAgICAgIFBUU0ZyYWcgPSBuZXdGcmFnO1xuICAgIH1cbiAgICAvLyBQVFMgaXMga25vd24gd2hlbiB0aGVyZSBhcmUgb3ZlcmxhcHBpbmcgc2VnbWVudHNcbiAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gdHJ1ZTtcbiAgfSk7XG5cbiAgaWYgKCFuZXdEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNjT2Zmc2V0KSB7XG4gICAgbG9nZ2VyLmxvZygnZGlzY29udGludWl0eSBzbGlkaW5nIGZyb20gcGxheWxpc3QsIHRha2UgZHJpZnQgaW50byBhY2NvdW50Jyk7XG4gICAgY29uc3QgbmV3RnJhZ21lbnRzID0gbmV3RGV0YWlscy5mcmFnbWVudHM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdGcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld0ZyYWdtZW50c1tpXS5jYyArPSBjY09mZnNldDtcbiAgICB9XG4gIH1cblxuICAvLyBpZiBhdCBsZWFzdCBvbmUgZnJhZ21lbnQgY29udGFpbnMgUFRTIGluZm8sIHJlY29tcHV0ZSBQVFMgaW5mb3JtYXRpb24gZm9yIGFsbCBmcmFnbWVudHNcbiAgaWYgKFBUU0ZyYWcpIHtcbiAgICB1cGRhdGVGcmFnUFRTRFRTKG5ld0RldGFpbHMsIFBUU0ZyYWcsIFBUU0ZyYWcuc3RhcnRQVFMsIFBUU0ZyYWcuZW5kUFRTLCBQVFNGcmFnLnN0YXJ0RFRTLCBQVFNGcmFnLmVuZERUUyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW5zdXJlIHRoYXQgZGVsdGEgaXMgd2l0aGluIG9sZEZyYWdtZW50cyByYW5nZVxuICAgIC8vIGFsc28gYWRqdXN0IHNsaWRpbmcgaW4gY2FzZSBkZWx0YSBpcyAwICh3ZSBjb3VsZCBoYXZlIG9sZD1bNTAtNjBdIGFuZCBuZXc9b2xkPVs1MC02MV0pXG4gICAgLy8gaW4gdGhhdCBjYXNlIHdlIGFsc28gbmVlZCB0byBhZGp1c3Qgc3RhcnQgb2Zmc2V0IG9mIGFsbCBmcmFnbWVudHNcbiAgICBhZGp1c3RTbGlkaW5nKG9sZERldGFpbHMsIG5ld0RldGFpbHMpO1xuICB9XG4gIC8vIGlmIHdlIGFyZSBoZXJlLCBpdCBtZWFucyB3ZSBoYXZlIGZyYWdtZW50cyBvdmVybGFwcGluZyBiZXR3ZWVuXG4gIC8vIG9sZCBhbmQgbmV3IGxldmVsLiByZWxpYWJsZSBQVFMgaW5mbyBpcyB0aHVzIHJlbHlpbmcgb24gb2xkIGxldmVsXG4gIG5ld0RldGFpbHMuUFRTS25vd24gPSBvbGREZXRhaWxzLlBUU0tub3duO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTdWJ0aXRsZVBsYXlsaXN0cyAob2xkUGxheWxpc3QsIG5ld1BsYXlsaXN0LCByZWZlcmVuY2VTdGFydCA9IDApIHtcbiAgbGV0IGxhc3RJbmRleCA9IC0xO1xuICBtYXBGcmFnbWVudEludGVyc2VjdGlvbihvbGRQbGF5bGlzdCwgbmV3UGxheWxpc3QsIChvbGRGcmFnLCBuZXdGcmFnLCBpbmRleCkgPT4ge1xuICAgIG5ld0ZyYWcuc3RhcnQgPSBvbGRGcmFnLnN0YXJ0O1xuICAgIGxhc3RJbmRleCA9IGluZGV4O1xuICB9KTtcblxuICBjb25zdCBmcmFncyA9IG5ld1BsYXlsaXN0LmZyYWdtZW50cztcbiAgaWYgKGxhc3RJbmRleCA8IDApIHtcbiAgICBmcmFncy5mb3JFYWNoKGZyYWcgPT4ge1xuICAgICAgZnJhZy5zdGFydCArPSByZWZlcmVuY2VTdGFydDtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGxldCBpID0gbGFzdEluZGV4ICsgMTsgaSA8IGZyYWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgZnJhZ3NbaV0uc3RhcnQgPSAoZnJhZ3NbaSAtIDFdLnN0YXJ0ICsgZnJhZ3NbaSAtIDFdLmR1cmF0aW9uKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwRnJhZ21lbnRJbnRlcnNlY3Rpb24gKG9sZFBsYXlsaXN0LCBuZXdQbGF5bGlzdCwgaW50ZXJzZWN0aW9uRm4pIHtcbiAgaWYgKCFvbGRQbGF5bGlzdCB8fCAhbmV3UGxheWxpc3QpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KG9sZFBsYXlsaXN0LnN0YXJ0U04sIG5ld1BsYXlsaXN0LnN0YXJ0U04pIC0gbmV3UGxheWxpc3Quc3RhcnRTTjtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4ob2xkUGxheWxpc3QuZW5kU04sIG5ld1BsYXlsaXN0LmVuZFNOKSAtIG5ld1BsYXlsaXN0LnN0YXJ0U047XG4gIGNvbnN0IGRlbHRhID0gbmV3UGxheWxpc3Quc3RhcnRTTiAtIG9sZFBsYXlsaXN0LnN0YXJ0U047XG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgY29uc3Qgb2xkRnJhZyA9IG9sZFBsYXlsaXN0LmZyYWdtZW50c1tkZWx0YSArIGldO1xuICAgIGNvbnN0IG5ld0ZyYWcgPSBuZXdQbGF5bGlzdC5mcmFnbWVudHNbaV07XG4gICAgaWYgKCFvbGRGcmFnIHx8ICFuZXdGcmFnKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW50ZXJzZWN0aW9uRm4ob2xkRnJhZywgbmV3RnJhZywgaSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdFNsaWRpbmcgKG9sZFBsYXlsaXN0LCBuZXdQbGF5bGlzdCkge1xuICBjb25zdCBkZWx0YSA9IG5ld1BsYXlsaXN0LnN0YXJ0U04gLSBvbGRQbGF5bGlzdC5zdGFydFNOO1xuICBjb25zdCBvbGRGcmFnbWVudHMgPSBvbGRQbGF5bGlzdC5mcmFnbWVudHM7XG4gIGNvbnN0IG5ld0ZyYWdtZW50cyA9IG5ld1BsYXlsaXN0LmZyYWdtZW50cztcblxuICBpZiAoZGVsdGEgPCAwIHx8IGRlbHRhID4gb2xkRnJhZ21lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0ZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIG5ld0ZyYWdtZW50c1tpXS5zdGFydCArPSBvbGRGcmFnbWVudHNbZGVsdGFdLnN0YXJ0O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlUmVsb2FkSW50ZXJ2YWwgKGN1cnJlbnRQbGF5bGlzdCwgbmV3UGxheWxpc3QsIGxhc3RSZXF1ZXN0VGltZSkge1xuICBsZXQgcmVsb2FkSW50ZXJ2YWwgPSAxMDAwICogKG5ld1BsYXlsaXN0LmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA/IG5ld1BsYXlsaXN0LmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA6IG5ld1BsYXlsaXN0LnRhcmdldGR1cmF0aW9uKTtcbiAgY29uc3QgbWluUmVsb2FkSW50ZXJ2YWwgPSByZWxvYWRJbnRlcnZhbCAvIDI7XG4gIGlmIChjdXJyZW50UGxheWxpc3QgJiYgbmV3UGxheWxpc3QuZW5kU04gPT09IGN1cnJlbnRQbGF5bGlzdC5lbmRTTikge1xuICAgIC8vIGZvbGxvdyBITFMgU3BlYywgSWYgdGhlIGNsaWVudCByZWxvYWRzIGEgUGxheWxpc3QgZmlsZSBhbmQgZmluZHMgdGhhdCBpdCBoYXMgbm90XG4gICAgLy8gY2hhbmdlZCB0aGVuIGl0IE1VU1Qgd2FpdCBmb3IgYSBwZXJpb2Qgb2Ygb25lLWhhbGYgdGhlIHRhcmdldFxuICAgIC8vIGR1cmF0aW9uIGJlZm9yZSByZXRyeWluZy5cbiAgICByZWxvYWRJbnRlcnZhbCA9IG1pblJlbG9hZEludGVydmFsO1xuICB9XG5cbiAgaWYgKGxhc3RSZXF1ZXN0VGltZSkge1xuICAgIHJlbG9hZEludGVydmFsID0gTWF0aC5tYXgobWluUmVsb2FkSW50ZXJ2YWwsIHJlbG9hZEludGVydmFsIC0gKHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSAtIGxhc3RSZXF1ZXN0VGltZSkpO1xuICB9XG4gIC8vIGluIGFueSBjYXNlLCBkb24ndCByZWxvYWQgbW9yZSB0aGFuIGhhbGYgb2YgdGFyZ2V0IGR1cmF0aW9uXG4gIHJldHVybiBNYXRoLnJvdW5kKHJlbG9hZEludGVydmFsKTtcbn1cbiIsIi8qXG4gKiBTdHJlYW0gQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEJpbmFyeVNlYXJjaCBmcm9tICcuLi91dGlscy9iaW5hcnktc2VhcmNoJztcbmltcG9ydCB7IEJ1ZmZlckhlbHBlciB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IERlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvZGVtdXhlcic7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IEZyYWdtZW50U3RhdGUgfSBmcm9tICcuL2ZyYWdtZW50LXRyYWNrZXInO1xuaW1wb3J0IEZyYWdtZW50IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgUGxheWxpc3RMb2FkZXIgZnJvbSAnLi4vbG9hZGVyL3BsYXlsaXN0LWxvYWRlcic7XG5pbXBvcnQgKiBhcyBMZXZlbEhlbHBlciBmcm9tICcuL2xldmVsLWhlbHBlcic7XG5pbXBvcnQgVGltZVJhbmdlcyBmcm9tICcuLi91dGlscy90aW1lLXJhbmdlcyc7XG5pbXBvcnQgeyBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IGFsaWduU3RyZWFtIH0gZnJvbSAnLi4vdXRpbHMvZGlzY29udGludWl0aWVzJztcbmltcG9ydCB7IGZpbmRGcmFnbWVudEJ5UERULCBmaW5kRnJhZ21lbnRCeVBUUyB9IGZyb20gJy4vZnJhZ21lbnQtZmluZGVycyc7XG5pbXBvcnQgR2FwQ29udHJvbGxlciBmcm9tICcuL2dhcC1jb250cm9sbGVyJztcbmltcG9ydCBCYXNlU3RyZWFtQ29udHJvbGxlciwgeyBTdGF0ZSB9IGZyb20gJy4vYmFzZS1zdHJlYW0tY29udHJvbGxlcic7XG5cbmNvbnN0IFRJQ0tfSU5URVJWQUwgPSAxMDA7IC8vIGhvdyBvZnRlbiB0byB0aWNrIGluIG1zXG5cbmNsYXNzIFN0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlU3RyZWFtQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSEVELFxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX1BBUlNFRCxcbiAgICAgIEV2ZW50LkxFVkVMX0xPQURFRCxcbiAgICAgIEV2ZW50LktFWV9MT0FERUQsXG4gICAgICBFdmVudC5GUkFHX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfREFUQSxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0VELFxuICAgICAgRXZlbnQuRVJST1IsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19TV0lUQ0hJTkcsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9DUkVBVEVELFxuICAgICAgRXZlbnQuQlVGRkVSX0FQUEVOREVELFxuICAgICAgRXZlbnQuQlVGRkVSX0ZMVVNIRUQpO1xuXG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLl9zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5nYXBDb250cm9sbGVyID0gbnVsbDtcbiAgfVxuXG4gIHN0YXJ0TG9hZCAoc3RhcnRQb3NpdGlvbikge1xuICAgIGlmICh0aGlzLmxldmVscykge1xuICAgICAgbGV0IGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lLCBobHMgPSB0aGlzLmhscztcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgICAvLyBkZXRlcm1pbmUgbG9hZCBsZXZlbFxuICAgICAgICBsZXQgc3RhcnRMZXZlbCA9IGhscy5zdGFydExldmVsO1xuICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyAtMSA6IGd1ZXNzIHN0YXJ0IExldmVsIGJ5IGRvaW5nIGEgYml0cmF0ZSB0ZXN0IGJ5IGxvYWRpbmcgZmlyc3QgZnJhZ21lbnQgb2YgbG93ZXN0IHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICBzdGFydExldmVsID0gMDtcbiAgICAgICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgbmV3IGxldmVsIHRvIHBsYXlsaXN0IGxvYWRlciA6IHRoaXMgd2lsbCB0cmlnZ2VyIHN0YXJ0IGxldmVsIGxvYWRcbiAgICAgICAgLy8gaGxzLm5leHRMb2FkTGV2ZWwgcmVtYWlucyB1bnRpbCBpdCBpcyBzZXQgdG8gYSBuZXcgdmFsdWUgb3IgdW50aWwgYSBuZXcgZnJhZyBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkXG4gICAgICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IHN0YXJ0TGV2ZWw7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHN0YXJ0UG9zaXRpb24gdW5kZWZpbmVkIGJ1dCBsYXN0Q3VycmVudFRpbWUgc2V0LCBzZXQgc3RhcnRQb3NpdGlvbiB0byBsYXN0IGN1cnJlbnRUaW1lXG4gICAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICBsb2dnZXIubG9nKGBvdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke2xhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gbGFzdEN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb3JjZVN0YXJ0TG9hZCA9IHRydWU7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB9XG4gIH1cblxuICBzdG9wTG9hZCAoKSB7XG4gICAgdGhpcy5mb3JjZVN0YXJ0TG9hZCA9IGZhbHNlO1xuICAgIHN1cGVyLnN0b3BMb2FkKCk7XG4gIH1cblxuICBkb1RpY2sgKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgIGNhc2UgU3RhdGUuQlVGRkVSX0ZMVVNISU5HOlxuICAgICAgLy8gaW4gYnVmZmVyIGZsdXNoaW5nIHN0YXRlLCByZXNldCBmcmFnTG9hZEVycm9yIGNvdW50ZXJcbiAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFN0YXRlLklETEU6XG4gICAgICB0aGlzLl9kb1RpY2tJZGxlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFN0YXRlLldBSVRJTkdfTEVWRUw6XG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXTtcbiAgICAgIC8vIGNoZWNrIGlmIHBsYXlsaXN0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICBpZiAobGV2ZWwgJiYgbGV2ZWwuZGV0YWlscykge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgIHZhciBub3cgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB2YXIgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XG4gICAgICAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgaWYgKCFyZXRyeURhdGUgfHwgKG5vdyA+PSByZXRyeURhdGUpIHx8ICh0aGlzLm1lZGlhICYmIHRoaXMubWVkaWEuc2Vla2luZykpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnbWVkaWFDb250cm9sbGVyOiByZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZScpO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU3RhdGUuRVJST1I6XG4gICAgY2FzZSBTdGF0ZS5TVE9QUEVEOlxuICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxuICAgIGNhc2UgU3RhdGUuUEFSU0lORzpcbiAgICBjYXNlIFN0YXRlLlBBUlNFRDpcbiAgICBjYXNlIFN0YXRlLkVOREVEOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBjaGVjayBidWZmZXJcbiAgICB0aGlzLl9jaGVja0J1ZmZlcigpO1xuICAgIC8vIGNoZWNrL3VwZGF0ZSBjdXJyZW50IGZyYWdtZW50XG4gICAgdGhpcy5fY2hlY2tGcmFnbWVudENoYW5nZWQoKTtcbiAgfVxuXG4gIC8vIElyb25pY2FsbHkgdGhlIFwiaWRsZVwiIHN0YXRlIGlzIHRoZSBvbiB3ZSBkbyB0aGUgbW9zdCBsb2dpYyBpbiBpdCBzZWVtcyAuLi4uXG4gIC8vIE5PVEU6IE1heWJlIHdlIGNvdWxkIHJhdGhlciBzY2hlZHVsZSBhIGNoZWNrIGZvciBidWZmZXIgbGVuZ3RoIGFmdGVyIGhhbGYgb2YgdGhlIGN1cnJlbnRseVxuICAvLyAgICAgICBwbGF5ZWQgc2VnbWVudCwgb3Igb24gcGF1c2UvcGxheS9zZWVrIGluc3RlYWQgb2YgbmFpdmVseSBjaGVja2luZyBldmVyeSAxMDBtcz9cbiAgX2RvVGlja0lkbGUgKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzLFxuICAgICAgY29uZmlnID0gaGxzLmNvbmZpZyxcbiAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTtcblxuICAgIC8vIGlmIHN0YXJ0IGxldmVsIG5vdCBwYXJzZWQgeWV0IE9SXG4gICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORCBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIGRpc2FibGVcbiAgICAvLyBleGl0IGxvb3AsIGFzIHdlIGVpdGhlciBuZWVkIG1vcmUgaW5mbyAobGV2ZWwgbm90IHBhcnNlZCkgb3Igd2UgbmVlZCBtZWRpYSB0byBiZSBhdHRhY2hlZCB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgIGlmICh0aGlzLmxldmVsTGFzdExvYWRlZCA9PT0gdW5kZWZpbmVkIHx8IChcbiAgICAgICFtZWRpYSAmJiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxuICAgIGxldCBwb3M7XG4gICAgaWYgKHRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHBvcyA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSB0aGlzLm5leHRMb2FkUG9zaXRpb247XG4gICAgfVxuXG4gICAgLy8gZGV0ZXJtaW5lIG5leHQgbG9hZCBsZXZlbFxuICAgIGxldCBsZXZlbCA9IGhscy5uZXh0TG9hZExldmVsLFxuICAgICAgbGV2ZWxJbmZvID0gdGhpcy5sZXZlbHNbbGV2ZWxdO1xuXG4gICAgaWYgKCFsZXZlbEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbGV2ZWxCaXRyYXRlID0gbGV2ZWxJbmZvLmJpdHJhdGUsXG4gICAgICBtYXhCdWZMZW47XG5cbiAgICAvLyBjb21wdXRlIG1heCBCdWZmZXIgTGVuZ3RoIHRoYXQgd2UgY291bGQgZ2V0IGZyb20gdGhpcyBsb2FkIGxldmVsLCBiYXNlZCBvbiBsZXZlbCBiaXRyYXRlLiBkb24ndCBidWZmZXIgbW9yZSB0aGFuIDYwIE1CIGFuZCBtb3JlIHRoYW4gMzBzXG4gICAgaWYgKGxldmVsQml0cmF0ZSkge1xuICAgICAgbWF4QnVmTGVuID0gTWF0aC5tYXgoOCAqIGNvbmZpZy5tYXhCdWZmZXJTaXplIC8gbGV2ZWxCaXRyYXRlLCBjb25maWcubWF4QnVmZmVyTGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4QnVmTGVuID0gY29uZmlnLm1heEJ1ZmZlckxlbmd0aDtcbiAgICB9XG5cbiAgICBtYXhCdWZMZW4gPSBNYXRoLm1pbihtYXhCdWZMZW4sIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpO1xuXG4gICAgLy8gZGV0ZXJtaW5lIG5leHQgY2FuZGlkYXRlIGZyYWdtZW50IHRvIGJlIGxvYWRlZCwgYmFzZWQgb24gY3VycmVudCBwb3NpdGlvbiBhbmQgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgIC8vIGVuc3VyZSB1cCB0byBgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aGAgb2YgYnVmZmVyIHVwZnJvbnRcblxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IG1lZGlhLCBwb3MsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKSxcbiAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuO1xuICAgIC8vIFN0YXkgaWRsZSBpZiB3ZSBhcmUgc3RpbGwgd2l0aCBidWZmZXIgbWFyZ2luc1xuICAgIGlmIChidWZmZXJMZW4gPj0gbWF4QnVmTGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50IC4uLlxuICAgIGxvZ2dlci50cmFjZShgYnVmZmVyIGxlbmd0aCBvZiAke2J1ZmZlckxlbi50b0ZpeGVkKDMpfSBpcyBiZWxvdyBtYXggb2YgJHttYXhCdWZMZW4udG9GaXhlZCgzKX0uIGNoZWNraW5nIGZvciBtb3JlIHBheWxvYWQgLi4uYCk7XG5cbiAgICAvLyBzZXQgbmV4dCBsb2FkIGxldmVsIDogdGhpcyB3aWxsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkIGlmIG5lZWRlZFxuICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuXG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgLy8gaWYgbGV2ZWwgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciBsZXZlbCByZXRyaWV2YWxcbiAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBlbnN1cmUgdGhhdCBuZXcgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIHRvIGF2b2lkIGxvYWRpbmcvdHJ5IHRvIGxvYWRcbiAgICAvLyBhIHVzZWxlc3MgYW5kIG91dGRhdGVkIGZyYWdtZW50ICh0aGF0IG1pZ2h0IGV2ZW4gaW50cm9kdWNlIGxvYWQgZXJyb3IgaWYgaXQgaXMgYWxyZWFkeSBvdXQgb2YgdGhlIGxpdmUgcGxheWxpc3QpXG4gICAgaWYgKCFsZXZlbERldGFpbHMgfHwgKGxldmVsRGV0YWlscy5saXZlICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBsZXZlbCkpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0xFVkVMO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpKSB7XG4gICAgICBjb25zdCBkYXRhID0ge307XG4gICAgICBpZiAodGhpcy5hbHRBdWRpbykge1xuICAgICAgICBkYXRhLnR5cGUgPSAndmlkZW8nO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9FT1MsIGRhdGEpO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVOREVEO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBoYXZlIHRoZSBsZXZlbERldGFpbHMgZm9yIHRoZSBzZWxlY3RlZCB2YXJpYW50LCBsZXRzIGNvbnRpbnVlIGVucmljaGVuIG91ciBzdHJlYW0gKGxvYWQga2V5cy9mcmFnbWVudHMgb3IgdHJpZ2dlciBFT1MsIGV0Yy4uKVxuICAgIHRoaXMuX2ZldGNoUGF5bG9hZE9yRW9zKHBvcywgYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzKTtcbiAgfVxuXG4gIF9mZXRjaFBheWxvYWRPckVvcyAocG9zLCBidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpIHtcbiAgICBjb25zdCBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cyxcbiAgICAgIGxldmVsID0gdGhpcy5sZXZlbCxcbiAgICAgIGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHMsXG4gICAgICBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcblxuICAgIC8vIGVtcHR5IHBsYXlsaXN0XG4gICAgaWYgKGZyYWdMZW4gPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBmaW5kIGZyYWdtZW50IGluZGV4LCBjb250aWd1b3VzIHdpdGggZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgIGxldCBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydCxcbiAgICAgIGVuZCA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uc3RhcnQgKyBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdLmR1cmF0aW9uLFxuICAgICAgYnVmZmVyRW5kID0gYnVmZmVySW5mby5lbmQsXG4gICAgICBmcmFnO1xuXG4gICAgaWYgKGxldmVsRGV0YWlscy5pbml0U2VnbWVudCAmJiAhbGV2ZWxEZXRhaWxzLmluaXRTZWdtZW50LmRhdGEpIHtcbiAgICAgIGZyYWcgPSBsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluIGNhc2Ugb2YgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHJlcXVlc3RlZCBwb3NpdGlvbiBpcyBub3QgbG9jYXRlZCBiZWZvcmUgcGxheWxpc3Qgc3RhcnRcbiAgICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgICBsZXQgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUgPSB0aGlzLmNvbmZpZy5pbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTtcbiAgICAgICAgaWYgKGZyYWdMZW4gPCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBDYW4gbm90IHN0YXJ0IHBsYXliYWNrIG9mIGEgbGV2ZWwsIHJlYXNvbjogbm90IGVub3VnaCBmcmFnbWVudHMgJHtmcmFnTGVufSA8ICR7aW5pdGlhbExpdmVNYW5pZmVzdFNpemV9YCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhZyA9IHRoaXMuX2Vuc3VyZUZyYWdtZW50QXRMaXZlUG9pbnQobGV2ZWxEZXRhaWxzLCBidWZmZXJFbmQsIHN0YXJ0LCBlbmQsIGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBmcmFnTGVuKTtcbiAgICAgICAgLy8gaWYgaXQgZXhwbGljaXRlbHkgcmV0dXJucyBudWxsIGRvbid0IGxvYWQgYW55IGZyYWdtZW50IGFuZCBleGl0IGZ1bmN0aW9uIG5vd1xuICAgICAgICBpZiAoZnJhZyA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVm9EIHBsYXlsaXN0OiBpZiBidWZmZXJFbmQgYmVmb3JlIHN0YXJ0IG9mIHBsYXlsaXN0LCBsb2FkIGZpcnN0IGZyYWdtZW50XG4gICAgICAgIGlmIChidWZmZXJFbmQgPCBzdGFydCkge1xuICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICBmcmFnID0gdGhpcy5fZmluZEZyYWdtZW50KHN0YXJ0LCBmcmFnUHJldmlvdXMsIGZyYWdMZW4sIGZyYWdtZW50cywgYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlscyk7XG4gICAgfVxuXG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIGlmIChmcmFnLmVuY3J5cHRlZCkge1xuICAgICAgICBsb2dnZXIubG9nKGBMb2FkaW5nIGtleSBmb3IgJHtmcmFnLnNufSBvZiBbJHtsZXZlbERldGFpbHMuc3RhcnRTTn0gLCR7bGV2ZWxEZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtsZXZlbH1gKTtcbiAgICAgICAgdGhpcy5fbG9hZEtleShmcmFnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcgJHtmcmFnLnNufSBvZiBbJHtsZXZlbERldGFpbHMuc3RhcnRTTn0gLCR7bGV2ZWxEZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtsZXZlbH0sIGN1cnJlbnRUaW1lOiR7cG9zLnRvRml4ZWQoMyl9LGJ1ZmZlckVuZDoke2J1ZmZlckVuZC50b0ZpeGVkKDMpfWApO1xuICAgICAgICB0aGlzLl9sb2FkRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2Vuc3VyZUZyYWdtZW50QXRMaXZlUG9pbnQgKGxldmVsRGV0YWlscywgYnVmZmVyRW5kLCBzdGFydCwgZW5kLCBmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgZnJhZ0xlbikge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZywgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgbGV0IGZyYWc7XG5cbiAgICAvLyBjaGVjayBpZiByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgd2l0aGluIHNlZWthYmxlIGJvdW5kYXJpZXMgOlxuICAgIC8vIGxvZ2dlci5sb2coYHN0YXJ0L3Bvcy9idWZFbmQvc2Vla2luZzoke3N0YXJ0LnRvRml4ZWQoMyl9LyR7cG9zLnRvRml4ZWQoMyl9LyR7YnVmZmVyRW5kLnRvRml4ZWQoMyl9LyR7dGhpcy5tZWRpYS5zZWVraW5nfWApO1xuICAgIGxldCBtYXhMYXRlbmN5ID0gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDogY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcblxuICAgIGlmIChidWZmZXJFbmQgPCBNYXRoLm1heChzdGFydCAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBlbmQgLSBtYXhMYXRlbmN5KSkge1xuICAgICAgbGV0IGxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc3RhcnQsIGxldmVsRGV0YWlscyk7XG4gICAgICBsb2dnZXIubG9nKGBidWZmZXIgZW5kOiAke2J1ZmZlckVuZC50b0ZpeGVkKDMpfSBpcyBsb2NhdGVkIHRvbyBmYXIgZnJvbSB0aGUgZW5kIG9mIGxpdmUgc2xpZGluZyBwbGF5bGlzdCwgcmVzZXQgY3VycmVudFRpbWUgdG8gOiAke2xpdmVTeW5jUG9zaXRpb24udG9GaXhlZCgzKX1gKTtcbiAgICAgIGJ1ZmZlckVuZCA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICBpZiAobWVkaWEgJiYgbWVkaWEucmVhZHlTdGF0ZSAmJiBtZWRpYS5kdXJhdGlvbiA+IGxpdmVTeW5jUG9zaXRpb24pIHtcbiAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgIH1cblxuICAgIC8vIGlmIGVuZCBvZiBidWZmZXIgZ3JlYXRlciB0aGFuIGxpdmUgZWRnZSwgZG9uJ3QgbG9hZCBhbnkgZnJhZ21lbnRcbiAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiBpZiBsaXZlIHBsYXlsaXN0IGludGVybWl0dGVudGx5IHNsaWRlcyBpbiB0aGUgcGFzdC5cbiAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTYxLDE4MjU4MDE2N11cbiAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTYyLDE4MjU4MDE2OV1cbiAgICAvLyBMb2FkaW5nIDE4MjU4MDE2OCBvZiBbMTgyNTgwMTYyICwxODI1ODAxNjldLGxldmVsIDEgLi5cbiAgICAvLyBMb2FkaW5nIDE4MjU4MDE2OSBvZiBbMTgyNTgwMTYyICwxODI1ODAxNjldLGxldmVsIDEgLi5cbiAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTYyLDE4MjU4MDE2OF0gPD09PT09PT09PT09PT0gaGVyZSB3ZSBzaG91bGQgaGF2ZSBidWZmZXJFbmQgPiBlbmQuIGluIHRoYXQgY2FzZSBicmVhayB0byBhdm9pZCByZWxvYWRpbmcgMTgyNTgwMTY4XG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2NCwxODI1ODAxNzFdXG4gICAgLy9cbiAgICAvLyBkb24ndCByZXR1cm4gbnVsbCBpbiBjYXNlIG1lZGlhIG5vdCBsb2FkZWQgeWV0IChyZWFkeXN0YXRlID09PSAwKVxuICAgIGlmIChsZXZlbERldGFpbHMuUFRTS25vd24gJiYgYnVmZmVyRW5kID4gZW5kICYmIG1lZGlhICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiAhbGV2ZWxEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAvKiB3ZSBhcmUgc3dpdGNoaW5nIGxldmVsIG9uIGxpdmUgcGxheWxpc3QsIGJ1dCB3ZSBkb24ndCBoYXZlIGFueSBQVFMgaW5mbyBmb3IgdGhhdCBxdWFsaXR5IGxldmVsIC4uLlxuICAgICAgICAgdHJ5IHRvIGxvYWQgZnJhZyBtYXRjaGluZyB3aXRoIG5leHQgU04uXG4gICAgICAgICBldmVuIGlmIFNOIGFyZSBub3Qgc3luY2hyb25pemVkIGJldHdlZW4gcGxheWxpc3RzLCBsb2FkaW5nIHRoaXMgZnJhZyB3aWxsIGhlbHAgdXNcbiAgICAgICAgIGNvbXB1dGUgcGxheWxpc3Qgc2xpZGluZyBhbmQgZmluZCB0aGUgcmlnaHQgb25lIGFmdGVyIGluIGNhc2UgaXQgd2FzIG5vdCB0aGUgcmlnaHQgY29uc2VjdXRpdmUgb25lICovXG4gICAgICBpZiAoZnJhZ1ByZXZpb3VzKSB7XG4gICAgICAgIGlmIChsZXZlbERldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgICAgLy8gUmVsaWVzIG9uIFBEVCBpbiBvcmRlciB0byBzd2l0Y2ggYml0cmF0ZXMgKFN1cHBvcnQgRVhULVgtRElTQ09OVElOVUlUWSB3aXRob3V0IEVYVC1YLURJU0NPTlRJTlVJVFktU0VRVUVOQ0UpXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIFBEVDogJHtmcmFnUHJldmlvdXMucHJvZ3JhbURhdGVUaW1lfWApO1xuICAgICAgICAgIGZyYWcgPSBmaW5kRnJhZ21lbnRCeVBEVChmcmFnbWVudHMsIGZyYWdQcmV2aW91cy5lbmRQcm9ncmFtRGF0ZVRpbWUsIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBVc2VzIGJ1ZmZlciBhbmQgc2VxdWVuY2UgbnVtYmVyIHRvIGNhbGN1bGF0ZSBzd2l0Y2ggc2VnbWVudCAocmVxdWlyZWQgaWYgdXNpbmcgRVhULVgtRElTQ09OVElOVUlUWS1TRVFVRU5DRSlcbiAgICAgICAgICBjb25zdCB0YXJnZXRTTiA9IGZyYWdQcmV2aW91cy5zbiArIDE7XG4gICAgICAgICAgaWYgKHRhcmdldFNOID49IGxldmVsRGV0YWlscy5zdGFydFNOICYmIHRhcmdldFNOIDw9IGxldmVsRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgICAgY29uc3QgZnJhZ05leHQgPSBmcmFnbWVudHNbdGFyZ2V0U04gLSBsZXZlbERldGFpbHMuc3RhcnRTTl07XG4gICAgICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzLmNjID09PSBmcmFnTmV4dC5jYykge1xuICAgICAgICAgICAgICBmcmFnID0gZnJhZ05leHQ7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYGxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggbmV4dCBTTjogJHtmcmFnLnNufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBuZXh0IGZyYWcgU04gbm90IGF2YWlsYWJsZSAob3Igbm90IHdpdGggc2FtZSBjb250aW51aXR5IGNvdW50ZXIpXG4gICAgICAgICAgLy8gbG9vayBmb3IgYSBmcmFnIHNoYXJpbmcgdGhlIHNhbWUgQ0NcbiAgICAgICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgICAgIGZyYWcgPSBCaW5hcnlTZWFyY2guc2VhcmNoKGZyYWdtZW50cywgZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZyYWdQcmV2aW91cy5jYyAtIGZyYWcuY2M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYGxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggc2FtZSBDQzogJHtmcmFnLnNufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIC8qIHdlIGhhdmUgbm8gaWRlYSBhYm91dCB3aGljaCBmcmFnbWVudCBzaG91bGQgYmUgbG9hZGVkLlxuICAgICAgICAgICBzbyBsZXQncyBsb2FkIG1pZCBmcmFnbWVudC4gaXQgd2lsbCBoZWxwIGNvbXB1dGluZyBwbGF5bGlzdCBzbGlkaW5nIGFuZCBmaW5kIHRoZSByaWdodCBvbmVcbiAgICAgICAgKi9cbiAgICAgICAgZnJhZyA9IGZyYWdtZW50c1tNYXRoLm1pbihmcmFnTGVuIC0gMSwgTWF0aC5yb3VuZChmcmFnTGVuIC8gMikpXTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCB1bmtub3duLCBsb2FkIG1pZGRsZSBmcmFnIDogJHtmcmFnLnNufWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgX2ZpbmRGcmFnbWVudCAoc3RhcnQsIGZyYWdQcmV2aW91cywgZnJhZ0xlbiwgZnJhZ21lbnRzLCBidWZmZXJFbmQsIGVuZCwgbGV2ZWxEZXRhaWxzKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGxldCBmcmFnO1xuXG4gICAgaWYgKGJ1ZmZlckVuZCA8IGVuZCkge1xuICAgICAgY29uc3QgbG9va3VwVG9sZXJhbmNlID0gKGJ1ZmZlckVuZCA+IGVuZCAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKSA/IDAgOiBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgIC8vIFJlbW92ZSB0aGUgdG9sZXJhbmNlIGlmIGl0IHdvdWxkIHB1dCB0aGUgYnVmZmVyRW5kIHBhc3QgdGhlIGFjdHVhbCBlbmQgb2Ygc3RyZWFtXG4gICAgICAvLyBVc2VzIGJ1ZmZlciBhbmQgc2VxdWVuY2UgbnVtYmVyIHRvIGNhbGN1bGF0ZSBzd2l0Y2ggc2VnbWVudCAocmVxdWlyZWQgaWYgdXNpbmcgRVhULVgtRElTQ09OVElOVUlUWS1TRVFVRU5DRSlcbiAgICAgIGZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgYnVmZmVyRW5kLCBsb29rdXBUb2xlcmFuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWFjaCBlbmQgb2YgcGxheWxpc3RcbiAgICAgIGZyYWcgPSBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdO1xuICAgIH1cbiAgICBpZiAoZnJhZykge1xuICAgICAgY29uc3QgY3VyU05JZHggPSBmcmFnLnNuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICBjb25zdCBzYW1lTGV2ZWwgPSBmcmFnUHJldmlvdXMgJiYgZnJhZy5sZXZlbCA9PT0gZnJhZ1ByZXZpb3VzLmxldmVsO1xuICAgICAgY29uc3QgcHJldkZyYWcgPSBmcmFnbWVudHNbY3VyU05JZHggLSAxXTtcbiAgICAgIGNvbnN0IG5leHRGcmFnID0gZnJhZ21lbnRzW2N1clNOSWR4ICsgMV07XG4gICAgICAvLyBsb2dnZXIubG9nKCdmaW5kIFNOIG1hdGNoaW5nIHdpdGggcG9zOicgKyAgYnVmZmVyRW5kICsgJzonICsgZnJhZy5zbik7XG4gICAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIGZyYWcuc24gPT09IGZyYWdQcmV2aW91cy5zbikge1xuICAgICAgICBpZiAoc2FtZUxldmVsICYmICFmcmFnLmJhY2t0cmFja2VkKSB7XG4gICAgICAgICAgaWYgKGZyYWcuc24gPCBsZXZlbERldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICAgIGxldCBkZWx0YVBUUyA9IGZyYWdQcmV2aW91cy5kZWx0YVBUUztcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc2lnbmlmaWNhbnQgZGVsdGEgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW8sIGxhcmdlciB0aGFuIG1heCBhbGxvd2VkIGhvbGUsXG4gICAgICAgICAgICAvLyBhbmQgaWYgcHJldmlvdXMgcmVtdXhlZCBmcmFnbWVudCBkaWQgbm90IHN0YXJ0IHdpdGggYSBrZXlmcmFtZS4gKGZyYWdQcmV2aW91cy5kcm9wcGVkKVxuICAgICAgICAgICAgLy8gbGV0J3MgdHJ5IHRvIGxvYWQgcHJldmlvdXMgZnJhZ21lbnQgYWdhaW4gdG8gZ2V0IGxhc3Qga2V5ZnJhbWVcbiAgICAgICAgICAgIC8vIHRoZW4gd2Ugd2lsbCByZWxvYWQgYWdhaW4gY3VycmVudCBmcmFnbWVudCAodGhhdCB3YXkgd2Ugc2hvdWxkIGJlIGFibGUgdG8gZmlsbCB0aGUgYnVmZmVyIGhvbGUgLi4uKVxuICAgICAgICAgICAgaWYgKGRlbHRhUFRTICYmIGRlbHRhUFRTID4gY29uZmlnLm1heEJ1ZmZlckhvbGUgJiYgZnJhZ1ByZXZpb3VzLmRyb3BwZWQgJiYgY3VyU05JZHgpIHtcbiAgICAgICAgICAgICAgZnJhZyA9IHByZXZGcmFnO1xuICAgICAgICAgICAgICBsb2dnZXIud2FybignU04ganVzdCBsb2FkZWQsIHdpdGggbGFyZ2UgUFRTIGdhcCBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbywgbWF5YmUgZnJhZyBpcyBub3Qgc3RhcnRpbmcgd2l0aCBhIGtleWZyYW1lID8gbG9hZCBwcmV2aW91cyBvbmUgdG8gdHJ5IHRvIG92ZXJjb21lIHRoaXMnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZyYWcgPSBuZXh0RnJhZztcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgU04ganVzdCBsb2FkZWQsIGxvYWQgbmV4dCBvbmU6ICR7ZnJhZy5zbn1gLCBmcmFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJhZyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZyYWcuYmFja3RyYWNrZWQpIHtcbiAgICAgICAgICAvLyBPbmx5IGJhY2t0cmFjayBhIG1heCBvZiAxIGNvbnNlY3V0aXZlIGZyYWdtZW50IHRvIHByZXZlbnQgc2xpZGluZyBiYWNrIHRvbyBmYXIgd2hlbiBsaXR0bGUgb3Igbm8gZnJhZ3Mgc3RhcnQgd2l0aCBrZXlmcmFtZXNcbiAgICAgICAgICBpZiAobmV4dEZyYWcgJiYgbmV4dEZyYWcuYmFja3RyYWNrZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBBbHJlYWR5IGJhY2t0cmFja2VkIGZyb20gZnJhZ21lbnQgJHtuZXh0RnJhZy5zbn0sIHdpbGwgbm90IGJhY2t0cmFjayB0byBmcmFnbWVudCAke2ZyYWcuc259LiBMb2FkaW5nIGZyYWdtZW50ICR7bmV4dEZyYWcuc259YCk7XG4gICAgICAgICAgICBmcmFnID0gbmV4dEZyYWc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGEgZnJhZ21lbnQgaGFzIGRyb3BwZWQgZnJhbWVzIGFuZCBpdCdzIGluIGEgc2FtZSBsZXZlbC9zZXF1ZW5jZSwgbG9hZCB0aGUgcHJldmlvdXMgZnJhZ21lbnQgdG8gdHJ5IGFuZCBmaW5kIHRoZSBrZXlmcmFtZVxuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGRyb3BwZWQgY291bnQgbm93IHNpbmNlIGl0IHdvbid0IGJlIHJlc2V0IHVudGlsIHdlIHBhcnNlIHRoZSBmcmFnbWVudCBhZ2Fpbiwgd2hpY2ggcHJldmVudHMgaW5maW5pdGUgYmFja3RyYWNraW5nIG9uIHRoZSBzYW1lIHNlZ21lbnRcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdMb2FkZWQgZnJhZ21lbnQgd2l0aCBkcm9wcGVkIGZyYW1lcywgYmFja3RyYWNraW5nIDEgc2VnbWVudCB0byBmaW5kIGEga2V5ZnJhbWUnKTtcbiAgICAgICAgICAgIGZyYWcuZHJvcHBlZCA9IDA7XG4gICAgICAgICAgICBpZiAocHJldkZyYWcpIHtcbiAgICAgICAgICAgICAgZnJhZyA9IHByZXZGcmFnO1xuICAgICAgICAgICAgICBmcmFnLmJhY2t0cmFja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyU05JZHgpIHtcbiAgICAgICAgICAgICAgLy8gY2FuJ3QgYmFja3RyYWNrIG9uIHZlcnkgZmlyc3QgZnJhZ21lbnRcbiAgICAgICAgICAgICAgZnJhZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgX2xvYWRLZXkgKGZyYWcpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuS0VZX0xPQURJTkc7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5LRVlfTE9BRElORywgeyBmcmFnIH0pO1xuICB9XG5cbiAgX2xvYWRGcmFnbWVudCAoZnJhZykge1xuICAgIC8vIENoZWNrIGlmIGZyYWdtZW50IGlzIG5vdCBsb2FkZWRcbiAgICBsZXQgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG5cbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgLy8gRG9uJ3QgdXBkYXRlIG5leHRMb2FkUG9zaXRpb24gZm9yIGZyYWdtZW50cyB3aGljaCBhcmUgbm90IGJ1ZmZlcmVkXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnLnNuKSAmJiAhZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgYmFja3RyYWNrZWQgZnJhZ21lbnRzIHRvIGxvYWRcbiAgICBpZiAoZnJhZy5iYWNrdHJhY2tlZCB8fCBmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCB8fCBmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuUEFSVElBTCkge1xuICAgICAgZnJhZy5hdXRvTGV2ZWwgPSB0aGlzLmhscy5hdXRvTGV2ZWxFbmFibGVkO1xuICAgICAgZnJhZy5iaXRyYXRlVGVzdCA9IHRoaXMuYml0cmF0ZVRlc3Q7XG5cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FESU5HLCB7IGZyYWcgfSk7XG4gICAgICAvLyBsYXp5IGRlbXV4ZXIgaW5pdCwgYXMgdGhpcyBjb3VsZCB0YWtlIHNvbWUgdGltZSAuLi4gZG8gaXQgZHVyaW5nIGZyYWcgbG9hZGluZ1xuICAgICAgaWYgKCF0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXIodGhpcy5obHMsICdtYWluJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgfSBlbHNlIGlmIChmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuQVBQRU5ESU5HKSB7XG4gICAgICAvLyBMb3dlciB0aGUgYnVmZmVyIHNpemUgYW5kIHRyeSBhZ2FpblxuICAgICAgaWYgKHRoaXMuX3JlZHVjZU1heEJ1ZmZlckxlbmd0aChmcmFnLmR1cmF0aW9uKSkge1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXQgc3RhdGUgKG5leHRTdGF0ZSkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBuZXh0U3RhdGUpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgdGhpcy5fc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICBsb2dnZXIubG9nKGBtYWluIHN0cmVhbToke3ByZXZpb3VzU3RhdGV9LT4ke25leHRTdGF0ZX1gKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuU1RSRUFNX1NUQVRFX1RSQU5TSVRJT04sIHsgcHJldmlvdXNTdGF0ZSwgbmV4dFN0YXRlIH0pO1xuICAgIH1cbiAgfVxuXG4gIGdldCBzdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG5cbiAgZ2V0QnVmZmVyZWRGcmFnIChwb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRCdWZmZXJlZEZyYWcocG9zaXRpb24sIFBsYXlsaXN0TG9hZGVyLkxldmVsVHlwZS5NQUlOKTtcbiAgfVxuXG4gIGdldCBjdXJyZW50TGV2ZWwgKCkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBjb25zdCBmcmFnID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgcmV0dXJuIGZyYWcubGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGdldCBuZXh0QnVmZmVyZWRGcmFnICgpIHtcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgLy8gZmlyc3QgZ2V0IGVuZCByYW5nZSBvZiBjdXJyZW50IGZyYWdtZW50XG4gICAgICByZXR1cm4gdGhpcy5mb2xsb3dpbmdCdWZmZXJlZEZyYWcodGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgZm9sbG93aW5nQnVmZmVyZWRGcmFnIChmcmFnKSB7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIC8vIHRyeSB0byBnZXQgcmFuZ2Ugb2YgbmV4dCBmcmFnbWVudCAoNTAwbXMgYWZ0ZXIgdGhpcyByYW5nZSlcbiAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhmcmFnLmVuZFBUUyArIDAuNSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0IG5leHRMZXZlbCAoKSB7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMubmV4dEJ1ZmZlcmVkRnJhZztcbiAgICBpZiAoZnJhZykge1xuICAgICAgcmV0dXJuIGZyYWcubGV2ZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICBfY2hlY2tGcmFnbWVudENoYW5nZWQgKCkge1xuICAgIGxldCBmcmFnUGxheWluZ0N1cnJlbnQsIGN1cnJlbnRUaW1lLCB2aWRlbyA9IHRoaXMubWVkaWE7XG4gICAgaWYgKHZpZGVvICYmIHZpZGVvLnJlYWR5U3RhdGUgJiYgdmlkZW8uc2Vla2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIGN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG4gICAgICAvKiBpZiB2aWRlbyBlbGVtZW50IGlzIGluIHNlZWtlZCBzdGF0ZSwgY3VycmVudFRpbWUgY2FuIG9ubHkgaW5jcmVhc2UuXG4gICAgICAgIChhc3N1bWluZyB0aGF0IHBsYXliYWNrIHJhdGUgaXMgcG9zaXRpdmUgLi4uKVxuICAgICAgICBBcyBzb21ldGltZXMgY3VycmVudFRpbWUganVtcHMgYmFjayB0byB6ZXJvIGFmdGVyIGFcbiAgICAgICAgbWVkaWEgZGVjb2RlIGVycm9yLCBjaGVjayB0aGlzLCB0byBhdm9pZCBzZWVraW5nIGJhY2sgdG9cbiAgICAgICAgd3JvbmcgcG9zaXRpb24gYWZ0ZXIgYSBtZWRpYSBkZWNvZGUgZXJyb3JcbiAgICAgICovXG4gICAgICBpZiAoY3VycmVudFRpbWUgPiB0aGlzLmxhc3RDdXJyZW50VGltZSkge1xuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW8sIGN1cnJlbnRUaW1lKSkge1xuICAgICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhjdXJyZW50VGltZSk7XG4gICAgICB9IGVsc2UgaWYgKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvLCBjdXJyZW50VGltZSArIDAuMSkpIHtcbiAgICAgICAgLyogZW5zdXJlIHRoYXQgRlJBR19DSEFOR0VEIGV2ZW50IGlzIHRyaWdnZXJlZCBhdCBzdGFydHVwLFxuICAgICAgICAgIHdoZW4gZmlyc3QgdmlkZW8gZnJhbWUgaXMgZGlzcGxheWVkIGFuZCBwbGF5YmFjayBpcyBwYXVzZWQuXG4gICAgICAgICAgYWRkIGEgdG9sZXJhbmNlIG9mIDEwMG1zLCBpbiBjYXNlIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLFxuICAgICAgICAgIGNoZWNrIGlmIGN1cnJlbnQgcG9zKzEwMG1zIGlzIGJ1ZmZlcmVkIGFuZCB1c2UgdGhhdCBidWZmZXIgcmFuZ2VcbiAgICAgICAgICBmb3IgRlJBR19DSEFOR0VEIGV2ZW50IHJlcG9ydGluZyAqL1xuICAgICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhjdXJyZW50VGltZSArIDAuMSk7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50KSB7XG4gICAgICAgIGxldCBmcmFnUGxheWluZyA9IGZyYWdQbGF5aW5nQ3VycmVudDtcbiAgICAgICAgaWYgKGZyYWdQbGF5aW5nICE9PSB0aGlzLmZyYWdQbGF5aW5nKSB7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0NIQU5HRUQsIHsgZnJhZzogZnJhZ1BsYXlpbmcgfSk7XG4gICAgICAgICAgY29uc3QgZnJhZ1BsYXlpbmdMZXZlbCA9IGZyYWdQbGF5aW5nLmxldmVsO1xuICAgICAgICAgIGlmICghdGhpcy5mcmFnUGxheWluZyB8fCB0aGlzLmZyYWdQbGF5aW5nLmxldmVsICE9PSBmcmFnUGxheWluZ0xldmVsKSB7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX1NXSVRDSEVELCB7IGxldmVsOiBmcmFnUGxheWluZ0xldmVsIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBmcmFnUGxheWluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAgb24gaW1tZWRpYXRlIGxldmVsIHN3aXRjaCA6XG4gICAgIC0gcGF1c2UgcGxheWJhY2sgaWYgcGxheWluZ1xuICAgICAtIGNhbmNlbCBhbnkgcGVuZGluZyBsb2FkIHJlcXVlc3RcbiAgICAgLSBhbmQgdHJpZ2dlciBhIGJ1ZmZlciBmbHVzaFxuICAqL1xuICBpbW1lZGlhdGVMZXZlbFN3aXRjaCAoKSB7XG4gICAgbG9nZ2VyLmxvZygnaW1tZWRpYXRlTGV2ZWxTd2l0Y2gnKTtcbiAgICBpZiAoIXRoaXMuaW1tZWRpYXRlU3dpdGNoKSB7XG4gICAgICB0aGlzLmltbWVkaWF0ZVN3aXRjaCA9IHRydWU7XG4gICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhLCBwcmV2aW91c2x5UGF1c2VkO1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHByZXZpb3VzbHlQYXVzZWQgPSBtZWRpYS5wYXVzZWQ7XG4gICAgICAgIG1lZGlhLnBhdXNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkb24ndCByZXN0YXJ0IHBsYXliYWNrIGFmdGVyIGluc3RhbnQgbGV2ZWwgc3dpdGNoIGluIGNhc2UgbWVkaWEgbm90IGF0dGFjaGVkXG4gICAgICAgIHByZXZpb3VzbHlQYXVzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmV2aW91c2x5UGF1c2VkID0gcHJldmlvdXNseVBhdXNlZDtcbiAgICB9XG4gICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAvLyBmbHVzaCBldmVyeXRoaW5nXG4gICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBvbiBpbW1lZGlhdGUgbGV2ZWwgc3dpdGNoIGVuZCwgYWZ0ZXIgbmV3IGZyYWdtZW50IGhhcyBiZWVuIGJ1ZmZlcmVkOlxuICAgKiAtIG51ZGdlIHZpZGVvIGRlY29kZXIgYnkgc2xpZ2h0bHkgYWRqdXN0aW5nIHZpZGVvIGN1cnJlbnRUaW1lIChpZiBjdXJyZW50VGltZSBidWZmZXJlZClcbiAgICogLSByZXN1bWUgdGhlIHBsYXliYWNrIGlmIG5lZWRlZFxuICAgKi9cbiAgaW1tZWRpYXRlTGV2ZWxTd2l0Y2hFbmQgKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEuYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLmltbWVkaWF0ZVN3aXRjaCA9IGZhbHNlO1xuICAgICAgaWYgKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLCBtZWRpYS5jdXJyZW50VGltZSkpIHtcbiAgICAgICAgLy8gb25seSBudWRnZSBpZiBjdXJyZW50VGltZSBpcyBidWZmZXJlZFxuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSAtPSAwLjAwMDE7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucHJldmlvdXNseVBhdXNlZCkge1xuICAgICAgICBtZWRpYS5wbGF5KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHRyeSB0byBzd2l0Y2ggQVNBUCB3aXRob3V0IGJyZWFraW5nIHZpZGVvIHBsYXliYWNrOlxuICAgKiBpbiBvcmRlciB0byBlbnN1cmUgc21vb3RoIGJ1dCBxdWljayBsZXZlbCBzd2l0Y2hpbmcsXG4gICAqIHdlIG5lZWQgdG8gZmluZCB0aGUgbmV4dCBmbHVzaGFibGUgYnVmZmVyIHJhbmdlXG4gICAqIHdlIHNob3VsZCB0YWtlIGludG8gYWNjb3VudCBuZXcgc2VnbWVudCBmZXRjaCB0aW1lXG4gICAqL1xuICBuZXh0TGV2ZWxTd2l0Y2ggKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAvLyBlbnN1cmUgdGhhdCBtZWRpYSBpcyBkZWZpbmVkIGFuZCB0aGF0IG1ldGFkYXRhIGFyZSBhdmFpbGFibGUgKHRvIHJldHJpZXZlIGN1cnJlbnRUaW1lKVxuICAgIGlmIChtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICBsZXQgZmV0Y2hkZWxheSwgZnJhZ1BsYXlpbmdDdXJyZW50LCBuZXh0QnVmZmVyZWRGcmFnO1xuICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgaWYgKGZyYWdQbGF5aW5nQ3VycmVudCAmJiBmcmFnUGxheWluZ0N1cnJlbnQuc3RhcnRQVFMgPiAxKSB7XG4gICAgICAgIC8vIGZsdXNoIGJ1ZmZlciBwcmVjZWRpbmcgY3VycmVudCBmcmFnbWVudCAoZmx1c2ggdW50aWwgY3VycmVudCBmcmFnbWVudCBzdGFydCBvZmZzZXQpXG4gICAgICAgIC8vIG1pbnVzIDFzIHRvIGF2b2lkIHZpZGVvIGZyZWV6aW5nLCB0aGF0IGNvdWxkIGhhcHBlbiBpZiB3ZSBmbHVzaCBrZXlmcmFtZSBvZiBjdXJyZW50IHZpZGVvIC4uLlxuICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBmcmFnUGxheWluZ0N1cnJlbnQuc3RhcnRQVFMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWVkaWEucGF1c2VkKSB7XG4gICAgICAgIC8vIGFkZCBhIHNhZmV0eSBkZWxheSBvZiAxc1xuICAgICAgICBsZXQgbmV4dExldmVsSWQgPSB0aGlzLmhscy5uZXh0TG9hZExldmVsLCBuZXh0TGV2ZWwgPSB0aGlzLmxldmVsc1tuZXh0TGV2ZWxJZF0sIGZyYWdMYXN0S2JwcyA9IHRoaXMuZnJhZ0xhc3RLYnBzO1xuICAgICAgICBpZiAoZnJhZ0xhc3RLYnBzICYmIHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gdGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiAqIG5leHRMZXZlbC5iaXRyYXRlIC8gKDEwMDAgKiBmcmFnTGFzdEticHMpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmV0Y2hkZWxheSA9IDA7XG4gICAgICB9XG4gICAgICAvLyBsb2dnZXIubG9nKCdmZXRjaGRlbGF5OicrZmV0Y2hkZWxheSk7XG4gICAgICAvLyBmaW5kIGJ1ZmZlciByYW5nZSB0aGF0IHdpbGwgYmUgcmVhY2hlZCBvbmNlIG5ldyBmcmFnbWVudCB3aWxsIGJlIGZldGNoZWRcbiAgICAgIG5leHRCdWZmZXJlZEZyYWcgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSArIGZldGNoZGVsYXkpO1xuICAgICAgaWYgKG5leHRCdWZmZXJlZEZyYWcpIHtcbiAgICAgICAgLy8gd2UgY2FuIGZsdXNoIGJ1ZmZlciByYW5nZSBmb2xsb3dpbmcgdGhpcyBvbmUgd2l0aG91dCBzdGFsbGluZyBwbGF5YmFja1xuICAgICAgICBuZXh0QnVmZmVyZWRGcmFnID0gdGhpcy5mb2xsb3dpbmdCdWZmZXJlZEZyYWcobmV4dEJ1ZmZlcmVkRnJhZyk7XG4gICAgICAgIGlmIChuZXh0QnVmZmVyZWRGcmFnKSB7XG4gICAgICAgICAgLy8gaWYgd2UgYXJlIGhlcmUsIHdlIGNhbiBhbHNvIGNhbmNlbCBhbnkgbG9hZGluZy9kZW11eGluZyBpbiBwcm9ncmVzcywgYXMgdGhleSBhcmUgdXNlbGVzc1xuICAgICAgICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgICAgaWYgKGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgLy8gc3RhcnQgZmx1c2ggcG9zaXRpb24gaXMgdGhlIHN0YXJ0IFBUUyBvZiBuZXh0IGJ1ZmZlcmVkIGZyYWcuXG4gICAgICAgICAgLy8gd2UgdXNlIGZyYWcubmF4U3RhcnRQVFMgd2hpY2ggaXMgbWF4KGF1ZGlvIHN0YXJ0UFRTLCB2aWRlbyBzdGFydFBUUykuXG4gICAgICAgICAgLy8gaW4gY2FzZSB0aGVyZSBpcyBhIHNtYWxsIFBUUyBEZWx0YSBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbywgdXNpbmcgbWF4U3RhcnRQVFMgYXZvaWRzIGZsdXNoaW5nIGxhc3Qgc2FtcGxlcyBmcm9tIGN1cnJlbnQgZnJhZ21lbnRcbiAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcihuZXh0QnVmZmVyZWRGcmFnLm1heFN0YXJ0UFRTLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZmx1c2hNYWluQnVmZmVyIChzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJVRkZFUl9GTFVTSElORztcbiAgICBsZXQgZmx1c2hTY29wZSA9IHsgc3RhcnRPZmZzZXQ6IHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQ6IGVuZE9mZnNldCB9O1xuICAgIC8vIGlmIGFsdGVybmF0ZSBhdWRpbyB0cmFja3MgYXJlIHVzZWQsIG9ubHkgZmx1c2ggdmlkZW8sIG90aGVyd2lzZSBmbHVzaCBldmVyeXRoaW5nXG4gICAgaWYgKHRoaXMuYWx0QXVkaW8pIHtcbiAgICAgIGZsdXNoU2NvcGUudHlwZSA9ICd2aWRlbyc7XG4gICAgfVxuXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hJTkcsIGZsdXNoU2NvcGUpO1xuICB9XG5cbiAgb25NZWRpYUF0dGFjaGVkIChkYXRhKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub25NZWRpYVNlZWtpbmcuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9udnNlZWtlZCA9IHRoaXMub25NZWRpYVNlZWtlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub252ZW5kZWQgPSB0aGlzLm9uTWVkaWFFbmRlZC5iaW5kKHRoaXMpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtlZCcsIHRoaXMub252c2Vla2VkKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAodGhpcy5sZXZlbHMgJiYgY29uZmlnLmF1dG9TdGFydExvYWQpIHtcbiAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuXG4gICAgdGhpcy5nYXBDb250cm9sbGVyID0gbmV3IEdhcENvbnRyb2xsZXIoY29uZmlnLCBtZWRpYSwgdGhpcy5mcmFnbWVudFRyYWNrZXIsIHRoaXMuaGxzKTtcbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcgKCkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhICYmIG1lZGlhLmVuZGVkKSB7XG4gICAgICBsb2dnZXIubG9nKCdNU0UgZGV0YWNoaW5nIGFuZCB2aWRlbyBlbmRlZCwgcmVzZXQgc3RhcnRQb3NpdGlvbicpO1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH1cblxuICAgIC8vIHJlc2V0IGZyYWdtZW50IGJhY2t0cmFja2VkIGZsYWdcbiAgICBsZXQgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgaWYgKGxldmVscykge1xuICAgICAgbGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgICBpZiAobGV2ZWwuZGV0YWlscykge1xuICAgICAgICAgIGxldmVsLmRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnJhZ21lbnQgPT4ge1xuICAgICAgICAgICAgZnJhZ21lbnQuYmFja3RyYWNrZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyByZW1vdmUgdmlkZW8gbGlzdGVuZXJzXG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtlZCcsIHRoaXMub252c2Vla2VkKTtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9udnNlZWtlZCA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgfVxuXG4gIG9uTWVkaWFTZWVrZWQgKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYSwgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogdW5kZWZpbmVkO1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoY3VycmVudFRpbWUpKSB7XG4gICAgICBsb2dnZXIubG9nKGBtZWRpYSBzZWVrZWQgdG8gJHtjdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuICAgIH1cblxuICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgRlJBR01FTlRfUExBWUlORyB0cmlnZ2VyaW5nXG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbk1hbmlmZXN0TG9hZGluZyAoKSB7XG4gICAgLy8gcmVzZXQgYnVmZmVyIG9uIG1hbmlmZXN0IGxvYWRpbmdcbiAgICBsb2dnZXIubG9nKCd0cmlnZ2VyIEJVRkZFUl9SRVNFVCcpO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX1JFU0VUKTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB0aGlzLnN0YWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gIH1cblxuICBvbk1hbmlmZXN0UGFyc2VkIChkYXRhKSB7XG4gICAgbGV0IGFhYyA9IGZhbHNlLCBoZWFhYyA9IGZhbHNlLCBjb2RlYztcbiAgICBkYXRhLmxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgIC8vIGRldGVjdCBpZiB3ZSBoYXZlIGRpZmZlcmVudCBraW5kIG9mIGF1ZGlvIGNvZGVjcyB1c2VkIGFtb25nc3QgcGxheWxpc3RzXG4gICAgICBjb2RlYyA9IGxldmVsLmF1ZGlvQ29kZWM7XG4gICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSkge1xuICAgICAgICAgIGFhYyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XG4gICAgICAgICAgaGVhYWMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dpdGNoID0gKGFhYyAmJiBoZWFhYyk7XG4gICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgbG9nZ2VyLmxvZygnYm90aCBBQUMvSEUtQUFDIGF1ZGlvIGZvdW5kIGluIGxldmVsczsgZGVjbGFyaW5nIGxldmVsIGNvZGVjIGFzIEhFLUFBQycpO1xuICAgIH1cblxuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKGNvbmZpZy5hdXRvU3RhcnRMb2FkIHx8IHRoaXMuZm9yY2VTdGFydExvYWQpIHtcbiAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgb25MZXZlbExvYWRlZCAoZGF0YSkge1xuICAgIGNvbnN0IG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgY29uc3QgbmV3TGV2ZWxJZCA9IGRhdGEubGV2ZWw7XG4gICAgY29uc3QgbGFzdExldmVsID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbExhc3RMb2FkZWRdO1xuICAgIGNvbnN0IGN1ckxldmVsID0gdGhpcy5sZXZlbHNbbmV3TGV2ZWxJZF07XG4gICAgY29uc3QgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgbGV0IHNsaWRpbmcgPSAwO1xuXG4gICAgbG9nZ2VyLmxvZyhgbGV2ZWwgJHtuZXdMZXZlbElkfSBsb2FkZWQgWyR7bmV3RGV0YWlscy5zdGFydFNOfSwke25ld0RldGFpbHMuZW5kU059XSxkdXJhdGlvbjoke2R1cmF0aW9ufWApO1xuXG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgbGV0IGN1ckRldGFpbHMgPSBjdXJMZXZlbC5kZXRhaWxzO1xuICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyB3ZSBhbHJlYWR5IGhhdmUgZGV0YWlscyBmb3IgdGhhdCBsZXZlbCwgbWVyZ2UgdGhlbVxuICAgICAgICBMZXZlbEhlbHBlci5tZXJnZURldGFpbHMoY3VyRGV0YWlscywgbmV3RGV0YWlscyk7XG4gICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgICAgdGhpcy5saXZlU3luY1Bvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIGN1ckRldGFpbHMpO1xuICAgICAgICBpZiAobmV3RGV0YWlscy5QVFNLbm93biAmJiBOdW1iZXIuaXNGaW5pdGUoc2xpZGluZykpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0IHNsaWRpbmc6JHtzbGlkaW5nLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnbGl2ZSBwbGF5bGlzdCAtIG91dGRhdGVkIFBUUywgdW5rbm93biBzbGlkaW5nJyk7XG4gICAgICAgICAgYWxpZ25TdHJlYW0odGhpcy5mcmFnUHJldmlvdXMsIGxhc3RMZXZlbCwgbmV3RGV0YWlscyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QgLSBmaXJzdCBsb2FkLCB1bmtub3duIHNsaWRpbmcnKTtcbiAgICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgICAgICBhbGlnblN0cmVhbSh0aGlzLmZyYWdQcmV2aW91cywgbGFzdExldmVsLCBuZXdEZXRhaWxzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBvdmVycmlkZSBsZXZlbCBpbmZvXG4gICAgY3VyTGV2ZWwuZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBuZXdMZXZlbElkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfVVBEQVRFRCwgeyBkZXRhaWxzOiBuZXdEZXRhaWxzLCBsZXZlbDogbmV3TGV2ZWxJZCB9KTtcblxuICAgIGlmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9PT0gZmFsc2UpIHtcbiAgICAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uIGlmIHNldCB0byAtMS4gdXNlIGl0IHN0cmFpZ2h0IGF3YXkgaWYgdmFsdWUgaXMgZGVmaW5lZFxuICAgICAgaWYgKHRoaXMuc3RhcnRQb3NpdGlvbiA9PT0gLTEgfHwgdGhpcy5sYXN0Q3VycmVudFRpbWUgPT09IC0xKSB7XG4gICAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcbiAgICAgICAgbGV0IHN0YXJ0VGltZU9mZnNldCA9IG5ld0RldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgICBpZiAoc3RhcnRUaW1lT2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgbmVnYXRpdmUgc3RhcnQgdGltZSBvZmZzZXQgJHtzdGFydFRpbWVPZmZzZXR9LCBjb3VudCBmcm9tIGVuZCBvZiBsYXN0IGZyYWdtZW50YCk7XG4gICAgICAgICAgICBzdGFydFRpbWVPZmZzZXQgPSBzbGlkaW5nICsgZHVyYXRpb24gKyBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci5sb2coYHN0YXJ0IHRpbWUgb2Zmc2V0IGZvdW5kIGluIHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byAke3N0YXJ0VGltZU9mZnNldH1gKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCwgc2V0IHN0YXJ0IHBvc2l0aW9uIHRvIGJlIGZyYWdtZW50IE4tdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50ICh1c3VhbGx5IDMpXG4gICAgICAgICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIG5ld0RldGFpbHMpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgY29uZmlndXJlIHN0YXJ0UG9zaXRpb24gdG8gJHt0aGlzLnN0YXJ0UG9zaXRpb259YCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgICAvLyBvbmx5IHN3aXRjaCBiYXRjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgbGV2ZWwgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25LZXlMb2FkZWQgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5LRVlfTE9BRElORykge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdMb2FkZWQgKGRhdGEpIHtcbiAgICBjb25zdCB7IGZyYWdDdXJyZW50LCBobHMsIGxldmVscywgbWVkaWEgfSA9IHRoaXM7XG4gICAgY29uc3QgZnJhZ0xvYWRlZCA9IGRhdGEuZnJhZztcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HICYmXG4gICAgICAgIGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGZyYWdMb2FkZWQudHlwZSA9PT0gJ21haW4nICYmXG4gICAgICAgIGZyYWdMb2FkZWQubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgIGZyYWdMb2FkZWQuc24gPT09IGZyYWdDdXJyZW50LnNuKSB7XG4gICAgICBjb25zdCBzdGF0cyA9IGRhdGEuc3RhdHM7XG4gICAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSBsZXZlbHNbZnJhZ0N1cnJlbnQubGV2ZWxdO1xuICAgICAgY29uc3QgZGV0YWlscyA9IGN1cnJlbnRMZXZlbC5kZXRhaWxzO1xuICAgICAgLy8gcmVzZXQgZnJhZyBiaXRyYXRlIHRlc3QgaW4gYW55IGNhc2UgYWZ0ZXIgZnJhZyBsb2FkZWQgZXZlbnRcbiAgICAgIC8vIGlmIHRoaXMgZnJhZyB3YXMgbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3QgQU5EIGlmIGhscy5uZXh0TG9hZExldmVsIGlzIGdyZWF0ZXIgdGhhbiAwXG4gICAgICAvLyB0aGVuIHRoaXMgbWVhbnMgdGhhdCB3ZSBzaG91bGQgYmUgYWJsZSB0byBsb2FkIGEgZnJhZ21lbnQgYXQgYSBoaWdoZXIgcXVhbGl0eSBsZXZlbFxuICAgICAgdGhpcy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGF0cyA9IHN0YXRzO1xuXG4gICAgICBsb2dnZXIubG9nKGBMb2FkZWQgJHtmcmFnQ3VycmVudC5zbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtmcmFnQ3VycmVudC5sZXZlbH1gKTtcbiAgICAgIGlmIChmcmFnTG9hZGVkLmJpdHJhdGVUZXN0ICYmIGhscy5uZXh0TG9hZExldmVsKSB7XG4gICAgICAgIC8vIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgLi4uIHdlIGp1c3QgbG9hZGVkIGEgZnJhZ21lbnQgdG8gZGV0ZXJtaW5lIGFkZXF1YXRlIHN0YXJ0IGJpdHJhdGUgYW5kIGluaXRpYWxpemUgYXV0b3N3aXRjaCBhbGdvXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICBzdGF0cy50cGFyc2VkID0gc3RhdHMudGJ1ZmZlcmVkID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7IHN0YXRzOiBzdGF0cywgZnJhZzogZnJhZ0N1cnJlbnQsIGlkOiAnbWFpbicgfSk7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfSBlbHNlIGlmIChmcmFnTG9hZGVkLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICBzdGF0cy50cGFyc2VkID0gc3RhdHMudGJ1ZmZlcmVkID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBkZXRhaWxzLmluaXRTZWdtZW50LmRhdGEgPSBkYXRhLnBheWxvYWQ7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZSQUdfQlVGRkVSRUQsIHsgc3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnQ3VycmVudCwgaWQ6ICdtYWluJyB9KTtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIubG9nKGBQYXJzaW5nICR7ZnJhZ0N1cnJlbnQuc259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLGxldmVsICR7ZnJhZ0N1cnJlbnQubGV2ZWx9LCBjYyAke2ZyYWdDdXJyZW50LmNjfWApO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcHBlbmRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEJpdHJhdGUgdGVzdCBmcmFncyBhcmUgbm90IHVzdWFsbHkgYnVmZmVyZWQgc28gdGhlIGZyYWdtZW50IHRyYWNrZXIgaWdub3JlcyB0aGVtLiBJZiBIbHMuanMgZGVjaWRlcyB0byBidWZmZXJcbiAgICAgICAgLy8gaXQgKGFuZCB0aGVyZWZvcmUgZW5kcyB1cCBhdCB0aGlzIGxpbmUpLCB0aGVuIHRoZSBmcmFnbWVudCB0cmFja2VyIG5lZWRzIHRvIGJlIG1hbnVhbGx5IGluZm9ybWVkLlxuICAgICAgICBpZiAoZnJhZ0xvYWRlZC5iaXRyYXRlVGVzdCkge1xuICAgICAgICAgIGZyYWdMb2FkZWQuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5vbkZyYWdMb2FkZWQoe1xuICAgICAgICAgICAgZnJhZzogZnJhZ0xvYWRlZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpIGFuZCBpZiBtZWRpYSBpcyBub3Qgc2Vla2luZyAodGhpcyBpcyB0byBvdmVyY29tZSBwb3RlbnRpYWwgdGltZXN0YW1wIGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0cyBhbmQgZnJhZ21lbnRzKVxuICAgICAgICBjb25zdCBhY2N1cmF0ZVRpbWVPZmZzZXQgPSAhKG1lZGlhICYmIG1lZGlhLnNlZWtpbmcpICYmIChkZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmUpO1xuICAgICAgICBjb25zdCBpbml0U2VnbWVudERhdGEgPSBkZXRhaWxzLmluaXRTZWdtZW50ID8gZGV0YWlscy5pbml0U2VnbWVudC5kYXRhIDogW107XG4gICAgICAgIGNvbnN0IGF1ZGlvQ29kZWMgPSB0aGlzLl9nZXRBdWRpb0NvZGVjKGN1cnJlbnRMZXZlbCk7XG5cbiAgICAgICAgLy8gdHJhbnNtdXggdGhlIE1QRUctVFMgZGF0YSB0byBJU08tQk1GRiBzZWdtZW50c1xuICAgICAgICBjb25zdCBkZW11eGVyID0gdGhpcy5kZW11eGVyID0gdGhpcy5kZW11eGVyIHx8IG5ldyBEZW11eGVyKHRoaXMuaGxzLCAnbWFpbicpO1xuICAgICAgICBkZW11eGVyLnB1c2goXG4gICAgICAgICAgZGF0YS5wYXlsb2FkLFxuICAgICAgICAgIGluaXRTZWdtZW50RGF0YSxcbiAgICAgICAgICBhdWRpb0NvZGVjLFxuICAgICAgICAgIGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjLFxuICAgICAgICAgIGZyYWdDdXJyZW50LFxuICAgICAgICAgIGRldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgICAgICBhY2N1cmF0ZVRpbWVPZmZzZXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdJbml0U2VnbWVudCAoZGF0YSkge1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBjb25zdCBmcmFnTmV3ID0gZGF0YS5mcmFnO1xuXG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdtYWluJyAmJlxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICBsZXQgdHJhY2tzID0gZGF0YS50cmFja3MsIHRyYWNrTmFtZSwgdHJhY2s7XG5cbiAgICAgIC8vIGlmIGF1ZGlvIHRyYWNrIGlzIGV4cGVjdGVkIHRvIGNvbWUgZnJvbSBhdWRpbyBzdHJlYW0gY29udHJvbGxlciwgZGlzY2FyZCBhbnkgY29taW5nIGZyb20gbWFpblxuICAgICAgaWYgKHRyYWNrcy5hdWRpbyAmJiB0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICAgIGRlbGV0ZSB0cmFja3MuYXVkaW87XG4gICAgICB9XG5cbiAgICAgIC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG4gICAgICB0cmFjayA9IHRyYWNrcy5hdWRpbztcbiAgICAgIGlmICh0cmFjaykge1xuICAgICAgICBsZXQgYXVkaW9Db2RlYyA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdLmF1ZGlvQ29kZWMsXG4gICAgICAgICAgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChhdWRpb0NvZGVjICYmIHRoaXMuYXVkaW9Db2RlY1N3YXApIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdzd2FwcGluZyBwbGF5bGlzdCBhdWRpbyBjb2RlYycpO1xuICAgICAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGluIGNhc2UgQUFDIGFuZCBIRS1BQUMgYXVkaW8gY29kZWNzIGFyZSBzaWduYWxsZWQgaW4gbWFuaWZlc3RcbiAgICAgICAgLy8gZm9yY2UgSEUtQUFDICwgYXMgaXQgc2VlbXMgdGhhdCBtb3N0IGJyb3dzZXJzIHByZWZlcnMgdGhhdCB3YXksXG4gICAgICAgIC8vIGV4Y2VwdCBmb3IgbW9ubyBzdHJlYW1zIE9SIG9uIEZGXG4gICAgICAgIC8vIHRoZXNlIGNvbmRpdGlvbnMgbWlnaHQgbmVlZCB0byBiZSByZXZpZXdlZCAuLi5cbiAgICAgICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgICAgIC8vIGRvbid0IGZvcmNlIEhFLUFBQyBpZiBtb25vIHN0cmVhbVxuICAgICAgICAgIGlmICh0cmFjay5tZXRhZGF0YS5jaGFubmVsQ291bnQgIT09IDEgJiZcbiAgICAgICAgICAgIC8vIGRvbid0IGZvcmNlIEhFLUFBQyBpZiBmaXJlZm94XG4gICAgICAgICAgICB1YS5pbmRleE9mKCdmaXJlZm94JykgPT09IC0xKSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhFLUFBQyBpcyBicm9rZW4gb24gQW5kcm9pZCwgYWx3YXlzIHNpZ25hbCBhdWRpbyBjb2RlYyBhcyBBQUMgZXZlbiBpZiB2YXJpYW50IG1hbmlmZXN0IHN0YXRlcyBvdGhlcndpc2VcbiAgICAgICAgaWYgKHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEgJiYgdHJhY2suY29udGFpbmVyICE9PSAnYXVkaW8vbXBlZycpIHsgLy8gRXhjbHVkZSBtcGVnIGF1ZGlvXG4gICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgIGxvZ2dlci5sb2coYEFuZHJvaWQ6IGZvcmNlIGF1ZGlvIGNvZGVjIHRvICR7YXVkaW9Db2RlY31gKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjay5sZXZlbENvZGVjID0gYXVkaW9Db2RlYztcbiAgICAgICAgdHJhY2suaWQgPSBkYXRhLmlkO1xuICAgICAgfVxuICAgICAgdHJhY2sgPSB0cmFja3MudmlkZW87XG4gICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgdHJhY2subGV2ZWxDb2RlYyA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdLnZpZGVvQ29kZWM7XG4gICAgICAgIHRyYWNrLmlkID0gZGF0YS5pZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0NPREVDUywgdHJhY2tzKTtcbiAgICAgIC8vIGxvb3AgdGhyb3VnaCB0cmFja3MgdGhhdCBhcmUgZ29pbmcgdG8gYmUgcHJvdmlkZWQgdG8gYnVmZmVyQ29udHJvbGxlclxuICAgICAgZm9yICh0cmFja05hbWUgaW4gdHJhY2tzKSB7XG4gICAgICAgIHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICAgIGxvZ2dlci5sb2coYG1haW4gdHJhY2s6JHt0cmFja05hbWV9LGNvbnRhaW5lcjoke3RyYWNrLmNvbnRhaW5lcn0sY29kZWNzW2xldmVsL3BhcnNlZF09WyR7dHJhY2subGV2ZWxDb2RlY30vJHt0cmFjay5jb2RlY31dYCk7XG4gICAgICAgIGxldCBpbml0U2VnbWVudCA9IHRyYWNrLmluaXRTZWdtZW50O1xuICAgICAgICBpZiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAvLyBhcm0gcGVuZGluZyBCdWZmZXJpbmcgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIGEgc2VnbWVudFxuICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCB7IHR5cGU6IHRyYWNrTmFtZSwgZGF0YTogaW5pdFNlZ21lbnQsIHBhcmVudDogJ21haW4nLCBjb250ZW50OiAnaW5pdFNlZ21lbnQnIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nRGF0YSAoZGF0YSkge1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBjb25zdCBmcmFnTmV3ID0gZGF0YS5mcmFnO1xuICAgIGlmIChmcmFnQ3VycmVudCAmJlxuICAgICAgICBkYXRhLmlkID09PSAnbWFpbicgJiZcbiAgICAgICAgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgIShkYXRhLnR5cGUgPT09ICdhdWRpbycgJiYgdGhpcy5hbHRBdWRpbykgJiYgLy8gZmlsdGVyIG91dCBtYWluIGF1ZGlvIGlmIGF1ZGlvIHRyYWNrIGlzIGxvYWRlZCB0aHJvdWdoIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIGxldCBsZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdLFxuICAgICAgICBmcmFnID0gZnJhZ0N1cnJlbnQ7XG4gICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShkYXRhLmVuZFBUUykpIHtcbiAgICAgICAgZGF0YS5lbmRQVFMgPSBkYXRhLnN0YXJ0UFRTICsgZnJhZ0N1cnJlbnQuZHVyYXRpb247XG4gICAgICAgIGRhdGEuZW5kRFRTID0gZGF0YS5zdGFydERUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5oYXNBdWRpbyA9PT0gdHJ1ZSkge1xuICAgICAgICBmcmFnLmFkZEVsZW1lbnRhcnlTdHJlYW0oRnJhZ21lbnQuRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuaGFzVmlkZW8gPT09IHRydWUpIHtcbiAgICAgICAgZnJhZy5hZGRFbGVtZW50YXJ5U3RyZWFtKEZyYWdtZW50LkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTyk7XG4gICAgICB9XG5cbiAgICAgIGxvZ2dlci5sb2coYFBhcnNlZCAke2RhdGEudHlwZX0sUFRTOlske2RhdGEuc3RhcnRQVFMudG9GaXhlZCgzKX0sJHtkYXRhLmVuZFBUUy50b0ZpeGVkKDMpfV0sRFRTOlske2RhdGEuc3RhcnREVFMudG9GaXhlZCgzKX0vJHtkYXRhLmVuZERUUy50b0ZpeGVkKDMpfV0sbmI6JHtkYXRhLm5ifSxkcm9wcGVkOiR7ZGF0YS5kcm9wcGVkIHx8IDB9YCk7XG5cbiAgICAgIC8vIERldGVjdCBnYXBzIGluIGEgZnJhZ21lbnQgIGFuZCB0cnkgdG8gZml4IGl0IGJ5IGZpbmRpbmcgYSBrZXlmcmFtZSBpbiB0aGUgcHJldmlvdXMgZnJhZ21lbnQgKHNlZSBfZmluZEZyYWdtZW50cylcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgZnJhZy5kcm9wcGVkID0gZGF0YS5kcm9wcGVkO1xuICAgICAgICBpZiAoZnJhZy5kcm9wcGVkKSB7XG4gICAgICAgICAgaWYgKCFmcmFnLmJhY2t0cmFja2VkKSB7XG4gICAgICAgICAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgICAgICAgICAgaWYgKGxldmVsRGV0YWlscyAmJiBmcmFnLnNuID09PSBsZXZlbERldGFpbHMuc3RhcnRTTikge1xuICAgICAgICAgICAgICBsb2dnZXIud2FybignbWlzc2luZyB2aWRlbyBmcmFtZShzKSBvbiBmaXJzdCBmcmFnLCBhcHBlbmRpbmcgd2l0aCBnYXAnLCBmcmFnLnNuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdtaXNzaW5nIHZpZGVvIGZyYW1lKHMpLCBiYWNrdHJhY2tpbmcgZnJhZ21lbnQnLCBmcmFnLnNuKTtcbiAgICAgICAgICAgICAgLy8gUmV0dXJuIGJhY2sgdG8gdGhlIElETEUgc3RhdGUgd2l0aG91dCBhcHBlbmRpbmcgdG8gYnVmZmVyXG4gICAgICAgICAgICAgIC8vIENhdXNlcyBmaW5kRnJhZ21lbnRzIHRvIGJhY2t0cmFjayBhIHNlZ21lbnQgYW5kIGZpbmQgdGhlIGtleWZyYW1lXG4gICAgICAgICAgICAgIC8vIEF1ZGlvIGZyYWdtZW50cyBhcnJpdmluZyBiZWZvcmUgdmlkZW8gc2V0cyB0aGUgbmV4dExvYWRQb3NpdGlvbiwgY2F1c2luZyBfZmluZEZyYWdtZW50cyB0byBza2lwIHRoZSBiYWNrdHJhY2tlZCBmcmFnbWVudFxuICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgICAgICAgICAgZnJhZy5iYWNrdHJhY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGRhdGEuc3RhcnRQVFM7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdBbHJlYWR5IGJhY2t0cmFja2VkIG9uIHRoaXMgZnJhZ21lbnQsIGFwcGVuZGluZyB3aXRoIHRoZSBnYXAnLCBmcmFnLnNuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT25seSByZXNldCB0aGUgYmFja3RyYWNrZWQgZmxhZyBpZiB3ZSd2ZSBsb2FkZWQgdGhlIGZyYWcgd2l0aG91dCBhbnkgZHJvcHBlZCBmcmFtZXNcbiAgICAgICAgICBmcmFnLmJhY2t0cmFja2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IGRyaWZ0ID0gTGV2ZWxIZWxwZXIudXBkYXRlRnJhZ1BUU0RUUyhsZXZlbC5kZXRhaWxzLCBmcmFnLCBkYXRhLnN0YXJ0UFRTLCBkYXRhLmVuZFBUUywgZGF0YS5zdGFydERUUywgZGF0YS5lbmREVFMpLFxuICAgICAgICBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX1BUU19VUERBVEVELCB7IGRldGFpbHM6IGxldmVsLmRldGFpbHMsIGxldmVsOiB0aGlzLmxldmVsLCBkcmlmdDogZHJpZnQsIHR5cGU6IGRhdGEudHlwZSwgc3RhcnQ6IGRhdGEuc3RhcnRQVFMsIGVuZDogZGF0YS5lbmRQVFMgfSk7XG4gICAgICAvLyBoYXMgcmVtdXhlciBkcm9wcGVkIHZpZGVvIGZyYW1lcyBsb2NhdGVkIGJlZm9yZSBmaXJzdCBrZXlmcmFtZSA/XG4gICAgICBbZGF0YS5kYXRhMSwgZGF0YS5kYXRhMl0uZm9yRWFjaChidWZmZXIgPT4ge1xuICAgICAgICAvLyBvbmx5IGFwcGVuZCBpbiBQQVJTSU5HIHN0YXRlIChyYXRpb25hbGUgaXMgdGhhdCBhbiBhcHBlbmRpbmcgZXJyb3IgY291bGQgaGFwcGVuIHN5bmNocm9ub3VzbHkgb24gZmlyc3Qgc2VnbWVudCBhcHBlbmRpbmcpXG4gICAgICAgIC8vIGluIHRoYXQgY2FzZSBpdCBpcyB1c2VsZXNzIHRvIGFwcGVuZCBmb2xsb3dpbmcgc2VnbWVudHNcbiAgICAgICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAvLyBhcm0gcGVuZGluZyBCdWZmZXJpbmcgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIGEgc2VnbWVudFxuICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywgeyB0eXBlOiBkYXRhLnR5cGUsIGRhdGE6IGJ1ZmZlciwgcGFyZW50OiAnbWFpbicsIGNvbnRlbnQ6ICdkYXRhJyB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdQYXJzZWQgKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgY29uc3QgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ21haW4nICYmXG4gICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHRoaXMuc3RhdHMudHBhcnNlZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XG4gICAgICB0aGlzLl9jaGVja0FwcGVuZGVkUGFyc2VkKCk7XG4gICAgfVxuICB9XG5cbiAgb25BdWRpb1RyYWNrU3dpdGNoaW5nIChkYXRhKSB7XG4gICAgLy8gaWYgYW55IFVSTCBmb3VuZCBvbiBuZXcgYXVkaW8gdHJhY2ssIGl0IGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgIGxldCBhbHRBdWRpbyA9ICEhZGF0YS51cmwsXG4gICAgICB0cmFja0lkID0gZGF0YS5pZDtcbiAgICAvLyBpZiB3ZSBzd2l0Y2ggb24gbWFpbiBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIG1lZGlhLmJ1ZmZlcmVkXG4gICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaWYgd2Ugc3dpdGNoIHRvIGFsdCBhdWRpbzogYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIgaXMgaGFuZGxpbmcgaXQuXG4gICAgLy8gd2Ugd2lsbCBqdXN0IGhhdmUgdG8gY2hhbmdlIGJ1ZmZlciBzY2hlZHVsaW5nIG9uIGF1ZGlvVHJhY2tTd2l0Y2hlZFxuICAgIGlmICghYWx0QXVkaW8pIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhQnVmZmVyICE9PSB0aGlzLm1lZGlhKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyBvbiBtYWluIGF1ZGlvLCB1c2UgbWVkaWEuYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nJyk7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgICAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlZmlsbCBhdWRpbyBidWZmZXIgZnJvbSBtYWluOiBjYW5jZWwgYW55IGZyYWcgbG9hZGluZyB0byBzcGVlZCB1cCBhdWRpbyBzd2l0Y2hcbiAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyB0byBtYWluIGF1ZGlvIHRyYWNrLCBjYW5jZWwgbWFpbiBmcmFnbWVudCBsb2FkJyk7XG4gICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgLy8gZGVzdHJveSBkZW11eGVyIHRvIGZvcmNlIGluaXQgc2VnbWVudCBnZW5lcmF0aW9uIChmb2xsb3dpbmcgYXVkaW8gc3dpdGNoKVxuICAgICAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGxvYWQgbmV3IGZyYWdtZW50XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgbGV0IGhscyA9IHRoaXMuaGxzO1xuICAgICAgLy8gc3dpdGNoaW5nIHRvIG1haW4gYXVkaW8sIGZsdXNoIGFsbCBhdWRpbyBhbmQgdHJpZ2dlciB0cmFjayBzd2l0Y2hlZFxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNISU5HLCB7IHN0YXJ0T2Zmc2V0OiAwLCBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgdHlwZTogJ2F1ZGlvJyB9KTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELCB7IGlkOiB0cmFja0lkIH0pO1xuICAgICAgdGhpcy5hbHRBdWRpbyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIG9uQXVkaW9UcmFja1N3aXRjaGVkIChkYXRhKSB7XG4gICAgbGV0IHRyYWNrSWQgPSBkYXRhLmlkLFxuICAgICAgYWx0QXVkaW8gPSAhIXRoaXMuaGxzLmF1ZGlvVHJhY2tzW3RyYWNrSWRdLnVybDtcbiAgICBpZiAoYWx0QXVkaW8pIHtcbiAgICAgIGxldCB2aWRlb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXI7XG4gICAgICAvLyBpZiB3ZSBzd2l0Y2hlZCBvbiBhbHRlcm5hdGUgYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCB2aWRlbyBzb3VyY2VidWZmZXIgYnVmZmVyZWRcbiAgICAgIGlmICh2aWRlb0J1ZmZlciAmJiB0aGlzLm1lZGlhQnVmZmVyICE9PSB2aWRlb0J1ZmZlcikge1xuICAgICAgICBsb2dnZXIubG9nKCdzd2l0Y2hpbmcgb24gYWx0ZXJuYXRlIGF1ZGlvLCB1c2UgdmlkZW8uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nJyk7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB2aWRlb0J1ZmZlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hbHRBdWRpbyA9IGFsdEF1ZGlvO1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25CdWZmZXJDcmVhdGVkIChkYXRhKSB7XG4gICAgbGV0IHRyYWNrcyA9IGRhdGEudHJhY2tzLCBtZWRpYVRyYWNrLCBuYW1lLCBhbHRlcm5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCB0eXBlIGluIHRyYWNrcykge1xuICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW3R5cGVdO1xuICAgICAgaWYgKHRyYWNrLmlkID09PSAnbWFpbicpIHtcbiAgICAgICAgbmFtZSA9IHR5cGU7XG4gICAgICAgIG1lZGlhVHJhY2sgPSB0cmFjaztcbiAgICAgICAgLy8ga2VlcCB2aWRlbyBzb3VyY2UgYnVmZmVyIHJlZmVyZW5jZVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSB0cmFja3NbdHlwZV0uYnVmZmVyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbHRlcm5hdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWx0ZXJuYXRlICYmIG1lZGlhVHJhY2spIHtcbiAgICAgIGxvZ2dlci5sb2coYGFsdGVybmF0ZSB0cmFjayBmb3VuZCwgdXNlICR7bmFtZX0uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nYCk7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gbWVkaWFUcmFjay5idWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgIH1cbiAgfVxuXG4gIG9uQnVmZmVyQXBwZW5kZWQgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdtYWluJykge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgaWYgKHN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8IHN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIGFwcGVuZGVkXG4gICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IChkYXRhLnBlbmRpbmcgPiAwKTtcbiAgICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jaGVja0FwcGVuZGVkUGFyc2VkICgpIHtcbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCAmJiAoIXRoaXMuYXBwZW5kZWQgfHwgIXRoaXMucGVuZGluZ0J1ZmZlcmluZykpIHtcbiAgICAgIGNvbnN0IGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgICAgIGxvZ2dlci5sb2coYG1haW4gYnVmZmVyZWQgOiAke1RpbWVSYW5nZXMudG9TdHJpbmcobWVkaWEuYnVmZmVyZWQpfWApO1xuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICAgIGNvbnN0IHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICAgICAgc3RhdHMudGJ1ZmZlcmVkID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAvLyB3ZSBzaG91bGQgZ2V0IHJpZCBvZiB0aGlzLmZyYWdMYXN0S2Jwc1xuICAgICAgICB0aGlzLmZyYWdMYXN0S2JwcyA9IE1hdGgucm91bmQoOCAqIHN0YXRzLnRvdGFsIC8gKHN0YXRzLnRidWZmZXJlZCAtIHN0YXRzLnRmaXJzdCkpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfQlVGRkVSRUQsIHsgc3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnLCBpZDogJ21haW4nIH0pO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IgKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZyB8fMKgdGhpcy5mcmFnQ3VycmVudDtcbiAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBtYWluIGZyYWdtZW50XG4gICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSAnbWFpbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyAwLjUgOiB0b2xlcmFuY2UgbmVlZGVkIGFzIHNvbWUgYnJvd3NlcnMgc3RhbGxzIHBsYXliYWNrIGJlZm9yZSByZWFjaGluZyBidWZmZXJlZCBlbmRcbiAgICBsZXQgbWVkaWFCdWZmZXJlZCA9ICEhdGhpcy5tZWRpYSAmJiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh0aGlzLm1lZGlhLCB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lKSAmJiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh0aGlzLm1lZGlhLCB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lICsgMC41KTtcblxuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICBpZiAoIWRhdGEuZmF0YWwpIHtcbiAgICAgICAgLy8ga2VlcCByZXRyeWluZyB1bnRpbCB0aGUgbGltaXQgd2lsbCBiZSByZWFjaGVkXG4gICAgICAgIGlmICgodGhpcy5mcmFnTG9hZEVycm9yICsgMSkgPD0gdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSkge1xuICAgICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dFxuICAgICAgICAgIGxldCBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsIHRoaXMuZnJhZ0xvYWRFcnJvcikgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTtcbiAgICAgICAgICBsb2dnZXIud2FybihgbWVkaWFDb250cm9sbGVyOiBmcmFnIGxvYWRpbmcgZmFpbGVkLCByZXRyeSBpbiAke2RlbGF5fSBtc2ApO1xuICAgICAgICAgIHRoaXMucmV0cnlEYXRlID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XG4gICAgICAgICAgLy8gcmV0cnkgbG9hZGluZyBzdGF0ZVxuICAgICAgICAgIC8vIGlmIGxvYWRlZG1ldGFkYXRhIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoYXQgd2UgYXJlIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBvbiBmaXJzdCBmcmFnXG4gICAgICAgICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuICAgICAgICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yKys7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihgbWVkaWFDb250cm9sbGVyOiAke2RhdGEuZGV0YWlsc30gcmVhY2hlcyBtYXggcmV0cnksIHJlZGlzcGF0Y2ggYXMgZmF0YWwgLi4uYCk7XG4gICAgICAgICAgLy8gc3dpdGNoIGVycm9yIHRvIGZhdGFsXG4gICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICAgIC8vIGlmIGZhdGFsIGVycm9yLCBzdG9wIHByb2Nlc3NpbmdcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYHN0cmVhbUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSxzd2l0Y2ggdG8gJHt0aGlzLnN0YXRlfSBzdGF0ZSAuLi5gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIG9mIG5vbiBmYXRhbCBlcnJvciB3aGlsZSBsb2FkaW5nIGxldmVsLCBpZiBsZXZlbCBjb250cm9sbGVyIGlzIG5vdCByZXRyeWluZyB0byBsb2FkIGxldmVsICwgc3dpdGNoIGJhY2sgdG8gSURMRVxuICAgICAgICAgIGlmICghZGF0YS5sZXZlbFJldHJ5ICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAvLyBpZiBpbiBhcHBlbmRpbmcgc3RhdGVcbiAgICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ21haW4nICYmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8wqB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQpKSB7XG4gICAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXG4gICAgICAgIGlmIChtZWRpYUJ1ZmZlcmVkKSB7XG4gICAgICAgICAgdGhpcy5fcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKHRoaXMuY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsIGJ1dCBicm93c2VyIGlzIHN0aWxsIGNvbXBsYWluaW5nIGFib3V0IGJ1ZmZlciBmdWxsIGVycm9yXG4gICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIG9uIElFL0VkZ2UsIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL3B1bGwvNzA4XG4gICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGZsdXNoIHRoZSB3aG9sZSBidWZmZXIgdG8gcmVjb3ZlclxuICAgICAgICAgIGxvZ2dlci53YXJuKCdidWZmZXIgZnVsbCBlcnJvciBhbHNvIG1lZGlhLmN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgZmx1c2ggZXZlcnl0aGluZycpO1xuICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIC8vIGZsdXNoIGV2ZXJ5dGhpbmdcbiAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgX3JlZHVjZU1heEJ1ZmZlckxlbmd0aCAobWluTGVuZ3RoKSB7XG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmIChjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoID49IG1pbkxlbmd0aCkge1xuICAgICAgLy8gcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIGFzIGl0IG1pZ2h0IGJlIHRvbyBoaWdoLiB3ZSBkbyB0aGlzIHRvIGF2b2lkIGxvb3AgZmx1c2hpbmcgLi4uXG4gICAgICBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoIC89IDI7XG4gICAgICBsb2dnZXIud2FybihgbWFpbjpyZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gJHtjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RofXNgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHRoZSBoZWFsdGggb2YgdGhlIGJ1ZmZlciBhbmQgYXR0ZW1wdHMgdG8gcmVzb2x2ZSBwbGF5YmFjayBzdGFsbHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tCdWZmZXIgKCkge1xuICAgIGNvbnN0IHsgbWVkaWEgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSB8fCBtZWRpYS5yZWFkeVN0YXRlID09PSAwKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGRvbid0IGhhdmUgbWVkaWEgb3IgaWYgdGhlIG1lZGlhIGhhc24ndCBidWZmZXJkIGFueXRoaW5nIHlldCAocmVhZHlTdGF0ZSAwKVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiBtZWRpYTtcbiAgICBjb25zdCBidWZmZXJlZCA9IG1lZGlhQnVmZmVyLmJ1ZmZlcmVkO1xuXG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmIGJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XG4gICAgICB0aGlzLl9zZWVrVG9TdGFydFBvcygpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pbW1lZGlhdGVTd2l0Y2gpIHtcbiAgICAgIHRoaXMuaW1tZWRpYXRlTGV2ZWxTd2l0Y2hFbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nYXBDb250cm9sbGVyLnBvbGwodGhpcy5sYXN0Q3VycmVudFRpbWUsIGJ1ZmZlcmVkKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCAoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9uIGZpcnN0IGZyYWdcbiAgICAvLyBpbiB0aGF0IGNhc2UsIHJlc2V0IHN0YXJ0RnJhZ1JlcXVlc3RlZCBmbGFnXG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uQnVmZmVyRmx1c2hlZCAoKSB7XG4gICAgLyogYWZ0ZXIgc3VjY2Vzc2Z1bCBidWZmZXIgZmx1c2hpbmcsIGZpbHRlciBmbHVzaGVkIGZyYWdtZW50cyBmcm9tIGJ1ZmZlcmVkRnJhZ3NcbiAgICAgIHVzZSBtZWRpYUJ1ZmZlcmVkIGluc3RlYWQgb2YgbWVkaWEgKHNvIHRoYXQgd2Ugd2lsbCBjaGVjayBhZ2FpbnN0IHZpZGVvLmJ1ZmZlcmVkIHJhbmdlcyBpbiBjYXNlIG9mIGFsdCBhdWRpbyB0cmFjaylcbiAgICAqL1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgLy8gZmlsdGVyIGZyYWdtZW50cyBwb3RlbnRpYWxseSBldmljdGVkIGZyb20gYnVmZmVyLiB0aGlzIGlzIHRvIGF2b2lkIG1lbWxlYWsgb24gbGl2ZSBzdHJlYW1zXG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKEZyYWdtZW50LkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTywgbWVkaWEuYnVmZmVyZWQpO1xuICAgIH1cbiAgICAvLyBtb3ZlIHRvIElETEUgb25jZSBmbHVzaCBjb21wbGV0ZS4gdGhpcyBzaG91bGQgdHJpZ2dlciBuZXcgZnJhZ21lbnQgbG9hZGluZ1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIC8vIHJlc2V0IHJlZmVyZW5jZSB0byBmcmFnXG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICB9XG5cbiAgc3dhcEF1ZGlvQ29kZWMgKCkge1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSAhdGhpcy5hdWRpb0NvZGVjU3dhcDtcbiAgfVxuXG4gIGNvbXB1dGVMaXZlUG9zaXRpb24gKHNsaWRpbmcsIGxldmVsRGV0YWlscykge1xuICAgIGxldCB0YXJnZXRMYXRlbmN5ID0gdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbiA6IHRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgICByZXR1cm4gc2xpZGluZyArIE1hdGgubWF4KDAsIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uIC0gdGFyZ2V0TGF0ZW5jeSk7XG4gIH1cblxuICAvKipcbiAgICogU2Vla3MgdG8gdGhlIHNldCBzdGFydFBvc2l0aW9uIGlmIG5vdCBlcXVhbCB0byB0aGUgbWVkaWFFbGVtZW50J3MgY3VycmVudCB0aW1lLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlZWtUb1N0YXJ0UG9zICgpIHtcbiAgICBjb25zdCB7IG1lZGlhIH0gPSB0aGlzO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgLy8gb25seSBhZGp1c3QgY3VycmVudFRpbWUgaWYgZGlmZmVyZW50IGZyb20gc3RhcnRQb3NpdGlvbiBvciBpZiBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZFxuICAgIC8vIGF0IHRoYXQgc3RhZ2UsIHRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBidWZmZXJlZCByYW5nZSwgYXMgd2UgcmVhY2ggdGhhdCBjb2RlIGFmdGVyIGZpcnN0IGZyYWdtZW50IGhhcyBiZWVuIGJ1ZmZlcmVkXG4gICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IG1lZGlhLnNlZWtpbmcgPyBjdXJyZW50VGltZSA6IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAvLyBpZiBjdXJyZW50VGltZSBub3QgbWF0Y2hpbmcgd2l0aCBleHBlY3RlZCBzdGFydFBvc2l0aW9uIG9yIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkIGJ1dCBjbG9zZSB0byBmaXJzdCBidWZmZXJlZFxuICAgIGlmIChjdXJyZW50VGltZSAhPT0gc3RhcnRQb3NpdGlvbikge1xuICAgICAgLy8gaWYgc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWQsIGxldCdzIHNlZWsgdG8gYnVmZmVyZWQuc3RhcnQoMClcbiAgICAgIGxvZ2dlci5sb2coYHRhcmdldCBzdGFydCBwb3NpdGlvbiBub3QgYnVmZmVyZWQsIHNlZWsgdG8gYnVmZmVyZWQuc3RhcnQoMCkgJHtzdGFydFBvc2l0aW9ufSBmcm9tIGN1cnJlbnQgdGltZSAke2N1cnJlbnRUaW1lfSBgKTtcbiAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICBfZ2V0QXVkaW9Db2RlYyAoY3VycmVudExldmVsKSB7XG4gICAgbGV0IGF1ZGlvQ29kZWMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dhcCkge1xuICAgICAgbG9nZ2VyLmxvZygnc3dhcHBpbmcgcGxheWxpc3QgYXVkaW8gY29kZWMnKTtcbiAgICAgIGlmIChhdWRpb0NvZGVjKSB7XG4gICAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXVkaW9Db2RlYztcbiAgfVxuXG4gIGdldCBsaXZlU3luY1Bvc2l0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGl2ZVN5bmNQb3NpdGlvbjtcbiAgfVxuXG4gIHNldCBsaXZlU3luY1Bvc2l0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX2xpdmVTeW5jUG9zaXRpb24gPSB2YWx1ZTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgU3RyZWFtQ29udHJvbGxlcjtcbiIsIi8qKlxuICogQGNsYXNzIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlclxuICovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCBEZWNyeXB0ZXIgZnJvbSAnLi4vY3J5cHQvZGVjcnlwdGVyJztcbmltcG9ydCB7IEJ1ZmZlckhlbHBlciB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IHsgZmluZEZyYWdtZW50QnlQRFQsIGZpbmRGcmFnbWVudEJ5UFRTIH0gZnJvbSAnLi9mcmFnbWVudC1maW5kZXJzJztcbmltcG9ydCB7IEZyYWdtZW50U3RhdGUgfSBmcm9tICcuL2ZyYWdtZW50LXRyYWNrZXInO1xuaW1wb3J0IEJhc2VTdHJlYW1Db250cm9sbGVyLCB7IFN0YXRlIH0gZnJvbSAnLi9iYXNlLXN0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCB7IG1lcmdlU3VidGl0bGVQbGF5bGlzdHMgfSBmcm9tICcuL2xldmVsLWhlbHBlcic7XG5cbmNvbnN0IHsgcGVyZm9ybWFuY2UgfSA9IHdpbmRvdztcbmNvbnN0IFRJQ0tfSU5URVJWQUwgPSA1MDA7IC8vIGhvdyBvZnRlbiB0byB0aWNrIGluIG1zXG5cbmV4cG9ydCBjbGFzcyBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlU3RyZWFtQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSEVELFxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxuICAgICAgRXZlbnQuRVJST1IsXG4gICAgICBFdmVudC5LRVlfTE9BREVELFxuICAgICAgRXZlbnQuRlJBR19MT0FERUQsXG4gICAgICBFdmVudC5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCxcbiAgICAgIEV2ZW50LlNVQlRJVExFX1RSQUNLX1NXSVRDSCxcbiAgICAgIEV2ZW50LlNVQlRJVExFX1RSQUNLX0xPQURFRCxcbiAgICAgIEV2ZW50LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELFxuICAgICAgRXZlbnQuTEVWRUxfVVBEQVRFRCk7XG5cbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkID0gW107XG4gICAgdGhpcy5jdXJyZW50VHJhY2tJZCA9IC0xO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcihobHMsIGhscy5jb25maWcpO1xuICAgIC8vIGxhc3RBVlN0YXJ0IHN0b3JlcyB0aGUgdGltZSBpbiBzZWNvbmRzIGZvciB0aGUgc3RhcnQgdGltZSBvZiBhIGxldmVsIGxvYWRcbiAgICB0aGlzLmxhc3RBVlN0YXJ0ID0gMDtcbiAgICB0aGlzLl9vbk1lZGlhU2Vla2luZyA9IHRoaXMub25NZWRpYVNlZWtpbmcuYmluZCh0aGlzKTtcbiAgfVxuXG4gIG9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkIChkYXRhKSB7XG4gICAgY29uc3QgeyBmcmFnLCBzdWNjZXNzIH0gPSBkYXRhO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXJlZCA9IHRoaXMudHJhY2tzQnVmZmVyZWRbdGhpcy5jdXJyZW50VHJhY2tJZF07XG4gICAgaWYgKCFidWZmZXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZS91cGRhdGUgYSBidWZmZXJlZCBhcnJheSBtYXRjaGluZyB0aGUgaW50ZXJmYWNlIHVzZWQgYnkgQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mb1xuICAgIC8vIHNvIHdlIGNhbiByZS11c2UgdGhlIGxvZ2ljIHVzZWQgdG8gZGV0ZWN0IGhvdyBtdWNoIGhhdmUgYmVlbiBidWZmZXJlZFxuICAgIGxldCB0aW1lUmFuZ2U7XG4gICAgY29uc3QgZnJhZ1N0YXJ0ID0gZnJhZy5zdGFydDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZnJhZ1N0YXJ0ID49IGJ1ZmZlcmVkW2ldLnN0YXJ0ICYmIGZyYWdTdGFydCA8PSBidWZmZXJlZFtpXS5lbmQpIHtcbiAgICAgICAgdGltZVJhbmdlID0gYnVmZmVyZWRbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZyYWdFbmQgPSBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgICBpZiAodGltZVJhbmdlKSB7XG4gICAgICB0aW1lUmFuZ2UuZW5kID0gZnJhZ0VuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZVJhbmdlID0ge1xuICAgICAgICBzdGFydDogZnJhZ1N0YXJ0LFxuICAgICAgICBlbmQ6IGZyYWdFbmRcbiAgICAgIH07XG4gICAgICBidWZmZXJlZC5wdXNoKHRpbWVSYW5nZSk7XG4gICAgfVxuICB9XG5cbiAgb25NZWRpYUF0dGFjaGVkICh7IG1lZGlhIH0pIHtcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMuX29uTWVkaWFTZWVraW5nKTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcgKCkge1xuICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMuX29uTWVkaWFTZWVraW5nKTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgfVxuXG4gIC8vIElmIHNvbWV0aGluZyBnb2VzIHdyb25nLCBwcm9jZWVkIHRvIG5leHQgZnJhZywgaWYgd2Ugd2VyZSBwcm9jZXNzaW5nIG9uZS5cbiAgb25FcnJvciAoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIC8vIGRvbid0IGhhbmRsZSBlcnJvciBub3QgcmVsYXRlZCB0byBzdWJ0aXRsZSBmcmFnbWVudFxuICAgIGlmICghZnJhZyB8fCBmcmFnLnR5cGUgIT09ICdzdWJ0aXRsZScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gIH1cblxuICAvLyBHb3QgYWxsIG5ldyBzdWJ0aXRsZSB0cmFja3MuXG4gIG9uU3VidGl0bGVUcmFja3NVcGRhdGVkIChkYXRhKSB7XG4gICAgbG9nZ2VyLmxvZygnc3VidGl0bGUgdHJhY2tzIHVwZGF0ZWQnKTtcbiAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkID0gW107XG4gICAgdGhpcy50cmFja3MgPSBkYXRhLnN1YnRpdGxlVHJhY2tzO1xuICAgIHRoaXMudHJhY2tzLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkW3RyYWNrLmlkXSA9IFtdO1xuICAgIH0pO1xuICB9XG5cbiAgb25TdWJ0aXRsZVRyYWNrU3dpdGNoIChkYXRhKSB7XG4gICAgdGhpcy5jdXJyZW50VHJhY2tJZCA9IGRhdGEuaWQ7XG5cbiAgICBpZiAoIXRoaXMudHJhY2tzIHx8IHRoaXMuY3VycmVudFRyYWNrSWQgPT09IC0xKSB7XG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0cmFjayBoYXMgdGhlIG5lY2Vzc2FyeSBkZXRhaWxzIHRvIGxvYWQgZnJhZ21lbnRzXG4gICAgY29uc3QgY3VycmVudFRyYWNrID0gdGhpcy50cmFja3NbdGhpcy5jdXJyZW50VHJhY2tJZF07XG4gICAgaWYgKGN1cnJlbnRUcmFjayAmJiBjdXJyZW50VHJhY2suZGV0YWlscykge1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICB9XG4gIH1cblxuICAvLyBHb3QgYSBuZXcgc2V0IG9mIHN1YnRpdGxlIGZyYWdtZW50cy5cbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGVkIChkYXRhKSB7XG4gICAgY29uc3QgeyBpZCwgZGV0YWlscyB9ID0gZGF0YTtcbiAgICBjb25zdCB7IGN1cnJlbnRUcmFja0lkLCB0cmFja3MgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRyYWNrID0gdHJhY2tzW2N1cnJlbnRUcmFja0lkXTtcbiAgICBpZiAoaWQgPj0gdHJhY2tzLmxlbmd0aCB8fCBpZCAhPT0gY3VycmVudFRyYWNrSWQgfHwgIWN1cnJlbnRUcmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkZXRhaWxzLmxpdmUpIHtcbiAgICAgIG1lcmdlU3VidGl0bGVQbGF5bGlzdHMoY3VycmVudFRyYWNrLmRldGFpbHMsIGRldGFpbHMsIHRoaXMubGFzdEFWU3RhcnQpO1xuICAgIH1cbiAgICBjdXJyZW50VHJhY2suZGV0YWlscyA9IGRldGFpbHM7XG4gICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgfVxuXG4gIG9uS2V5TG9hZGVkICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuS0VZX0xPQURJTkcpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0xvYWRlZCAoZGF0YSkge1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBjb25zdCBkZWNyeXB0RGF0YSA9IGRhdGEuZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICBjb25zdCBmcmFnTG9hZGVkID0gZGF0YS5mcmFnO1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyAmJlxuICAgICAgICBmcmFnQ3VycmVudCAmJlxuICAgICAgICBkYXRhLmZyYWcudHlwZSA9PT0gJ3N1YnRpdGxlJyAmJlxuICAgICAgICBmcmFnQ3VycmVudC5zbiA9PT0gZGF0YS5mcmFnLnNuKSB7XG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgZGVjcnlwdGVkXG4gICAgICBpZiAoZGF0YS5wYXlsb2FkLmJ5dGVMZW5ndGggPiAwICYmIChkZWNyeXB0RGF0YSAmJiBkZWNyeXB0RGF0YS5rZXkgJiYgZGVjcnlwdERhdGEubWV0aG9kID09PSAnQUVTLTEyOCcpKSB7XG4gICAgICAgIGxldCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgICAvLyBkZWNyeXB0IHRoZSBzdWJ0aXRsZXNcbiAgICAgICAgdGhpcy5kZWNyeXB0ZXIuZGVjcnlwdChkYXRhLnBheWxvYWQsIGRlY3J5cHREYXRhLmtleS5idWZmZXIsIGRlY3J5cHREYXRhLml2LmJ1ZmZlciwgZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICBsZXQgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZSQUdfREVDUllQVEVELCB7IGZyYWc6IGZyYWdMb2FkZWQsIHBheWxvYWQ6IGRlY3J5cHRlZERhdGEsIHN0YXRzOiB7IHRzdGFydDogc3RhcnRUaW1lLCB0ZGVjcnlwdDogZW5kVGltZSB9IH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkxldmVsVXBkYXRlZCAoeyBkZXRhaWxzIH0pIHtcbiAgICBjb25zdCBmcmFncyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAgIHRoaXMubGFzdEFWU3RhcnQgPSBmcmFncy5sZW5ndGggPyBmcmFnc1swXS5zdGFydCA6IDA7XG4gIH1cblxuICBkb1RpY2sgKCkge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgY2FzZSBTdGF0ZS5JRExFOiB7XG4gICAgICBjb25zdCB7IGNvbmZpZywgY3VycmVudFRyYWNrSWQsIGZyYWdtZW50VHJhY2tlciwgbWVkaWEsIHRyYWNrcyB9ID0gdGhpcztcbiAgICAgIGlmICghdHJhY2tzIHx8ICF0cmFja3NbY3VycmVudFRyYWNrSWRdIHx8ICF0cmFja3NbY3VycmVudFRyYWNrSWRdLmRldGFpbHMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgbWF4QnVmZmVySG9sZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB9ID0gY29uZmlnO1xuICAgICAgY29uc3QgbWF4Q29uZmlnQnVmZmVyID0gTWF0aC5taW4oY29uZmlnLm1heEJ1ZmZlckxlbmd0aCwgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCk7XG4gICAgICBjb25zdCBidWZmZXJlZEluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvKHRoaXMuX2dldEJ1ZmZlcmVkKCksIG1lZGlhLmN1cnJlbnRUaW1lLCBtYXhCdWZmZXJIb2xlKTtcbiAgICAgIGNvbnN0IHsgZW5kOiBidWZmZXJFbmQsIGxlbjogYnVmZmVyTGVuIH0gPSBidWZmZXJlZEluZm87XG5cbiAgICAgIGNvbnN0IHRyYWNrRGV0YWlscyA9IHRyYWNrc1tjdXJyZW50VHJhY2tJZF0uZGV0YWlscztcbiAgICAgIGNvbnN0IGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHM7XG4gICAgICBjb25zdCBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgIGNvbnN0IGVuZCA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uc3RhcnQgKyBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdLmR1cmF0aW9uO1xuXG4gICAgICBpZiAoYnVmZmVyTGVuID4gbWF4Q29uZmlnQnVmZmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGZvdW5kRnJhZztcbiAgICAgIGNvbnN0IGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgICAgaWYgKGJ1ZmZlckVuZCA8IGVuZCkge1xuICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIHRyYWNrRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgICBmb3VuZEZyYWcgPSBmaW5kRnJhZ21lbnRCeVBEVChmcmFnbWVudHMsIGZyYWdQcmV2aW91cy5lbmRQcm9ncmFtRGF0ZVRpbWUsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm91bmRGcmFnKSB7XG4gICAgICAgICAgZm91bmRGcmFnID0gZmluZEZyYWdtZW50QnlQVFMoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZEZyYWcgJiYgZm91bmRGcmFnLmVuY3J5cHRlZCkge1xuICAgICAgICBsb2dnZXIubG9nKGBMb2FkaW5nIGtleSBmb3IgJHtmb3VuZEZyYWcuc259YCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5LRVlfTE9BRElORywgeyBmcmFnOiBmb3VuZEZyYWcgfSk7XG4gICAgICB9IGVsc2UgaWYgKGZvdW5kRnJhZyAmJiBmcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZm91bmRGcmFnKSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEKSB7XG4gICAgICAgIC8vIG9ubHkgbG9hZCBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmb3VuZEZyYWc7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FESU5HLCB7IGZyYWc6IGZvdW5kRnJhZyB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RvcExvYWQgKCkge1xuICAgIHRoaXMubGFzdEFWU3RhcnQgPSAwO1xuICAgIHN1cGVyLnN0b3BMb2FkKCk7XG4gIH1cblxuICBfZ2V0QnVmZmVyZWQgKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrc0J1ZmZlcmVkW3RoaXMuY3VycmVudFRyYWNrSWRdIHx8IFtdO1xuICB9XG5cbiAgb25NZWRpYVNlZWtpbmcgKCkge1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgfVxufVxuIiwiaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IGNvbXB1dGVSZWxvYWRJbnRlcnZhbCB9IGZyb20gJy4vbGV2ZWwtaGVscGVyJztcblxuY2xhc3MgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNIRUQsXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FERUQsXG4gICAgICBFdmVudC5TVUJUSVRMRV9UUkFDS19MT0FERUQpO1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IHN1YnRpdGxlRGlzcGxheSBFbmFibGUvZGlzYWJsZSBzdWJ0aXRsZSBkaXNwbGF5IHJlbmRlcmluZ1xuICAgICAqL1xuICAgIHRoaXMuc3VidGl0bGVEaXNwbGF5ID0gdHJ1ZTtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLy8gTGlzdGVuIGZvciBzdWJ0aXRsZSB0cmFjayBjaGFuZ2UsIHRoZW4gZXh0cmFjdCB0aGUgY3VycmVudCB0cmFjayBJRC5cbiAgb25NZWRpYUF0dGFjaGVkIChkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucXVldWVkRGVmYXVsdFRyYWNrKSB7XG4gICAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjaztcbiAgICAgIGRlbGV0ZSB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjaztcbiAgICB9XG5cbiAgICB0aGlzLnRyYWNrQ2hhbmdlTGlzdGVuZXIgPSB0aGlzLl9vblRleHRUcmFja3NDaGFuZ2VkLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcgPSAhKHRoaXMubWVkaWEudGV4dFRyYWNrcyAmJiAnb25jaGFuZ2UnIGluIHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgaWYgKHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgdGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgdGhpcy50cmFja0NoYW5nZUxpc3RlbmVyKCk7XG4gICAgICB9LCA1MDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhLnRleHRUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy50cmFja0NoYW5nZUxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nICgpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhLnRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy50cmFja0NoYW5nZUxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfVxuXG4gIC8vIEZpcmVkIHdoZW5ldmVyIGEgbmV3IG1hbmlmZXN0IGlzIGxvYWRlZC5cbiAgb25NYW5pZmVzdExvYWRlZCAoZGF0YSkge1xuICAgIGxldCB0cmFja3MgPSBkYXRhLnN1YnRpdGxlcyB8fCBbXTtcbiAgICB0aGlzLnRyYWNrcyA9IHRyYWNrcztcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB7IHN1YnRpdGxlVHJhY2tzOiB0cmFja3MgfSk7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggYXZhaWxhYmxlIHN1YnRpdGxlIHRyYWNrcyBhbmQgYXV0b3NlbGVjdCBkZWZhdWx0IGlmIG5lZWRlZFxuICAgIC8vIFRPRE86IGltcHJvdmUgc2VsZWN0aW9uIGxvZ2ljIHRvIGhhbmRsZSBmb3JjZWQsIGV0Y1xuICAgIHRyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGlmICh0cmFjay5kZWZhdWx0KSB7XG4gICAgICAgIC8vIHNldHRpbmcgdGhpcy5zdWJ0aXRsZVRyYWNrIHdpbGwgdHJpZ2dlciBpbnRlcm5hbCBsb2dpY1xuICAgICAgICAvLyBpZiBtZWRpYSBoYXMgbm90IGJlZW4gYXR0YWNoZWQgeWV0LCBpdCB3aWxsIGZhaWxcbiAgICAgICAgLy8gd2Uga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgZGVmYXVsdCB0cmFjayBpZFxuICAgICAgICAvLyBhbmQgd2UnbGwgc2V0IHN1YnRpdGxlVHJhY2sgd2hlbiBvbk1lZGlhQXR0YWNoZWQgaXMgdHJpZ2dlcmVkXG4gICAgICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdHJhY2suaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPSB0cmFjay5pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGVkIChkYXRhKSB7XG4gICAgY29uc3QgeyBpZCwgZGV0YWlscyB9ID0gZGF0YTtcbiAgICBjb25zdCB7IHRyYWNrSWQsIHRyYWNrcyB9ID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0cmFja3NbdHJhY2tJZF07XG4gICAgaWYgKGlkID49IHRyYWNrcy5sZW5ndGggfHwgaWQgIT09IHRyYWNrSWQgfHwgIWN1cnJlbnRUcmFjayB8fCB0aGlzLnN0b3BwZWQpIHtcbiAgICAgIHRoaXMuX2NsZWFyUmVsb2FkVGltZXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2dnZXIubG9nKGBzdWJ0aXRsZSB0cmFjayAke2lkfSBsb2FkZWRgKTtcbiAgICBpZiAoZGV0YWlscy5saXZlKSB7XG4gICAgICBjb25zdCByZWxvYWRJbnRlcnZhbCA9IGNvbXB1dGVSZWxvYWRJbnRlcnZhbChjdXJyZW50VHJhY2suZGV0YWlscywgZGV0YWlscywgZGF0YS5zdGF0cy50cmVxdWVzdCk7XG4gICAgICBsb2dnZXIubG9nKGBSZWxvYWRpbmcgbGl2ZSBzdWJ0aXRsZSBwbGF5bGlzdCBpbiAke3JlbG9hZEludGVydmFsfW1zYCk7XG4gICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xvYWRDdXJyZW50VHJhY2soKTtcbiAgICAgIH0sIHJlbG9hZEludGVydmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY2xlYXJSZWxvYWRUaW1lcigpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXJ0TG9hZCAoKSB7XG4gICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5fbG9hZEN1cnJlbnRUcmFjaygpO1xuICB9XG5cbiAgc3RvcExvYWQgKCkge1xuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgdGhpcy5fY2xlYXJSZWxvYWRUaW1lcigpO1xuICB9XG5cbiAgLyoqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdCAqKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2tzICgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3M7XG4gIH1cblxuICAvKiogZ2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpICoqL1xuICBnZXQgc3VidGl0bGVUcmFjayAoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tJZDtcbiAgfVxuXG4gIC8qKiBzZWxlY3QgYSBzdWJ0aXRsZSB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKiovXG4gIHNldCBzdWJ0aXRsZVRyYWNrIChzdWJ0aXRsZVRyYWNrSWQpIHtcbiAgICBpZiAodGhpcy50cmFja0lkICE9PSBzdWJ0aXRsZVRyYWNrSWQpIHtcbiAgICAgIHRoaXMuX3RvZ2dsZVRyYWNrTW9kZXMoc3VidGl0bGVUcmFja0lkKTtcbiAgICAgIHRoaXMuX3NldFN1YnRpdGxlVHJhY2tJbnRlcm5hbChzdWJ0aXRsZVRyYWNrSWQpO1xuICAgIH1cbiAgfVxuXG4gIF9jbGVhclJlbG9hZFRpbWVyICgpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgX2xvYWRDdXJyZW50VHJhY2sgKCkge1xuICAgIGNvbnN0IHsgdHJhY2tJZCwgdHJhY2tzLCBobHMgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRyYWNrID0gdHJhY2tzW3RyYWNrSWRdO1xuICAgIGlmICh0cmFja0lkIDwgMCB8fCAhY3VycmVudFRyYWNrIHx8IChjdXJyZW50VHJhY2suZGV0YWlscyAmJiAhY3VycmVudFRyYWNrLmRldGFpbHMubGl2ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyLmxvZyhgTG9hZGluZyBzdWJ0aXRsZSB0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfVFJBQ0tfTE9BRElORywgeyB1cmw6IGN1cnJlbnRUcmFjay51cmwsIGlkOiB0cmFja0lkIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBvbGQgc3VidGl0bGVUcmFjayBhbmQgc2V0cyBjdXJyZW50IG1vZGUgb24gdGhlIG5leHQgc3VidGl0bGVUcmFjay5cbiAgICogVGhpcyBvcGVyYXRlcyBvbiB0aGUgRE9NIHRleHRUcmFja3MuXG4gICAqIEEgdmFsdWUgb2YgLTEgd2lsbCBkaXNhYmxlIGFsbCBzdWJ0aXRsZSB0cmFja3MuXG4gICAqIEBwYXJhbSBuZXdJZCAtIFRoZSBpZCBvZiB0aGUgbmV4dCB0cmFjayB0byBlbmFibGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90b2dnbGVUcmFja01vZGVzIChuZXdJZCkge1xuICAgIGNvbnN0IHsgbWVkaWEsIHN1YnRpdGxlRGlzcGxheSwgdHJhY2tJZCB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dFRyYWNrcyA9IGZpbHRlclN1YnRpdGxlVHJhY2tzKG1lZGlhLnRleHRUcmFja3MpO1xuICAgIGlmIChuZXdJZCA9PT0gLTEpIHtcbiAgICAgIFtdLnNsaWNlLmNhbGwodGV4dFRyYWNrcykuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgIHRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9sZFRyYWNrID0gdGV4dFRyYWNrc1t0cmFja0lkXTtcbiAgICAgIGlmIChvbGRUcmFjaykge1xuICAgICAgICBvbGRUcmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBuZXh0VHJhY2sgPSB0ZXh0VHJhY2tzW25ld0lkXTtcbiAgICBpZiAobmV4dFRyYWNrKSB7XG4gICAgICBuZXh0VHJhY2subW9kZSA9IHN1YnRpdGxlRGlzcGxheSA/ICdzaG93aW5nJyA6ICdoaWRkZW4nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHJlc3BvbnNpYmxlIGZvciB2YWxpZGF0aW5nIHRoZSBzdWJ0aXRsZSBpbmRleCBhbmQgcGVyaW9kaWNhbGx5IHJlbG9hZGluZyBpZiBsaXZlLlxuICAgICAqIERpc3BhdGNoZXMgdGhlIFNVQlRJVExFX1RSQUNLX1NXSVRDSCBldmVudCwgd2hpY2ggaW5zdHJ1Y3RzIHRoZSBzdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlciB0byBsb2FkIHRoZSBzZWxlY3RlZCB0cmFjay5cbiAgICAgKiBAcGFyYW0gbmV3SWQgLSBUaGUgaWQgb2YgdGhlIHN1YnRpdGxlIHRyYWNrIHRvIGFjdGl2YXRlLlxuICAgICAqL1xuICBfc2V0U3VidGl0bGVUcmFja0ludGVybmFsIChuZXdJZCkge1xuICAgIGNvbnN0IHsgaGxzLCB0cmFja3MgfSA9IHRoaXM7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobmV3SWQpIHx8IG5ld0lkIDwgLTEgfHwgbmV3SWQgPj0gdHJhY2tzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudHJhY2tJZCA9IG5ld0lkO1xuICAgIGxvZ2dlci5sb2coYFN3aXRjaGluZyB0byBzdWJ0aXRsZSB0cmFjayAke25ld0lkfWApO1xuICAgIGhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgeyBpZDogbmV3SWQgfSk7XG4gICAgdGhpcy5fbG9hZEN1cnJlbnRUcmFjaygpO1xuICB9XG5cbiAgX29uVGV4dFRyYWNrc0NoYW5nZWQgKCkge1xuICAgIC8vIE1lZGlhIGlzIHVuZGVmaW5lZCB3aGVuIHN3aXRjaGluZyBzdHJlYW1zIHZpYSBsb2FkU291cmNlKClcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgdHJhY2tJZCA9IC0xO1xuICAgIGxldCB0cmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyh0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xuICAgIGZvciAobGV0IGlkID0gMDsgaWQgPCB0cmFja3MubGVuZ3RoOyBpZCsrKSB7XG4gICAgICBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnaGlkZGVuJykge1xuICAgICAgICAvLyBEbyBub3QgYnJlYWsgaW4gY2FzZSB0aGVyZSBpcyBhIGZvbGxvd2luZyB0cmFjayB3aXRoIHNob3dpbmcuXG4gICAgICAgIHRyYWNrSWQgPSBpZDtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgdHJhY2tJZCA9IGlkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXR0aW5nIGN1cnJlbnQgc3VidGl0bGVUcmFjayB3aWxsIGludm9rZSBjb2RlLlxuICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IHRyYWNrSWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyU3VidGl0bGVUcmFja3MgKHRleHRUcmFja0xpc3QpIHtcbiAgbGV0IHRyYWNrcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHRUcmFja0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0cmFjayA9IHRleHRUcmFja0xpc3RbaV07XG4gICAgLy8gRWRnZSBhZGRzIGEgdHJhY2sgd2l0aG91dCBhIGxhYmVsOyB3ZSBkb24ndCB3YW50IHRvIHVzZSBpdFxuICAgIGlmICh0cmFjay5raW5kID09PSAnc3VidGl0bGVzJyAmJiB0cmFjay5sYWJlbCkge1xuICAgICAgdHJhY2tzLnB1c2godGV4dFRyYWNrTGlzdFtpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFja3M7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuIiwiLypcbiAqIFRpbWVsaW5lIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCBDZWE2MDhQYXJzZXIgZnJvbSAnLi4vdXRpbHMvY2VhLTYwOC1wYXJzZXInO1xuaW1wb3J0IE91dHB1dEZpbHRlciBmcm9tICcuLi91dGlscy9vdXRwdXQtZmlsdGVyJztcbmltcG9ydCBXZWJWVFRQYXJzZXIgZnJvbSAnLi4vdXRpbHMvd2VidnR0LXBhcnNlcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgc2VuZEFkZFRyYWNrRXZlbnQsIGNsZWFyQ3VycmVudEN1ZXMgfSBmcm9tICcuLi91dGlscy90ZXh0dHJhY2stdXRpbHMnO1xuXG5mdW5jdGlvbiBjYW5SZXVzZVZ0dFRleHRUcmFjayAoaW5Vc2VUcmFjaywgbWFuaWZlc3RUcmFjaykge1xuICByZXR1cm4gaW5Vc2VUcmFjayAmJiBpblVzZVRyYWNrLmxhYmVsID09PSBtYW5pZmVzdFRyYWNrLm5hbWUgJiYgIShpblVzZVRyYWNrLnRleHRUcmFjazEgfHwgaW5Vc2VUcmFjay50ZXh0VHJhY2syKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uICh4MSwgeDIsIHkxLCB5Mikge1xuICByZXR1cm4gTWF0aC5taW4oeDIsIHkyKSAtIE1hdGgubWF4KHgxLCB5MSk7XG59XG5cbmNsYXNzIFRpbWVsaW5lQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsIEV2ZW50Lk1FRElBX0FUVEFDSElORyxcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19VU0VSREFUQSxcbiAgICAgIEV2ZW50LkZSQUdfREVDUllQVEVELFxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxuICAgICAgRXZlbnQuTEVWRUxfU1dJVENISU5HLFxuICAgICAgRXZlbnQuSU5JVF9QVFNfRk9VTkQpO1xuXG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5DdWVzID0gaGxzLmNvbmZpZy5jdWVIYW5kbGVyO1xuICAgIHRoaXMudGV4dFRyYWNrcyA9IFtdO1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgdGhpcy5pbml0UFRTID0gW107XG4gICAgdGhpcy5jdWVSYW5nZXMgPSBbXTtcbiAgICB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG5cbiAgICB0aGlzLmNhcHRpb25zUHJvcGVydGllcyA9IHtcbiAgICAgIHRleHRUcmFjazE6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFjazI6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhbmd1YWdlQ29kZVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMpIHtcbiAgICAgIGxldCBjaGFubmVsMSA9IG5ldyBPdXRwdXRGaWx0ZXIodGhpcywgJ3RleHRUcmFjazEnKTtcbiAgICAgIGxldCBjaGFubmVsMiA9IG5ldyBPdXRwdXRGaWx0ZXIodGhpcywgJ3RleHRUcmFjazInKTtcblxuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIgPSBuZXcgQ2VhNjA4UGFyc2VyKDAsIGNoYW5uZWwxLCBjaGFubmVsMik7XG4gICAgfVxuICB9XG5cbiAgYWRkQ3VlcyAodHJhY2tOYW1lLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbikge1xuICAgIC8vIHNraXAgY3VlcyB3aGljaCBvdmVybGFwIG1vcmUgdGhhbiA1MCUgd2l0aCBwcmV2aW91c2x5IHBhcnNlZCB0aW1lIHJhbmdlc1xuICAgIGNvbnN0IHJhbmdlcyA9IHRoaXMuY3VlUmFuZ2VzO1xuICAgIGxldCBtZXJnZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gcmFuZ2VzLmxlbmd0aDsgaS0tOykge1xuICAgICAgbGV0IGN1ZVJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgbGV0IG92ZXJsYXAgPSBpbnRlcnNlY3Rpb24oY3VlUmFuZ2VbMF0sIGN1ZVJhbmdlWzFdLCBzdGFydFRpbWUsIGVuZFRpbWUpO1xuICAgICAgaWYgKG92ZXJsYXAgPj0gMCkge1xuICAgICAgICBjdWVSYW5nZVswXSA9IE1hdGgubWluKGN1ZVJhbmdlWzBdLCBzdGFydFRpbWUpO1xuICAgICAgICBjdWVSYW5nZVsxXSA9IE1hdGgubWF4KGN1ZVJhbmdlWzFdLCBlbmRUaW1lKTtcbiAgICAgICAgbWVyZ2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKChvdmVybGFwIC8gKGVuZFRpbWUgLSBzdGFydFRpbWUpKSA+IDAuNSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW1lcmdlZCkge1xuICAgICAgcmFuZ2VzLnB1c2goW3N0YXJ0VGltZSwgZW5kVGltZV0pO1xuICAgIH1cblxuICAgIHRoaXMuQ3Vlcy5uZXdDdWUodGhpcy5jYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gIH1cblxuICAvLyBUcmlnZ2VyZWQgd2hlbiBhbiBpbml0aWFsIFBUUyBpcyBmb3VuZDsgdXNlZCBmb3Igc3luY2hyb25pc2F0aW9uIG9mIFdlYlZUVC5cbiAgb25Jbml0UHRzRm91bmQgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5pZCA9PT0gJ21haW4nKSB7XG4gICAgICB0aGlzLmluaXRQVFNbZGF0YS5mcmFnLmNjXSA9IGRhdGEuaW5pdFBUUztcbiAgICB9XG5cbiAgICAvLyBEdWUgdG8gYXN5bmNocm9ub3VzIHByb2Nlc3NpbmcsIGluaXRpYWwgUFRTIG1heSBhcnJpdmUgbGF0ZXIgdGhhbiB0aGUgZmlyc3QgVlRUIGZyYWdtZW50cyBhcmUgbG9hZGVkLlxuICAgIC8vIFBhcnNlIGFueSB1bnBhcnNlZCBmcmFnbWVudHMgdXBvbiByZWNlaXZpbmcgdGhlIGluaXRpYWwgUFRTLlxuICAgIGlmICh0aGlzLnVucGFyc2VkVnR0RnJhZ3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCB1bnBhcnNlZFZ0dEZyYWdzID0gdGhpcy51bnBhcnNlZFZ0dEZyYWdzO1xuICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgICB1bnBhcnNlZFZ0dEZyYWdzLmZvckVhY2goZnJhZyA9PiB7XG4gICAgICAgIHRoaXMub25GcmFnTG9hZGVkKGZyYWcpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0RXhpc3RpbmdUcmFjayAodHJhY2tOYW1lKSB7XG4gICAgY29uc3QgeyBtZWRpYSB9ID0gdGhpcztcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVkaWEudGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdGV4dFRyYWNrID0gbWVkaWEudGV4dFRyYWNrc1tpXTtcbiAgICAgICAgaWYgKHRleHRUcmFja1t0cmFja05hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHRUcmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNyZWF0ZUNhcHRpb25zVHJhY2sgKHRyYWNrTmFtZSkge1xuICAgIGNvbnN0IHsgbGFiZWwsIGxhbmd1YWdlQ29kZSB9ID0gdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXNbdHJhY2tOYW1lXTtcbiAgICBjb25zdCBjYXB0aW9uc1RyYWNrcyA9IHRoaXMuY2FwdGlvbnNUcmFja3M7XG4gICAgaWYgKCFjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKSB7XG4gICAgICAvLyBFbmFibGUgcmV1c2Ugb2YgZXhpc3RpbmcgdGV4dCB0cmFjay5cbiAgICAgIGNvbnN0IGV4aXN0aW5nVHJhY2sgPSB0aGlzLmdldEV4aXN0aW5nVHJhY2sodHJhY2tOYW1lKTtcbiAgICAgIGlmICghZXhpc3RpbmdUcmFjaykge1xuICAgICAgICBjb25zdCB0ZXh0VHJhY2sgPSB0aGlzLmNyZWF0ZVRleHRUcmFjaygnY2FwdGlvbnMnLCBsYWJlbCwgbGFuZ3VhZ2VDb2RlKTtcbiAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgIC8vIFNldCBhIHNwZWNpYWwgcHJvcGVydHkgb24gdGhlIHRyYWNrIHNvIHdlIGtub3cgaXQncyBtYW5hZ2VkIGJ5IEhscy5qc1xuICAgICAgICAgIHRleHRUcmFja1t0cmFja05hbWVdID0gdHJ1ZTtcbiAgICAgICAgICBjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdID0gdGV4dFRyYWNrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdID0gZXhpc3RpbmdUcmFjaztcbiAgICAgICAgY2xlYXJDdXJyZW50Q3VlcyhjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKTtcbiAgICAgICAgc2VuZEFkZFRyYWNrRXZlbnQoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSwgdGhpcy5tZWRpYSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlVGV4dFRyYWNrIChraW5kLCBsYWJlbCwgbGFuZykge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHJldHVybiBtZWRpYS5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgb25NZWRpYUF0dGFjaGluZyAoZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMuX2NsZWFuVHJhY2tzKCk7XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nICgpIHtcbiAgICBjb25zdCB7IGNhcHRpb25zVHJhY2tzIH0gPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKGNhcHRpb25zVHJhY2tzKS5mb3JFYWNoKHRyYWNrTmFtZSA9PiB7XG4gICAgICBjbGVhckN1cnJlbnRDdWVzKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pO1xuICAgICAgZGVsZXRlIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV07XG4gICAgfSk7XG4gIH1cblxuICBvbk1hbmlmZXN0TG9hZGluZyAoKSB7XG4gICAgdGhpcy5sYXN0U24gPSAtMTsgLy8gRGV0ZWN0IGRpc2NvbnRpZ3VpdHkgaW4gZnJhZ21lbnQgcGFyc2luZ1xuICAgIHRoaXMucHJldkNDID0gLTE7XG4gICAgdGhpcy52dHRDQ3MgPSB7IC8vIERldGVjdCBkaXNjb250aW51aXR5IGluIHN1YnRpdGxlIG1hbmlmZXN0c1xuICAgICAgY2NPZmZzZXQ6IDAsXG4gICAgICBwcmVzZW50YXRpb25PZmZzZXQ6IDAsXG4gICAgICAwOiB7XG4gICAgICAgIHN0YXJ0OiAwLCBwcmV2Q0M6IC0xLCBuZXc6IGZhbHNlXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9jbGVhblRyYWNrcygpO1xuICB9XG5cbiAgX2NsZWFuVHJhY2tzICgpIHtcbiAgICAvLyBjbGVhciBvdXRkYXRlZCBzdWJ0aXRsZXNcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBjb25zdCB0ZXh0VHJhY2tzID0gbWVkaWEudGV4dFRyYWNrcztcbiAgICAgIGlmICh0ZXh0VHJhY2tzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNsZWFyQ3VycmVudEN1ZXModGV4dFRyYWNrc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbk1hbmlmZXN0TG9hZGVkIChkYXRhKSB7XG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gdGhpcy51bnBhcnNlZFZ0dEZyYWdzIHx8IFtdO1xuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICAgIHRoaXMuY3VlUmFuZ2VzID0gW107XG5cbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlV2ViVlRUKSB7XG4gICAgICB0aGlzLnRyYWNrcyA9IGRhdGEuc3VidGl0bGVzIHx8IFtdO1xuICAgICAgY29uc3QgaW5Vc2VUcmFja3MgPSB0aGlzLm1lZGlhID8gdGhpcy5tZWRpYS50ZXh0VHJhY2tzIDogW107XG5cbiAgICAgIHRoaXMudHJhY2tzLmZvckVhY2goKHRyYWNrLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgdGV4dFRyYWNrO1xuICAgICAgICBpZiAoaW5kZXggPCBpblVzZVRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICBsZXQgaW5Vc2VUcmFjayA9IG51bGw7XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluVXNlVHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2FuUmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFja3NbaV0sIHRyYWNrKSkge1xuICAgICAgICAgICAgICBpblVzZVRyYWNrID0gaW5Vc2VUcmFja3NbaV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJldXNlIHRyYWNrcyB3aXRoIHRoZSBzYW1lIGxhYmVsLCBidXQgZG8gbm90IHJldXNlIDYwOC83MDggdHJhY2tzXG4gICAgICAgICAgaWYgKGluVXNlVHJhY2spIHtcbiAgICAgICAgICAgIHRleHRUcmFjayA9IGluVXNlVHJhY2s7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGV4dFRyYWNrKSB7XG4gICAgICAgICAgdGV4dFRyYWNrID0gdGhpcy5jcmVhdGVUZXh0VHJhY2soJ3N1YnRpdGxlcycsIHRyYWNrLm5hbWUsIHRyYWNrLmxhbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYWNrLmRlZmF1bHQpIHtcbiAgICAgICAgICB0ZXh0VHJhY2subW9kZSA9IHRoaXMuaGxzLnN1YnRpdGxlRGlzcGxheSA/ICdzaG93aW5nJyA6ICdoaWRkZW4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRUcmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGV4dFRyYWNrcy5wdXNoKHRleHRUcmFjayk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBvbkxldmVsU3dpdGNoaW5nICgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLmhscy5jdXJyZW50TGV2ZWwuY2xvc2VkQ2FwdGlvbnMgIT09ICdOT05FJztcbiAgfVxuXG4gIG9uRnJhZ0xvYWRlZCAoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgcGF5bG9hZCA9IGRhdGEucGF5bG9hZDtcbiAgICBpZiAoZnJhZy50eXBlID09PSAnbWFpbicpIHtcbiAgICAgIGxldCBzbiA9IGZyYWcuc247XG4gICAgICAvLyBpZiB0aGlzIGZyYWcgaXNuJ3QgY29udGlndW91cywgY2xlYXIgdGhlIHBhcnNlciBzbyBjdWVzIHdpdGggYmFkIHN0YXJ0L2VuZCB0aW1lcyBhcmVuJ3QgYWRkZWQgdG8gdGhlIHRleHRUcmFja1xuICAgICAgaWYgKHNuICE9PSB0aGlzLmxhc3RTbiArIDEpIHtcbiAgICAgICAgY29uc3QgY2VhNjA4UGFyc2VyID0gdGhpcy5jZWE2MDhQYXJzZXI7XG4gICAgICAgIGlmIChjZWE2MDhQYXJzZXIpIHtcbiAgICAgICAgICBjZWE2MDhQYXJzZXIucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0U24gPSBzbjtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYnJhY2Utc3R5bGVcbiAgICAvLyBJZiBmcmFnbWVudCBpcyBzdWJ0aXRsZSB0eXBlLCBwYXJzZSBhcyBXZWJWVFQuXG4gICAgZWxzZSBpZiAoZnJhZy50eXBlID09PSAnc3VidGl0bGUnKSB7XG4gICAgICBpZiAocGF5bG9hZC5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgYW4gaW5pdGlhbCBzeW5jaHJvbmlzYXRpb24gUFRTLiBTdG9yZSBmcmFnbWVudHMgYXMgbG9uZyBhcyBub25lIGhhcyBhcnJpdmVkLlxuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh0aGlzLmluaXRQVFNbZnJhZy5jY10pKSB7XG4gICAgICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzLnB1c2goZGF0YSk7XG4gICAgICAgICAgaWYgKHRoaXMuaW5pdFBUUy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGZpbmlzaCB1bnN1Y2Nlc3NmdWxseSwgb3RoZXJ3aXNlIHRoZSBzdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlciBjb3VsZCBiZSBibG9ja2VkIGZyb20gbG9hZGluZyBuZXcgZnJhZ3MuXG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7IHN1Y2Nlc3M6IGZhbHNlLCBmcmFnOiBmcmFnIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGVjcnlwdERhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgICAgICAvLyBJZiB0aGUgc3VidGl0bGVzIGFyZSBub3QgZW5jcnlwdGVkLCBwYXJzZSBWVFRzIG5vdy4gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIHdhaXQuXG4gICAgICAgIGlmICgoZGVjcnlwdERhdGEgPT0gbnVsbCkgfHwgKGRlY3J5cHREYXRhLmtleSA9PSBudWxsKSB8fCAoZGVjcnlwdERhdGEubWV0aG9kICE9PSAnQUVTLTEyOCcpKSB7XG4gICAgICAgICAgdGhpcy5fcGFyc2VWVFRzKGZyYWcsIHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbiBjYXNlIHRoZXJlIGlzIG5vIHBheWxvYWQsIGZpbmlzaCB1bnN1Y2Nlc3NmdWxseS5cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfcGFyc2VWVFRzIChmcmFnLCBwYXlsb2FkKSB7XG4gICAgbGV0IHZ0dENDcyA9IHRoaXMudnR0Q0NzO1xuICAgIGlmICghdnR0Q0NzW2ZyYWcuY2NdKSB7XG4gICAgICB2dHRDQ3NbZnJhZy5jY10gPSB7IHN0YXJ0OiBmcmFnLnN0YXJ0LCBwcmV2Q0M6IHRoaXMucHJldkNDLCBuZXc6IHRydWUgfTtcbiAgICAgIHRoaXMucHJldkNDID0gZnJhZy5jYztcbiAgICB9XG4gICAgbGV0IHRleHRUcmFja3MgPSB0aGlzLnRleHRUcmFja3MsXG4gICAgICBobHMgPSB0aGlzLmhscztcblxuICAgIC8vIFBhcnNlIHRoZSBXZWJWVFQgZmlsZSBjb250ZW50cy5cbiAgICBXZWJWVFRQYXJzZXIucGFyc2UocGF5bG9hZCwgdGhpcy5pbml0UFRTW2ZyYWcuY2NdLCB2dHRDQ3MsIGZyYWcuY2MsIGZ1bmN0aW9uIChjdWVzKSB7XG4gICAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0ZXh0VHJhY2tzW2ZyYWcubGV2ZWxdO1xuICAgICAgLy8gV2ViVlRUUGFyc2VyLnBhcnNlIGlzIGFuIGFzeW5jIG1ldGhvZCBhbmQgaWYgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0IHRyYWNrIG1vZGUgaXMgc2V0IHRvIFwiZGlzYWJsZWRcIlxuICAgICAgLy8gYmVmb3JlIHBhcnNpbmcgaXMgZG9uZSB0aGVuIGRvbid0IHRyeSB0byBhY2Nlc3MgY3VycmVudFRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZCBhcyBjdWVzIHdpbGwgYmUgbnVsbFxuICAgICAgLy8gYW5kIHRyeWluZyB0byBhY2Nlc3MgZ2V0Q3VlQnlJZCBtZXRob2Qgb2YgY3VlcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvblxuICAgICAgaWYgKGN1cnJlbnRUcmFjay5tb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7IHN1Y2Nlc3M6IGZhbHNlLCBmcmFnOiBmcmFnIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBBZGQgY3VlcyBhbmQgdHJpZ2dlciBldmVudCB3aXRoIHN1Y2Nlc3MgdHJ1ZS5cbiAgICAgIGN1ZXMuZm9yRWFjaChjdWUgPT4ge1xuICAgICAgICAvLyBTb21ldGltZXMgdGhlcmUgYXJlIGN1ZSBvdmVybGFwcyBvbiBzZWdtZW50ZWQgdnR0cyBzbyB0aGUgc2FtZVxuICAgICAgICAvLyBjdWUgY2FuIGFwcGVhciBtb3JlIHRoYW4gb25jZSBpbiBkaWZmZXJlbnQgdnR0IGZpbGVzLlxuICAgICAgICAvLyBUaGlzIGF2b2lkIHNob3dpbmcgZHVwbGljYXRlZCBjdWVzIHdpdGggc2FtZSB0aW1lY29kZSBhbmQgdGV4dC5cbiAgICAgICAgaWYgKCFjdXJyZW50VHJhY2suY3Vlcy5nZXRDdWVCeUlkKGN1ZS5pZCkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY3VycmVudFRyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc3QgdGV4dFRyYWNrQ3VlID0gbmV3IHdpbmRvdy5UZXh0VHJhY2tDdWUoY3VlLnN0YXJ0VGltZSwgY3VlLmVuZFRpbWUsIGN1ZS50ZXh0KTtcbiAgICAgICAgICAgIHRleHRUcmFja0N1ZS5pZCA9IGN1ZS5pZDtcbiAgICAgICAgICAgIGN1cnJlbnRUcmFjay5hZGRDdWUodGV4dFRyYWNrQ3VlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiB0cnVlLCBmcmFnOiBmcmFnIH0pO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIHBhcnNpbmcuIFRyaWdnZXIgZXZlbnQgd2l0aCBzdWNjZXNzIGZhbHNlLlxuICAgICAgbG9nZ2VyLmxvZyhgRmFpbGVkIHRvIHBhcnNlIFZUVCBjdWU6ICR7ZX1gKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7IHN1Y2Nlc3M6IGZhbHNlLCBmcmFnOiBmcmFnIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgb25GcmFnRGVjcnlwdGVkIChkYXRhKSB7XG4gICAgbGV0IGRlY3J5cHRlZERhdGEgPSBkYXRhLnBheWxvYWQsXG4gICAgICBmcmFnID0gZGF0YS5mcmFnO1xuXG4gICAgaWYgKGZyYWcudHlwZSA9PT0gJ3N1YnRpdGxlJykge1xuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodGhpcy5pbml0UFRTW2ZyYWcuY2NdKSkge1xuICAgICAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MucHVzaChkYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wYXJzZVZUVHMoZnJhZywgZGVjcnlwdGVkRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnUGFyc2luZ1VzZXJkYXRhIChkYXRhKSB7XG4gICAgLy8gcHVzaCBhbGwgb2YgdGhlIENFQS03MDggbWVzc2FnZXMgaW50byB0aGUgaW50ZXJwcmV0ZXJcbiAgICAvLyBpbW1lZGlhdGVseS4gSXQgd2lsbCBjcmVhdGUgdGhlIHByb3BlciB0aW1lc3RhbXBzIGJhc2VkIG9uIG91ciBQVFMgdmFsdWVcbiAgICBpZiAodGhpcy5lbmFibGVkICYmIHRoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEuc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2NkYXRhcyA9IHRoaXMuZXh0cmFjdENlYTYwOERhdGEoZGF0YS5zYW1wbGVzW2ldLmJ5dGVzKTtcbiAgICAgICAgdGhpcy5jZWE2MDhQYXJzZXIuYWRkRGF0YShkYXRhLnNhbXBsZXNbaV0ucHRzLCBjY2RhdGFzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBleHRyYWN0Q2VhNjA4RGF0YSAoYnl0ZUFycmF5KSB7XG4gICAgbGV0IGNvdW50ID0gYnl0ZUFycmF5WzBdICYgMzE7XG4gICAgbGV0IHBvc2l0aW9uID0gMjtcbiAgICBsZXQgdG1wQnl0ZSwgY2NieXRlMSwgY2NieXRlMiwgY2NWYWxpZCwgY2NUeXBlO1xuICAgIGxldCBhY3R1YWxDQ0J5dGVzID0gW107XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgIHRtcEJ5dGUgPSBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICBjY2J5dGUxID0gMHg3RiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgIGNjYnl0ZTIgPSAweDdGICYgYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgY2NWYWxpZCA9ICg0ICYgdG1wQnl0ZSkgIT09IDA7XG4gICAgICBjY1R5cGUgPSAzICYgdG1wQnl0ZTtcblxuICAgICAgaWYgKGNjYnl0ZTEgPT09IDAgJiYgY2NieXRlMiA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNjVmFsaWQpIHtcbiAgICAgICAgaWYgKGNjVHlwZSA9PT0gMCkgeyAvLyB8fCBjY1R5cGUgPT09IDFcbiAgICAgICAgICBhY3R1YWxDQ0J5dGVzLnB1c2goY2NieXRlMSk7XG4gICAgICAgICAgYWN0dWFsQ0NCeXRlcy5wdXNoKGNjYnl0ZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY3R1YWxDQ0J5dGVzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVsaW5lQ29udHJvbGxlcjtcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEFFU0NyeXB0byB7XG4gIGNvbnN0cnVjdG9yIChzdWJ0bGUsIGl2KSB7XG4gICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGU7XG4gICAgdGhpcy5hZXNJViA9IGl2O1xuICB9XG5cbiAgZGVjcnlwdCAoZGF0YSwga2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3VidGxlLmRlY3J5cHQoeyBuYW1lOiAnQUVTLUNCQycsIGl2OiB0aGlzLmFlc0lWIH0sIGtleSwgZGF0YSk7XG4gIH1cbn1cbiIsIi8vIFBLQ1M3XG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUGFkZGluZyAoYnVmZmVyKSB7XG4gIGNvbnN0IG91dHB1dEJ5dGVzID0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gIGNvbnN0IHBhZGRpbmdCeXRlcyA9IG91dHB1dEJ5dGVzICYmIChuZXcgRGF0YVZpZXcoYnVmZmVyKSkuZ2V0VWludDgob3V0cHV0Qnl0ZXMgLSAxKTtcbiAgaWYgKHBhZGRpbmdCeXRlcykge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoMCwgb3V0cHV0Qnl0ZXMgLSBwYWRkaW5nQnl0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWZmZXI7XG4gIH1cbn1cblxuY2xhc3MgQUVTRGVjcnlwdG9yIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8vIFN0YXRpYyBhZnRlciBydW5uaW5nIGluaXRUYWJsZVxuICAgIHRoaXMucmNvbiA9IFsweDAsIDB4MSwgMHgyLCAweDQsIDB4OCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XG4gICAgdGhpcy5zdWJNaXggPSBbbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NildO1xuICAgIHRoaXMuaW52U3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpXTtcbiAgICB0aGlzLnNCb3ggPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB0aGlzLmludlNCb3ggPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcblxuICAgIC8vIENoYW5nZXMgZHVyaW5nIHJ1bnRpbWVcbiAgICB0aGlzLmtleSA9IG5ldyBVaW50MzJBcnJheSgwKTtcblxuICAgIHRoaXMuaW5pdFRhYmxlKCk7XG4gIH1cblxuICAvLyBVc2luZyB2aWV3LmdldFVpbnQzMigpIGFsc28gc3dhcHMgdGhlIGJ5dGUgb3JkZXIuXG4gIHVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyAoYXJyYXlCdWZmZXIpIHtcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgbGV0IG5ld0FycmF5ID0gbmV3IFVpbnQzMkFycmF5KDQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBuZXdBcnJheVtpXSA9IHZpZXcuZ2V0VWludDMyKGkgKiA0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH1cblxuICBpbml0VGFibGUgKCkge1xuICAgIGxldCBzQm94ID0gdGhpcy5zQm94O1xuICAgIGxldCBpbnZTQm94ID0gdGhpcy5pbnZTQm94O1xuICAgIGxldCBzdWJNaXggPSB0aGlzLnN1Yk1peDtcbiAgICBsZXQgc3ViTWl4MCA9IHN1Yk1peFswXTtcbiAgICBsZXQgc3ViTWl4MSA9IHN1Yk1peFsxXTtcbiAgICBsZXQgc3ViTWl4MiA9IHN1Yk1peFsyXTtcbiAgICBsZXQgc3ViTWl4MyA9IHN1Yk1peFszXTtcbiAgICBsZXQgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgbGV0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgbGV0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgbGV0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgbGV0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG5cbiAgICBsZXQgZCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeGkgPSAwO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGlmIChpIDwgMTI4KSB7XG4gICAgICAgIGRbaV0gPSBpIDw8IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkW2ldID0gKGkgPDwgMSkgXiAweDExYjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGxldCBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpO1xuICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xuICAgICAgc0JveFt4XSA9IHN4O1xuICAgICAgaW52U0JveFtzeF0gPSB4O1xuXG4gICAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXG4gICAgICBsZXQgeDIgPSBkW3hdO1xuICAgICAgbGV0IHg0ID0gZFt4Ml07XG4gICAgICBsZXQgeDggPSBkW3g0XTtcblxuICAgICAgLy8gQ29tcHV0ZSBzdWIvaW52U3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcbiAgICAgIGxldCB0ID0gKGRbc3hdICogMHgxMDEpIF4gKHN4ICogMHgxMDEwMTAwKTtcbiAgICAgIHN1Yk1peDBbeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG4gICAgICBzdWJNaXgxW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcbiAgICAgIHN1Yk1peDJbeF0gPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG4gICAgICBzdWJNaXgzW3hdID0gdDtcblxuICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApO1xuICAgICAgaW52U3ViTWl4MFtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG4gICAgICBpbnZTdWJNaXgxW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG4gICAgICBpbnZTdWJNaXgyW3N4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcbiAgICAgIGludlN1Yk1peDNbc3hdID0gdDtcblxuICAgICAgLy8gQ29tcHV0ZSBuZXh0IGNvdW50ZXJcbiAgICAgIGlmICgheCkge1xuICAgICAgICB4ID0geGkgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcbiAgICAgICAgeGkgXj0gZFtkW3hpXV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZXhwYW5kS2V5IChrZXlCdWZmZXIpIHtcbiAgICAvLyBjb252ZXJ0IGtleUJ1ZmZlciB0byBVaW50MzJBcnJheVxuICAgIGxldCBrZXkgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhrZXlCdWZmZXIpO1xuICAgIGxldCBzYW1lS2V5ID0gdHJ1ZTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBrZXkubGVuZ3RoICYmIHNhbWVLZXkpIHtcbiAgICAgIHNhbWVLZXkgPSAoa2V5W29mZnNldF0gPT09IHRoaXMua2V5W29mZnNldF0pO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuXG4gICAgaWYgKHNhbWVLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICBsZXQga2V5U2l6ZSA9IHRoaXMua2V5U2l6ZSA9IGtleS5sZW5ndGg7XG5cbiAgICBpZiAoa2V5U2l6ZSAhPT0gNCAmJiBrZXlTaXplICE9PSA2ICYmIGtleVNpemUgIT09IDgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZXMga2V5IHNpemU9JyArIGtleVNpemUpO1xuICAgIH1cblxuICAgIGxldCBrc1Jvd3MgPSB0aGlzLmtzUm93cyA9IChrZXlTaXplICsgNiArIDEpICogNDtcbiAgICBsZXQga3NSb3c7XG4gICAgbGV0IGludktzUm93O1xuXG4gICAgbGV0IGtleVNjaGVkdWxlID0gdGhpcy5rZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xuICAgIGxldCBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcbiAgICBsZXQgc2JveCA9IHRoaXMuc0JveDtcbiAgICBsZXQgcmNvbiA9IHRoaXMucmNvbjtcblxuICAgIGxldCBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICBsZXQgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICBsZXQgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICBsZXQgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICBsZXQgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcblxuICAgIGxldCBwcmV2O1xuICAgIGxldCB0O1xuXG4gICAgZm9yIChrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG4gICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG4gICAgICAgIHByZXYgPSBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlba3NSb3ddO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHQgPSBwcmV2O1xuXG4gICAgICBpZiAoa3NSb3cgJSBrZXlTaXplID09PSAwKSB7XG4gICAgICAgIC8vIFJvdCB3b3JkXG4gICAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG5cbiAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgdCA9IChzYm94W3QgPj4+IDI0XSA8PCAyNCkgfCAoc2JveFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKHNib3hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBzYm94W3QgJiAweGZmXTtcblxuICAgICAgICAvLyBNaXggUmNvblxuICAgICAgICB0IF49IHJjb25bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNDtcbiAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0KSB7XG4gICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgIHQgPSAoc2JveFt0ID4+PiAyNF0gPDwgMjQpIHwgKHNib3hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChzYm94Wyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgc2JveFt0ICYgMHhmZl07XG4gICAgICB9XG5cbiAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IHByZXYgPSAoa2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQpID4+PiAwO1xuICAgIH1cblxuICAgIGZvciAoaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcbiAgICAgIGlmIChpbnZLc1JvdyAmIDMpIHtcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludlN1Yk1peDBbc2JveFt0ID4+PiAyNF1dIF4gaW52U3ViTWl4MVtzYm94Wyh0ID4+PiAxNikgJiAweGZmXV0gXiBpbnZTdWJNaXgyW3Nib3hbKHQgPj4+IDgpICYgMHhmZl1dIF4gaW52U3ViTWl4M1tzYm94W3QgJiAweGZmXV07XG4gICAgICB9XG5cbiAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludktleVNjaGVkdWxlW2ludktzUm93XSA+Pj4gMDtcbiAgICB9XG4gIH1cblxuICAvLyBBZGRpbmcgdGhpcyBhcyBhIG1ldGhvZCBncmVhdGx5IGltcHJvdmVzIHBlcmZvcm1hbmNlLlxuICBuZXR3b3JrVG9Ib3N0T3JkZXJTd2FwICh3b3JkKSB7XG4gICAgcmV0dXJuICh3b3JkIDw8IDI0KSB8ICgod29yZCAmIDB4ZmYwMCkgPDwgOCkgfCAoKHdvcmQgJiAweGZmMDAwMCkgPj4gOCkgfCAod29yZCA+Pj4gMjQpO1xuICB9XG5cbiAgZGVjcnlwdCAoaW5wdXRBcnJheUJ1ZmZlciwgb2Zmc2V0LCBhZXNJViwgcmVtb3ZlUEtDUzdQYWRkaW5nKSB7XG4gICAgbGV0IG5Sb3VuZHMgPSB0aGlzLmtleVNpemUgKyA2O1xuICAgIGxldCBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGU7XG4gICAgbGV0IGludlNCT1ggPSB0aGlzLmludlNCb3g7XG5cbiAgICBsZXQgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgbGV0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgbGV0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgbGV0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgbGV0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG5cbiAgICBsZXQgaW5pdFZlY3RvciA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGFlc0lWKTtcbiAgICBsZXQgaW5pdFZlY3RvcjAgPSBpbml0VmVjdG9yWzBdO1xuICAgIGxldCBpbml0VmVjdG9yMSA9IGluaXRWZWN0b3JbMV07XG4gICAgbGV0IGluaXRWZWN0b3IyID0gaW5pdFZlY3RvclsyXTtcbiAgICBsZXQgaW5pdFZlY3RvcjMgPSBpbml0VmVjdG9yWzNdO1xuXG4gICAgbGV0IGlucHV0SW50MzIgPSBuZXcgSW50MzJBcnJheShpbnB1dEFycmF5QnVmZmVyKTtcbiAgICBsZXQgb3V0cHV0SW50MzIgPSBuZXcgSW50MzJBcnJheShpbnB1dEludDMyLmxlbmd0aCk7XG5cbiAgICBsZXQgdDAsIHQxLCB0MiwgdDM7XG4gICAgbGV0IHMwLCBzMSwgczIsIHMzO1xuICAgIGxldCBpbnB1dFdvcmRzMCwgaW5wdXRXb3JkczEsIGlucHV0V29yZHMyLCBpbnB1dFdvcmRzMztcblxuICAgIGxldCBrc1JvdywgaTtcbiAgICBsZXQgc3dhcFdvcmQgPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXA7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgaW5wdXRJbnQzMi5sZW5ndGgpIHtcbiAgICAgIGlucHV0V29yZHMwID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXRdKTtcbiAgICAgIGlucHV0V29yZHMxID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAxXSk7XG4gICAgICBpbnB1dFdvcmRzMiA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgMl0pO1xuICAgICAgaW5wdXRXb3JkczMgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDNdKTtcblxuICAgICAgczAgPSBpbnB1dFdvcmRzMCBeIGludktleVNjaGVkdWxlWzBdO1xuICAgICAgczEgPSBpbnB1dFdvcmRzMyBeIGludktleVNjaGVkdWxlWzFdO1xuICAgICAgczIgPSBpbnB1dFdvcmRzMiBeIGludktleVNjaGVkdWxlWzJdO1xuICAgICAgczMgPSBpbnB1dFdvcmRzMSBeIGludktleVNjaGVkdWxlWzNdO1xuXG4gICAgICBrc1JvdyA9IDQ7XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcm91bmRzIG9mIGRlY3J5cHRpb25cbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuUm91bmRzOyBpKyspIHtcbiAgICAgICAgdDAgPSBpbnZTdWJNaXgwW3MwID4+PiAyNF0gXiBpbnZTdWJNaXgxWyhzMSA+PiAxNikgJiAweGZmXSBeIGludlN1Yk1peDJbKHMyID4+IDgpICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MzICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICAgIHQxID0gaW52U3ViTWl4MFtzMSA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczIgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMyA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMCAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgICAgdDIgPSBpbnZTdWJNaXgwW3MyID4+PiAyNF0gXiBpbnZTdWJNaXgxWyhzMyA+PiAxNikgJiAweGZmXSBeIGludlN1Yk1peDJbKHMwID4+IDgpICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MxICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xuICAgICAgICB0MyA9IGludlN1Yk1peDBbczMgPj4+IDI0XSBeIGludlN1Yk1peDFbKHMwID4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4MlsoczEgPj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbczIgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107XG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgICAgICBzMCA9IHQwO1xuICAgICAgICBzMSA9IHQxO1xuICAgICAgICBzMiA9IHQyO1xuICAgICAgICBzMyA9IHQzO1xuXG4gICAgICAgIGtzUm93ID0ga3NSb3cgKyA0O1xuICAgICAgfVxuXG4gICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcbiAgICAgIHQwID0gKChpbnZTQk9YW3MwID4+PiAyNF0gPDwgMjQpIF4gKGludlNCT1hbKHMxID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeIChpbnZTQk9YWyhzMiA+PiA4KSAmIDB4ZmZdIDw8IDgpIF4gaW52U0JPWFtzMyAmIDB4ZmZdKSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgIHQxID0gKChpbnZTQk9YW3MxID4+PiAyNF0gPDwgMjQpIF4gKGludlNCT1hbKHMyID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeIChpbnZTQk9YWyhzMyA+PiA4KSAmIDB4ZmZdIDw8IDgpIF4gaW52U0JPWFtzMCAmIDB4ZmZdKSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICB0MiA9ICgoaW52U0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSBeIChpbnZTQk9YWyhzMyA+PiAxNikgJiAweGZmXSA8PCAxNikgXiAoaW52U0JPWFsoczAgPj4gOCkgJiAweGZmXSA8PCA4KSBeIGludlNCT1hbczEgJiAweGZmXSkgXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xuICAgICAgdDMgPSAoKGludlNCT1hbczMgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczAgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMxID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MyICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcbiAgICAgIGtzUm93ID0ga3NSb3cgKyAzO1xuXG4gICAgICAvLyBXcml0ZVxuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0XSA9IHN3YXBXb3JkKHQwIF4gaW5pdFZlY3RvcjApO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgMV0gPSBzd2FwV29yZCh0MyBeIGluaXRWZWN0b3IxKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDJdID0gc3dhcFdvcmQodDIgXiBpbml0VmVjdG9yMik7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAzXSA9IHN3YXBXb3JkKHQxIF4gaW5pdFZlY3RvcjMpO1xuXG4gICAgICAvLyByZXNldCBpbml0VmVjdG9yIHRvIGxhc3QgNCB1bnNpZ25lZCBpbnRcbiAgICAgIGluaXRWZWN0b3IwID0gaW5wdXRXb3JkczA7XG4gICAgICBpbml0VmVjdG9yMSA9IGlucHV0V29yZHMxO1xuICAgICAgaW5pdFZlY3RvcjIgPSBpbnB1dFdvcmRzMjtcbiAgICAgIGluaXRWZWN0b3IzID0gaW5wdXRXb3JkczM7XG5cbiAgICAgIG9mZnNldCA9IG9mZnNldCArIDQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbW92ZVBLQ1M3UGFkZGluZyA/IHJlbW92ZVBhZGRpbmcob3V0cHV0SW50MzIuYnVmZmVyKSA6IG91dHB1dEludDMyLmJ1ZmZlcjtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMua2V5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMua2V5U2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmtzUm93cyA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuc0JveCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmludlNCb3ggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdWJNaXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbnZTdWJNaXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5rZXlTY2hlZHVsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmludktleVNjaGVkdWxlID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5yY29uID0gdW5kZWZpbmVkO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFFU0RlY3J5cHRvcjtcbiIsImltcG9ydCBBRVNDcnlwdG8gZnJvbSAnLi9hZXMtY3J5cHRvJztcbmltcG9ydCBGYXN0QUVTS2V5IGZyb20gJy4vZmFzdC1hZXMta2V5JztcbmltcG9ydCBBRVNEZWNyeXB0b3IgZnJvbSAnLi9hZXMtZGVjcnlwdG9yJztcblxuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuXG5pbXBvcnQgeyBnZXRTZWxmU2NvcGUgfSBmcm9tICcuLi91dGlscy9nZXQtc2VsZi1zY29wZSc7XG5cbi8vIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTEyMzcyNTkvNTg5NDkzXG5jb25zdCBnbG9iYWwgPSBnZXRTZWxmU2NvcGUoKTsgLy8gc2FmZWd1YXJkIGZvciBjb2RlIHRoYXQgbWlnaHQgcnVuIGJvdGggb24gd29ya2VyIGFuZCBtYWluIHRocmVhZFxuXG5jbGFzcyBEZWNyeXB0ZXIge1xuICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIsIGNvbmZpZywgeyByZW1vdmVQS0NTN1BhZGRpbmcgPSB0cnVlIH0gPSB7fSkge1xuICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nID0gcmVtb3ZlUEtDUzdQYWRkaW5nO1xuICAgIC8vIGJ1aWx0IGluIGRlY3J5cHRvciBleHBlY3RzIFBLQ1M3IHBhZGRpbmdcbiAgICBpZiAocmVtb3ZlUEtDUzdQYWRkaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBicm93c2VyQ3J5cHRvID0gZ2xvYmFsLmNyeXB0bztcbiAgICAgICAgaWYgKGJyb3dzZXJDcnlwdG8pIHtcbiAgICAgICAgICB0aGlzLnN1YnRsZSA9IGJyb3dzZXJDcnlwdG8uc3VidGxlIHx8IGJyb3dzZXJDcnlwdG8ud2Via2l0U3VidGxlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgICB0aGlzLmRpc2FibGVXZWJDcnlwdG8gPSAhdGhpcy5zdWJ0bGU7XG4gIH1cblxuICBpc1N5bmMgKCkge1xuICAgIHJldHVybiAodGhpcy5kaXNhYmxlV2ViQ3J5cHRvICYmIHRoaXMuY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTKTtcbiAgfVxuXG4gIGRlY3J5cHQgKGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZVdlYkNyeXB0byAmJiB0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUykge1xuICAgICAgaWYgKHRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgICBsb2dnZXIubG9nKCdKUyBBRVMgZGVjcnlwdCcpO1xuICAgICAgICB0aGlzLmxvZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBkZWNyeXB0b3IgPSB0aGlzLmRlY3J5cHRvcjtcbiAgICAgIGlmICghZGVjcnlwdG9yKSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdG9yID0gZGVjcnlwdG9yID0gbmV3IEFFU0RlY3J5cHRvcigpO1xuICAgICAgfVxuXG4gICAgICBkZWNyeXB0b3IuZXhwYW5kS2V5KGtleSk7XG4gICAgICBjYWxsYmFjayhkZWNyeXB0b3IuZGVjcnlwdChkYXRhLCAwLCBpdiwgdGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgICBsb2dnZXIubG9nKCdXZWJDcnlwdG8gQUVTIGRlY3J5cHQnKTtcbiAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBzdWJ0bGUgPSB0aGlzLnN1YnRsZTtcbiAgICAgIGlmICh0aGlzLmtleSAhPT0ga2V5KSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmZhc3RBZXNLZXkgPSBuZXcgRmFzdEFFU0tleShzdWJ0bGUsIGtleSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmFzdEFlc0tleS5leHBhbmRLZXkoKVxuICAgICAgICAudGhlbigoYWVzS2V5KSA9PiB7XG4gICAgICAgICAgLy8gZGVjcnlwdCB1c2luZyB3ZWIgY3J5cHRvXG4gICAgICAgICAgbGV0IGNyeXB0byA9IG5ldyBBRVNDcnlwdG8oc3VidGxlLCBpdik7XG4gICAgICAgICAgY3J5cHRvLmRlY3J5cHQoZGF0YSwgYWVzS2V5KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5vbldlYkNyeXB0b0Vycm9yKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHRoaXMub25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgb25XZWJDcnlwdG9FcnJvciAoZXJyLCBkYXRhLCBrZXksIGl2LCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUykge1xuICAgICAgbG9nZ2VyLmxvZygnV2ViQ3J5cHRvIEVycm9yLCBkaXNhYmxlIFdlYkNyeXB0byBBUEknKTtcbiAgICAgIHRoaXMuZGlzYWJsZVdlYkNyeXB0byA9IHRydWU7XG4gICAgICB0aGlzLmxvZ0VuYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5kZWNyeXB0KGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmVycm9yKGBkZWNyeXB0aW5nIGVycm9yIDogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiBlcnIubWVzc2FnZSB9KTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBsZXQgZGVjcnlwdG9yID0gdGhpcy5kZWNyeXB0b3I7XG4gICAgaWYgKGRlY3J5cHRvcikge1xuICAgICAgZGVjcnlwdG9yLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZGVjcnlwdG9yID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZWNyeXB0ZXI7XG4iLCJjbGFzcyBGYXN0QUVTS2V5IHtcbiAgY29uc3RydWN0b3IgKHN1YnRsZSwga2V5KSB7XG4gICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGU7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gIH1cblxuICBleHBhbmRLZXkgKCkge1xuICAgIHJldHVybiB0aGlzLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIHRoaXMua2V5LCB7IG5hbWU6ICdBRVMtQ0JDJyB9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRmFzdEFFU0tleTtcbiIsIi8qKlxuICogQUFDIGRlbXV4ZXJcbiAqL1xuaW1wb3J0ICogYXMgQURUUyBmcm9tICcuL2FkdHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCBJRDMgZnJvbSAnLi4vZGVtdXgvaWQzJztcblxuY2xhc3MgQUFDRGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yIChvYnNlcnZlciwgcmVtdXhlciwgY29uZmlnKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XG4gIH1cblxuICByZXNldEluaXRTZWdtZW50IChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0geyBjb250YWluZXI6ICdhdWRpby9hZHRzJywgdHlwZTogJ2F1ZGlvJywgaWQ6IDAsIHNlcXVlbmNlTnVtYmVyOiAwLCBpc0FBQzogdHJ1ZSwgc2FtcGxlczogW10sIGxlbjogMCwgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYywgZHVyYXRpb246IGR1cmF0aW9uLCBpbnB1dFRpbWVTY2FsZTogOTAwMDAgfTtcbiAgfVxuXG4gIHJlc2V0VGltZVN0YW1wICgpIHtcbiAgfVxuXG4gIHN0YXRpYyBwcm9iZSAoZGF0YSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciB0aGUgQURUUyBzeW5jIHdvcmRcbiAgICAvLyBMb29rIGZvciBBRFRTIGhlYWRlciB8IDExMTEgMTExMSB8IDExMTEgWDAwWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDFcbiAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcbiAgICAvLyBNb3JlIGluZm8gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgICBjb25zdCBpZDNEYXRhID0gSUQzLmdldElEM0RhdGEoZGF0YSwgMCkgfHwgW107XG4gICAgbGV0IG9mZnNldCA9IGlkM0RhdGEubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgbGVuZ3RoID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICAgIGlmIChBRFRTLnByb2JlKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnQURUUyBzeW5jIHdvcmQgZm91bmQgIScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICBhcHBlbmQgKGRhdGEsIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIGxldCB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG4gICAgbGV0IGlkM0RhdGEgPSBJRDMuZ2V0SUQzRGF0YShkYXRhLCAwKSB8fCBbXTtcbiAgICBsZXQgdGltZXN0YW1wID0gSUQzLmdldFRpbWVTdGFtcChpZDNEYXRhKTtcbiAgICBsZXQgcHRzID0gTnVtYmVyLmlzRmluaXRlKHRpbWVzdGFtcCkgPyB0aW1lc3RhbXAgKiA5MCA6IHRpbWVPZmZzZXQgKiA5MDAwMDtcbiAgICBsZXQgZnJhbWVJbmRleCA9IDA7XG4gICAgbGV0IHN0YW1wID0gcHRzO1xuICAgIGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICBsZXQgb2Zmc2V0ID0gaWQzRGF0YS5sZW5ndGg7XG5cbiAgICBsZXQgaWQzU2FtcGxlcyA9IFt7IHB0czogc3RhbXAsIGR0czogc3RhbXAsIGRhdGE6IGlkM0RhdGEgfV07XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoIC0gMSkge1xuICAgICAgaWYgKEFEVFMuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSAmJiAob2Zmc2V0ICsgNSkgPCBsZW5ndGgpIHtcbiAgICAgICAgQURUUy5pbml0VHJhY2tDb25maWcodHJhY2ssIHRoaXMub2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgdHJhY2subWFuaWZlc3RDb2RlYyk7XG4gICAgICAgIGxldCBmcmFtZSA9IEFEVFMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICBzdGFtcCA9IGZyYW1lLnNhbXBsZS5wdHM7XG4gICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBBQUMgZnJhbWUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChJRDMuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBpZDNEYXRhID0gSUQzLmdldElEM0RhdGEoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgaWQzU2FtcGxlcy5wdXNoKHsgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcCwgZGF0YTogaWQzRGF0YSB9KTtcbiAgICAgICAgb2Zmc2V0ICs9IGlkM0RhdGEubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBmb3VuZCwga2VlcCBsb29raW5nXG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVtdXhlci5yZW11eCh0cmFjayxcbiAgICAgIHsgc2FtcGxlczogW10gfSxcbiAgICAgIHsgc2FtcGxlczogaWQzU2FtcGxlcywgaW5wdXRUaW1lU2NhbGU6IDkwMDAwIH0sXG4gICAgICB7IHNhbXBsZXM6IFtdIH0sXG4gICAgICB0aW1lT2Zmc2V0LFxuICAgICAgY29udGlndW91cyxcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBQUNEZW11eGVyO1xuIiwiLyoqXG4gKiAgQURUUyBwYXJzZXIgaGVscGVyXG4gKi9cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcblxuaW1wb3J0IHsgZ2V0U2VsZlNjb3BlIH0gZnJvbSAnLi4vdXRpbHMvZ2V0LXNlbGYtc2NvcGUnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXVkaW9Db25maWcgKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgbGV0IGFkdHNPYmplY3RUeXBlLCAvLyA6aW50XG4gICAgYWR0c1NhbXBsZWluZ0luZGV4LCAvLyA6aW50XG4gICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4LCAvLyA6aW50XG4gICAgYWR0c0NoYW5lbENvbmZpZywgLy8gOmludFxuICAgIGNvbmZpZyxcbiAgICB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksXG4gICAgbWFuaWZlc3RDb2RlYyA9IGF1ZGlvQ29kZWMsXG4gICAgYWR0c1NhbXBsZWluZ1JhdGVzID0gW1xuICAgICAgOTYwMDAsIDg4MjAwLFxuICAgICAgNjQwMDAsIDQ4MDAwLFxuICAgICAgNDQxMDAsIDMyMDAwLFxuICAgICAgMjQwMDAsIDIyMDUwLFxuICAgICAgMTYwMDAsIDEyMDAwLFxuICAgICAgMTEwMjUsIDgwMDAsXG4gICAgICA3MzUwXTtcbiAgLy8gYnl0ZSAyXG4gIGFkdHNPYmplY3RUeXBlID0gKChkYXRhW29mZnNldCArIDJdICYgMHhDMCkgPj4+IDYpICsgMTtcbiAgYWR0c1NhbXBsZWluZ0luZGV4ID0gKChkYXRhW29mZnNldCArIDJdICYgMHgzQykgPj4+IDIpO1xuICBpZiAoYWR0c1NhbXBsZWluZ0luZGV4ID4gYWR0c1NhbXBsZWluZ1JhdGVzLmxlbmd0aCAtIDEpIHtcbiAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCByZWFzb246IGBpbnZhbGlkIEFEVFMgc2FtcGxpbmcgaW5kZXg6JHthZHRzU2FtcGxlaW5nSW5kZXh9YCB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgYWR0c0NoYW5lbENvbmZpZyA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4MDEpIDw8IDIpO1xuICAvLyBieXRlIDNcbiAgYWR0c0NoYW5lbENvbmZpZyB8PSAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweEMwKSA+Pj4gNik7XG4gIGxvZ2dlci5sb2coYG1hbmlmZXN0IGNvZGVjOiR7YXVkaW9Db2RlY30sQURUUyBkYXRhOnR5cGU6JHthZHRzT2JqZWN0VHlwZX0sc2FtcGxlaW5nSW5kZXg6JHthZHRzU2FtcGxlaW5nSW5kZXh9WyR7YWR0c1NhbXBsZWluZ1JhdGVzW2FkdHNTYW1wbGVpbmdJbmRleF19SHpdLGNoYW5uZWxDb25maWc6JHthZHRzQ2hhbmVsQ29uZmlnfWApO1xuICAvLyBmaXJlZm94OiBmcmVxIGxlc3MgdGhhbiAyNGtIeiA9IEFBQyBTQlIgKEhFLUFBQylcbiAgaWYgKC9maXJlZm94L2kudGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgaWYgKGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2KSB7XG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4IC0gMztcbiAgICB9IGVsc2Uge1xuICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xuICAgIH1cbiAgICAvLyBBbmRyb2lkIDogYWx3YXlzIHVzZSBBQUNcbiAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSkge1xuICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xuICB9IGVsc2Uge1xuICAgIC8qICBmb3Igb3RoZXIgYnJvd3NlcnMgKENocm9tZS9WaXZhbGRpL09wZXJhIC4uLilcbiAgICAgICAgYWx3YXlzIGZvcmNlIGF1ZGlvIHR5cGUgdG8gYmUgSEUtQUFDIFNCUiwgYXMgc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBhdWRpbyBjb2RlYyBzd2l0Y2ggcHJvcGVybHkgKGxpa2UgQ2hyb21lIC4uLilcbiAgICAqL1xuICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEhFLUFBQyBvciBIRS1BQUN2MikgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgQU5EIGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHopXG4gICAgaWYgKChhdWRpb0NvZGVjICYmICgoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjI5JykgIT09IC0xKSB8fFxuICAgICAgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSkpIHx8XG4gICAgICAoIWF1ZGlvQ29kZWMgJiYgYWR0c1NhbXBsZWluZ0luZGV4ID49IDYpKSB7XG4gICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4IC0gMztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEFBQykgQU5EIChmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6IEFORCBuYiBjaGFubmVsIGlzIDEpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIGFuZCBtb25vIGF1ZGlvKVxuICAgICAgLy8gQ2hyb21lIGZhaWxzIHRvIHBsYXkgYmFjayB3aXRoIGxvdyBmcmVxdWVuY3kgQUFDIExDIG1vbm8gd2hlbiBpbml0aWFsaXplZCB3aXRoIEhFLUFBQy4gIFRoaXMgaXMgbm90IGEgcHJvYmxlbSB3aXRoIHN0ZXJlby5cbiAgICAgIGlmIChhdWRpb0NvZGVjICYmIGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xICYmICgoYWR0c1NhbXBsZWluZ0luZGV4ID49IDYgJiYgYWR0c0NoYW5lbENvbmZpZyA9PT0gMSkgfHxcbiAgICAgICAgICAgIC92aXZhbGRpL2kudGVzdCh1c2VyQWdlbnQpKSB8fFxuICAgICAgICAoIWF1ZGlvQ29kZWMgJiYgYWR0c0NoYW5lbENvbmZpZyA9PT0gMSkpIHtcbiAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICB9XG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXg7XG4gICAgfVxuICB9XG4gIC8qIHJlZmVyIHRvIGh0dHA6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPU1QRUctNF9BdWRpbyNBdWRpb19TcGVjaWZpY19Db25maWdcbiAgICAgIElTTyAxNDQ5Ni0zIChBQUMpLnBkZiAtIFRhYmxlIDEuMTMg4oCUIFN5bnRheCBvZiBBdWRpb1NwZWNpZmljQ29uZmlnKClcbiAgICBBdWRpbyBQcm9maWxlIC8gQXVkaW8gT2JqZWN0IFR5cGVcbiAgICAwOiBOdWxsXG4gICAgMTogQUFDIE1haW5cbiAgICAyOiBBQUMgTEMgKExvdyBDb21wbGV4aXR5KVxuICAgIDM6IEFBQyBTU1IgKFNjYWxhYmxlIFNhbXBsZSBSYXRlKVxuICAgIDQ6IEFBQyBMVFAgKExvbmcgVGVybSBQcmVkaWN0aW9uKVxuICAgIDU6IFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbilcbiAgICA2OiBBQUMgU2NhbGFibGVcbiAgIHNhbXBsaW5nIGZyZXFcbiAgICAwOiA5NjAwMCBIelxuICAgIDE6IDg4MjAwIEh6XG4gICAgMjogNjQwMDAgSHpcbiAgICAzOiA0ODAwMCBIelxuICAgIDQ6IDQ0MTAwIEh6XG4gICAgNTogMzIwMDAgSHpcbiAgICA2OiAyNDAwMCBIelxuICAgIDc6IDIyMDUwIEh6XG4gICAgODogMTYwMDAgSHpcbiAgICA5OiAxMjAwMCBIelxuICAgIDEwOiAxMTAyNSBIelxuICAgIDExOiA4MDAwIEh6XG4gICAgMTI6IDczNTAgSHpcbiAgICAxMzogUmVzZXJ2ZWRcbiAgICAxNDogUmVzZXJ2ZWRcbiAgICAxNTogZnJlcXVlbmN5IGlzIHdyaXR0ZW4gZXhwbGljdGx5XG4gICAgQ2hhbm5lbCBDb25maWd1cmF0aW9uc1xuICAgIFRoZXNlIGFyZSB0aGUgY2hhbm5lbCBjb25maWd1cmF0aW9uczpcbiAgICAwOiBEZWZpbmVkIGluIEFPVCBTcGVjaWZjIENvbmZpZ1xuICAgIDE6IDEgY2hhbm5lbDogZnJvbnQtY2VudGVyXG4gICAgMjogMiBjaGFubmVsczogZnJvbnQtbGVmdCwgZnJvbnQtcmlnaHRcbiAgKi9cbiAgLy8gYXVkaW9PYmplY3RUeXBlID0gcHJvZmlsZSA9PiBwcm9maWxlLCB0aGUgTVBFRy00IEF1ZGlvIE9iamVjdCBUeXBlIG1pbnVzIDFcbiAgY29uZmlnWzBdID0gYWR0c09iamVjdFR5cGUgPDwgMztcbiAgLy8gc2FtcGxpbmdGcmVxdWVuY3lJbmRleFxuICBjb25maWdbMF0gfD0gKGFkdHNTYW1wbGVpbmdJbmRleCAmIDB4MEUpID4+IDE7XG4gIGNvbmZpZ1sxXSB8PSAoYWR0c1NhbXBsZWluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgLy8gY2hhbm5lbENvbmZpZ3VyYXRpb25cbiAgY29uZmlnWzFdIHw9IGFkdHNDaGFuZWxDb25maWcgPDwgMztcbiAgaWYgKGFkdHNPYmplY3RUeXBlID09PSA1KSB7XG4gICAgLy8gYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4XG4gICAgY29uZmlnWzFdIHw9IChhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggJiAweDBFKSA+PiAxO1xuICAgIGNvbmZpZ1syXSA9IChhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAgIC8vIGFkdHNPYmplY3RUeXBlIChmb3JjZSB0byAyLCBjaHJvbWUgaXMgY2hlY2tpbmcgdGhhdCBvYmplY3QgdHlwZSBpcyBsZXNzIHRoYW4gNSA/Pz9cbiAgICAvLyAgICBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLmdpdC8rL21hc3Rlci9tZWRpYS9mb3JtYXRzL21wNC9hYWMuY2NcbiAgICBjb25maWdbMl0gfD0gMiA8PCAyO1xuICAgIGNvbmZpZ1szXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHsgY29uZmlnOiBjb25maWcsIHNhbXBsZXJhdGU6IGFkdHNTYW1wbGVpbmdSYXRlc1thZHRzU2FtcGxlaW5nSW5kZXhdLCBjaGFubmVsQ291bnQ6IGFkdHNDaGFuZWxDb25maWcsIGNvZGVjOiAoJ21wNGEuNDAuJyArIGFkdHNPYmplY3RUeXBlKSwgbWFuaWZlc3RDb2RlYzogbWFuaWZlc3RDb2RlYyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNIZWFkZXJQYXR0ZXJuIChkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRhdGFbb2Zmc2V0XSA9PT0gMHhmZiAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZjYpID09PSAweGYwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGVhZGVyTGVuZ3RoIChkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIChkYXRhW29mZnNldCArIDFdICYgMHgwMSA/IDcgOiA5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZ1bGxGcmFtZUxlbmd0aCAoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDAzKSA8PCAxMSkgfFxuICAgIChkYXRhW29mZnNldCArIDRdIDw8IDMpIHxcbiAgICAoKGRhdGFbb2Zmc2V0ICsgNV0gJiAweEUwKSA+Pj4gNSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hlYWRlciAoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxuICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcbiAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gIGlmIChvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2JlIChkYXRhLCBvZmZzZXQpIHtcbiAgLy8gc2FtZSBhcyBpc0hlYWRlciBidXQgd2UgYWxzbyBjaGVjayB0aGF0IEFEVFMgZnJhbWUgZm9sbG93cyBsYXN0IEFEVFMgZnJhbWVcbiAgLy8gb3IgZW5kIG9mIGRhdGEgaXMgcmVhY2hlZFxuICBpZiAob2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpKSB7XG4gICAgLy8gQURUUyBoZWFkZXIgTGVuZ3RoXG4gICAgbGV0IGhlYWRlckxlbmd0aCA9IGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAgIC8vIEFEVFMgZnJhbWUgTGVuZ3RoXG4gICAgbGV0IGZyYW1lTGVuZ3RoID0gaGVhZGVyTGVuZ3RoO1xuICAgIGlmIChvZmZzZXQgKyA1IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgIGZyYW1lTGVuZ3RoID0gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgbGV0IG5ld09mZnNldCA9IG9mZnNldCArIGZyYW1lTGVuZ3RoO1xuICAgIGlmIChuZXdPZmZzZXQgPT09IGRhdGEubGVuZ3RoIHx8IChuZXdPZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG5ld09mZnNldCkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFRyYWNrQ29uZmlnICh0cmFjaywgb2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYykge1xuICBpZiAoIXRyYWNrLnNhbXBsZXJhdGUpIHtcbiAgICBsZXQgY29uZmlnID0gZ2V0QXVkaW9Db25maWcob2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYyk7XG4gICAgdHJhY2suY29uZmlnID0gY29uZmlnLmNvbmZpZztcbiAgICB0cmFjay5zYW1wbGVyYXRlID0gY29uZmlnLnNhbXBsZXJhdGU7XG4gICAgdHJhY2suY2hhbm5lbENvdW50ID0gY29uZmlnLmNoYW5uZWxDb3VudDtcbiAgICB0cmFjay5jb2RlYyA9IGNvbmZpZy5jb2RlYztcbiAgICB0cmFjay5tYW5pZmVzdENvZGVjID0gY29uZmlnLm1hbmlmZXN0Q29kZWM7XG4gICAgbG9nZ2VyLmxvZyhgcGFyc2VkIGNvZGVjOiR7dHJhY2suY29kZWN9LHJhdGU6JHtjb25maWcuc2FtcGxlcmF0ZX0sbmIgY2hhbm5lbDoke2NvbmZpZy5jaGFubmVsQ291bnR9YCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYW1lRHVyYXRpb24gKHNhbXBsZXJhdGUpIHtcbiAgcmV0dXJuIDEwMjQgKiA5MDAwMCAvIHNhbXBsZXJhdGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZyYW1lSGVhZGVyIChkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCwgZnJhbWVEdXJhdGlvbikge1xuICBsZXQgaGVhZGVyTGVuZ3RoLCBmcmFtZUxlbmd0aCwgc3RhbXA7XG4gIGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAvLyBUaGUgcHJvdGVjdGlvbiBza2lwIGJpdCB0ZWxscyB1cyBpZiB3ZSBoYXZlIDIgYnl0ZXMgb2YgQ1JDIGRhdGEgYXQgdGhlIGVuZCBvZiB0aGUgQURUUyBoZWFkZXJcbiAgaGVhZGVyTGVuZ3RoID0gZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG4gIC8vIHJldHJpZXZlIGZyYW1lIHNpemVcbiAgZnJhbWVMZW5ndGggPSBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgZnJhbWVMZW5ndGggLT0gaGVhZGVyTGVuZ3RoO1xuXG4gIGlmICgoZnJhbWVMZW5ndGggPiAwKSAmJiAoKG9mZnNldCArIGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoKSA8PSBsZW5ndGgpKSB7XG4gICAgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICAvLyBsb2dnZXIubG9nKGBBQUMgZnJhbWUsIG9mZnNldC9sZW5ndGgvdG90YWwvcHRzOiR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtmcmFtZUxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9LyR7KHN0YW1wLzkwKS50b0ZpeGVkKDApfWApO1xuICAgIHJldHVybiB7IGhlYWRlckxlbmd0aCwgZnJhbWVMZW5ndGgsIHN0YW1wIH07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kRnJhbWUgKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCkge1xuICBsZXQgZnJhbWVEdXJhdGlvbiA9IGdldEZyYW1lRHVyYXRpb24odHJhY2suc2FtcGxlcmF0ZSk7XG4gIGxldCBoZWFkZXIgPSBwYXJzZUZyYW1lSGVhZGVyKGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4LCBmcmFtZUR1cmF0aW9uKTtcbiAgaWYgKGhlYWRlcikge1xuICAgIGxldCBzdGFtcCA9IGhlYWRlci5zdGFtcDtcbiAgICBsZXQgaGVhZGVyTGVuZ3RoID0gaGVhZGVyLmhlYWRlckxlbmd0aDtcbiAgICBsZXQgZnJhbWVMZW5ndGggPSBoZWFkZXIuZnJhbWVMZW5ndGg7XG5cbiAgICAvLyBsb2dnZXIubG9nKGBBQUMgZnJhbWUsIG9mZnNldC9sZW5ndGgvdG90YWwvcHRzOiR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtmcmFtZUxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9LyR7KHN0YW1wLzkwKS50b0ZpeGVkKDApfWApO1xuICAgIGxldCBhYWNTYW1wbGUgPSB7XG4gICAgICB1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgb2Zmc2V0ICsgaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGgpLFxuICAgICAgcHRzOiBzdGFtcCxcbiAgICAgIGR0czogc3RhbXBcbiAgICB9O1xuXG4gICAgdHJhY2suc2FtcGxlcy5wdXNoKGFhY1NhbXBsZSk7XG4gICAgdHJhY2subGVuICs9IGZyYW1lTGVuZ3RoO1xuXG4gICAgcmV0dXJuIHsgc2FtcGxlOiBhYWNTYW1wbGUsIGxlbmd0aDogZnJhbWVMZW5ndGggKyBoZWFkZXJMZW5ndGggfTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iLCIvKipcbiAqXG4gKiBpbmxpbmUgZGVtdXhlcjogcHJvYmUgZnJhZ21lbnRzIGFuZCBpbnN0YW50aWF0ZVxuICogYXBwcm9wcmlhdGUgZGVtdXhlciBkZXBlbmRpbmcgb24gY29udGVudCB0eXBlIChUU0RlbXV4ZXIsIEFBQ0RlbXV4ZXIsIC4uLilcbiAqXG4gKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IERlY3J5cHRlciBmcm9tICcuLi9jcnlwdC9kZWNyeXB0ZXInO1xuaW1wb3J0IEFBQ0RlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvYWFjZGVtdXhlcic7XG5pbXBvcnQgTVA0RGVtdXhlciBmcm9tICcuLi9kZW11eC9tcDRkZW11eGVyJztcbmltcG9ydCBUU0RlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvdHNkZW11eGVyJztcbmltcG9ydCBNUDNEZW11eGVyIGZyb20gJy4uL2RlbXV4L21wM2RlbXV4ZXInO1xuaW1wb3J0IE1QNFJlbXV4ZXIgZnJvbSAnLi4vcmVtdXgvbXA0LXJlbXV4ZXInO1xuaW1wb3J0IFBhc3NUaHJvdWdoUmVtdXhlciBmcm9tICcuLi9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyJztcblxuaW1wb3J0IHsgZ2V0U2VsZlNjb3BlIH0gZnJvbSAnLi4vdXRpbHMvZ2V0LXNlbGYtc2NvcGUnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuLy8gc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTIzNzI1OS81ODk0OTNcbmNvbnN0IGdsb2JhbCA9IGdldFNlbGZTY29wZSgpOyAvLyBzYWZlZ3VhcmQgZm9yIGNvZGUgdGhhdCBtaWdodCBydW4gYm90aCBvbiB3b3JrZXIgYW5kIG1haW4gdGhyZWFkXG5cbmxldCBub3c7XG4vLyBwZXJmb3JtYW5jZS5ub3coKSBub3QgYXZhaWxhYmxlIG9uIFdlYldvcmtlciwgYXQgbGVhc3Qgb24gU2FmYXJpIERlc2t0b3BcbnRyeSB7XG4gIG5vdyA9IGdsb2JhbC5wZXJmb3JtYW5jZS5ub3cuYmluZChnbG9iYWwucGVyZm9ybWFuY2UpO1xufSBjYXRjaCAoZXJyKSB7XG4gIGxvZ2dlci5kZWJ1ZygnVW5hYmxlIHRvIHVzZSBQZXJmb3JtYW5jZSBBUEkgb24gdGhpcyBlbnZpcm9ubWVudCcpO1xuICBub3cgPSBnbG9iYWwuRGF0ZS5ub3c7XG59XG5cbmNsYXNzIERlbXV4ZXJJbmxpbmUge1xuICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgdmVuZG9yKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy52ZW5kb3IgPSB2ZW5kb3I7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICBpZiAoZGVtdXhlcikge1xuICAgICAgZGVtdXhlci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG5cbiAgcHVzaCAoZGF0YSwgZGVjcnlwdGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICBpZiAoKGRhdGEuYnl0ZUxlbmd0aCA+IDApICYmIChkZWNyeXB0ZGF0YSAhPSBudWxsKSAmJiAoZGVjcnlwdGRhdGEua2V5ICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5tZXRob2QgPT09ICdBRVMtMTI4JykpIHtcbiAgICAgIGxldCBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlcjtcbiAgICAgIGlmIChkZWNyeXB0ZXIgPT0gbnVsbCkge1xuICAgICAgICBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIodGhpcy5vYnNlcnZlciwgdGhpcy5jb25maWcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBub3coKTtcbiAgICAgIGRlY3J5cHRlci5kZWNyeXB0KGRhdGEsIGRlY3J5cHRkYXRhLmtleS5idWZmZXIsIGRlY3J5cHRkYXRhLml2LmJ1ZmZlciwgKGRlY3J5cHRlZERhdGEpID0+IHtcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IG5vdygpO1xuICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19ERUNSWVBURUQsIHsgc3RhdHM6IHsgdHN0YXJ0OiBzdGFydFRpbWUsIHRkZWNyeXB0OiBlbmRUaW1lIH0gfSk7XG4gICAgICAgIHRoaXMucHVzaERlY3J5cHRlZChuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKSwgZGVjcnlwdGRhdGEsIG5ldyBVaW50OEFycmF5KGluaXRTZWdtZW50KSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hEZWNyeXB0ZWQobmV3IFVpbnQ4QXJyYXkoZGF0YSksIGRlY3J5cHRkYXRhLCBuZXcgVWludDhBcnJheShpbml0U2VnbWVudCksIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUyk7XG4gICAgfVxuICB9XG5cbiAgcHVzaERlY3J5cHRlZCAoZGF0YSwgZGVjcnlwdGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICBpZiAoIWRlbXV4ZXIgfHxcbiAgICAgIC8vIGluIGNhc2Ugb2YgY29udGludWl0eSBjaGFuZ2UsIG9yIHRyYWNrIHN3aXRjaFxuICAgICAgLy8gd2UgbWlnaHQgc3dpdGNoIGZyb20gY29udGVudCB0eXBlIChBQUMgY29udGFpbmVyIHRvIFRTIGNvbnRhaW5lciwgb3IgVFMgdG8gZm1wNCBmb3IgZXhhbXBsZSlcbiAgICAgIC8vIHNvIGxldCdzIGNoZWNrIHRoYXQgY3VycmVudCBkZW11eGVyIGlzIHN0aWxsIHZhbGlkXG4gICAgICAoKGRpc2NvbnRpbnVpdHkgfHwgdHJhY2tTd2l0Y2gpICYmICF0aGlzLnByb2JlKGRhdGEpKSkge1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgICAgY29uc3QgdHlwZVN1cHBvcnRlZCA9IHRoaXMudHlwZVN1cHBvcnRlZDtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgLy8gcHJvYmluZyBvcmRlciBpcyBUUy9BQUMvTVAzL01QNFxuICAgICAgY29uc3QgbXV4Q29uZmlnID0gW1xuICAgICAgICB7IGRlbXV4OiBUU0RlbXV4ZXIsIHJlbXV4OiBNUDRSZW11eGVyIH0sXG4gICAgICAgIHsgZGVtdXg6IE1QNERlbXV4ZXIsIHJlbXV4OiBQYXNzVGhyb3VnaFJlbXV4ZXIgfSxcbiAgICAgICAgeyBkZW11eDogQUFDRGVtdXhlciwgcmVtdXg6IE1QNFJlbXV4ZXIgfSxcbiAgICAgICAgeyBkZW11eDogTVAzRGVtdXhlciwgcmVtdXg6IE1QNFJlbXV4ZXIgfVxuICAgICAgXTtcblxuICAgICAgLy8gcHJvYmUgZm9yIGNvbnRlbnQgdHlwZVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG11eENvbmZpZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBtdXggPSBtdXhDb25maWdbaV07XG4gICAgICAgIGNvbnN0IHByb2JlID0gbXV4LmRlbXV4LnByb2JlO1xuICAgICAgICBpZiAocHJvYmUoZGF0YSkpIHtcbiAgICAgICAgICBjb25zdCByZW11eGVyID0gdGhpcy5yZW11eGVyID0gbmV3IG11eC5yZW11eChvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCB0aGlzLnZlbmRvcik7XG4gICAgICAgICAgZGVtdXhlciA9IG5ldyBtdXguZGVtdXgob2JzZXJ2ZXIsIHJlbXV4ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCk7XG4gICAgICAgICAgdGhpcy5wcm9iZSA9IHByb2JlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWRlbXV4ZXIpIHtcbiAgICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiAnbm8gZGVtdXggbWF0Y2hpbmcgd2l0aCBjb250ZW50IGZvdW5kJyB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5kZW11eGVyID0gZGVtdXhlcjtcbiAgICB9XG4gICAgY29uc3QgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcblxuICAgIGlmIChkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoKSB7XG4gICAgICBkZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKTtcbiAgICAgIHJlbXV4ZXIucmVzZXRJbml0U2VnbWVudCgpO1xuICAgIH1cbiAgICBpZiAoZGlzY29udGludWl0eSkge1xuICAgICAgZGVtdXhlci5yZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFBUUyk7XG4gICAgICByZW11eGVyLnJlc2V0VGltZVN0YW1wKGRlZmF1bHRJbml0UFRTKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkZW11eGVyLnNldERlY3J5cHREYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkZW11eGVyLnNldERlY3J5cHREYXRhKGRlY3J5cHRkYXRhKTtcbiAgICB9XG5cbiAgICBkZW11eGVyLmFwcGVuZChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERlbXV4ZXJJbmxpbmU7XG4iLCIvKiBkZW11eGVyIHdlYiB3b3JrZXIuXG4gKiAgLSBsaXN0ZW4gdG8gd29ya2VyIG1lc3NhZ2UsIGFuZCB0cmlnZ2VyIERlbXV4ZXJJbmxpbmUgdXBvbiByZWNlcHRpb24gb2YgRnJhZ21lbnRzLlxuICogIC0gcHJvdmlkZXMgTVA0IEJveGVzIGJhY2sgdG8gbWFpbiB0aHJlYWQgdXNpbmcgW3RyYW5zZmVyYWJsZSBvYmplY3RzXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDExLzEyL1RyYW5zZmVyYWJsZS1PYmplY3RzLUxpZ2h0bmluZy1GYXN0KSBpbiBvcmRlciB0byBtaW5pbWl6ZSBtZXNzYWdlIHBhc3Npbmcgb3ZlcmhlYWQuXG4gKi9cblxuaW1wb3J0IERlbXV4ZXJJbmxpbmUgZnJvbSAnLi4vZGVtdXgvZGVtdXhlci1pbmxpbmUnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBlbmFibGVMb2dzIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcblxubGV0IERlbXV4ZXJXb3JrZXIgPSBmdW5jdGlvbiAoc2VsZikge1xuICAvLyBvYnNlcnZlciBzZXR1cFxuICBsZXQgb2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIG9ic2VydmVyLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyIChldmVudCwgLi4uZGF0YSkge1xuICAgIG9ic2VydmVyLmVtaXQoZXZlbnQsIGV2ZW50LCAuLi5kYXRhKTtcbiAgfTtcblxuICBvYnNlcnZlci5vZmYgPSBmdW5jdGlvbiBvZmYgKGV2ZW50LCAuLi5kYXRhKSB7XG4gICAgb2JzZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIC4uLmRhdGEpO1xuICB9O1xuXG4gIGxldCBmb3J3YXJkTWVzc2FnZSA9IGZ1bmN0aW9uIChldiwgZGF0YSkge1xuICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBldmVudDogZXYsIGRhdGE6IGRhdGEgfSk7XG4gIH07XG5cbiAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgbGV0IGRhdGEgPSBldi5kYXRhO1xuICAgIC8vIGNvbnNvbGUubG9nKCdkZW11eGVyIGNtZDonICsgZGF0YS5jbWQpO1xuICAgIHN3aXRjaCAoZGF0YS5jbWQpIHtcbiAgICBjYXNlICdpbml0JzpcbiAgICAgIGNvbnN0IGNvbmZpZyA9IEpTT04ucGFyc2UoZGF0YS5jb25maWcpO1xuICAgICAgc2VsZi5kZW11eGVyID0gbmV3IERlbXV4ZXJJbmxpbmUob2JzZXJ2ZXIsIGRhdGEudHlwZVN1cHBvcnRlZCwgY29uZmlnLCBkYXRhLnZlbmRvcik7XG5cbiAgICAgIGVuYWJsZUxvZ3MoY29uZmlnLmRlYnVnKTtcblxuICAgICAgLy8gc2lnbmFsIGVuZCBvZiB3b3JrZXIgaW5pdFxuICAgICAgZm9yd2FyZE1lc3NhZ2UoJ2luaXQnLCBudWxsKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RlbXV4JzpcbiAgICAgIHNlbGYuZGVtdXhlci5wdXNoKGRhdGEuZGF0YSwgZGF0YS5kZWNyeXB0ZGF0YSwgZGF0YS5pbml0U2VnbWVudCwgZGF0YS5hdWRpb0NvZGVjLCBkYXRhLnZpZGVvQ29kZWMsIGRhdGEudGltZU9mZnNldCwgZGF0YS5kaXNjb250aW51aXR5LCBkYXRhLnRyYWNrU3dpdGNoLCBkYXRhLmNvbnRpZ3VvdXMsIGRhdGEuZHVyYXRpb24sIGRhdGEuYWNjdXJhdGVUaW1lT2Zmc2V0LCBkYXRhLmRlZmF1bHRJbml0UFRTKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGZvcndhcmQgZXZlbnRzIHRvIG1haW4gdGhyZWFkXG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfREVDUllQVEVELCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTRUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRVJST1IsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuICBvYnNlcnZlci5vbihFdmVudC5JTklUX1BUU19GT1VORCwgZm9yd2FyZE1lc3NhZ2UpO1xuXG4gIC8vIHNwZWNpYWwgY2FzZSBmb3IgRlJBR19QQVJTSU5HX0RBVEE6IHBhc3MgZGF0YTEvZGF0YTIgYXMgdHJhbnNmZXJhYmxlIG9iamVjdCAobm8gY29weSlcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIGZ1bmN0aW9uIChldiwgZGF0YSkge1xuICAgIGxldCB0cmFuc2ZlcmFibGUgPSBbXTtcbiAgICBsZXQgbWVzc2FnZSA9IHsgZXZlbnQ6IGV2LCBkYXRhOiBkYXRhIH07XG4gICAgaWYgKGRhdGEuZGF0YTEpIHtcbiAgICAgIG1lc3NhZ2UuZGF0YTEgPSBkYXRhLmRhdGExLmJ1ZmZlcjtcbiAgICAgIHRyYW5zZmVyYWJsZS5wdXNoKGRhdGEuZGF0YTEuYnVmZmVyKTtcbiAgICAgIGRlbGV0ZSBkYXRhLmRhdGExO1xuICAgIH1cbiAgICBpZiAoZGF0YS5kYXRhMikge1xuICAgICAgbWVzc2FnZS5kYXRhMiA9IGRhdGEuZGF0YTIuYnVmZmVyO1xuICAgICAgdHJhbnNmZXJhYmxlLnB1c2goZGF0YS5kYXRhMi5idWZmZXIpO1xuICAgICAgZGVsZXRlIGRhdGEuZGF0YTI7XG4gICAgfVxuICAgIHNlbGYucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXJhYmxlKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEZW11eGVyV29ya2VyO1xuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCAqIGFzIHdvcmsgZnJvbSAnd2Vid29ya2lmeS13ZWJwYWNrJztcblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRGVtdXhlcklubGluZSBmcm9tICcuLi9kZW11eC9kZW11eGVyLWlubGluZSc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGdldE1lZGlhU291cmNlIH0gZnJvbSAnLi4vdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyJztcbmltcG9ydCB7IGdldFNlbGZTY29wZSB9IGZyb20gJy4uL3V0aWxzL2dldC1zZWxmLXNjb3BlJztcblxuaW1wb3J0IHsgT2JzZXJ2ZXIgfSBmcm9tICcuLi9vYnNlcnZlcic7XG5cbi8vIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTEyMzcyNTkvNTg5NDkzXG5jb25zdCBnbG9iYWwgPSBnZXRTZWxmU2NvcGUoKTsgLy8gc2FmZWd1YXJkIGZvciBjb2RlIHRoYXQgbWlnaHQgcnVuIGJvdGggb24gd29ya2VyIGFuZCBtYWluIHRocmVhZFxuY29uc3QgTWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSgpO1xuXG5jbGFzcyBEZW11eGVyIHtcbiAgY29uc3RydWN0b3IgKGhscywgaWQpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmlkID0gaWQ7XG5cbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXIoKTtcbiAgICBjb25zdCBjb25maWcgPSBobHMuY29uZmlnO1xuXG4gICAgY29uc3QgZm9yd2FyZE1lc3NhZ2UgPSAoZXYsIGRhdGEpID0+IHtcbiAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgZGF0YS5mcmFnID0gdGhpcy5mcmFnO1xuICAgICAgZGF0YS5pZCA9IHRoaXMuaWQ7XG4gICAgICBobHMudHJpZ2dlcihldiwgZGF0YSk7XG4gICAgfTtcblxuICAgIC8vIGZvcndhcmQgZXZlbnRzIHRvIG1haW4gdGhyZWFkXG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19ERUNSWVBURUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKEV2ZW50LkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuSU5JVF9QVFNfRk9VTkQsIGZvcndhcmRNZXNzYWdlKTtcblxuICAgIGNvbnN0IHR5cGVTdXBwb3J0ZWQgPSB7XG4gICAgICBtcDQ6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXA0JyksXG4gICAgICBtcGVnOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wZWcnKSxcbiAgICAgIG1wMzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcDQ7IGNvZGVjcz1cIm1wM1wiJylcbiAgICB9O1xuICAgIC8vIG5hdmlnYXRvci52ZW5kb3IgaXMgbm90IGFsd2F5cyBhdmFpbGFibGUgaW4gV2ViIFdvcmtlclxuICAgIC8vIHJlZmVyIHRvIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Xb3JrZXJHbG9iYWxTY29wZS9uYXZpZ2F0b3JcbiAgICBjb25zdCB2ZW5kb3IgPSBuYXZpZ2F0b3IudmVuZG9yO1xuICAgIGlmIChjb25maWcuZW5hYmxlV29ya2VyICYmICh0eXBlb2YgKFdvcmtlcikgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgbG9nZ2VyLmxvZygnZGVtdXhpbmcgaW4gd2Vid29ya2VyJyk7XG4gICAgICBsZXQgdztcbiAgICAgIHRyeSB7XG4gICAgICAgIHcgPSB0aGlzLncgPSB3b3JrKHJlcXVpcmUucmVzb2x2ZSgnLi4vZGVtdXgvZGVtdXhlci13b3JrZXIuanMnKSk7XG4gICAgICAgIHRoaXMub253bXNnID0gdGhpcy5vbldvcmtlck1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xuICAgICAgICB3Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLCBmYXRhbDogdHJ1ZSwgZXZlbnQ6ICdkZW11eGVyV29ya2VyJywgZXJyOiB7IG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UgKyAnICgnICsgZXZlbnQuZmlsZW5hbWUgKyAnOicgKyBldmVudC5saW5lbm8gKyAnKScgfSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdy5wb3N0TWVzc2FnZSh7IGNtZDogJ2luaXQnLCB0eXBlU3VwcG9ydGVkOiB0eXBlU3VwcG9ydGVkLCB2ZW5kb3I6IHZlbmRvciwgaWQ6IGlkLCBjb25maWc6IEpTT04uc3RyaW5naWZ5KGNvbmZpZykgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ0Vycm9yIGluIHdvcmtlcjonLCBlcnIpO1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIHdoaWxlIGluaXRpYWxpemluZyBEZW11eGVyV29ya2VyLCBmYWxsYmFjayBvbiBEZW11eGVySW5saW5lJyk7XG4gICAgICAgIGlmICh3KSB7XG4gICAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIGRlbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICAgIGdsb2JhbC5VUkwucmV2b2tlT2JqZWN0VVJMKHcub2JqZWN0VVJMKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcklubGluZShvYnNlcnZlciwgdHlwZVN1cHBvcnRlZCwgY29uZmlnLCB2ZW5kb3IpO1xuICAgICAgICB0aGlzLncgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVySW5saW5lKG9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvcik7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgaWYgKHcpIHtcbiAgICAgIHcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMub253bXNnKTtcbiAgICAgIHcudGVybWluYXRlKCk7XG4gICAgICB0aGlzLncgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICAgIGlmIChkZW11eGVyKSB7XG4gICAgICAgIGRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICBvYnNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1c2ggKGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBmcmFnLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUykge1xuICAgIGNvbnN0IHcgPSB0aGlzLnc7XG4gICAgY29uc3QgdGltZU9mZnNldCA9IE51bWJlci5pc0Zpbml0ZShmcmFnLnN0YXJ0UFRTKSA/IGZyYWcuc3RhcnRQVFMgOiBmcmFnLnN0YXJ0O1xuICAgIGNvbnN0IGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICBjb25zdCBsYXN0RnJhZyA9IHRoaXMuZnJhZztcbiAgICBjb25zdCBkaXNjb250aW51aXR5ID0gIShsYXN0RnJhZyAmJiAoZnJhZy5jYyA9PT0gbGFzdEZyYWcuY2MpKTtcbiAgICBjb25zdCB0cmFja1N3aXRjaCA9ICEobGFzdEZyYWcgJiYgKGZyYWcubGV2ZWwgPT09IGxhc3RGcmFnLmxldmVsKSk7XG4gICAgY29uc3QgbmV4dFNOID0gbGFzdEZyYWcgJiYgKGZyYWcuc24gPT09IChsYXN0RnJhZy5zbiArIDEpKTtcbiAgICBjb25zdCBjb250aWd1b3VzID0gIXRyYWNrU3dpdGNoICYmIG5leHRTTjtcbiAgICBpZiAoZGlzY29udGludWl0eSkge1xuICAgICAgbG9nZ2VyLmxvZyhgJHt0aGlzLmlkfTpkaXNjb250aW51aXR5IGRldGVjdGVkYCk7XG4gICAgfVxuXG4gICAgaWYgKHRyYWNrU3dpdGNoKSB7XG4gICAgICBsb2dnZXIubG9nKGAke3RoaXMuaWR9OnN3aXRjaCBkZXRlY3RlZGApO1xuICAgIH1cblxuICAgIHRoaXMuZnJhZyA9IGZyYWc7XG4gICAgaWYgKHcpIHtcbiAgICAgIC8vIHBvc3QgZnJhZ21lbnQgcGF5bG9hZCBhcyB0cmFuc2ZlcmFibGUgb2JqZWN0cyBmb3IgQXJyYXlCdWZmZXIgKG5vIGNvcHkpXG4gICAgICB3LnBvc3RNZXNzYWdlKHsgY21kOiAnZGVtdXgnLCBkYXRhLCBkZWNyeXB0ZGF0YSwgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUyB9LCBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBbZGF0YV0gOiBbXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xuICAgICAgaWYgKGRlbXV4ZXIpIHtcbiAgICAgICAgZGVtdXhlci5wdXNoKGRhdGEsIGRlY3J5cHRkYXRhLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbldvcmtlck1lc3NhZ2UgKGV2KSB7XG4gICAgbGV0IGRhdGEgPSBldi5kYXRhLFxuICAgICAgaGxzID0gdGhpcy5obHM7XG4gICAgc3dpdGNoIChkYXRhLmV2ZW50KSB7XG4gICAgY2FzZSAnaW5pdCc6XG4gICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgZGVtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICBnbG9iYWwuVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLncub2JqZWN0VVJMKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBGUkFHX1BBUlNJTkdfREFUQTogZGF0YTEgYW5kIGRhdGEyIGFyZSB0cmFuc2ZlcmFibGUgb2JqZWN0c1xuICAgIGNhc2UgRXZlbnQuRlJBR19QQVJTSU5HX0RBVEE6XG4gICAgICBkYXRhLmRhdGEuZGF0YTEgPSBuZXcgVWludDhBcnJheShkYXRhLmRhdGExKTtcbiAgICAgIGlmIChkYXRhLmRhdGEyKSB7XG4gICAgICAgIGRhdGEuZGF0YS5kYXRhMiA9IG5ldyBVaW50OEFycmF5KGRhdGEuZGF0YTIpO1xuICAgICAgfVxuXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgZGVmYXVsdDpcbiAgICAgIGRhdGEuZGF0YSA9IGRhdGEuZGF0YSB8fCB7fTtcbiAgICAgIGRhdGEuZGF0YS5mcmFnID0gdGhpcy5mcmFnO1xuICAgICAgZGF0YS5kYXRhLmlkID0gdGhpcy5pZDtcbiAgICAgIGhscy50cmlnZ2VyKGRhdGEuZXZlbnQsIGRhdGEuZGF0YSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGVtdXhlcjtcbiIsIi8qKlxuICogUGFyc2VyIGZvciBleHBvbmVudGlhbCBHb2xvbWIgY29kZXMsIGEgdmFyaWFibGUtYml0d2lkdGggbnVtYmVyIGVuY29kaW5nIHNjaGVtZSB1c2VkIGJ5IGgyNjQuXG4qL1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBFeHBHb2xvbWIge1xuICBjb25zdHJ1Y3RvciAoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhpcy5kYXRhXG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAvLyB0aGUgY3VycmVudCB3b3JkIGJlaW5nIGV4YW1pbmVkXG4gICAgdGhpcy53b3JkID0gMDsgLy8gOnVpbnRcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJpdHMgbGVmdCB0byBleGFtaW5lIGluIHRoZSBjdXJyZW50IHdvcmRcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSAwOyAvLyA6dWludFxuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBsb2FkV29yZCAoKSB7XG4gICAgbGV0XG4gICAgICBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgYnl0ZXNBdmFpbGFibGUgPSB0aGlzLmJ5dGVzQXZhaWxhYmxlLFxuICAgICAgcG9zaXRpb24gPSBkYXRhLmJ5dGVMZW5ndGggLSBieXRlc0F2YWlsYWJsZSxcbiAgICAgIHdvcmtpbmdCeXRlcyA9IG5ldyBVaW50OEFycmF5KDQpLFxuICAgICAgYXZhaWxhYmxlQnl0ZXMgPSBNYXRoLm1pbig0LCBieXRlc0F2YWlsYWJsZSk7XG4gICAgaWYgKGF2YWlsYWJsZUJ5dGVzID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJ5dGVzIGF2YWlsYWJsZScpO1xuICAgIH1cblxuICAgIHdvcmtpbmdCeXRlcy5zZXQoZGF0YS5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBhdmFpbGFibGVCeXRlcykpO1xuICAgIHRoaXMud29yZCA9IG5ldyBEYXRhVmlldyh3b3JraW5nQnl0ZXMuYnVmZmVyKS5nZXRVaW50MzIoMCk7XG4gICAgLy8gdHJhY2sgdGhlIGFtb3VudCBvZiB0aGlzLmRhdGEgdGhhdCBoYXMgYmVlbiBwcm9jZXNzZWRcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSBhdmFpbGFibGVCeXRlcyAqIDg7XG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSAtPSBhdmFpbGFibGVCeXRlcztcbiAgfVxuXG4gIC8vIChjb3VudDppbnQpOnZvaWRcbiAgc2tpcEJpdHMgKGNvdW50KSB7XG4gICAgbGV0IHNraXBCeXRlczsgLy8gOmludFxuICAgIGlmICh0aGlzLmJpdHNBdmFpbGFibGUgPiBjb3VudCkge1xuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgLT0gdGhpcy5iaXRzQXZhaWxhYmxlO1xuICAgICAgc2tpcEJ5dGVzID0gY291bnQgPj4gMztcbiAgICAgIGNvdW50IC09IChza2lwQnl0ZXMgPj4gMyk7XG4gICAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IHNraXBCeXRlcztcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gKHNpemU6aW50KTp1aW50XG4gIHJlYWRCaXRzIChzaXplKSB7XG4gICAgbGV0XG4gICAgICBiaXRzID0gTWF0aC5taW4odGhpcy5iaXRzQXZhaWxhYmxlLCBzaXplKSwgLy8gOnVpbnRcbiAgICAgIHZhbHUgPSB0aGlzLndvcmQgPj4+ICgzMiAtIGJpdHMpOyAvLyA6dWludFxuICAgIGlmIChzaXplID4gMzIpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignQ2Fubm90IHJlYWQgbW9yZSB0aGFuIDMyIGJpdHMgYXQgYSB0aW1lJyk7XG4gICAgfVxuXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGJpdHM7XG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMud29yZCA8PD0gYml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXNBdmFpbGFibGUgPiAwKSB7XG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgfVxuXG4gICAgYml0cyA9IHNpemUgLSBiaXRzO1xuICAgIGlmIChiaXRzID4gMCAmJiB0aGlzLmJpdHNBdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiB2YWx1IDw8IGJpdHMgfCB0aGlzLnJlYWRCaXRzKGJpdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdTtcbiAgICB9XG4gIH1cblxuICAvLyAoKTp1aW50XG4gIHNraXBMWiAoKSB7XG4gICAgbGV0IGxlYWRpbmdaZXJvQ291bnQ7IC8vIDp1aW50XG4gICAgZm9yIChsZWFkaW5nWmVyb0NvdW50ID0gMDsgbGVhZGluZ1plcm9Db3VudCA8IHRoaXMuYml0c0F2YWlsYWJsZTsgKytsZWFkaW5nWmVyb0NvdW50KSB7XG4gICAgICBpZiAoKHRoaXMud29yZCAmICgweDgwMDAwMDAwID4+PiBsZWFkaW5nWmVyb0NvdW50KSkgIT09IDApIHtcbiAgICAgICAgLy8gdGhlIGZpcnN0IGJpdCBvZiB3b3JraW5nIHdvcmQgaXMgMVxuICAgICAgICB0aGlzLndvcmQgPDw9IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd2UgZXhoYXVzdGVkIHdvcmQgYW5kIHN0aWxsIGhhdmUgbm90IGZvdW5kIGEgMVxuICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudCArIHRoaXMuc2tpcExaKCk7XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIHNraXBVRUcgKCkge1xuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBza2lwRUcgKCkge1xuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICB9XG5cbiAgLy8gKCk6dWludFxuICByZWFkVUVHICgpIHtcbiAgICBsZXQgY2x6ID0gdGhpcy5za2lwTFooKTsgLy8gOnVpbnRcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cyhjbHogKyAxKSAtIDE7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZEVHICgpIHtcbiAgICBsZXQgdmFsdSA9IHRoaXMucmVhZFVFRygpOyAvLyA6aW50XG4gICAgaWYgKDB4MDEgJiB2YWx1KSB7XG4gICAgICAvLyB0aGUgbnVtYmVyIGlzIG9kZCBpZiB0aGUgbG93IG9yZGVyIGJpdCBpcyBzZXRcbiAgICAgIHJldHVybiAoMSArIHZhbHUpID4+PiAxOyAvLyBhZGQgMSB0byBtYWtlIGl0IGV2ZW4sIGFuZCBkaXZpZGUgYnkgMlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTEgKiAodmFsdSA+Pj4gMSk7IC8vIGRpdmlkZSBieSB0d28gdGhlbiBtYWtlIGl0IG5lZ2F0aXZlXG4gICAgfVxuICB9XG5cbiAgLy8gU29tZSBjb252ZW5pZW5jZSBmdW5jdGlvbnNcbiAgLy8gOkJvb2xlYW5cbiAgcmVhZEJvb2xlYW4gKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDEpID09PSAxO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRVQnl0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoOCk7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZFVTaG9ydCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMTYpO1xuICB9XG4gIC8vICgpOmludFxuICByZWFkVUludCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMzIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkdmFuY2UgdGhlIEV4cEdvbG9tYiBkZWNvZGVyIHBhc3QgYSBzY2FsaW5nIGxpc3QuIFRoZSBzY2FsaW5nXG4gICAqIGxpc3QgaXMgb3B0aW9uYWxseSB0cmFuc21pdHRlZCBhcyBwYXJ0IG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyXG4gICAqIHNldCBhbmQgaXMgbm90IHJlbGV2YW50IHRvIHRyYW5zbXV4aW5nLlxuICAgKiBAcGFyYW0gY291bnQge251bWJlcn0gdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIHRoaXMgc2NhbGluZyBsaXN0XG4gICAqIEBzZWUgUmVjb21tZW5kYXRpb24gSVRVLVQgSC4yNjQsIFNlY3Rpb24gNy4zLjIuMS4xLjFcbiAgICovXG4gIHNraXBTY2FsaW5nTGlzdCAoY291bnQpIHtcbiAgICBsZXRcbiAgICAgIGxhc3RTY2FsZSA9IDgsXG4gICAgICBuZXh0U2NhbGUgPSA4LFxuICAgICAgaixcbiAgICAgIGRlbHRhU2NhbGU7XG4gICAgZm9yIChqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgIGlmIChuZXh0U2NhbGUgIT09IDApIHtcbiAgICAgICAgZGVsdGFTY2FsZSA9IHRoaXMucmVhZEVHKCk7XG4gICAgICAgIG5leHRTY2FsZSA9IChsYXN0U2NhbGUgKyBkZWx0YVNjYWxlICsgMjU2KSAlIDI1NjtcbiAgICAgIH1cbiAgICAgIGxhc3RTY2FsZSA9IChuZXh0U2NhbGUgPT09IDApID8gbGFzdFNjYWxlIDogbmV4dFNjYWxlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBhbmQgcmV0dXJuIHNvbWUgaW50ZXJlc3RpbmcgdmlkZW9cbiAgICogcHJvcGVydGllcy4gQSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGlzIHRoZSBIMjY0IG1ldGFkYXRhIHRoYXRcbiAgICogZGVzY3JpYmVzIHRoZSBwcm9wZXJ0aWVzIG9mIHVwY29taW5nIHZpZGVvIGZyYW1lcy5cbiAgICogQHBhcmFtIGRhdGEge1VpbnQ4QXJyYXl9IHRoZSBieXRlcyBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXRcbiAgICogQHJldHVybiB7b2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxuICAgKiBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0LCBpbmNsdWRpbmcgdGhlIGRpbWVuc2lvbnMgb2YgdGhlXG4gICAqIGFzc29jaWF0ZWQgdmlkZW8gZnJhbWVzLlxuICAgKi9cbiAgcmVhZFNQUyAoKSB7XG4gICAgbGV0XG4gICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gMCxcbiAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gMCxcbiAgICAgIGZyYW1lQ3JvcFRvcE9mZnNldCA9IDAsXG4gICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSAwLFxuICAgICAgcHJvZmlsZUlkYywgcHJvZmlsZUNvbXBhdCwgbGV2ZWxJZGMsXG4gICAgICBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUsIHBpY1dpZHRoSW5NYnNNaW51czEsXG4gICAgICBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxLFxuICAgICAgZnJhbWVNYnNPbmx5RmxhZyxcbiAgICAgIHNjYWxpbmdMaXN0Q291bnQsXG4gICAgICBpLFxuICAgICAgcmVhZFVCeXRlID0gdGhpcy5yZWFkVUJ5dGUuYmluZCh0aGlzKSxcbiAgICAgIHJlYWRCaXRzID0gdGhpcy5yZWFkQml0cy5iaW5kKHRoaXMpLFxuICAgICAgcmVhZFVFRyA9IHRoaXMucmVhZFVFRy5iaW5kKHRoaXMpLFxuICAgICAgcmVhZEJvb2xlYW4gPSB0aGlzLnJlYWRCb29sZWFuLmJpbmQodGhpcyksXG4gICAgICBza2lwQml0cyA9IHRoaXMuc2tpcEJpdHMuYmluZCh0aGlzKSxcbiAgICAgIHNraXBFRyA9IHRoaXMuc2tpcEVHLmJpbmQodGhpcyksXG4gICAgICBza2lwVUVHID0gdGhpcy5za2lwVUVHLmJpbmQodGhpcyksXG4gICAgICBza2lwU2NhbGluZ0xpc3QgPSB0aGlzLnNraXBTY2FsaW5nTGlzdC5iaW5kKHRoaXMpO1xuXG4gICAgcmVhZFVCeXRlKCk7XG4gICAgcHJvZmlsZUlkYyA9IHJlYWRVQnl0ZSgpOyAvLyBwcm9maWxlX2lkY1xuICAgIHByb2ZpbGVDb21wYXQgPSByZWFkQml0cyg1KTsgLy8gY29uc3RyYWludF9zZXRbMC00XV9mbGFnLCB1KDUpXG4gICAgc2tpcEJpdHMoMyk7IC8vIHJlc2VydmVkX3plcm9fM2JpdHMgdSgzKSxcbiAgICBsZXZlbElkYyA9IHJlYWRVQnl0ZSgpOyAvLyBsZXZlbF9pZGMgdSg4KVxuICAgIHNraXBVRUcoKTsgLy8gc2VxX3BhcmFtZXRlcl9zZXRfaWRcbiAgICAvLyBzb21lIHByb2ZpbGVzIGhhdmUgbW9yZSBvcHRpb25hbCBkYXRhIHdlIGRvbid0IG5lZWRcbiAgICBpZiAocHJvZmlsZUlkYyA9PT0gMTAwIHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDExMCB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSAxMjIgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMjQ0IHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDQ0IHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDgzIHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDg2IHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDExOCB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSAxMjgpIHtcbiAgICAgIGxldCBjaHJvbWFGb3JtYXRJZGMgPSByZWFkVUVHKCk7XG4gICAgICBpZiAoY2hyb21hRm9ybWF0SWRjID09PSAzKSB7XG4gICAgICAgIHNraXBCaXRzKDEpO1xuICAgICAgfSAvLyBzZXBhcmF0ZV9jb2xvdXJfcGxhbmVfZmxhZ1xuXG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9sdW1hX21pbnVzOFxuICAgICAgc2tpcFVFRygpOyAvLyBiaXRfZGVwdGhfY2hyb21hX21pbnVzOFxuICAgICAgc2tpcEJpdHMoMSk7IC8vIHFwcHJpbWVfeV96ZXJvX3RyYW5zZm9ybV9ieXBhc3NfZmxhZ1xuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHsgLy8gc2VxX3NjYWxpbmdfbWF0cml4X3ByZXNlbnRfZmxhZ1xuICAgICAgICBzY2FsaW5nTGlzdENvdW50ID0gKGNocm9tYUZvcm1hdElkYyAhPT0gMykgPyA4IDogMTI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FsaW5nTGlzdENvdW50OyBpKyspIHtcbiAgICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkgeyAvLyBzZXFfc2NhbGluZ19saXN0X3ByZXNlbnRfZmxhZ1sgaSBdXG4gICAgICAgICAgICBpZiAoaSA8IDYpIHtcbiAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDE2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCg2NCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNraXBVRUcoKTsgLy8gbG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNFxuICAgIGxldCBwaWNPcmRlckNudFR5cGUgPSByZWFkVUVHKCk7XG4gICAgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMCkge1xuICAgICAgcmVhZFVFRygpOyAvLyBsb2cyX21heF9waWNfb3JkZXJfY250X2xzYl9taW51czRcbiAgICB9IGVsc2UgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMSkge1xuICAgICAgc2tpcEJpdHMoMSk7IC8vIGRlbHRhX3BpY19vcmRlcl9hbHdheXNfemVyb19mbGFnXG4gICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl9ub25fcmVmX3BpY1xuICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3JfdG9wX3RvX2JvdHRvbV9maWVsZFxuICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlID0gcmVhZFVFRygpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTsgaSsrKSB7XG4gICAgICAgIHNraXBFRygpO1xuICAgICAgfSAvLyBvZmZzZXRfZm9yX3JlZl9mcmFtZVsgaSBdXG4gICAgfVxuICAgIHNraXBVRUcoKTsgLy8gbWF4X251bV9yZWZfZnJhbWVzXG4gICAgc2tpcEJpdHMoMSk7IC8vIGdhcHNfaW5fZnJhbWVfbnVtX3ZhbHVlX2FsbG93ZWRfZmxhZ1xuICAgIHBpY1dpZHRoSW5NYnNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSA9IHJlYWRVRUcoKTtcbiAgICBmcmFtZU1ic09ubHlGbGFnID0gcmVhZEJpdHMoMSk7XG4gICAgaWYgKGZyYW1lTWJzT25seUZsYWcgPT09IDApIHtcbiAgICAgIHNraXBCaXRzKDEpO1xuICAgIH0gLy8gbWJfYWRhcHRpdmVfZnJhbWVfZmllbGRfZmxhZ1xuXG4gICAgc2tpcEJpdHMoMSk7IC8vIGRpcmVjdF84eDhfaW5mZXJlbmNlX2ZsYWdcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkgeyAvLyBmcmFtZV9jcm9wcGluZ19mbGFnXG4gICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgfVxuICAgIGxldCBwaXhlbFJhdGlvID0gWzEsIDFdO1xuICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAvLyB2dWlfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWdcbiAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpb0lkYyA9IHJlYWRVQnl0ZSgpO1xuICAgICAgICBzd2l0Y2ggKGFzcGVjdFJhdGlvSWRjKSB7XG4gICAgICAgIGNhc2UgMTogcGl4ZWxSYXRpbyA9IFsxLCAxXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogcGl4ZWxSYXRpbyA9IFsxMiwgMTFdOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBwaXhlbFJhdGlvID0gWzEwLCAxMV07IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IHBpeGVsUmF0aW8gPSBbMTYsIDExXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNTogcGl4ZWxSYXRpbyA9IFs0MCwgMzNdOyBicmVhaztcbiAgICAgICAgY2FzZSA2OiBwaXhlbFJhdGlvID0gWzI0LCAxMV07IGJyZWFrO1xuICAgICAgICBjYXNlIDc6IHBpeGVsUmF0aW8gPSBbMjAsIDExXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgODogcGl4ZWxSYXRpbyA9IFszMiwgMTFdOyBicmVhaztcbiAgICAgICAgY2FzZSA5OiBwaXhlbFJhdGlvID0gWzgwLCAzM107IGJyZWFrO1xuICAgICAgICBjYXNlIDEwOiBwaXhlbFJhdGlvID0gWzE4LCAxMV07IGJyZWFrO1xuICAgICAgICBjYXNlIDExOiBwaXhlbFJhdGlvID0gWzE1LCAxMV07IGJyZWFrO1xuICAgICAgICBjYXNlIDEyOiBwaXhlbFJhdGlvID0gWzY0LCAzM107IGJyZWFrO1xuICAgICAgICBjYXNlIDEzOiBwaXhlbFJhdGlvID0gWzE2MCwgOTldOyBicmVhaztcbiAgICAgICAgY2FzZSAxNDogcGl4ZWxSYXRpbyA9IFs0LCAzXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMTU6IHBpeGVsUmF0aW8gPSBbMywgMl07IGJyZWFrO1xuICAgICAgICBjYXNlIDE2OiBwaXhlbFJhdGlvID0gWzIsIDFdOyBicmVhaztcbiAgICAgICAgY2FzZSAyNTU6IHtcbiAgICAgICAgICBwaXhlbFJhdGlvID0gW3JlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKSwgcmVhZFVCeXRlKCkgPDwgOCB8IHJlYWRVQnl0ZSgpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogTWF0aC5jZWlsKCgoKHBpY1dpZHRoSW5NYnNNaW51czEgKyAxKSAqIDE2KSAtIGZyYW1lQ3JvcExlZnRPZmZzZXQgKiAyIC0gZnJhbWVDcm9wUmlnaHRPZmZzZXQgKiAyKSksXG4gICAgICBoZWlnaHQ6ICgoMiAtIGZyYW1lTWJzT25seUZsYWcpICogKHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgKyAxKSAqIDE2KSAtICgoZnJhbWVNYnNPbmx5RmxhZyA/IDIgOiA0KSAqIChmcmFtZUNyb3BUb3BPZmZzZXQgKyBmcmFtZUNyb3BCb3R0b21PZmZzZXQpKSxcbiAgICAgIHBpeGVsUmF0aW86IHBpeGVsUmF0aW9cbiAgICB9O1xuICB9XG5cbiAgcmVhZFNsaWNlVHlwZSAoKSB7XG4gICAgLy8gc2tpcCBOQUx1IHR5cGVcbiAgICB0aGlzLnJlYWRVQnl0ZSgpO1xuICAgIC8vIGRpc2NhcmQgZmlyc3RfbWJfaW5fc2xpY2VcbiAgICB0aGlzLnJlYWRVRUcoKTtcbiAgICAvLyByZXR1cm4gc2xpY2VfdHlwZVxuICAgIHJldHVybiB0aGlzLnJlYWRVRUcoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFeHBHb2xvbWI7XG4iLCIvKipcbiAqIElEMyBwYXJzZXJcbiAqL1xuY2xhc3MgSUQzIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2ggaW5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGlzIGZvdW5kXG4gICAqL1xuICBzdGF0aWMgaXNIZWFkZXIgKGRhdGEsIG9mZnNldCkge1xuICAgIC8qXG4gICAgKiBodHRwOi8vaWQzLm9yZy9pZDN2Mi4zLjBcbiAgICAqIFswXSAgICAgPSAnSSdcbiAgICAqIFsxXSAgICAgPSAnRCdcbiAgICAqIFsyXSAgICAgPSAnMydcbiAgICAqIFszLDRdICAgPSB7VmVyc2lvbn1cbiAgICAqIFs1XSAgICAgPSB7RmxhZ3N9XG4gICAgKiBbNi05XSAgID0ge0lEMyBTaXplfVxuICAgICpcbiAgICAqIEFuIElEM3YyIHRhZyBjYW4gYmUgZGV0ZWN0ZWQgd2l0aCB0aGUgZm9sbG93aW5nIHBhdHRlcm46XG4gICAgKiAgJDQ5IDQ0IDMzIHl5IHl5IHh4IHp6IHp6IHp6IHp6XG4gICAgKiBXaGVyZSB5eSBpcyBsZXNzIHRoYW4gJEZGLCB4eCBpcyB0aGUgJ2ZsYWdzJyBieXRlIGFuZCB6eiBpcyBsZXNzIHRoYW4gJDgwXG4gICAgKi9cbiAgICBpZiAob2Zmc2V0ICsgMTAgPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vIGxvb2sgZm9yICdJRDMnIGlkZW50aWZpZXJcbiAgICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4NDkgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg0NCAmJiBkYXRhW29mZnNldCArIDJdID09PSAweDMzKSB7XG4gICAgICAgIC8vIGNoZWNrIHZlcnNpb24gaXMgd2l0aGluIHJhbmdlXG4gICAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhGRiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhGRikge1xuICAgICAgICAgIC8vIGNoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXG4gICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgNl0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgN10gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOF0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOV0gPCAweDgwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGFuIElEMyBmb290ZXIgY2FuIGJlIGZvdW5kIGF0IG9mZnNldCBpbiBkYXRhXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaCBpblxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIGFuIElEMyBmb290ZXIgaXMgZm91bmRcbiAgICovXG4gIHN0YXRpYyBpc0Zvb3RlciAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgLypcbiAgICAqIFRoZSBmb290ZXIgaXMgYSBjb3B5IG9mIHRoZSBoZWFkZXIsIGJ1dCB3aXRoIGEgZGlmZmVyZW50IGlkZW50aWZpZXJcbiAgICAqL1xuICAgIGlmIChvZmZzZXQgKyAxMCA8PSBkYXRhLmxlbmd0aCkge1xuICAgICAgLy8gbG9vayBmb3IgJzNESScgaWRlbnRpZmllclxuICAgICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHgzMyAmJiBkYXRhW29mZnNldCArIDFdID09PSAweDQ0ICYmIGRhdGFbb2Zmc2V0ICsgMl0gPT09IDB4NDkpIHtcbiAgICAgICAgLy8gY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgM10gPCAweEZGICYmIGRhdGFbb2Zmc2V0ICsgNF0gPCAweEZGKSB7XG4gICAgICAgICAgLy8gY2hlY2sgc2l6ZSBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA3XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA4XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFueSBhZGphY2VudCBJRDMgdGFncyBmb3VuZCBpbiBkYXRhIHN0YXJ0aW5nIGF0IG9mZnNldCwgYXMgb25lIGJsb2NrIG9mIGRhdGFcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSAtIFRoZSBibG9jayBvZiBkYXRhIGNvbnRhaW5pbmcgYW55IElEMyB0YWdzIGZvdW5kXG4gICAqL1xuICBzdGF0aWMgZ2V0SUQzRGF0YSAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgZnJvbnQgPSBvZmZzZXQ7XG4gICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICB3aGlsZSAoSUQzLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgIC8vIElEMyBoZWFkZXIgaXMgMTAgYnl0ZXNcbiAgICAgIGxlbmd0aCArPSAxMDtcblxuICAgICAgY29uc3Qgc2l6ZSA9IElEMy5fcmVhZFNpemUoZGF0YSwgb2Zmc2V0ICsgNik7XG4gICAgICBsZW5ndGggKz0gc2l6ZTtcblxuICAgICAgaWYgKElEMy5pc0Zvb3RlcihkYXRhLCBvZmZzZXQgKyAxMCkpIHtcbiAgICAgICAgLy8gSUQzIGZvb3RlciBpcyAxMCBieXRlc1xuICAgICAgICBsZW5ndGggKz0gMTA7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldCArPSBsZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBkYXRhLnN1YmFycmF5KGZyb250LCBmcm9udCArIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHN0YXRpYyBfcmVhZFNpemUgKGRhdGEsIG9mZnNldCkge1xuICAgIGxldCBzaXplID0gMDtcbiAgICBzaXplID0gKChkYXRhW29mZnNldF0gJiAweDdmKSA8PCAyMSk7XG4gICAgc2l6ZSB8PSAoKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDdmKSA8PCAxNCk7XG4gICAgc2l6ZSB8PSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDdmKSA8PCA3KTtcbiAgICBzaXplIHw9IChkYXRhW29mZnNldCArIDNdICYgMHg3Zik7XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoZXMgZm9yIHRoZSBFbGVtZW50YXJ5IFN0cmVhbSB0aW1lc3RhbXAgZm91bmQgaW4gdGhlIElEMyBkYXRhIGNodW5rXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSAtIEJsb2NrIG9mIGRhdGEgY29udGFpbmluZyBvbmUgb3IgbW9yZSBJRDMgdGFnc1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHRpbWVzdGFtcFxuICAgKi9cbiAgc3RhdGljIGdldFRpbWVTdGFtcCAoZGF0YSkge1xuICAgIGNvbnN0IGZyYW1lcyA9IElEMy5nZXRJRDNGcmFtZXMoZGF0YSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZyYW1lID0gZnJhbWVzW2ldO1xuICAgICAgaWYgKElEMy5pc1RpbWVTdGFtcEZyYW1lKGZyYW1lKSkge1xuICAgICAgICByZXR1cm4gSUQzLl9yZWFkVGltZVN0YW1wKGZyYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSUQzIGZyYW1lIGlzIGFuIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmcmFtZVxuICAgKiBAcGFyYW0ge0lEMyBmcmFtZX0gZnJhbWVcbiAgICovXG4gIHN0YXRpYyBpc1RpbWVTdGFtcEZyYW1lIChmcmFtZSkge1xuICAgIHJldHVybiAoZnJhbWUgJiYgZnJhbWUua2V5ID09PSAnUFJJVicgJiYgZnJhbWUuaW5mbyA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJyk7XG4gIH1cblxuICBzdGF0aWMgX2dldEZyYW1lRGF0YSAoZGF0YSkge1xuICAgIC8qXG4gICAgRnJhbWUgSUQgICAgICAgJHh4IHh4IHh4IHh4IChmb3VyIGNoYXJhY3RlcnMpXG4gICAgU2l6ZSAgICAgICAgICAgJHh4IHh4IHh4IHh4XG4gICAgRmxhZ3MgICAgICAgICAgJHh4IHh4XG4gICAgKi9cbiAgICBjb25zdCB0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhWzBdLCBkYXRhWzFdLCBkYXRhWzJdLCBkYXRhWzNdKTtcbiAgICBjb25zdCBzaXplID0gSUQzLl9yZWFkU2l6ZShkYXRhLCA0KTtcblxuICAgIC8vIHNraXAgZnJhbWUgaWQsIHNpemUsIGFuZCBmbGFnc1xuICAgIGxldCBvZmZzZXQgPSAxMDtcblxuICAgIHJldHVybiB7IHR5cGUsIHNpemUsIGRhdGE6IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBzaXplKSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgSUQzIGZyYW1lcyBmb3VuZCBpbiBhbGwgdGhlIElEMyB0YWdzIGluIHRoZSBpZDNEYXRhXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gaWQzRGF0YSAtIFRoZSBJRDMgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXG4gICAqIEByZXR1cm4ge0lEMyBmcmFtZVtdfSAtIEFycmF5IG9mIElEMyBmcmFtZSBvYmplY3RzXG4gICAqL1xuICBzdGF0aWMgZ2V0SUQzRnJhbWVzIChpZDNEYXRhKSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgZnJhbWVzID0gW107XG5cbiAgICB3aGlsZSAoSUQzLmlzSGVhZGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBJRDMuX3JlYWRTaXplKGlkM0RhdGEsIG9mZnNldCArIDYpO1xuICAgICAgLy8gc2tpcCBwYXN0IElEMyBoZWFkZXJcbiAgICAgIG9mZnNldCArPSAxMDtcbiAgICAgIGNvbnN0IGVuZCA9IG9mZnNldCArIHNpemU7XG4gICAgICAvLyBsb29wIHRocm91Z2ggZnJhbWVzIGluIHRoZSBJRDMgdGFnXG4gICAgICB3aGlsZSAob2Zmc2V0ICsgOCA8IGVuZCkge1xuICAgICAgICBjb25zdCBmcmFtZURhdGEgPSBJRDMuX2dldEZyYW1lRGF0YShpZDNEYXRhLnN1YmFycmF5KG9mZnNldCkpO1xuICAgICAgICBjb25zdCBmcmFtZSA9IElEMy5fZGVjb2RlRnJhbWUoZnJhbWVEYXRhKTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2tpcCBmcmFtZSBoZWFkZXIgYW5kIGZyYW1lIGRhdGFcbiAgICAgICAgb2Zmc2V0ICs9IGZyYW1lRGF0YS5zaXplICsgMTA7XG4gICAgICB9XG5cbiAgICAgIGlmIChJRDMuaXNGb290ZXIoaWQzRGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBvZmZzZXQgKz0gMTA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYW1lcztcbiAgfVxuXG4gIHN0YXRpYyBfZGVjb2RlRnJhbWUgKGZyYW1lKSB7XG4gICAgaWYgKGZyYW1lLnR5cGUgPT09ICdQUklWJykge1xuICAgICAgcmV0dXJuIElEMy5fZGVjb2RlUHJpdkZyYW1lKGZyYW1lKTtcbiAgICB9IGVsc2UgaWYgKGZyYW1lLnR5cGVbMF0gPT09ICdUJykge1xuICAgICAgcmV0dXJuIElEMy5fZGVjb2RlVGV4dEZyYW1lKGZyYW1lKTtcbiAgICB9IGVsc2UgaWYgKGZyYW1lLnR5cGVbMF0gPT09ICdXJykge1xuICAgICAgcmV0dXJuIElEMy5fZGVjb2RlVVJMRnJhbWUoZnJhbWUpO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBzdGF0aWMgX3JlYWRUaW1lU3RhbXAgKHRpbWVTdGFtcEZyYW1lKSB7XG4gICAgaWYgKHRpbWVTdGFtcEZyYW1lLmRhdGEuYnl0ZUxlbmd0aCA9PT0gOCkge1xuICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRpbWVTdGFtcEZyYW1lLmRhdGEpO1xuICAgICAgLy8gdGltZXN0YW1wIGlzIDMzIGJpdCBleHByZXNzZWQgYXMgYSBiaWctZW5kaWFuIGVpZ2h0LW9jdGV0IG51bWJlcixcbiAgICAgIC8vIHdpdGggdGhlIHVwcGVyIDMxIGJpdHMgc2V0IHRvIHplcm8uXG4gICAgICBjb25zdCBwdHMzM0JpdCA9IGRhdGFbM10gJiAweDE7XG4gICAgICBsZXQgdGltZXN0YW1wID0gKGRhdGFbNF0gPDwgMjMpICtcbiAgICAgICAgICAgICAgICAgICAgICAoZGF0YVs1XSA8PCAxNSkgK1xuICAgICAgICAgICAgICAgICAgICAgIChkYXRhWzZdIDw8IDcpICtcbiAgICAgICAgICAgICAgICAgICAgICAgZGF0YVs3XTtcbiAgICAgIHRpbWVzdGFtcCAvPSA0NTtcblxuICAgICAgaWYgKHB0czMzQml0KSB7XG4gICAgICAgIHRpbWVzdGFtcCArPSA0NzcyMTg1OC44NDtcbiAgICAgIH0gLy8gMl4zMiAvIDkwXG5cbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHN0YXRpYyBfZGVjb2RlUHJpdkZyYW1lIChmcmFtZSkge1xuICAgIC8qXG4gICAgRm9ybWF0OiA8dGV4dCBzdHJpbmc+XFwwPGJpbmFyeSBkYXRhPlxuICAgICovXG4gICAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IG93bmVyID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLCB0cnVlKTtcbiAgICBjb25zdCBwcml2YXRlRGF0YSA9IG5ldyBVaW50OEFycmF5KGZyYW1lLmRhdGEuc3ViYXJyYXkob3duZXIubGVuZ3RoICsgMSkpO1xuXG4gICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBpbmZvOiBvd25lciwgZGF0YTogcHJpdmF0ZURhdGEuYnVmZmVyIH07XG4gIH1cblxuICBzdGF0aWMgX2RlY29kZVRleHRGcmFtZSAoZnJhbWUpIHtcbiAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGZyYW1lLnR5cGUgPT09ICdUWFhYJykge1xuICAgICAgLypcbiAgICAgIEZvcm1hdDpcbiAgICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgICBbMS0/XSA9IHtEZXNjcmlwdGlvbn1cXDB7VmFsdWV9XG4gICAgICAqL1xuICAgICAgbGV0IGluZGV4ID0gMTtcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XG5cbiAgICAgIGluZGV4ICs9IGRlc2NyaXB0aW9uLmxlbmd0aCArIDE7XG4gICAgICBjb25zdCB2YWx1ZSA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuXG4gICAgICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGluZm86IGRlc2NyaXB0aW9uLCBkYXRhOiB2YWx1ZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvKlxuICAgICAgRm9ybWF0OlxuICAgICAgWzBdICAgPSB7VGV4dCBFbmNvZGluZ31cbiAgICAgIFsxLT9dID0ge1ZhbHVlfVxuICAgICAgKi9cbiAgICAgIGNvbnN0IHRleHQgPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoMSkpO1xuICAgICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBkYXRhOiB0ZXh0IH07XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIF9kZWNvZGVVUkxGcmFtZSAoZnJhbWUpIHtcbiAgICBpZiAoZnJhbWUudHlwZSA9PT0gJ1dYWFgnKSB7XG4gICAgICAvKlxuICAgICAgRm9ybWF0OlxuICAgICAgWzBdICAgPSB7VGV4dCBFbmNvZGluZ31cbiAgICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtVUkx9XG4gICAgICAqL1xuICAgICAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGxldCBpbmRleCA9IDE7XG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuXG4gICAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgICAgY29uc3QgdmFsdWUgPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcblxuICAgICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBpbmZvOiBkZXNjcmlwdGlvbiwgZGF0YTogdmFsdWUgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLypcbiAgICAgIEZvcm1hdDpcbiAgICAgIFswLT9dID0ge1VSTH1cbiAgICAgICovXG4gICAgICBjb25zdCB1cmwgPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEpO1xuICAgICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBkYXRhOiB1cmwgfTtcbiAgICB9XG4gIH1cblxuICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg5MzY5ODQvdWludDhhcnJheS10by1zdHJpbmctaW4tamF2YXNjcmlwdC8yMjM3MzE5N1xuICAvLyBodHRwOi8vd3d3Lm9uaWNvcy5jb20vc3RhZmYvaXovYW11c2UvamF2YXNjcmlwdC9leHBlcnQvdXRmLnR4dFxuICAvKiB1dGYuanMgLSBVVEYtOCA8PT4gVVRGLTE2IGNvbnZlcnRpb25cbiAgICpcbiAgICogQ29weXJpZ2h0IChDKSAxOTk5IE1hc2FuYW8gSXp1bW8gPGl6QG9uaWNvcy5jby5qcD5cbiAgICogVmVyc2lvbjogMS4wXG4gICAqIExhc3RNb2RpZmllZDogRGVjIDI1IDE5OTlcbiAgICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUuICBZb3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0LlxuICAgKi9cbiAgc3RhdGljIF91dGY4QXJyYXlUb1N0ciAoYXJyYXksIGV4aXRPbk51bGwgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICBsZXQgYztcbiAgICBsZXQgY2hhcjI7XG4gICAgbGV0IGNoYXIzO1xuICAgIGxldCBvdXQgPSAnJztcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGMgPSBhcnJheVtpKytdO1xuICAgICAgaWYgKGMgPT09IDB4MDAgJiYgZXhpdE9uTnVsbCkge1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfSBlbHNlIGlmIChjID09PSAweDAwIHx8IGMgPT09IDB4MDMpIHtcbiAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyAzIChFTkRfT0ZfVEVYVCkgb3IgMCAoTlVMTCkgdGhlbiBza2lwIGl0XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjID4+IDQpIHtcbiAgICAgIGNhc2UgMDogY2FzZSAxOiBjYXNlIDI6IGNhc2UgMzogY2FzZSA0OiBjYXNlIDU6IGNhc2UgNjogY2FzZSA3OlxuICAgICAgICAvLyAweHh4eHh4eFxuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyOiBjYXNlIDEzOlxuICAgICAgICAvLyAxMTB4IHh4eHggICAxMHh4IHh4eHhcbiAgICAgICAgY2hhcjIgPSBhcnJheVtpKytdO1xuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDFGKSA8PCA2KSB8IChjaGFyMiAmIDB4M0YpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE0OlxuICAgICAgICAvLyAxMTEwIHh4eHggIDEweHggeHh4eCAgMTB4eCB4eHh4XG4gICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcbiAgICAgICAgY2hhcjMgPSBhcnJheVtpKytdO1xuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDBGKSA8PCAxMikgfFxuICAgICAgICAgICAgICAgICAgICAoKGNoYXIyICYgMHgzRikgPDwgNikgfFxuICAgICAgICAgICAgICAgICAgICAoKGNoYXIzICYgMHgzRikgPDwgMCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn1cblxuY29uc3QgdXRmOEFycmF5VG9TdHIgPSBJRDMuX3V0ZjhBcnJheVRvU3RyO1xuXG5leHBvcnQgZGVmYXVsdCBJRDM7XG5cbmV4cG9ydCB7IHV0ZjhBcnJheVRvU3RyIH07XG4iLCIvKipcbiAqIE1QMyBkZW11eGVyXG4gKi9cbmltcG9ydCBJRDMgZnJvbSAnLi4vZGVtdXgvaWQzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgTXBlZ0F1ZGlvIGZyb20gJy4vbXBlZ2F1ZGlvJztcblxuY2xhc3MgTVAzRGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yIChvYnNlcnZlciwgcmVtdXhlciwgY29uZmlnKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XG4gIH1cblxuICByZXNldEluaXRTZWdtZW50IChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0geyBjb250YWluZXI6ICdhdWRpby9tcGVnJywgdHlwZTogJ2F1ZGlvJywgaWQ6IC0xLCBzZXF1ZW5jZU51bWJlcjogMCwgaXNBQUM6IGZhbHNlLCBzYW1wbGVzOiBbXSwgbGVuOiAwLCBtYW5pZmVzdENvZGVjOiBhdWRpb0NvZGVjLCBkdXJhdGlvbjogZHVyYXRpb24sIGlucHV0VGltZVNjYWxlOiA5MDAwMCB9O1xuICB9XG5cbiAgcmVzZXRUaW1lU3RhbXAgKCkge1xuICB9XG5cbiAgc3RhdGljIHByb2JlIChkYXRhKSB7XG4gICAgLy8gY2hlY2sgaWYgZGF0YSBjb250YWlucyBJRDMgdGltZXN0YW1wIGFuZCBNUEVHIHN5bmMgd29yZFxuICAgIGxldCBvZmZzZXQsIGxlbmd0aDtcbiAgICBsZXQgaWQzRGF0YSA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIDApO1xuICAgIGlmIChpZDNEYXRhICYmIElEMy5nZXRUaW1lU3RhbXAoaWQzRGF0YSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gTG9vayBmb3IgTVBFRyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTFYIFhZWlggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxIGFuZCBZIG9yIFogc2hvdWxkIGJlIDFcbiAgICAgIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgZGlmZmVyZW50IGZyb20gMCAoTGF5ZXIgSSBvciBMYXllciBJSSBvciBMYXllciBJSUkpXG4gICAgICAvLyBNb3JlIGluZm8gaHR0cDovL3d3dy5tcDMtdGVjaC5vcmcvcHJvZ3JhbW1lci9mcmFtZV9oZWFkZXIuaHRtbFxuICAgICAgZm9yIChvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aCwgbGVuZ3RoID0gTWF0aC5taW4oZGF0YS5sZW5ndGggLSAxLCBvZmZzZXQgKyAxMDApOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICAgIGlmIChNcGVnQXVkaW8ucHJvYmUoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ01QRUcgQXVkaW8gc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gIGFwcGVuZCAoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgbGV0IGlkM0RhdGEgPSBJRDMuZ2V0SUQzRGF0YShkYXRhLCAwKTtcbiAgICBsZXQgdGltZXN0YW1wID0gSUQzLmdldFRpbWVTdGFtcChpZDNEYXRhKTtcbiAgICBsZXQgcHRzID0gdGltZXN0YW1wID8gOTAgKiB0aW1lc3RhbXAgOiB0aW1lT2Zmc2V0ICogOTAwMDA7XG4gICAgbGV0IG9mZnNldCA9IGlkM0RhdGEubGVuZ3RoO1xuICAgIGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICBsZXQgZnJhbWVJbmRleCA9IDAsIHN0YW1wID0gMDtcbiAgICBsZXQgdHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrO1xuXG4gICAgbGV0IGlkM1NhbXBsZXMgPSBbeyBwdHM6IHB0cywgZHRzOiBwdHMsIGRhdGE6IGlkM0RhdGEgfV07XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoTXBlZ0F1ZGlvLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgbGV0IGZyYW1lID0gTXBlZ0F1ZGlvLmFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCk7XG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgc3RhbXAgPSBmcmFtZS5zYW1wbGUucHRzO1xuICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdVbmFibGUgdG8gcGFyc2UgTXBlZyBhdWRpbyBmcmFtZScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKElEMy5pc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGlkM0RhdGEgPSBJRDMuZ2V0SUQzRGF0YShkYXRhLCBvZmZzZXQpO1xuICAgICAgICBpZDNTYW1wbGVzLnB1c2goeyBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wLCBkYXRhOiBpZDNEYXRhIH0pO1xuICAgICAgICBvZmZzZXQgKz0gaWQzRGF0YS5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGZvdW5kLCBrZWVwIGxvb2tpbmdcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZW11eGVyLnJlbXV4KHRyYWNrLFxuICAgICAgeyBzYW1wbGVzOiBbXSB9LFxuICAgICAgeyBzYW1wbGVzOiBpZDNTYW1wbGVzLCBpbnB1dFRpbWVTY2FsZTogOTAwMDAgfSxcbiAgICAgIHsgc2FtcGxlczogW10gfSxcbiAgICAgIHRpbWVPZmZzZXQsXG4gICAgICBjb250aWd1b3VzLFxuICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1QM0RlbXV4ZXI7XG4iLCIvKipcbiAqIE1QNCBkZW11eGVyXG4gKi9cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcblxuY29uc3QgVUlOVDMyX01BWCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5cbmNsYXNzIE1QNERlbXV4ZXIge1xuICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIsIHJlbXV4ZXIpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5yZW11eGVyID0gcmVtdXhlcjtcbiAgfVxuXG4gIHJlc2V0VGltZVN0YW1wIChpbml0UFRTKSB7XG4gICAgdGhpcy5pbml0UFRTID0gaW5pdFBUUztcbiAgfVxuXG4gIHJlc2V0SW5pdFNlZ21lbnQgKGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbikge1xuICAgIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgICBpZiAoaW5pdFNlZ21lbnQgJiYgaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkge1xuICAgICAgY29uc3QgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhID0gTVA0RGVtdXhlci5wYXJzZUluaXRTZWdtZW50KGluaXRTZWdtZW50KTtcblxuICAgICAgLy8gZGVmYXVsdCBhdWRpbyBjb2RlYyBpZiBub3RoaW5nIHNwZWNpZmllZFxuICAgICAgLy8gVE9ETyA6IGV4dHJhY3QgdGhhdCBmcm9tIGluaXRzZWdtZW50XG4gICAgICBpZiAoYXVkaW9Db2RlYyA9PSBudWxsKSB7XG4gICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgIH1cblxuICAgICAgaWYgKHZpZGVvQ29kZWMgPT0gbnVsbCkge1xuICAgICAgICB2aWRlb0NvZGVjID0gJ2F2YzEuNDJlMDFlJztcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHJhY2tzID0ge307XG4gICAgICBpZiAoaW5pdERhdGEuYXVkaW8gJiYgaW5pdERhdGEudmlkZW8pIHtcbiAgICAgICAgdHJhY2tzLmF1ZGlvdmlkZW8gPSB7IGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsIGNvZGVjOiBhdWRpb0NvZGVjICsgJywnICsgdmlkZW9Db2RlYywgaW5pdFNlZ21lbnQ6IGR1cmF0aW9uID8gaW5pdFNlZ21lbnQgOiBudWxsIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5pdERhdGEuYXVkaW8pIHtcbiAgICAgICAgICB0cmFja3MuYXVkaW8gPSB7IGNvbnRhaW5lcjogJ2F1ZGlvL21wNCcsIGNvZGVjOiBhdWRpb0NvZGVjLCBpbml0U2VnbWVudDogZHVyYXRpb24gPyBpbml0U2VnbWVudCA6IG51bGwgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbml0RGF0YS52aWRlbykge1xuICAgICAgICAgIHRyYWNrcy52aWRlbyA9IHsgY29udGFpbmVyOiAndmlkZW8vbXA0JywgY29kZWM6IHZpZGVvQ29kZWMsIGluaXRTZWdtZW50OiBkdXJhdGlvbiA/IGluaXRTZWdtZW50IDogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwgeyB0cmFja3MgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhdWRpb0NvZGVjKSB7XG4gICAgICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICB9XG5cbiAgICAgIGlmICh2aWRlb0NvZGVjKSB7XG4gICAgICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHByb2JlIChkYXRhKSB7XG4gICAgLy8gZW5zdXJlIHdlIGZpbmQgYSBtb29mIGJveCBpbiB0aGUgZmlyc3QgMTYga0JcbiAgICByZXR1cm4gTVA0RGVtdXhlci5maW5kQm94KHsgZGF0YTogZGF0YSwgc3RhcnQ6IDAsIGVuZDogTWF0aC5taW4oZGF0YS5sZW5ndGgsIDE2Mzg0KSB9LCBbJ21vb2YnXSkubGVuZ3RoID4gMDtcbiAgfVxuXG4gIHN0YXRpYyBiaW4yc3RyIChidWZmZXIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBidWZmZXIpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRVaW50MTYgKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgaWYgKGJ1ZmZlci5kYXRhKSB7XG4gICAgICBvZmZzZXQgKz0gYnVmZmVyLnN0YXJ0O1xuICAgICAgYnVmZmVyID0gYnVmZmVyLmRhdGE7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsID0gYnVmZmVyW29mZnNldF0gPDwgOCB8XG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIDFdO1xuXG4gICAgcmV0dXJuIHZhbCA8IDAgPyA2NTUzNiArIHZhbCA6IHZhbDtcbiAgfVxuXG4gIHN0YXRpYyByZWFkVWludDMyIChidWZmZXIsIG9mZnNldCkge1xuICAgIGlmIChidWZmZXIuZGF0YSkge1xuICAgICAgb2Zmc2V0ICs9IGJ1ZmZlci5zdGFydDtcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5kYXRhO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbCA9IGJ1ZmZlcltvZmZzZXRdIDw8IDI0IHxcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPDwgMTYgfFxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAyXSA8PCA4IHxcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgM107XG4gICAgcmV0dXJuIHZhbCA8IDAgPyA0Mjk0OTY3Mjk2ICsgdmFsIDogdmFsO1xuICB9XG5cbiAgc3RhdGljIHdyaXRlVWludDMyIChidWZmZXIsIG9mZnNldCwgdmFsdWUpIHtcbiAgICBpZiAoYnVmZmVyLmRhdGEpIHtcbiAgICAgIG9mZnNldCArPSBidWZmZXIuc3RhcnQ7XG4gICAgICBidWZmZXIgPSBidWZmZXIuZGF0YTtcbiAgICB9XG4gICAgYnVmZmVyW29mZnNldF0gPSB2YWx1ZSA+PiAyNDtcbiAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltvZmZzZXQgKyAzXSA9IHZhbHVlICYgMHhmZjtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGRhdGEgZm9yIGEgYm94IHNwZWNpZmllZCBieSBpdHMgcGF0aFxuICBzdGF0aWMgZmluZEJveCAoZGF0YSwgcGF0aCkge1xuICAgIGxldCByZXN1bHRzID0gW10sXG4gICAgICBpLCBzaXplLCB0eXBlLCBlbmQsIHN1YnJlc3VsdHMsIHN0YXJ0LCBlbmRib3g7XG5cbiAgICBpZiAoZGF0YS5kYXRhKSB7XG4gICAgICBzdGFydCA9IGRhdGEuc3RhcnQ7XG4gICAgICBlbmQgPSBkYXRhLmVuZDtcbiAgICAgIGRhdGEgPSBkYXRhLmRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGVuZCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAoIXBhdGgubGVuZ3RoKSB7XG4gICAgICAvLyBzaG9ydC1jaXJjdWl0IHRoZSBzZWFyY2ggZm9yIGVtcHR5IHBhdGhzXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDspIHtcbiAgICAgIHNpemUgPSBNUDREZW11eGVyLnJlYWRVaW50MzIoZGF0YSwgaSk7XG4gICAgICB0eXBlID0gTVA0RGVtdXhlci5iaW4yc3RyKGRhdGEuc3ViYXJyYXkoaSArIDQsIGkgKyA4KSk7XG4gICAgICBlbmRib3ggPSBzaXplID4gMSA/IGkgKyBzaXplIDogZW5kO1xuXG4gICAgICBpZiAodHlwZSA9PT0gcGF0aFswXSkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgb2YgdGhlIHBhdGggYW5kIHdlJ3ZlIGZvdW5kIHRoZSBib3ggd2Ugd2VyZVxuICAgICAgICAgIC8vIGxvb2tpbmcgZm9yXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHsgZGF0YTogZGF0YSwgc3RhcnQ6IGkgKyA4LCBlbmQ6IGVuZGJveCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHRoZSBuZXh0IGJveCBhbG9uZyB0aGUgcGF0aFxuICAgICAgICAgIHN1YnJlc3VsdHMgPSBNUDREZW11eGVyLmZpbmRCb3goeyBkYXRhOiBkYXRhLCBzdGFydDogaSArIDgsIGVuZDogZW5kYm94IH0sIHBhdGguc2xpY2UoMSkpO1xuICAgICAgICAgIGlmIChzdWJyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHN1YnJlc3VsdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaSA9IGVuZGJveDtcbiAgICB9XG5cbiAgICAvLyB3ZSd2ZSBmaW5pc2hlZCBzZWFyY2hpbmcgYWxsIG9mIGRhdGFcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZVNlZ21lbnRJbmRleCAoaW5pdFNlZ21lbnQpIHtcbiAgICBjb25zdCBtb292ID0gTVA0RGVtdXhlci5maW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnXSlbMF07XG4gICAgY29uc3QgbW9vdkVuZE9mZnNldCA9IG1vb3YgPyBtb292LmVuZCA6IG51bGw7IC8vIHdlIG5lZWQgdGhpcyBpbiBjYXNlIHdlIG5lZWQgdG8gY2hvcCBvZiBnYXJiYWdlIG9mIHRoZSBlbmQgb2YgY3VycmVudCBkYXRhXG5cbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGxldCBzaWR4ID0gTVA0RGVtdXhlci5maW5kQm94KGluaXRTZWdtZW50LCBbJ3NpZHgnXSk7XG4gICAgbGV0IHJlZmVyZW5jZXM7XG5cbiAgICBpZiAoIXNpZHggfHwgIXNpZHhbMF0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJlZmVyZW5jZXMgPSBbXTtcbiAgICBzaWR4ID0gc2lkeFswXTtcblxuICAgIGNvbnN0IHZlcnNpb24gPSBzaWR4LmRhdGFbMF07XG5cbiAgICAvLyBzZXQgaW5pdGlhbCBvZmZzZXQsIHdlIHNraXAgdGhlIHJlZmVyZW5jZSBJRCAobm90IG5lZWRlZClcbiAgICBpbmRleCA9IHZlcnNpb24gPT09IDAgPyA4IDogMTY7XG5cbiAgICBjb25zdCB0aW1lc2NhbGUgPSBNUDREZW11eGVyLnJlYWRVaW50MzIoc2lkeCwgaW5kZXgpO1xuICAgIGluZGV4ICs9IDQ7XG5cbiAgICAvLyBUT0RPOiBwYXJzZSBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgYW5kIGZpcnN0T2Zmc2V0XG4gICAgLy8gdXN1YWxseSB6ZXJvIGluIG91ciBjYXNlXG4gICAgbGV0IGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSA9IDA7XG4gICAgbGV0IGZpcnN0T2Zmc2V0ID0gMDtcblxuICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICBpbmRleCArPSA4O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCArPSAxNjtcbiAgICB9XG5cbiAgICAvLyBza2lwIHJlc2VydmVkXG4gICAgaW5kZXggKz0gMjtcblxuICAgIGxldCBzdGFydEJ5dGUgPSBzaWR4LmVuZCArIGZpcnN0T2Zmc2V0O1xuXG4gICAgY29uc3QgcmVmZXJlbmNlc0NvdW50ID0gTVA0RGVtdXhlci5yZWFkVWludDE2KHNpZHgsIGluZGV4KTtcbiAgICBpbmRleCArPSAyO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWZlcmVuY2VzQ291bnQ7IGkrKykge1xuICAgICAgbGV0IHJlZmVyZW5jZUluZGV4ID0gaW5kZXg7XG5cbiAgICAgIGNvbnN0IHJlZmVyZW5jZUluZm8gPSBNUDREZW11eGVyLnJlYWRVaW50MzIoc2lkeCwgcmVmZXJlbmNlSW5kZXgpO1xuICAgICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcblxuICAgICAgY29uc3QgcmVmZXJlbmNlU2l6ZSA9IHJlZmVyZW5jZUluZm8gJiAweDdGRkZGRkZGO1xuICAgICAgY29uc3QgcmVmZXJlbmNlVHlwZSA9IChyZWZlcmVuY2VJbmZvICYgMHg4MDAwMDAwMCkgPj4+IDMxO1xuXG4gICAgICBpZiAocmVmZXJlbmNlVHlwZSA9PT0gMSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1NJRFggaGFzIGhpZXJhcmNoaWNhbCByZWZlcmVuY2VzIChub3Qgc3VwcG9ydGVkKScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN1YnNlZ21lbnREdXJhdGlvbiA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMihzaWR4LCByZWZlcmVuY2VJbmRleCk7XG4gICAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuXG4gICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICByZWZlcmVuY2VTaXplLFxuICAgICAgICBzdWJzZWdtZW50RHVyYXRpb24sIC8vIHVuc2NhbGVkXG4gICAgICAgIGluZm86IHtcbiAgICAgICAgICBkdXJhdGlvbjogc3Vic2VnbWVudER1cmF0aW9uIC8gdGltZXNjYWxlLFxuICAgICAgICAgIHN0YXJ0OiBzdGFydEJ5dGUsXG4gICAgICAgICAgZW5kOiBzdGFydEJ5dGUgKyByZWZlcmVuY2VTaXplIC0gMVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgc3RhcnRCeXRlICs9IHJlZmVyZW5jZVNpemU7XG5cbiAgICAgIC8vIFNraXBwaW5nIDEgYml0IGZvciB8c3RhcnRzV2l0aFNhcHwsIDMgYml0cyBmb3IgfHNhcFR5cGV8LCBhbmQgMjggYml0c1xuICAgICAgLy8gZm9yIHxzYXBEZWx0YXwuXG4gICAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuXG4gICAgICAvLyBza2lwIHRvIG5leHQgcmVmXG4gICAgICBpbmRleCA9IHJlZmVyZW5jZUluZGV4O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUsXG4gICAgICB0aW1lc2NhbGUsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgcmVmZXJlbmNlc0NvdW50LFxuICAgICAgcmVmZXJlbmNlcyxcbiAgICAgIG1vb3ZFbmRPZmZzZXRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBNUDQgaW5pdGlhbGl6YXRpb24gc2VnbWVudCBhbmQgZXh0cmFjdHMgc3RyZWFtIHR5cGUgYW5kXG4gICAqIHRpbWVzY2FsZSB2YWx1ZXMgZm9yIGFueSBkZWNsYXJlZCB0cmFja3MuIFRpbWVzY2FsZSB2YWx1ZXMgaW5kaWNhdGUgdGhlXG4gICAqIG51bWJlciBvZiBjbG9jayB0aWNrcyBwZXIgc2Vjb25kIHRvIGFzc3VtZSBmb3IgdGltZS1iYXNlZCB2YWx1ZXNcbiAgICogZWxzZXdoZXJlIGluIHRoZSBNUDQuXG4gICAqXG4gICAqIFRvIGRldGVybWluZSB0aGUgc3RhcnQgdGltZSBvZiBhbiBNUDQsIHlvdSBuZWVkIHR3byBwaWVjZXMgb2ZcbiAgICogaW5mb3JtYXRpb246IHRoZSB0aW1lc2NhbGUgdW5pdCBhbmQgdGhlIGVhcmxpZXN0IGJhc2UgbWVkaWEgZGVjb2RlXG4gICAqIHRpbWUuIE11bHRpcGxlIHRpbWVzY2FsZXMgY2FuIGJlIHNwZWNpZmllZCB3aXRoaW4gYW4gTVA0IGJ1dCB0aGVcbiAgICogYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBpcyBhbHdheXMgZXhwcmVzc2VkIGluIHRoZSB0aW1lc2NhbGUgZnJvbVxuICAgKiB0aGUgbWVkaWEgaGVhZGVyIGJveCBmb3IgdGhlIHRyYWNrOlxuICAgKiBgYGBcbiAgICogbW9vdiA+IHRyYWsgPiBtZGlhID4gbWRoZC50aW1lc2NhbGVcbiAgICogbW9vdiA+IHRyYWsgPiBtZGlhID4gaGRsclxuICAgKiBgYGBcbiAgICogQHBhcmFtIGluaXQge1VpbnQ4QXJyYXl9IHRoZSBieXRlcyBvZiB0aGUgaW5pdCBzZWdtZW50XG4gICAqIEByZXR1cm4ge29iamVjdH0gYSBoYXNoIG9mIHRyYWNrIHR5cGUgdG8gdGltZXNjYWxlIHZhbHVlcyBvciBudWxsIGlmXG4gICAqIHRoZSBpbml0IHNlZ21lbnQgaXMgbWFsZm9ybWVkLlxuICAgKi9cbiAgc3RhdGljIHBhcnNlSW5pdFNlZ21lbnQgKGluaXRTZWdtZW50KSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGxldCB0cmFrcyA9IE1QNERlbXV4ZXIuZmluZEJveChpbml0U2VnbWVudCwgWydtb292JywgJ3RyYWsnXSk7XG5cbiAgICB0cmFrcy5mb3JFYWNoKHRyYWsgPT4ge1xuICAgICAgY29uc3QgdGtoZCA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ3RraGQnXSlbMF07XG4gICAgICBpZiAodGtoZCkge1xuICAgICAgICBsZXQgdmVyc2lvbiA9IHRraGQuZGF0YVt0a2hkLnN0YXJ0XTtcbiAgICAgICAgbGV0IGluZGV4ID0gdmVyc2lvbiA9PT0gMCA/IDEyIDogMjA7XG4gICAgICAgIGxldCB0cmFja0lkID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRraGQsIGluZGV4KTtcblxuICAgICAgICBjb25zdCBtZGhkID0gTVA0RGVtdXhlci5maW5kQm94KHRyYWssIFsnbWRpYScsICdtZGhkJ10pWzBdO1xuICAgICAgICBpZiAobWRoZCkge1xuICAgICAgICAgIHZlcnNpb24gPSBtZGhkLmRhdGFbbWRoZC5zdGFydF07XG4gICAgICAgICAgaW5kZXggPSB2ZXJzaW9uID09PSAwID8gMTIgOiAyMDtcbiAgICAgICAgICBjb25zdCB0aW1lc2NhbGUgPSBNUDREZW11eGVyLnJlYWRVaW50MzIobWRoZCwgaW5kZXgpO1xuXG4gICAgICAgICAgY29uc3QgaGRsciA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnaGRsciddKVswXTtcbiAgICAgICAgICBpZiAoaGRscikge1xuICAgICAgICAgICAgY29uc3QgaGRsclR5cGUgPSBNUDREZW11eGVyLmJpbjJzdHIoaGRsci5kYXRhLnN1YmFycmF5KGhkbHIuc3RhcnQgKyA4LCBoZGxyLnN0YXJ0ICsgMTIpKTtcbiAgICAgICAgICAgIGxldCB0eXBlID0geyAnc291bic6ICdhdWRpbycsICd2aWRlJzogJ3ZpZGVvJyB9W2hkbHJUeXBlXTtcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgIC8vIGV4dHJhY3QgY29kZWMgaW5mby4gVE9ETyA6IHBhcnNlIGNvZGVjIGRldGFpbHMgdG8gYmUgYWJsZSB0byBidWlsZCBNSU1FIHR5cGVcbiAgICAgICAgICAgICAgbGV0IGNvZGVjQm94ID0gTVA0RGVtdXhlci5maW5kQm94KHRyYWssIFsnbWRpYScsICdtaW5mJywgJ3N0YmwnLCAnc3RzZCddKTtcbiAgICAgICAgICAgICAgaWYgKGNvZGVjQm94Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvZGVjQm94ID0gY29kZWNCb3hbMF07XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVjVHlwZSA9IE1QNERlbXV4ZXIuYmluMnN0cihjb2RlY0JveC5kYXRhLnN1YmFycmF5KGNvZGVjQm94LnN0YXJ0ICsgMTIsIGNvZGVjQm94LnN0YXJ0ICsgMTYpKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBNUDREZW11eGVyOiR7dHlwZX06JHtjb2RlY1R5cGV9IGZvdW5kYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0W3RyYWNrSWRdID0geyB0aW1lc2NhbGU6IHRpbWVzY2FsZSwgdHlwZTogdHlwZSB9O1xuICAgICAgICAgICAgICByZXN1bHRbdHlwZV0gPSB7IHRpbWVzY2FsZTogdGltZXNjYWxlLCBpZDogdHJhY2tJZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAqIERldGVybWluZSB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSwgaW4gc2Vjb25kcywgZm9yIGFuIE1QNFxuICogZnJhZ21lbnQuIElmIG11bHRpcGxlIGZyYWdtZW50cyBhcmUgc3BlY2lmaWVkLCB0aGUgZWFybGllc3QgdGltZSBpc1xuICogcmV0dXJuZWQuXG4gKlxuICogVGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgY2FuIGJlIHBhcnNlZCBmcm9tIHRyYWNrIGZyYWdtZW50XG4gKiBtZXRhZGF0YTpcbiAqIGBgYFxuICogbW9vZiA+IHRyYWYgPiB0ZmR0LmJhc2VNZWRpYURlY29kZVRpbWVcbiAqIGBgYFxuICogSXQgcmVxdWlyZXMgdGhlIHRpbWVzY2FsZSB2YWx1ZSBmcm9tIHRoZSBtZGhkIHRvIGludGVycHJldC5cbiAqXG4gKiBAcGFyYW0gdGltZXNjYWxlIHtvYmplY3R9IGEgaGFzaCBvZiB0cmFjayBpZHMgdG8gdGltZXNjYWxlIHZhbHVlcy5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGVhcmxpZXN0IGJhc2UgbWVkaWEgZGVjb2RlIHN0YXJ0IHRpbWUgZm9yIHRoZVxuICogZnJhZ21lbnQsIGluIHNlY29uZHNcbiAqL1xuICBzdGF0aWMgZ2V0U3RhcnREVFMgKGluaXREYXRhLCBmcmFnbWVudCkge1xuICAgIGxldCB0cmFmcywgYmFzZVRpbWVzLCByZXN1bHQ7XG5cbiAgICAvLyB3ZSBuZWVkIGluZm8gZnJvbSB0d28gY2hpbGRyZW5kIG9mIGVhY2ggdHJhY2sgZnJhZ21lbnQgYm94XG4gICAgdHJhZnMgPSBNUDREZW11eGVyLmZpbmRCb3goZnJhZ21lbnQsIFsnbW9vZicsICd0cmFmJ10pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBzdGFydCB0aW1lcyBmb3IgZWFjaCB0cmFja1xuICAgIGJhc2VUaW1lcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgdHJhZnMubWFwKGZ1bmN0aW9uICh0cmFmKSB7XG4gICAgICByZXR1cm4gTVA0RGVtdXhlci5maW5kQm94KHRyYWYsIFsndGZoZCddKS5tYXAoZnVuY3Rpb24gKHRmaGQpIHtcbiAgICAgICAgbGV0IGlkLCBzY2FsZSwgYmFzZVRpbWU7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgICAgIGlkID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRmaGQsIDQpO1xuICAgICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgICAgICBzY2FsZSA9IGluaXREYXRhW2lkXS50aW1lc2NhbGUgfHwgOTBlMztcblxuICAgICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgICBiYXNlVGltZSA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkubWFwKGZ1bmN0aW9uICh0ZmR0KSB7XG4gICAgICAgICAgbGV0IHZlcnNpb24sIHJlc3VsdDtcblxuICAgICAgICAgIHZlcnNpb24gPSB0ZmR0LmRhdGFbdGZkdC5zdGFydF07XG4gICAgICAgICAgcmVzdWx0ID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRmZHQsIDQpO1xuICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgICByZXN1bHQgKj0gTWF0aC5wb3coMiwgMzIpO1xuXG4gICAgICAgICAgICByZXN1bHQgKz0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRmZHQsIDgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KVswXTtcbiAgICAgICAgLy8gY29udmVydCBiYXNlIHRpbWUgdG8gc2Vjb25kc1xuICAgICAgICByZXR1cm4gYmFzZVRpbWUgLyBzY2FsZTtcbiAgICAgIH0pO1xuICAgIH0pKTtcblxuICAgIC8vIHJldHVybiB0aGUgbWluaW11bVxuICAgIHJlc3VsdCA9IE1hdGgubWluLmFwcGx5KG51bGwsIGJhc2VUaW1lcyk7XG4gICAgcmV0dXJuIGlzRmluaXRlKHJlc3VsdCkgPyByZXN1bHQgOiAwO1xuICB9XG5cbiAgc3RhdGljIG9mZnNldFN0YXJ0RFRTIChpbml0RGF0YSwgZnJhZ21lbnQsIHRpbWVPZmZzZXQpIHtcbiAgICBNUDREZW11eGVyLmZpbmRCb3goZnJhZ21lbnQsIFsnbW9vZicsICd0cmFmJ10pLm1hcChmdW5jdGlvbiAodHJhZikge1xuICAgICAgcmV0dXJuIE1QNERlbXV4ZXIuZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkubWFwKGZ1bmN0aW9uICh0ZmhkKSB7XG4gICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgICAgbGV0IGlkID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRmaGQsIDQpO1xuICAgICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgICAgICBsZXQgdGltZXNjYWxlID0gaW5pdERhdGFbaWRdLnRpbWVzY2FsZSB8fCA5MGUzO1xuXG4gICAgICAgIC8vIGdldCB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBmcm9tIHRoZSB0ZmR0XG4gICAgICAgIE1QNERlbXV4ZXIuZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkubWFwKGZ1bmN0aW9uICh0ZmR0KSB7XG4gICAgICAgICAgbGV0IHZlcnNpb24gPSB0ZmR0LmRhdGFbdGZkdC5zdGFydF07XG4gICAgICAgICAgbGV0IGJhc2VNZWRpYURlY29kZVRpbWUgPSBNUDREZW11eGVyLnJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgIE1QNERlbXV4ZXIud3JpdGVVaW50MzIodGZkdCwgNCwgYmFzZU1lZGlhRGVjb2RlVGltZSAtIHRpbWVPZmZzZXQgKiB0aW1lc2NhbGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lICo9IE1hdGgucG93KDIsIDMyKTtcbiAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgKz0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRmZHQsIDgpO1xuICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAtPSB0aW1lT2Zmc2V0ICogdGltZXNjYWxlO1xuICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGgubWF4KGJhc2VNZWRpYURlY29kZVRpbWUsIDApO1xuICAgICAgICAgICAgY29uc3QgdXBwZXIgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICAgICAgICAgIGNvbnN0IGxvd2VyID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICAgICAgICBNUDREZW11eGVyLndyaXRlVWludDMyKHRmZHQsIDQsIHVwcGVyKTtcbiAgICAgICAgICAgIE1QNERlbXV4ZXIud3JpdGVVaW50MzIodGZkdCwgOCwgbG93ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgYXBwZW5kIChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICBsZXQgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhO1xuICAgIGlmICghaW5pdERhdGEpIHtcbiAgICAgIHRoaXMucmVzZXRJbml0U2VnbWVudChkYXRhLCB0aGlzLmF1ZGlvQ29kZWMsIHRoaXMudmlkZW9Db2RlYywgZmFsc2UpO1xuICAgICAgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhO1xuICAgIH1cbiAgICBsZXQgc3RhcnREVFMsIGluaXRQVFMgPSB0aGlzLmluaXRQVFM7XG4gICAgaWYgKGluaXRQVFMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IHN0YXJ0RFRTID0gTVA0RGVtdXhlci5nZXRTdGFydERUUyhpbml0RGF0YSwgZGF0YSk7XG4gICAgICB0aGlzLmluaXRQVFMgPSBpbml0UFRTID0gc3RhcnREVFMgLSB0aW1lT2Zmc2V0O1xuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LklOSVRfUFRTX0ZPVU5ELCB7IGluaXRQVFM6IGluaXRQVFMgfSk7XG4gICAgfVxuICAgIE1QNERlbXV4ZXIub2Zmc2V0U3RhcnREVFMoaW5pdERhdGEsIGRhdGEsIGluaXRQVFMpO1xuICAgIHN0YXJ0RFRTID0gTVA0RGVtdXhlci5nZXRTdGFydERUUyhpbml0RGF0YSwgZGF0YSk7XG4gICAgdGhpcy5yZW11eGVyLnJlbXV4KGluaXREYXRhLmF1ZGlvLCBpbml0RGF0YS52aWRlbywgbnVsbCwgbnVsbCwgc3RhcnREVFMsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgZGF0YSk7XG4gIH1cblxuICBkZXN0cm95ICgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1QNERlbXV4ZXI7XG4iLCIvKipcbiAqICBNUEVHIHBhcnNlciBoZWxwZXJcbiAqL1xuXG5jb25zdCBNcGVnQXVkaW8gPSB7XG5cbiAgQml0cmF0ZXNNYXA6IFtcbiAgICAzMiwgNjQsIDk2LCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMjg4LCAzMjAsIDM1MiwgMzg0LCA0MTYsIDQ0OCxcbiAgICAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDM4NCxcbiAgICAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLFxuICAgIDMyLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MCwgMTc2LCAxOTIsIDIyNCwgMjU2LFxuICAgIDgsIDE2LCAyNCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MF0sXG5cbiAgU2FtcGxpbmdSYXRlTWFwOiBbNDQxMDAsIDQ4MDAwLCAzMjAwMCwgMjIwNTAsIDI0MDAwLCAxNjAwMCwgMTEwMjUsIDEyMDAwLCA4MDAwXSxcblxuICBTYW1wbGVzQ29lZmZpY2llbnRzOiBbXG4gICAgLy8gTVBFRyAyLjVcbiAgICBbXG4gICAgICAwLCAvLyBSZXNlcnZlZFxuICAgICAgNzIsIC8vIExheWVyM1xuICAgICAgMTQ0LCAvLyBMYXllcjJcbiAgICAgIDEyIC8vIExheWVyMVxuICAgIF0sXG4gICAgLy8gUmVzZXJ2ZWRcbiAgICBbXG4gICAgICAwLCAvLyBSZXNlcnZlZFxuICAgICAgMCwgLy8gTGF5ZXIzXG4gICAgICAwLCAvLyBMYXllcjJcbiAgICAgIDAgLy8gTGF5ZXIxXG4gICAgXSxcbiAgICAvLyBNUEVHIDJcbiAgICBbXG4gICAgICAwLCAvLyBSZXNlcnZlZFxuICAgICAgNzIsIC8vIExheWVyM1xuICAgICAgMTQ0LCAvLyBMYXllcjJcbiAgICAgIDEyIC8vIExheWVyMVxuICAgIF0sXG4gICAgLy8gTVBFRyAxXG4gICAgW1xuICAgICAgMCwgLy8gUmVzZXJ2ZWRcbiAgICAgIDE0NCwgLy8gTGF5ZXIzXG4gICAgICAxNDQsIC8vIExheWVyMlxuICAgICAgMTIgLy8gTGF5ZXIxXG4gICAgXVxuICBdLFxuXG4gIEJ5dGVzSW5TbG90OiBbXG4gICAgMCwgLy8gUmVzZXJ2ZWRcbiAgICAxLCAvLyBMYXllcjNcbiAgICAxLCAvLyBMYXllcjJcbiAgICA0IC8vIExheWVyMVxuICBdLFxuXG4gIGFwcGVuZEZyYW1lOiBmdW5jdGlvbiAodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KSB7XG4gICAgLy8gVXNpbmcgaHR0cDovL3d3dy5kYXRhdm95YWdlLmNvbS9tcGdzY3JpcHQvbXBlZ2hkci5odG0gYXMgYSByZWZlcmVuY2VcbiAgICBpZiAob2Zmc2V0ICsgMjQgPiBkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBsZXQgaGVhZGVyID0gdGhpcy5wYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICAgIGlmIChoZWFkZXIgJiYgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgICBsZXQgZnJhbWVEdXJhdGlvbiA9IGhlYWRlci5zYW1wbGVzUGVyRnJhbWUgKiA5MDAwMCAvIGhlYWRlci5zYW1wbGVSYXRlO1xuICAgICAgbGV0IHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gICAgICBsZXQgc2FtcGxlID0geyB1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoKSwgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcCB9O1xuXG4gICAgICB0cmFjay5jb25maWcgPSBbXTtcbiAgICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGhlYWRlci5jaGFubmVsQ291bnQ7XG4gICAgICB0cmFjay5zYW1wbGVyYXRlID0gaGVhZGVyLnNhbXBsZVJhdGU7XG4gICAgICB0cmFjay5zYW1wbGVzLnB1c2goc2FtcGxlKTtcbiAgICAgIHRyYWNrLmxlbiArPSBoZWFkZXIuZnJhbWVMZW5ndGg7XG5cbiAgICAgIHJldHVybiB7IHNhbXBsZSwgbGVuZ3RoOiBoZWFkZXIuZnJhbWVMZW5ndGggfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LFxuXG4gIHBhcnNlSGVhZGVyOiBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgbGV0IGhlYWRlckIgPSAoZGF0YVtvZmZzZXQgKyAxXSA+PiAzKSAmIDM7XG4gICAgbGV0IGhlYWRlckMgPSAoZGF0YVtvZmZzZXQgKyAxXSA+PiAxKSAmIDM7XG4gICAgbGV0IGhlYWRlckUgPSAoZGF0YVtvZmZzZXQgKyAyXSA+PiA0KSAmIDE1O1xuICAgIGxldCBoZWFkZXJGID0gKGRhdGFbb2Zmc2V0ICsgMl0gPj4gMikgJiAzO1xuICAgIGxldCBoZWFkZXJHID0gKGRhdGFbb2Zmc2V0ICsgMl0gPj4gMSkgJiAxO1xuICAgIGlmIChoZWFkZXJCICE9PSAxICYmIGhlYWRlckUgIT09IDAgJiYgaGVhZGVyRSAhPT0gMTUgJiYgaGVhZGVyRiAhPT0gMykge1xuICAgICAgbGV0IGNvbHVtbkluQml0cmF0ZXMgPSBoZWFkZXJCID09PSAzID8gKDMgLSBoZWFkZXJDKSA6IChoZWFkZXJDID09PSAzID8gMyA6IDQpO1xuICAgICAgbGV0IGJpdFJhdGUgPSBNcGVnQXVkaW8uQml0cmF0ZXNNYXBbY29sdW1uSW5CaXRyYXRlcyAqIDE0ICsgaGVhZGVyRSAtIDFdICogMTAwMDtcbiAgICAgIGxldCBjb2x1bW5JblNhbXBsZVJhdGVzID0gaGVhZGVyQiA9PT0gMyA/IDAgOiBoZWFkZXJCID09PSAyID8gMSA6IDI7XG4gICAgICBsZXQgc2FtcGxlUmF0ZSA9IE1wZWdBdWRpby5TYW1wbGluZ1JhdGVNYXBbY29sdW1uSW5TYW1wbGVSYXRlcyAqIDMgKyBoZWFkZXJGXTtcbiAgICAgIGxldCBjaGFubmVsQ291bnQgPSBkYXRhW29mZnNldCArIDNdID4+IDYgPT09IDMgPyAxIDogMjsgLy8gSWYgYml0cyBvZiBjaGFubmVsIG1vZGUgYXJlIGAxMWAgdGhlbiBpdCBpcyBhIHNpbmdsZSBjaGFubmVsIChNb25vKVxuICAgICAgbGV0IHNhbXBsZUNvZWZmaWNpZW50ID0gTXBlZ0F1ZGlvLlNhbXBsZXNDb2VmZmljaWVudHNbaGVhZGVyQl1baGVhZGVyQ107XG4gICAgICBsZXQgYnl0ZXNJblNsb3QgPSBNcGVnQXVkaW8uQnl0ZXNJblNsb3RbaGVhZGVyQ107XG4gICAgICBsZXQgc2FtcGxlc1BlckZyYW1lID0gc2FtcGxlQ29lZmZpY2llbnQgKiA4ICogYnl0ZXNJblNsb3Q7XG4gICAgICBsZXQgZnJhbWVMZW5ndGggPSBwYXJzZUludChzYW1wbGVDb2VmZmljaWVudCAqIGJpdFJhdGUgLyBzYW1wbGVSYXRlICsgaGVhZGVyRywgMTApICogYnl0ZXNJblNsb3Q7XG5cbiAgICAgIHJldHVybiB7IHNhbXBsZVJhdGUsIGNoYW5uZWxDb3VudCwgZnJhbWVMZW5ndGgsIHNhbXBsZXNQZXJGcmFtZSB9O1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgaXNIZWFkZXJQYXR0ZXJuOiBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFbb2Zmc2V0XSA9PT0gMHhmZiAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZTApID09PSAweGUwICYmIChkYXRhW29mZnNldCArIDFdICYgMHgwNikgIT09IDB4MDA7XG4gIH0sXG5cbiAgaXNIZWFkZXI6IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcbiAgICAvLyBMb29rIGZvciBNUEVHIGhlYWRlciB8IDExMTEgMTExMSB8IDExMVggWFlaWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDEgYW5kIFkgb3IgWiBzaG91bGQgYmUgMVxuICAgIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgZGlmZmVyZW50IGZyb20gMCAoTGF5ZXIgSSBvciBMYXllciBJSSBvciBMYXllciBJSUkpXG4gICAgLy8gTW9yZSBpbmZvIGh0dHA6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIHRoaXMuaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBwcm9iZTogZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgIC8vIHNhbWUgYXMgaXNIZWFkZXIgYnV0IHdlIGFsc28gY2hlY2sgdGhhdCBNUEVHIGZyYW1lIGZvbGxvd3MgbGFzdCBNUEVHIGZyYW1lXG4gICAgLy8gb3IgZW5kIG9mIGRhdGEgaXMgcmVhY2hlZFxuICAgIGlmIChvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgdGhpcy5pc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgLy8gTVBFRyBoZWFkZXIgTGVuZ3RoXG4gICAgICBsZXQgaGVhZGVyTGVuZ3RoID0gNDtcbiAgICAgIC8vIE1QRUcgZnJhbWUgTGVuZ3RoXG4gICAgICBsZXQgaGVhZGVyID0gdGhpcy5wYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICAgICAgbGV0IGZyYW1lTGVuZ3RoID0gaGVhZGVyTGVuZ3RoO1xuICAgICAgaWYgKGhlYWRlciAmJiBoZWFkZXIuZnJhbWVMZW5ndGgpIHtcbiAgICAgICAgZnJhbWVMZW5ndGggPSBoZWFkZXIuZnJhbWVMZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGxldCBuZXdPZmZzZXQgPSBvZmZzZXQgKyBmcmFtZUxlbmd0aDtcbiAgICAgIGlmIChuZXdPZmZzZXQgPT09IGRhdGEubGVuZ3RoIHx8IChuZXdPZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgdGhpcy5pc0hlYWRlclBhdHRlcm4oZGF0YSwgbmV3T2Zmc2V0KSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTXBlZ0F1ZGlvO1xuIiwiLyoqXG4gKiBTQU1QTEUtQUVTIGRlY3J5cHRlclxuKi9cblxuaW1wb3J0IERlY3J5cHRlciBmcm9tICcuLi9jcnlwdC9kZWNyeXB0ZXInO1xuXG5jbGFzcyBTYW1wbGVBZXNEZWNyeXB0ZXIge1xuICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIsIGNvbmZpZywgZGVjcnlwdGRhdGEsIGRpc2NhcmRFUEIpIHtcbiAgICB0aGlzLmRlY3J5cHRkYXRhID0gZGVjcnlwdGRhdGE7XG4gICAgdGhpcy5kaXNjYXJkRVBCID0gZGlzY2FyZEVQQjtcbiAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIob2JzZXJ2ZXIsIGNvbmZpZywgeyByZW1vdmVQS0NTN1BhZGRpbmc6IGZhbHNlIH0pO1xuICB9XG5cbiAgZGVjcnlwdEJ1ZmZlciAoZW5jcnlwdGVkRGF0YSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KGVuY3J5cHRlZERhdGEsIHRoaXMuZGVjcnlwdGRhdGEua2V5LmJ1ZmZlciwgdGhpcy5kZWNyeXB0ZGF0YS5pdi5idWZmZXIsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIEFBQyAtIGVuY3J5cHQgYWxsIGZ1bGwgMTYgYnl0ZXMgYmxvY2tzIHN0YXJ0aW5nIGZyb20gb2Zmc2V0IDE2XG4gIGRlY3J5cHRBYWNTYW1wbGUgKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaywgc3luYykge1xuICAgIGxldCBjdXJVbml0ID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdDtcbiAgICBsZXQgZW5jcnlwdGVkRGF0YSA9IGN1clVuaXQuc3ViYXJyYXkoMTYsIGN1clVuaXQubGVuZ3RoIC0gY3VyVW5pdC5sZW5ndGggJSAxNik7XG4gICAgbGV0IGVuY3J5cHRlZEJ1ZmZlciA9IGVuY3J5cHRlZERhdGEuYnVmZmVyLnNsaWNlKFxuICAgICAgZW5jcnlwdGVkRGF0YS5ieXRlT2Zmc2V0LFxuICAgICAgZW5jcnlwdGVkRGF0YS5ieXRlT2Zmc2V0ICsgZW5jcnlwdGVkRGF0YS5sZW5ndGgpO1xuXG4gICAgbGV0IGxvY2FsdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5kZWNyeXB0QnVmZmVyKGVuY3J5cHRlZEJ1ZmZlciwgZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgIGRlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICAgIGN1clVuaXQuc2V0KGRlY3J5cHRlZERhdGEsIDE2KTtcblxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGxvY2FsdGhpcy5kZWNyeXB0QWFjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRlY3J5cHRBYWNTYW1wbGVzIChzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2spIHtcbiAgICBmb3IgKDs7IHNhbXBsZUluZGV4KyspIHtcbiAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0Lmxlbmd0aCA8IDMyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgc3luYyA9IHRoaXMuZGVjcnlwdGVyLmlzU3luYygpO1xuXG4gICAgICB0aGlzLmRlY3J5cHRBYWNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrLCBzeW5jKTtcblxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBVkMgLSBlbmNyeXB0IG9uZSAxNiBieXRlcyBibG9jayBvdXQgb2YgdGVuLCBzdGFydGluZyBmcm9tIG9mZnNldCAzMlxuICBnZXRBdmNFbmNyeXB0ZWREYXRhIChkZWNvZGVkRGF0YSkge1xuICAgIGxldCBlbmNyeXB0ZWREYXRhTGVuID0gTWF0aC5mbG9vcigoZGVjb2RlZERhdGEubGVuZ3RoIC0gNDgpIC8gMTYwKSAqIDE2ICsgMTY7XG4gICAgbGV0IGVuY3J5cHRlZERhdGEgPSBuZXcgSW50OEFycmF5KGVuY3J5cHRlZERhdGFMZW4pO1xuICAgIGxldCBvdXRwdXRQb3MgPSAwO1xuICAgIGZvciAobGV0IGlucHV0UG9zID0gMzI7IGlucHV0UG9zIDw9IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2OyBpbnB1dFBvcyArPSAxNjAsIG91dHB1dFBvcyArPSAxNikge1xuICAgICAgZW5jcnlwdGVkRGF0YS5zZXQoZGVjb2RlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLCBvdXRwdXRQb3MpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmNyeXB0ZWREYXRhO1xuICB9XG5cbiAgZ2V0QXZjRGVjcnlwdGVkVW5pdCAoZGVjb2RlZERhdGEsIGRlY3J5cHRlZERhdGEpIHtcbiAgICBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSk7XG4gICAgbGV0IGlucHV0UG9zID0gMDtcbiAgICBmb3IgKGxldCBvdXRwdXRQb3MgPSAzMjsgb3V0cHV0UG9zIDw9IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2OyBvdXRwdXRQb3MgKz0gMTYwLCBpbnB1dFBvcyArPSAxNikge1xuICAgICAgZGVjb2RlZERhdGEuc2V0KGRlY3J5cHRlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLCBvdXRwdXRQb3MpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNvZGVkRGF0YTtcbiAgfVxuXG4gIGRlY3J5cHRBdmNTYW1wbGUgKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0LCBzeW5jKSB7XG4gICAgbGV0IGRlY29kZWREYXRhID0gdGhpcy5kaXNjYXJkRVBCKGN1clVuaXQuZGF0YSk7XG4gICAgbGV0IGVuY3J5cHRlZERhdGEgPSB0aGlzLmdldEF2Y0VuY3J5cHRlZERhdGEoZGVjb2RlZERhdGEpO1xuICAgIGxldCBsb2NhbHRoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5kZWNyeXB0QnVmZmVyKGVuY3J5cHRlZERhdGEuYnVmZmVyLCBmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgY3VyVW5pdC5kYXRhID0gbG9jYWx0aGlzLmdldEF2Y0RlY3J5cHRlZFVuaXQoZGVjb2RlZERhdGEsIGRlY3J5cHRlZERhdGEpO1xuXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgbG9jYWx0aGlzLmRlY3J5cHRBdmNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBkZWNyeXB0QXZjU2FtcGxlcyAoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2spIHtcbiAgICBmb3IgKDs7IHNhbXBsZUluZGV4KyssIHVuaXRJbmRleCA9IDApIHtcbiAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBjdXJVbml0cyA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXRzO1xuICAgICAgZm9yICg7OyB1bml0SW5kZXgrKykge1xuICAgICAgICBpZiAodW5pdEluZGV4ID49IGN1clVuaXRzLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGN1clVuaXQgPSBjdXJVbml0c1t1bml0SW5kZXhdO1xuICAgICAgICBpZiAoY3VyVW5pdC5sZW5ndGggPD0gNDggfHwgKGN1clVuaXQudHlwZSAhPT0gMSAmJiBjdXJVbml0LnR5cGUgIT09IDUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3luYyA9IHRoaXMuZGVjcnlwdGVyLmlzU3luYygpO1xuXG4gICAgICAgIHRoaXMuZGVjcnlwdEF2Y1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaywgY3VyVW5pdCwgc3luYyk7XG5cbiAgICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNhbXBsZUFlc0RlY3J5cHRlcjtcbiIsIi8qKlxuICogaGlnaGx5IG9wdGltaXplZCBUUyBkZW11eGVyOlxuICogcGFyc2UgUEFULCBQTVRcbiAqIGV4dHJhY3QgUEVTIHBhY2tldCBmcm9tIGF1ZGlvIGFuZCB2aWRlbyBQSURzXG4gKiBleHRyYWN0IEFWQy9IMjY0IE5BTCB1bml0cyBhbmQgQUFDL0FEVFMgc2FtcGxlcyBmcm9tIFBFUyBwYWNrZXRcbiAqIHRyaWdnZXIgdGhlIHJlbXV4ZXIgdXBvbiBwYXJzaW5nIGNvbXBsZXRpb25cbiAqIGl0IGFsc28gdHJpZXMgdG8gd29ya2Fyb3VuZCBhcyBiZXN0IGFzIGl0IGNhbiBhdWRpbyBjb2RlYyBzd2l0Y2ggKEhFLUFBQyB0byBBQUMgYW5kIHZpY2UgdmVyc2EpLCB3aXRob3V0IGhhdmluZyB0byByZXN0YXJ0IHRoZSBNZWRpYVNvdXJjZS5cbiAqIGl0IGFsc28gY29udHJvbHMgdGhlIHJlbXV4aW5nIHByb2Nlc3MgOlxuICogdXBvbiBkaXNjb250aW51aXR5IG9yIGxldmVsIHN3aXRjaCBkZXRlY3Rpb24sIGl0IHdpbGwgYWxzbyBub3RpZmllcyB0aGUgcmVtdXhlciBzbyB0aGF0IGl0IGNhbiByZXNldCBpdHMgc3RhdGUuXG4qL1xuXG5pbXBvcnQgKiBhcyBBRFRTIGZyb20gJy4vYWR0cyc7XG5pbXBvcnQgTXBlZ0F1ZGlvIGZyb20gJy4vbXBlZ2F1ZGlvJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV4cEdvbG9tYiBmcm9tICcuL2V4cC1nb2xvbWInO1xuaW1wb3J0IFNhbXBsZUFlc0RlY3J5cHRlciBmcm9tICcuL3NhbXBsZS1hZXMnO1xuLy8gaW1wb3J0IEhleCBmcm9tICcuLi91dGlscy9oZXgnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5cbi8vIFdlIGFyZSB1c2luZyBmaXhlZCB0cmFjayBJRHMgZm9yIGRyaXZpbmcgdGhlIE1QNCByZW11eGVyXG4vLyBpbnN0ZWFkIG9mIGZvbGxvd2luZyB0aGUgVFMgUElEcy5cbi8vIFRoZXJlIGlzIG5vIHJlYXNvbiBub3QgdG8gZG8gdGhpcyBhbmQgc29tZSBicm93c2Vycy9Tb3VyY2VCdWZmZXItZGVtdXhlcnNcbi8vIG1heSBub3QgbGlrZSBpZiB0aGVyZSBhcmUgVHJhY2tJRCBcInN3aXRjaGVzXCJcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMTMzMVxuLy8gSGVyZSB3ZSBhcmUgbWFwcGluZyBvdXIgaW50ZXJuYWwgdHJhY2sgdHlwZXMgdG8gY29uc3RhbnQgTVA0IHRyYWNrIElEc1xuLy8gV2l0aCBNU0UgY3VycmVudGx5IG9uZSBjYW4gb25seSBoYXZlIG9uZSB0cmFjayBvZiBlYWNoLCBhbmQgd2UgYXJlIG11eGluZ1xuLy8gd2hhdGV2ZXIgdmlkZW8vYXVkaW8gcmVuZGl0aW9uIGluIHRoZW0uXG5jb25zdCBSZW11eGVyVHJhY2tJZENvbmZpZyA9IHtcbiAgdmlkZW86IDEsXG4gIGF1ZGlvOiAyLFxuICBpZDM6IDMsXG4gIHRleHQ6IDRcbn07XG5cbmNsYXNzIFRTRGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yIChvYnNlcnZlciwgcmVtdXhlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgdGhpcy5yZW11eGVyID0gcmVtdXhlcjtcbiAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XG4gIH1cblxuICBzZXREZWNyeXB0RGF0YSAoZGVjcnlwdGRhdGEpIHtcbiAgICBpZiAoKGRlY3J5cHRkYXRhICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5rZXkgIT0gbnVsbCkgJiYgKGRlY3J5cHRkYXRhLm1ldGhvZCA9PT0gJ1NBTVBMRS1BRVMnKSkge1xuICAgICAgdGhpcy5zYW1wbGVBZXMgPSBuZXcgU2FtcGxlQWVzRGVjcnlwdGVyKHRoaXMub2JzZXJ2ZXIsIHRoaXMuY29uZmlnLCBkZWNyeXB0ZGF0YSwgdGhpcy5kaXNjYXJkRVBCKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwcm9iZSAoZGF0YSkge1xuICAgIGNvbnN0IHN5bmNPZmZzZXQgPSBUU0RlbXV4ZXIuX3N5bmNPZmZzZXQoZGF0YSk7XG4gICAgaWYgKHN5bmNPZmZzZXQgPCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzeW5jT2Zmc2V0KSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBNUEVHMi1UUyBkZXRlY3RlZCBidXQgZmlyc3Qgc3luYyB3b3JkIGZvdW5kIEAgb2Zmc2V0ICR7c3luY09mZnNldH0sIGp1bmsgYWhlYWQgP2ApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgX3N5bmNPZmZzZXQgKGRhdGEpIHtcbiAgICAvLyBzY2FuIDEwMDAgZmlyc3QgYnl0ZXNcbiAgICBjb25zdCBzY2Fud2luZG93ID0gTWF0aC5taW4oMTAwMCwgZGF0YS5sZW5ndGggLSAzICogMTg4KTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzY2Fud2luZG93KSB7XG4gICAgICAvLyBhIFRTIGZyYWdtZW50IHNob3VsZCBjb250YWluIGF0IGxlYXN0IDMgVFMgcGFja2V0cywgYSBQQVQsIGEgUE1ULCBhbmQgb25lIFBJRCwgZWFjaCBzdGFydGluZyB3aXRoIDB4NDdcbiAgICAgIGlmIChkYXRhW2ldID09PSAweDQ3ICYmIGRhdGFbaSArIDE4OF0gPT09IDB4NDcgJiYgZGF0YVtpICsgMiAqIDE4OF0gPT09IDB4NDcpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdHJhY2sgbW9kZWwgaW50ZXJuYWwgdG8gZGVtdXhlciB1c2VkIHRvIGRyaXZlIHJlbXV4aW5nIGlucHV0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICdhdWRpbycgfCAndmlkZW8nIHwgJ2lkMycgfCAndGV4dCdcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG4gICAqIEByZXR1cm4ge29iamVjdH0gVFNEZW11eGVyJ3MgaW50ZXJuYWwgdHJhY2sgbW9kZWxcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVUcmFjayAodHlwZSwgZHVyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGFpbmVyOiB0eXBlID09PSAndmlkZW8nIHx8IHR5cGUgPT09ICdhdWRpbycgPyAndmlkZW8vbXAydCcgOiB1bmRlZmluZWQsXG4gICAgICB0eXBlLFxuICAgICAgaWQ6IFJlbXV4ZXJUcmFja0lkQ29uZmlnW3R5cGVdLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBsZW46IDAsXG4gICAgICBkcm9wcGVkOiB0eXBlID09PSAndmlkZW8nID8gMCA6IHVuZGVmaW5lZCxcbiAgICAgIGlzQUFDOiB0eXBlID09PSAnYXVkaW8nID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGR1cmF0aW9uOiB0eXBlID09PSAnYXVkaW8nID8gZHVyYXRpb24gOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3IGluaXQgc2VnbWVudCBvbiB0aGUgZGVtdXhlci9yZW11eGVyIGludGVyZmFjZS4gTmVlZGVkIGZvciBkaXNjb250aW51aXRpZXMvdHJhY2stc3dpdGNoZXMgKG9yIGF0IHN0cmVhbSBzdGFydClcbiAgICogUmVzZXRzIGFsbCBpbnRlcm5hbCB0cmFjayBpbnN0YW5jZXMgb2YgdGhlIGRlbXV4ZXIuXG4gICAqXG4gICAqIEBvdmVycmlkZSBJbXBsZW1lbnRzIGdlbmVyaWMgZGVtdXhpbmcvcmVtdXhpbmcgaW50ZXJmYWNlIChzZWUgRGVtdXhlcklubGluZSlcbiAgICogQHBhcmFtIHtvYmplY3R9IGluaXRTZWdtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdWRpb0NvZGVjXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aWRlb0NvZGVjXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiAoaW4gVFMgdGltZXNjYWxlID0gOTBrSHopXG4gICAqL1xuICByZXNldEluaXRTZWdtZW50IChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcbiAgICB0aGlzLnBtdFBhcnNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BtdElkID0gLTE7XG5cbiAgICB0aGlzLl9hdmNUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygndmlkZW8nLCBkdXJhdGlvbik7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygnYXVkaW8nLCBkdXJhdGlvbik7XG4gICAgdGhpcy5faWQzVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ2lkMycsIGR1cmF0aW9uKTtcbiAgICB0aGlzLl90eHRUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygndGV4dCcsIGR1cmF0aW9uKTtcblxuICAgIC8vIGZsdXNoIGFueSBwYXJ0aWFsIGNvbnRlbnRcbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLmFhY0xhc3RQVFMgPSBudWxsO1xuICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlc2V0VGltZVN0YW1wICgpIHt9XG5cbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICBhcHBlbmQgKGRhdGEsIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIGxldCBzdGFydCwgbGVuID0gZGF0YS5sZW5ndGgsIHN0dCwgcGlkLCBhdGYsIG9mZnNldCwgcGVzLFxuICAgICAgdW5rbm93blBJRHMgPSBmYWxzZTtcbiAgICB0aGlzLmNvbnRpZ3VvdXMgPSBjb250aWd1b3VzO1xuICAgIGxldCBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZCxcbiAgICAgIGF2Y1RyYWNrID0gdGhpcy5fYXZjVHJhY2ssXG4gICAgICBhdWRpb1RyYWNrID0gdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgIGlkM1RyYWNrID0gdGhpcy5faWQzVHJhY2ssXG4gICAgICBhdmNJZCA9IGF2Y1RyYWNrLnBpZCxcbiAgICAgIGF1ZGlvSWQgPSBhdWRpb1RyYWNrLnBpZCxcbiAgICAgIGlkM0lkID0gaWQzVHJhY2sucGlkLFxuICAgICAgcG10SWQgPSB0aGlzLl9wbXRJZCxcbiAgICAgIGF2Y0RhdGEgPSBhdmNUcmFjay5wZXNEYXRhLFxuICAgICAgYXVkaW9EYXRhID0gYXVkaW9UcmFjay5wZXNEYXRhLFxuICAgICAgaWQzRGF0YSA9IGlkM1RyYWNrLnBlc0RhdGEsXG4gICAgICBwYXJzZVBBVCA9IHRoaXMuX3BhcnNlUEFULFxuICAgICAgcGFyc2VQTVQgPSB0aGlzLl9wYXJzZVBNVCxcbiAgICAgIHBhcnNlUEVTID0gdGhpcy5fcGFyc2VQRVMsXG4gICAgICBwYXJzZUFWQ1BFUyA9IHRoaXMuX3BhcnNlQVZDUEVTLmJpbmQodGhpcyksXG4gICAgICBwYXJzZUFBQ1BFUyA9IHRoaXMuX3BhcnNlQUFDUEVTLmJpbmQodGhpcyksXG4gICAgICBwYXJzZU1QRUdQRVMgPSB0aGlzLl9wYXJzZU1QRUdQRVMuYmluZCh0aGlzKSxcbiAgICAgIHBhcnNlSUQzUEVTID0gdGhpcy5fcGFyc2VJRDNQRVMuYmluZCh0aGlzKTtcblxuICAgIGNvbnN0IHN5bmNPZmZzZXQgPSBUU0RlbXV4ZXIuX3N5bmNPZmZzZXQoZGF0YSk7XG5cbiAgICAvLyBkb24ndCBwYXJzZSBsYXN0IFRTIHBhY2tldCBpZiBpbmNvbXBsZXRlXG4gICAgbGVuIC09IChsZW4gKyBzeW5jT2Zmc2V0KSAlIDE4ODtcblxuICAgIC8vIGxvb3AgdGhyb3VnaCBUUyBwYWNrZXRzXG4gICAgZm9yIChzdGFydCA9IHN5bmNPZmZzZXQ7IHN0YXJ0IDwgbGVuOyBzdGFydCArPSAxODgpIHtcbiAgICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHg0Nykge1xuICAgICAgICBzdHQgPSAhIShkYXRhW3N0YXJ0ICsgMV0gJiAweDQwKTtcbiAgICAgICAgLy8gcGlkIGlzIGEgMTMtYml0IGZpZWxkIHN0YXJ0aW5nIGF0IHRoZSBsYXN0IGJpdCBvZiBUU1sxXVxuICAgICAgICBwaWQgPSAoKGRhdGFbc3RhcnQgKyAxXSAmIDB4MWYpIDw8IDgpICsgZGF0YVtzdGFydCArIDJdO1xuICAgICAgICBhdGYgPSAoZGF0YVtzdGFydCArIDNdICYgMHgzMCkgPj4gNDtcbiAgICAgICAgLy8gaWYgYW4gYWRhcHRpb24gZmllbGQgaXMgcHJlc2VudCwgaXRzIGxlbmd0aCBpcyBzcGVjaWZpZWQgYnkgdGhlIGZpZnRoIGJ5dGUgb2YgdGhlIFRTIHBhY2tldCBoZWFkZXIuXG4gICAgICAgIGlmIChhdGYgPiAxKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA1ICsgZGF0YVtzdGFydCArIDRdO1xuICAgICAgICAgIC8vIGNvbnRpbnVlIGlmIHRoZXJlIGlzIG9ubHkgYWRhcHRhdGlvbiBmaWVsZFxuICAgICAgICAgIGlmIChvZmZzZXQgPT09IChzdGFydCArIDE4OCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChwaWQpIHtcbiAgICAgICAgY2FzZSBhdmNJZDpcbiAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICBpZiAoYXZjRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXZjRGF0YSkpICYmIHBlcy5wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBwYXJzZUFWQ1BFUyhwZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXZjRGF0YSA9IHsgZGF0YTogW10sIHNpemU6IDAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF2Y0RhdGEpIHtcbiAgICAgICAgICAgIGF2Y0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIDE4OCkpO1xuICAgICAgICAgICAgYXZjRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBhdWRpb0lkOlxuICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgIGlmIChhdWRpb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF1ZGlvRGF0YSkpICYmIHBlcy5wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoYXVkaW9UcmFjay5pc0FBQykge1xuICAgICAgICAgICAgICAgIHBhcnNlQUFDUEVTKHBlcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VNUEVHUEVTKHBlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1ZGlvRGF0YSA9IHsgZGF0YTogW10sIHNpemU6IDAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xuICAgICAgICAgICAgYXVkaW9EYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcbiAgICAgICAgICAgIGF1ZGlvRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZDNJZDpcbiAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSkpICYmIHBlcy5wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBwYXJzZUlEM1BFUyhwZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZDNEYXRhID0geyBkYXRhOiBbXSwgc2l6ZTogMCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaWQzRGF0YSkge1xuICAgICAgICAgICAgaWQzRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICBpZDNEYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG10SWQgPSB0aGlzLl9wbXRJZCA9IHBhcnNlUEFUKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgcG10SWQ6XG4gICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHBhcnNlZFBJRHMgPSBwYXJzZVBNVChkYXRhLCBvZmZzZXQsIHRoaXMudHlwZVN1cHBvcnRlZC5tcGVnID09PSB0cnVlIHx8IHRoaXMudHlwZVN1cHBvcnRlZC5tcDMgPT09IHRydWUsIHRoaXMuc2FtcGxlQWVzICE9IG51bGwpO1xuXG4gICAgICAgICAgLy8gb25seSB1cGRhdGUgdHJhY2sgaWQgaWYgdHJhY2sgUElEIGZvdW5kIHdoaWxlIHBhcnNpbmcgUE1UXG4gICAgICAgICAgLy8gdGhpcyBpcyB0byBhdm9pZCByZXNldHRpbmcgdGhlIFBJRCB0byAtMSBpbiBjYXNlXG4gICAgICAgICAgLy8gdHJhY2sgUElEIHRyYW5zaWVudGx5IGRpc2FwcGVhcnMgZnJvbSB0aGUgc3RyZWFtXG4gICAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaW4gY2FzZSBvZiB0cmFuc2llbnQgbWlzc2luZyBhdWRpbyBzYW1wbGVzIGZvciBleGFtcGxlXG4gICAgICAgICAgLy8gTk9URSB0aGlzIGlzIG9ubHkgdGhlIFBJRCBvZiB0aGUgdHJhY2sgYXMgZm91bmQgaW4gVFMsXG4gICAgICAgICAgLy8gYnV0IHdlIGFyZSBub3QgdXNpbmcgdGhpcyBmb3IgTVA0IHRyYWNrIElEcy5cbiAgICAgICAgICBhdmNJZCA9IHBhcnNlZFBJRHMuYXZjO1xuICAgICAgICAgIGlmIChhdmNJZCA+IDApIHtcbiAgICAgICAgICAgIGF2Y1RyYWNrLnBpZCA9IGF2Y0lkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF1ZGlvSWQgPSBwYXJzZWRQSURzLmF1ZGlvO1xuICAgICAgICAgIGlmIChhdWRpb0lkID4gMCkge1xuICAgICAgICAgICAgYXVkaW9UcmFjay5waWQgPSBhdWRpb0lkO1xuICAgICAgICAgICAgYXVkaW9UcmFjay5pc0FBQyA9IHBhcnNlZFBJRHMuaXNBQUM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlkM0lkID0gcGFyc2VkUElEcy5pZDM7XG4gICAgICAgICAgaWYgKGlkM0lkID4gMCkge1xuICAgICAgICAgICAgaWQzVHJhY2sucGlkID0gaWQzSWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHVua25vd25QSURzICYmICFwbXRQYXJzZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ3JlcGFyc2UgZnJvbSBiZWdpbm5pbmcnKTtcbiAgICAgICAgICAgIHVua25vd25QSURzID0gZmFsc2U7XG4gICAgICAgICAgICAvLyB3ZSBzZXQgaXQgdG8gLTE4OCwgdGhlICs9IDE4OCBpbiB0aGUgZm9yIGxvb3Agd2lsbCByZXNldCBzdGFydCB0byAwXG4gICAgICAgICAgICBzdGFydCA9IHN5bmNPZmZzZXQgLSAxODg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgY2FzZSAweDFmZmY6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdW5rbm93blBJRHMgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdUUyBwYWNrZXQgZGlkIG5vdCBzdGFydCB3aXRoIDB4NDcnIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB0cnkgdG8gcGFyc2UgbGFzdCBQRVMgcGFja2V0c1xuICAgIGlmIChhdmNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdmNEYXRhKSkgJiYgcGVzLnB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZUFWQ1BFUyhwZXMsIHRydWUpO1xuICAgICAgYXZjVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVpdGhlciBhdmNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIGF2Y1RyYWNrLnBlc0RhdGEgPSBhdmNEYXRhO1xuICAgIH1cblxuICAgIGlmIChhdWRpb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF1ZGlvRGF0YSkpICYmIHBlcy5wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGF1ZGlvVHJhY2suaXNBQUMpIHtcbiAgICAgICAgcGFyc2VBQUNQRVMocGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlTVBFR1BFUyhwZXMpO1xuICAgICAgfVxuXG4gICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXVkaW9EYXRhICYmIGF1ZGlvRGF0YS5zaXplKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ2xhc3QgQUFDIFBFUyBwYWNrZXQgdHJ1bmNhdGVkLG1pZ2h0IG92ZXJsYXAgYmV0d2VlbiBmcmFnbWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgLy8gZWl0aGVyIGF1ZGlvRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBhdWRpb0RhdGE7XG4gICAgfVxuXG4gICAgaWYgKGlkM0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGlkM0RhdGEpKSAmJiBwZXMucHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcnNlSUQzUEVTKHBlcyk7XG4gICAgICBpZDNUcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWl0aGVyIGlkM0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2FtcGxlQWVzID09IG51bGwpIHtcbiAgICAgIHRoaXMucmVtdXhlci5yZW11eChhdWRpb1RyYWNrLCBhdmNUcmFjaywgaWQzVHJhY2ssIHRoaXMuX3R4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlY3J5cHRBbmRSZW11eChhdWRpb1RyYWNrLCBhdmNUcmFjaywgaWQzVHJhY2ssIHRoaXMuX3R4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgIH1cbiAgfVxuXG4gIGRlY3J5cHRBbmRSZW11eCAoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgaWYgKGF1ZGlvVHJhY2suc2FtcGxlcyAmJiBhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICBsZXQgbG9jYWx0aGlzID0gdGhpcztcbiAgICAgIHRoaXMuc2FtcGxlQWVzLmRlY3J5cHRBYWNTYW1wbGVzKGF1ZGlvVHJhY2suc2FtcGxlcywgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2NhbHRoaXMuZGVjcnlwdEFuZFJlbXV4QXZjKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWNyeXB0QW5kUmVtdXhBdmMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICBkZWNyeXB0QW5kUmVtdXhBdmMgKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMpIHtcbiAgICAgIGxldCBsb2NhbHRoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5zYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2FsdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHVyYXRpb24gPSAwO1xuICB9XG5cbiAgX3BhcnNlUEFUIChkYXRhLCBvZmZzZXQpIHtcbiAgICAvLyBza2lwIHRoZSBQU0kgaGVhZGVyIGFuZCBwYXJzZSB0aGUgZmlyc3QgUE1UIGVudHJ5XG4gICAgcmV0dXJuIChkYXRhW29mZnNldCArIDEwXSAmIDB4MUYpIDw8IDggfCBkYXRhW29mZnNldCArIDExXTtcbiAgICAvLyBsb2dnZXIubG9nKCdQTVQgUElEOicgICsgdGhpcy5fcG10SWQpO1xuICB9XG5cbiAgX3BhcnNlUE1UIChkYXRhLCBvZmZzZXQsIG1wZWdTdXBwb3J0ZWQsIGlzU2FtcGxlQWVzKSB7XG4gICAgbGV0IHNlY3Rpb25MZW5ndGgsIHRhYmxlRW5kLCBwcm9ncmFtSW5mb0xlbmd0aCwgcGlkLCByZXN1bHQgPSB7IGF1ZGlvOiAtMSwgYXZjOiAtMSwgaWQzOiAtMSwgaXNBQUM6IHRydWUgfTtcbiAgICBzZWN0aW9uTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAyXTtcbiAgICB0YWJsZUVuZCA9IG9mZnNldCArIDMgKyBzZWN0aW9uTGVuZ3RoIC0gNDtcbiAgICAvLyB0byBkZXRlcm1pbmUgd2hlcmUgdGhlIHRhYmxlIGlzLCB3ZSBoYXZlIHRvIGZpZ3VyZSBvdXQgaG93XG4gICAgLy8gbG9uZyB0aGUgcHJvZ3JhbSBpbmZvIGRlc2NyaXB0b3JzIGFyZVxuICAgIHByb2dyYW1JbmZvTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xuICAgIC8vIGFkdmFuY2UgdGhlIG9mZnNldCB0byB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIG1hcHBpbmcgdGFibGVcbiAgICBvZmZzZXQgKz0gMTIgKyBwcm9ncmFtSW5mb0xlbmd0aDtcbiAgICB3aGlsZSAob2Zmc2V0IDwgdGFibGVFbmQpIHtcbiAgICAgIHBpZCA9IChkYXRhW29mZnNldCArIDFdICYgMHgxRikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMl07XG4gICAgICBzd2l0Y2ggKGRhdGFbb2Zmc2V0XSkge1xuICAgICAgY2FzZSAweGNmOiAvLyBTQU1QTEUtQUVTIEFBQ1xuICAgICAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygndW5rb3duIHN0cmVhbSB0eXBlOicgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgICAgICAvLyBJU08vSUVDIDEzODE4LTcgQURUUyBBQUMgKE1QRUctMiBsb3dlciBiaXQtcmF0ZSBhdWRpbylcbiAgICAgIGNhc2UgMHgwZjpcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnQUFDIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmIChyZXN1bHQuYXVkaW8gPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmF1ZGlvID0gcGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gUGFja2V0aXplZCBtZXRhZGF0YSAoSUQzKVxuICAgICAgY2FzZSAweDE1OlxuICAgICAgICAvLyBsb2dnZXIubG9nKCdJRDMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pZDMgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmlkMyA9IHBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4ZGI6IC8vIFNBTVBMRS1BRVMgQVZDXG4gICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCd1bmtvd24gc3RyZWFtIHR5cGU6JyArIGRhdGFbb2Zmc2V0XSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuXG4gICAgICAgIC8vIElUVS1UIFJlYy4gSC4yNjQgYW5kIElTTy9JRUMgMTQ0OTYtMTAgKGxvd2VyIGJpdC1yYXRlIHZpZGVvKVxuICAgICAgY2FzZSAweDFiOlxuICAgICAgICAvLyBsb2dnZXIubG9nKCdBVkMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5hdmMgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmF2YyA9IHBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIElTTy9JRUMgMTExNzItMyAoTVBFRy0xIGF1ZGlvKVxuICAgICAgICAvLyBvciBJU08vSUVDIDEzODE4LTMgKE1QRUctMiBoYWx2ZWQgc2FtcGxlIHJhdGUgYXVkaW8pXG4gICAgICBjYXNlIDB4MDM6XG4gICAgICBjYXNlIDB4MDQ6XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ01QRUcgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKCFtcGVnU3VwcG9ydGVkKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnTVBFRyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIgZm9yIG5vdycpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuYXVkaW8gPSBwaWQ7XG4gICAgICAgICAgcmVzdWx0LmlzQUFDID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMHgyNDpcbiAgICAgICAgbG9nZ2VyLndhcm4oJ0hFVkMgc3RyZWFtIHR5cGUgZm91bmQsIG5vdCBzdXBwb3J0ZWQgZm9yIG5vdycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbG9nZ2VyLmxvZygndW5rb3duIHN0cmVhbSB0eXBlOicgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIG1vdmUgdG8gdGhlIG5leHQgdGFibGUgZW50cnlcbiAgICAgIC8vIHNraXAgcGFzdCB0aGUgZWxlbWVudGFyeSBzdHJlYW0gZGVzY3JpcHRvcnMsIGlmIHByZXNlbnRcbiAgICAgIG9mZnNldCArPSAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDBGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyA0XSkgKyA1O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgX3BhcnNlUEVTIChzdHJlYW0pIHtcbiAgICBsZXQgaSA9IDAsIGZyYWcsIHBlc0ZsYWdzLCBwZXNQcmVmaXgsIHBlc0xlbiwgcGVzSGRyTGVuLCBwZXNEYXRhLCBwZXNQdHMsIHBlc0R0cywgcGF5bG9hZFN0YXJ0T2Zmc2V0LCBkYXRhID0gc3RyZWFtLmRhdGE7XG4gICAgLy8gc2FmZXR5IGNoZWNrXG4gICAgaWYgKCFzdHJlYW0gfHwgc3RyZWFtLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIHdlIG1pZ2h0IG5lZWQgdXAgdG8gMTkgYnl0ZXMgdG8gcmVhZCBQRVMgaGVhZGVyXG4gICAgLy8gaWYgZmlyc3QgY2h1bmsgb2YgZGF0YSBpcyBsZXNzIHRoYW4gMTkgYnl0ZXMsIGxldCdzIG1lcmdlIGl0IHdpdGggZm9sbG93aW5nIG9uZXMgdW50aWwgd2UgZ2V0IDE5IGJ5dGVzXG4gICAgLy8gdXN1YWxseSBvbmx5IG9uZSBtZXJnZSBpcyBuZWVkZWQgKGFuZCB0aGlzIGlzIHJhcmUgLi4uKVxuICAgIHdoaWxlIChkYXRhWzBdLmxlbmd0aCA8IDE5ICYmIGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgbGV0IG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShkYXRhWzBdLmxlbmd0aCArIGRhdGFbMV0ubGVuZ3RoKTtcbiAgICAgIG5ld0RhdGEuc2V0KGRhdGFbMF0pO1xuICAgICAgbmV3RGF0YS5zZXQoZGF0YVsxXSwgZGF0YVswXS5sZW5ndGgpO1xuICAgICAgZGF0YVswXSA9IG5ld0RhdGE7XG4gICAgICBkYXRhLnNwbGljZSgxLCAxKTtcbiAgICB9XG4gICAgLy8gcmV0cmlldmUgUFRTL0RUUyBmcm9tIGZpcnN0IGZyYWdtZW50XG4gICAgZnJhZyA9IGRhdGFbMF07XG4gICAgcGVzUHJlZml4ID0gKGZyYWdbMF0gPDwgMTYpICsgKGZyYWdbMV0gPDwgOCkgKyBmcmFnWzJdO1xuICAgIGlmIChwZXNQcmVmaXggPT09IDEpIHtcbiAgICAgIHBlc0xlbiA9IChmcmFnWzRdIDw8IDgpICsgZnJhZ1s1XTtcbiAgICAgIC8vIGlmIFBFUyBwYXJzZWQgbGVuZ3RoIGlzIG5vdCB6ZXJvIGFuZCBncmVhdGVyIHRoYW4gdG90YWwgcmVjZWl2ZWQgbGVuZ3RoLCBzdG9wIHBhcnNpbmcuIFBFUyBtaWdodCBiZSB0cnVuY2F0ZWRcbiAgICAgIC8vIG1pbnVzIDYgOiBQRVMgaGVhZGVyIHNpemVcbiAgICAgIGlmIChwZXNMZW4gJiYgcGVzTGVuID4gc3RyZWFtLnNpemUgLSA2KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBwZXNGbGFncyA9IGZyYWdbN107XG4gICAgICBpZiAocGVzRmxhZ3MgJiAweEMwKSB7XG4gICAgICAgIC8qIFBFUyBoZWFkZXIgZGVzY3JpYmVkIGhlcmUgOiBodHRwOi8vZHZkLnNvdXJjZWZvcmdlLm5ldC9kdmRpbmZvL3Blcy1oZHIuaHRtbFxuICAgICAgICAgICAgYXMgUFRTIC8gRFRTIGlzIDMzIGJpdCB3ZSBjYW5ub3QgdXNlIGJpdHdpc2Ugb3BlcmF0b3IgaW4gSlMsXG4gICAgICAgICAgICBhcyBCaXR3aXNlIG9wZXJhdG9ycyB0cmVhdCB0aGVpciBvcGVyYW5kcyBhcyBhIHNlcXVlbmNlIG9mIDMyIGJpdHMgKi9cbiAgICAgICAgcGVzUHRzID0gKGZyYWdbOV0gJiAweDBFKSAqIDUzNjg3MDkxMiArLy8gMSA8PCAyOVxuICAgICAgICAgIChmcmFnWzEwXSAmIDB4RkYpICogNDE5NDMwNCArLy8gMSA8PCAyMlxuICAgICAgICAgIChmcmFnWzExXSAmIDB4RkUpICogMTYzODQgKy8vIDEgPDwgMTRcbiAgICAgICAgICAoZnJhZ1sxMl0gJiAweEZGKSAqIDEyOCArLy8gMSA8PCA3XG4gICAgICAgICAgKGZyYWdbMTNdICYgMHhGRSkgLyAyO1xuICAgICAgICAvLyBjaGVjayBpZiBncmVhdGVyIHRoYW4gMl4zMiAtMVxuICAgICAgICBpZiAocGVzUHRzID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgIC8vIGRlY3JlbWVudCAyXjMzXG4gICAgICAgICAgcGVzUHRzIC09IDg1ODk5MzQ1OTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlc0ZsYWdzICYgMHg0MCkge1xuICAgICAgICAgIHBlc0R0cyA9IChmcmFnWzE0XSAmIDB4MEUpICogNTM2ODcwOTEyICsvLyAxIDw8IDI5XG4gICAgICAgICAgICAoZnJhZ1sxNV0gJiAweEZGKSAqIDQxOTQzMDQgKy8vIDEgPDwgMjJcbiAgICAgICAgICAgIChmcmFnWzE2XSAmIDB4RkUpICogMTYzODQgKy8vIDEgPDwgMTRcbiAgICAgICAgICAgIChmcmFnWzE3XSAmIDB4RkYpICogMTI4ICsvLyAxIDw8IDdcbiAgICAgICAgICAgIChmcmFnWzE4XSAmIDB4RkUpIC8gMjtcbiAgICAgICAgICAvLyBjaGVjayBpZiBncmVhdGVyIHRoYW4gMl4zMiAtMVxuICAgICAgICAgIGlmIChwZXNEdHMgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAvLyBkZWNyZW1lbnQgMl4zM1xuICAgICAgICAgICAgcGVzRHRzIC09IDg1ODk5MzQ1OTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwZXNQdHMgLSBwZXNEdHMgPiA2MCAqIDkwMDAwKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgJHtNYXRoLnJvdW5kKChwZXNQdHMgLSBwZXNEdHMpIC8gOTAwMDApfXMgZGVsdGEgYmV0d2VlbiBQVFMgYW5kIERUUywgYWxpZ24gdGhlbWApO1xuICAgICAgICAgICAgcGVzUHRzID0gcGVzRHRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZXNEdHMgPSBwZXNQdHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBlc0hkckxlbiA9IGZyYWdbOF07XG4gICAgICAvLyA5IGJ5dGVzIDogNiBieXRlcyBmb3IgUEVTIGhlYWRlciArIDMgYnl0ZXMgZm9yIFBFUyBleHRlbnNpb25cbiAgICAgIHBheWxvYWRTdGFydE9mZnNldCA9IHBlc0hkckxlbiArIDk7XG5cbiAgICAgIHN0cmVhbS5zaXplIC09IHBheWxvYWRTdGFydE9mZnNldDtcbiAgICAgIC8vIHJlYXNzZW1ibGUgUEVTIHBhY2tldFxuICAgICAgcGVzRGF0YSA9IG5ldyBVaW50OEFycmF5KHN0cmVhbS5zaXplKTtcbiAgICAgIGZvciAobGV0IGogPSAwLCBkYXRhTGVuID0gZGF0YS5sZW5ndGg7IGogPCBkYXRhTGVuOyBqKyspIHtcbiAgICAgICAgZnJhZyA9IGRhdGFbal07XG4gICAgICAgIGxldCBsZW4gPSBmcmFnLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0ID4gbGVuKSB7XG4gICAgICAgICAgICAvLyB0cmltIGZ1bGwgZnJhZyBpZiBQRVMgaGVhZGVyIGJpZ2dlciB0aGFuIGZyYWdcbiAgICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCAtPSBsZW47XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdHJpbSBwYXJ0aWFsIGZyYWcgaWYgUEVTIGhlYWRlciBzbWFsbGVyIHRoYW4gZnJhZ1xuICAgICAgICAgICAgZnJhZyA9IGZyYWcuc3ViYXJyYXkocGF5bG9hZFN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgIGxlbiAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwZXNEYXRhLnNldChmcmFnLCBpKTtcbiAgICAgICAgaSArPSBsZW47XG4gICAgICB9XG4gICAgICBpZiAocGVzTGVuKSB7XG4gICAgICAgIC8vIHBheWxvYWQgc2l6ZSA6IHJlbW92ZSBQRVMgaGVhZGVyICsgUEVTIGV4dGVuc2lvblxuICAgICAgICBwZXNMZW4gLT0gcGVzSGRyTGVuICsgMztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRhdGE6IHBlc0RhdGEsIHB0czogcGVzUHRzLCBkdHM6IHBlc0R0cywgbGVuOiBwZXNMZW4gfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVzaEFjY2VzVW5pdCAoYXZjU2FtcGxlLCBhdmNUcmFjaykge1xuICAgIGlmIChhdmNTYW1wbGUudW5pdHMubGVuZ3RoICYmIGF2Y1NhbXBsZS5mcmFtZSkge1xuICAgICAgY29uc3Qgc2FtcGxlcyA9IGF2Y1RyYWNrLnNhbXBsZXM7XG4gICAgICBjb25zdCBuYlNhbXBsZXMgPSBzYW1wbGVzLmxlbmd0aDtcbiAgICAgIC8vIG9ubHkgcHVzaCBBVkMgc2FtcGxlIGlmIHN0YXJ0aW5nIHdpdGggYSBrZXlmcmFtZSBpcyBub3QgbWFuZGF0b3J5IE9SXG4gICAgICAvLyAgICBpZiBrZXlmcmFtZSBhbHJlYWR5IGZvdW5kIGluIHRoaXMgZnJhZ21lbnQgT1JcbiAgICAgIC8vICAgICAgIGtleWZyYW1lIGZvdW5kIGluIGxhc3QgZnJhZ21lbnQgKHRyYWNrLnNwcykgQU5EXG4gICAgICAvLyAgICAgICAgICBzYW1wbGVzIGFscmVhZHkgYXBwZW5kZWQgKHdlIGFscmVhZHkgZm91bmQgYSBrZXlmcmFtZSBpbiB0aGlzIGZyYWdtZW50KSBPUiBmcmFnbWVudCBpcyBjb250aWd1b3VzXG4gICAgICBpZiAoIXRoaXMuY29uZmlnLmZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkgfHxcbiAgICAgICAgICBhdmNTYW1wbGUua2V5ID09PSB0cnVlIHx8XG4gICAgICAgICAgKGF2Y1RyYWNrLnNwcyAmJiAobmJTYW1wbGVzIHx8IHRoaXMuY29udGlndW91cykpKSB7XG4gICAgICAgIGF2Y1NhbXBsZS5pZCA9IG5iU2FtcGxlcztcbiAgICAgICAgc2FtcGxlcy5wdXNoKGF2Y1NhbXBsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkcm9wcGVkIHNhbXBsZXMsIHRyYWNrIGl0XG4gICAgICAgIGF2Y1RyYWNrLmRyb3BwZWQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF2Y1NhbXBsZS5kZWJ1Zy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci5sb2coYXZjU2FtcGxlLnB0cyArICcvJyArIGF2Y1NhbXBsZS5kdHMgKyAnOicgKyBhdmNTYW1wbGUuZGVidWcpO1xuICAgIH1cbiAgfVxuXG4gIF9wYXJzZUFWQ1BFUyAocGVzLCBsYXN0KSB7XG4gICAgLy8gbG9nZ2VyLmxvZygncGFyc2UgbmV3IFBFUycpO1xuICAgIGxldCB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrLFxuICAgICAgdW5pdHMgPSB0aGlzLl9wYXJzZUFWQ05BTHUocGVzLmRhdGEpLFxuICAgICAgZGVidWcgPSBmYWxzZSxcbiAgICAgIGV4cEdvbG9tYkRlY29kZXIsXG4gICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSxcbiAgICAgIHB1c2gsXG4gICAgICBzcHNmb3VuZCA9IGZhbHNlLFxuICAgICAgaSxcbiAgICAgIHB1c2hBY2Nlc1VuaXQgPSB0aGlzLnB1c2hBY2Nlc1VuaXQuYmluZCh0aGlzKSxcbiAgICAgIGNyZWF0ZUFWQ1NhbXBsZSA9IGZ1bmN0aW9uIChrZXksIHB0cywgZHRzLCBkZWJ1Zykge1xuICAgICAgICByZXR1cm4geyBrZXk6IGtleSwgcHRzOiBwdHMsIGR0czogZHRzLCB1bml0czogW10sIGRlYnVnOiBkZWJ1ZyB9O1xuICAgICAgfTtcbiAgICAvLyBmcmVlIHBlcy5kYXRhIHRvIHNhdmUgdXAgc29tZSBtZW1vcnlcbiAgICBwZXMuZGF0YSA9IG51bGw7XG5cbiAgICAvLyBpZiBuZXcgTkFMIHVuaXRzIGZvdW5kIGFuZCBsYXN0IHNhbXBsZSBzdGlsbCB0aGVyZSwgbGV0J3MgcHVzaCAuLi5cbiAgICAvLyB0aGlzIGhlbHBzIHBhcnNpbmcgc3RyZWFtcyB3aXRoIG1pc3NpbmcgQVVEIChvbmx5IGRvIHRoaXMgaWYgQVVEIG5ldmVyIGZvdW5kKVxuICAgIGlmIChhdmNTYW1wbGUgJiYgdW5pdHMubGVuZ3RoICYmICF0cmFjay5hdWRGb3VuZCkge1xuICAgICAgcHVzaEFjY2VzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcbiAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgfVxuXG4gICAgdW5pdHMuZm9yRWFjaCh1bml0ID0+IHtcbiAgICAgIHN3aXRjaCAodW5pdC50eXBlKSB7XG4gICAgICAvLyBORFJcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgIGlmICghYXZjU2FtcGxlKSB7XG4gICAgICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUgPSBjcmVhdGVBVkNTYW1wbGUodHJ1ZSwgcGVzLnB0cywgcGVzLmR0cywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdORFIgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGF2Y1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgIGxldCBkYXRhID0gdW5pdC5kYXRhO1xuICAgICAgICAvLyBvbmx5IGNoZWNrIHNsaWNlIHR5cGUgdG8gZGV0ZWN0IEtGIGluIGNhc2UgU1BTIGZvdW5kIGluIHNhbWUgcGFja2V0IChhbnkga2V5ZnJhbWUgaXMgcHJlY2VkZWQgYnkgU1BTIC4uLilcbiAgICAgICAgaWYgKHNwc2ZvdW5kICYmIGRhdGEubGVuZ3RoID4gNCkge1xuICAgICAgICAgIC8vIHJldHJpZXZlIHNsaWNlIHR5cGUgYnkgcGFyc2luZyBiZWdpbm5pbmcgb2YgTkFMIHVuaXQgKGZvbGxvdyBIMjY0IHNwZWMsIHNsaWNlX2hlYWRlciBkZWZpbml0aW9uKSB0byBkZXRlY3Qga2V5ZnJhbWUgZW1iZWRkZWQgaW4gTkRSXG4gICAgICAgICAgbGV0IHNsaWNlVHlwZSA9IG5ldyBFeHBHb2xvbWIoZGF0YSkucmVhZFNsaWNlVHlwZSgpO1xuICAgICAgICAgIC8vIDIgOiBJIHNsaWNlLCA0IDogU0kgc2xpY2UsIDcgOiBJIHNsaWNlLCA5OiBTSSBzbGljZVxuICAgICAgICAgIC8vIFNJIHNsaWNlIDogQSBzbGljZSB0aGF0IGlzIGNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seSBhbmQgdXNpbmcgcXVhbnRpc2F0aW9uIG9mIHRoZSBwcmVkaWN0aW9uIHNhbXBsZXMuXG4gICAgICAgICAgLy8gQW4gU0kgc2xpY2UgY2FuIGJlIGNvZGVkIHN1Y2ggdGhhdCBpdHMgZGVjb2RlZCBzYW1wbGVzIGNhbiBiZSBjb25zdHJ1Y3RlZCBpZGVudGljYWxseSB0byBhbiBTUCBzbGljZS5cbiAgICAgICAgICAvLyBJIHNsaWNlOiBBIHNsaWNlIHRoYXQgaXMgbm90IGFuIFNJIHNsaWNlIHRoYXQgaXMgZGVjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkuXG4gICAgICAgICAgLy8gaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDcpIHtcbiAgICAgICAgICBpZiAoc2xpY2VUeXBlID09PSAyIHx8IHNsaWNlVHlwZSA9PT0gNCB8fCBzbGljZVR5cGUgPT09IDcgfHwgc2xpY2VUeXBlID09PSA5KSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIElEUlxuICAgICAgY2FzZSA1OlxuICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgLy8gaGFuZGxlIFBFUyBub3Qgc3RhcnRpbmcgd2l0aCBBVURcbiAgICAgICAgaWYgKCFhdmNTYW1wbGUpIHtcbiAgICAgICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ0lEUiAnO1xuICAgICAgICB9XG5cbiAgICAgICAgYXZjU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgIGF2Y1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBTRUlcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1NFSSAnO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBFeHBHb2xvbWIodGhpcy5kaXNjYXJkRVBCKHVuaXQuZGF0YSkpO1xuXG4gICAgICAgIC8vIHNraXAgZnJhbWVUeXBlXG4gICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgdmFyIHBheWxvYWRUeXBlID0gMDtcbiAgICAgICAgdmFyIHBheWxvYWRTaXplID0gMDtcbiAgICAgICAgdmFyIGVuZE9mQ2FwdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGIgPSAwO1xuXG4gICAgICAgIHdoaWxlICghZW5kT2ZDYXB0aW9ucyAmJiBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlID4gMSkge1xuICAgICAgICAgIHBheWxvYWRUeXBlID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBiID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgIHBheWxvYWRUeXBlICs9IGI7XG4gICAgICAgICAgfSB3aGlsZSAoYiA9PT0gMHhGRik7XG5cbiAgICAgICAgICAvLyBQYXJzZSBwYXlsb2FkIHNpemUuXG4gICAgICAgICAgcGF5bG9hZFNpemUgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGIgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgcGF5bG9hZFNpemUgKz0gYjtcbiAgICAgICAgICB9IHdoaWxlIChiID09PSAweEZGKTtcblxuICAgICAgICAgIC8vIFRPRE86IHRoZXJlIGNhbiBiZSBtb3JlIHRoYW4gb25lIHBheWxvYWQgaW4gYW4gU0VJIHBhY2tldC4uLlxuICAgICAgICAgIC8vIFRPRE86IG5lZWQgdG8gcmVhZCB0eXBlIGFuZCBzaXplIGluIGEgd2hpbGUgbG9vcCB0byBnZXQgdGhlbSBhbGxcbiAgICAgICAgICBpZiAocGF5bG9hZFR5cGUgPT09IDQgJiYgZXhwR29sb21iRGVjb2Rlci5ieXRlc0F2YWlsYWJsZSAhPT0gMCkge1xuICAgICAgICAgICAgZW5kT2ZDYXB0aW9ucyA9IHRydWU7XG5cbiAgICAgICAgICAgIGxldCBjb3VudHJ5Q29kZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICAgIGlmIChjb3VudHJ5Q29kZSA9PT0gMTgxKSB7XG4gICAgICAgICAgICAgIGxldCBwcm92aWRlckNvZGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVU2hvcnQoKTtcblxuICAgICAgICAgICAgICBpZiAocHJvdmlkZXJDb2RlID09PSA0OSkge1xuICAgICAgICAgICAgICAgIGxldCB1c2VyU3RydWN0dXJlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUludCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJTdHJ1Y3R1cmUgPT09IDB4NDc0MTM5MzQpIHtcbiAgICAgICAgICAgICAgICAgIGxldCB1c2VyRGF0YVR5cGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAvLyBSYXcgQ0VBLTYwOCBieXRlcyB3cmFwcGVkIGluIENFQS03MDggcGFja2V0XG4gICAgICAgICAgICAgICAgICBpZiAodXNlckRhdGFUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdEJ5dGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2Vjb25kQnl0ZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsQ0NzID0gMzEgJiBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBieXRlQXJyYXkgPSBbZmlyc3RCeXRlLCBzZWNvbmRCeXRlXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDQ3M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIDMgYnl0ZXMgcGVyIENDXG4gICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnNlcnRTYW1wbGVJbk9yZGVyKHRoaXMuX3R4dFRyYWNrLnNhbXBsZXMsIHsgdHlwZTogMywgcHRzOiBwZXMucHRzLCBieXRlczogYnl0ZUFycmF5IH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZFNpemUgPCBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF5bG9hZFNpemU7IGkrKykge1xuICAgICAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgLy8gU1BTXG4gICAgICBjYXNlIDc6XG4gICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICBzcHNmb3VuZCA9IHRydWU7XG4gICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1NQUyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0cmFjay5zcHMpIHtcbiAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyID0gbmV3IEV4cEdvbG9tYih1bml0LmRhdGEpO1xuICAgICAgICAgIGxldCBjb25maWcgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRTUFMoKTtcbiAgICAgICAgICB0cmFjay53aWR0aCA9IGNvbmZpZy53aWR0aDtcbiAgICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICAgIHRyYWNrLnBpeGVsUmF0aW8gPSBjb25maWcucGl4ZWxSYXRpbztcbiAgICAgICAgICB0cmFjay5zcHMgPSBbdW5pdC5kYXRhXTtcbiAgICAgICAgICB0cmFjay5kdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICAgIGxldCBjb2RlY2FycmF5ID0gdW5pdC5kYXRhLnN1YmFycmF5KDEsIDQpO1xuICAgICAgICAgIGxldCBjb2RlY3N0cmluZyA9ICdhdmMxLic7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgbGV0IGggPSBjb2RlY2FycmF5W2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvZGVjc3RyaW5nICs9IGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyYWNrLmNvZGVjID0gY29kZWNzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFBQU1xuICAgICAgY2FzZSA4OlxuICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgaWYgKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnUFBTICc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRyYWNrLnBwcykge1xuICAgICAgICAgIHRyYWNrLnBwcyA9IFt1bml0LmRhdGFdO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEFVRFxuICAgICAgY2FzZSA5OlxuICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgIHRyYWNrLmF1ZEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgIHB1c2hBY2Nlc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZShmYWxzZSwgcGVzLnB0cywgcGVzLmR0cywgZGVidWcgPyAnQVVEICcgOiAnJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBGaWxsZXIgRGF0YVxuICAgICAgY2FzZSAxMjpcbiAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAndW5rbm93biBOQUwgJyArIHVuaXQudHlwZSArICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGF2Y1NhbXBsZSAmJiBwdXNoKSB7XG4gICAgICAgIGxldCB1bml0cyA9IGF2Y1NhbXBsZS51bml0cztcbiAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBpZiBsYXN0IFBFUyBwYWNrZXQsIHB1c2ggc2FtcGxlc1xuICAgIGlmIChsYXN0ICYmIGF2Y1NhbXBsZSkge1xuICAgICAgcHVzaEFjY2VzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcbiAgICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBfaW5zZXJ0U2FtcGxlSW5PcmRlciAoYXJyLCBkYXRhKSB7XG4gICAgbGV0IGxlbiA9IGFyci5sZW5ndGg7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgIGlmIChkYXRhLnB0cyA+PSBhcnJbbGVuIC0gMV0ucHRzKSB7XG4gICAgICAgIGFyci5wdXNoKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gbGVuIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgICAgaWYgKGRhdGEucHRzIDwgYXJyW3Bvc10ucHRzKSB7XG4gICAgICAgICAgICBhcnIuc3BsaWNlKHBvcywgMCwgZGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXJyLnB1c2goZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgX2dldExhc3ROYWxVbml0ICgpIHtcbiAgICBsZXQgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUsIGxhc3RVbml0O1xuICAgIC8vIHRyeSB0byBmYWxsYmFjayB0byBwcmV2aW91cyBzYW1wbGUgaWYgY3VycmVudCBvbmUgaXMgZW1wdHlcbiAgICBpZiAoIWF2Y1NhbXBsZSB8fCBhdmNTYW1wbGUudW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsZXQgdHJhY2sgPSB0aGlzLl9hdmNUcmFjaywgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgICBhdmNTYW1wbGUgPSBzYW1wbGVzW3NhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGlmIChhdmNTYW1wbGUpIHtcbiAgICAgIGxldCB1bml0cyA9IGF2Y1NhbXBsZS51bml0cztcbiAgICAgIGxhc3RVbml0ID0gdW5pdHNbdW5pdHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBsYXN0VW5pdDtcbiAgfVxuXG4gIF9wYXJzZUFWQ05BTHUgKGFycmF5KSB7XG4gICAgbGV0IGkgPSAwLCBsZW4gPSBhcnJheS5ieXRlTGVuZ3RoLCB2YWx1ZSwgb3ZlcmZsb3csIHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssIHN0YXRlID0gdHJhY2submFsdVN0YXRlIHx8IDAsIGxhc3RTdGF0ZSA9IHN0YXRlO1xuICAgIGxldCB1bml0cyA9IFtdLCB1bml0LCB1bml0VHlwZSwgbGFzdFVuaXRTdGFydCA9IC0xLCBsYXN0VW5pdFR5cGU7XG4gICAgLy8gbG9nZ2VyLmxvZygnUEVTOicgKyBIZXguaGV4RHVtcChhcnJheSkpO1xuXG4gICAgaWYgKHN0YXRlID09PSAtMSkge1xuICAgIC8vIHNwZWNpYWwgdXNlIGNhc2Ugd2hlcmUgd2UgZm91bmQgMyBvciA0LWJ5dGUgc3RhcnQgY29kZXMgZXhhY3RseSBhdCB0aGUgZW5kIG9mIHByZXZpb3VzIFBFUyBwYWNrZXRcbiAgICAgIGxhc3RVbml0U3RhcnQgPSAwO1xuICAgICAgLy8gTkFMdSB0eXBlIGlzIHZhbHVlIHJlYWQgZnJvbSBvZmZzZXQgMFxuICAgICAgbGFzdFVuaXRUeXBlID0gYXJyYXlbMF0gJiAweDFmO1xuICAgICAgc3RhdGUgPSAwO1xuICAgICAgaSA9IDE7XG4gICAgfVxuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIHZhbHVlID0gYXJyYXlbaSsrXTtcbiAgICAgIC8vIG9wdGltaXphdGlvbi4gc3RhdGUgMCBhbmQgMSBhcmUgdGhlIHByZWRvbWluYW50IGNhc2UuIGxldCdzIGhhbmRsZSB0aGVtIG91dHNpZGUgb2YgdGhlIHN3aXRjaC9jYXNlXG4gICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT09IDEpIHtcbiAgICAgICAgc3RhdGUgPSB2YWx1ZSA/IDAgOiAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIGhlcmUgd2UgaGF2ZSBzdGF0ZSBlaXRoZXIgZXF1YWwgdG8gMiBvciAzXG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHN0YXRlID0gMztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDEpIHtcbiAgICAgICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCkge1xuICAgICAgICAgIHVuaXQgPSB7IGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGkgLSBzdGF0ZSAtIDEpLCB0eXBlOiBsYXN0VW5pdFR5cGUgfTtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbGFzdFVuaXRTdGFydCBpcyB1bmRlZmluZWQgPT4gdGhpcyBpcyB0aGUgZmlyc3Qgc3RhcnQgY29kZSBmb3VuZCBpbiB0aGlzIFBFUyBwYWNrZXRcbiAgICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiBzdGFydCBjb2RlIGRlbGltaXRlciBpcyBvdmVybGFwcGluZyBiZXR3ZWVuIDIgUEVTIHBhY2tldHMsXG4gICAgICAgICAgLy8gaWUgaXQgc3RhcnRlZCBpbiBsYXN0IHBhY2tldCAobGFzdFN0YXRlIG5vdCB6ZXJvKVxuICAgICAgICAgIC8vIGFuZCBlbmRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgUEVTIHBhY2tldCAoaSA8PSA0IC0gbGFzdFN0YXRlKVxuICAgICAgICAgIGxldCBsYXN0VW5pdCA9IHRoaXMuX2dldExhc3ROYWxVbml0KCk7XG4gICAgICAgICAgaWYgKGxhc3RVbml0KSB7XG4gICAgICAgICAgICBpZiAobGFzdFN0YXRlICYmIChpIDw9IDQgLSBsYXN0U3RhdGUpKSB7XG4gICAgICAgICAgICAgIC8vIHN0YXJ0IGRlbGltaXRlciBvdmVybGFwcGluZyBiZXR3ZWVuIFBFUyBwYWNrZXRzXG4gICAgICAgICAgICAgIC8vIHN0cmlwIHN0YXJ0IGRlbGltaXRlciBieXRlcyBmcm9tIHRoZSBlbmQgb2YgbGFzdCBOQUwgdW5pdFxuICAgICAgICAgICAgICAvLyBjaGVjayBpZiBsYXN0VW5pdCBoYWQgYSBzdGF0ZSBkaWZmZXJlbnQgZnJvbSB6ZXJvXG4gICAgICAgICAgICAgIGlmIChsYXN0VW5pdC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGxhc3QgYnl0ZXNcbiAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gbGFzdFVuaXQuZGF0YS5zdWJhcnJheSgwLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggLSBsYXN0U3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBOQUwgdW5pdHMgYXJlIG5vdCBzdGFydGluZyByaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGFja2V0LCBwdXNoIHByZWNlZGluZyBkYXRhIGludG8gcHJldmlvdXMgTkFMIHVuaXQuXG4gICAgICAgICAgICBvdmVyZmxvdyA9IGkgLSBzdGF0ZSAtIDE7XG4gICAgICAgICAgICBpZiAob3ZlcmZsb3cgPiAwKSB7XG4gICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2ZpcnN0IE5BTFUgZm91bmQgd2l0aCBvdmVyZmxvdzonICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICBsZXQgdG1wID0gbmV3IFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICB0bXAuc2V0KGxhc3RVbml0LmRhdGEsIDApO1xuICAgICAgICAgICAgICB0bXAuc2V0KGFycmF5LnN1YmFycmF5KDAsIG92ZXJmbG93KSwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgY2FuIHJlYWQgdW5pdCB0eXBlXG4gICAgICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICAgICAgdW5pdFR5cGUgPSBhcnJheVtpXSAmIDB4MWY7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmluZCBOQUxVIEAgb2Zmc2V0OicgKyBpICsgJyx0eXBlOicgKyB1bml0VHlwZSk7XG4gICAgICAgICAgbGFzdFVuaXRTdGFydCA9IGk7XG4gICAgICAgICAgbGFzdFVuaXRUeXBlID0gdW5pdFR5cGU7XG4gICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vdCBlbm91Z2ggYnl0ZSB0byByZWFkIHVuaXQgdHlwZS4gbGV0J3MgcmVhZCBpdCBvbiBuZXh0IFBFUyBwYXJzaW5nXG4gICAgICAgICAgc3RhdGUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdFVuaXRTdGFydCA+PSAwICYmIHN0YXRlID49IDApIHtcbiAgICAgIHVuaXQgPSB7IGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGxlbiksIHR5cGU6IGxhc3RVbml0VHlwZSwgc3RhdGU6IHN0YXRlIH07XG4gICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgICAgLy8gbG9nZ2VyLmxvZygncHVzaGluZyBOQUxVLCB0eXBlL3NpemUvc3RhdGU6JyArIHVuaXQudHlwZSArICcvJyArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgJy8nICsgc3RhdGUpO1xuICAgIH1cbiAgICAvLyBubyBOQUx1IGZvdW5kXG4gICAgaWYgKHVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gYXBwZW5kIHBlcy5kYXRhIHRvIHByZXZpb3VzIE5BTCB1bml0XG4gICAgICBsZXQgbGFzdFVuaXQgPSB0aGlzLl9nZXRMYXN0TmFsVW5pdCgpO1xuICAgICAgaWYgKGxhc3RVbml0KSB7XG4gICAgICAgIGxldCB0bXAgPSBuZXcgVWludDhBcnJheShsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggKyBhcnJheS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdG1wLnNldChsYXN0VW5pdC5kYXRhLCAwKTtcbiAgICAgICAgdG1wLnNldChhcnJheSwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgbGFzdFVuaXQuZGF0YSA9IHRtcDtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJhY2submFsdVN0YXRlID0gc3RhdGU7XG4gICAgcmV0dXJuIHVuaXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlbW92ZSBFbXVsYXRpb24gUHJldmVudGlvbiBieXRlcyBmcm9tIGEgUkJTUFxuICAgKi9cbiAgZGlzY2FyZEVQQiAoZGF0YSkge1xuICAgIGxldCBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICBFUEJQb3NpdGlvbnMgPSBbXSxcbiAgICAgIGkgPSAxLFxuICAgICAgbmV3TGVuZ3RoLCBuZXdEYXRhO1xuXG4gICAgLy8gRmluZCBhbGwgYEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzYFxuICAgIHdoaWxlIChpIDwgbGVuZ3RoIC0gMikge1xuICAgICAgaWYgKGRhdGFbaV0gPT09IDAgJiZcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9PT0gMCAmJlxuICAgICAgICAgIGRhdGFbaSArIDJdID09PSAweDAzKSB7XG4gICAgICAgIEVQQlBvc2l0aW9ucy5wdXNoKGkgKyAyKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vIEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzIHdlcmUgZm91bmQganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gICAgLy8gYXJyYXlcbiAgICBpZiAoRVBCUG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIGhvbGQgdGhlIE5BTCB1bml0IGRhdGFcbiAgICBuZXdMZW5ndGggPSBsZW5ndGggLSBFUEJQb3NpdGlvbnMubGVuZ3RoO1xuICAgIG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xuICAgIGxldCBzb3VyY2VJbmRleCA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBzb3VyY2VJbmRleCsrLCBpKyspIHtcbiAgICAgIGlmIChzb3VyY2VJbmRleCA9PT0gRVBCUG9zaXRpb25zWzBdKSB7XG4gICAgICAgIC8vIFNraXAgdGhpcyBieXRlXG4gICAgICAgIHNvdXJjZUluZGV4Kys7XG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIHBvc2l0aW9uIGluZGV4XG4gICAgICAgIEVQQlBvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgbmV3RGF0YVtpXSA9IGRhdGFbc291cmNlSW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfVxuXG4gIF9wYXJzZUFBQ1BFUyAocGVzKSB7XG4gICAgbGV0IHRyYWNrID0gdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgIGRhdGEgPSBwZXMuZGF0YSxcbiAgICAgIHB0cyA9IHBlcy5wdHMsXG4gICAgICBzdGFydE9mZnNldCA9IDAsXG4gICAgICBhYWNPdmVyRmxvdyA9IHRoaXMuYWFjT3ZlckZsb3csXG4gICAgICBhYWNMYXN0UFRTID0gdGhpcy5hYWNMYXN0UFRTLFxuICAgICAgZnJhbWVEdXJhdGlvbiwgZnJhbWVJbmRleCwgb2Zmc2V0LCBzdGFtcCwgbGVuO1xuICAgIGlmIChhYWNPdmVyRmxvdykge1xuICAgICAgbGV0IHRtcCA9IG5ldyBVaW50OEFycmF5KGFhY092ZXJGbG93LmJ5dGVMZW5ndGggKyBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgdG1wLnNldChhYWNPdmVyRmxvdywgMCk7XG4gICAgICB0bXAuc2V0KGRhdGEsIGFhY092ZXJGbG93LmJ5dGVMZW5ndGgpO1xuICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDOiBhcHBlbmQgb3ZlcmZsb3dpbmcgJHthYWNPdmVyRmxvdy5ieXRlTGVuZ3RofSBieXRlcyB0byBiZWdpbm5pbmcgb2YgbmV3IFBFU2ApO1xuICAgICAgZGF0YSA9IHRtcDtcbiAgICB9XG4gICAgLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcbiAgICBmb3IgKG9mZnNldCA9IHN0YXJ0T2Zmc2V0LCBsZW4gPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgIGlmIChBRFRTLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIEFEVFMgaGVhZGVyIGRvZXMgbm90IHN0YXJ0IHN0cmFpZ2h0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBheWxvYWQsIHJhaXNlIGFuIGVycm9yXG4gICAgaWYgKG9mZnNldCkge1xuICAgICAgbGV0IHJlYXNvbiwgZmF0YWw7XG4gICAgICBpZiAob2Zmc2V0IDwgbGVuIC0gMSkge1xuICAgICAgICByZWFzb24gPSBgQUFDIFBFUyBkaWQgbm90IHN0YXJ0IHdpdGggQURUUyBoZWFkZXIsb2Zmc2V0OiR7b2Zmc2V0fWA7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWFzb24gPSAnbm8gQURUUyBoZWFkZXIgZm91bmQgaW4gQUFDIFBFUyc7XG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci53YXJuKGBwYXJzaW5nIGVycm9yOiR7cmVhc29ufWApO1xuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiBmYXRhbCwgcmVhc29uOiByZWFzb24gfSk7XG4gICAgICBpZiAoZmF0YWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIEFEVFMuaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCB0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRoaXMuYXVkaW9Db2RlYyk7XG4gICAgZnJhbWVJbmRleCA9IDA7XG4gICAgZnJhbWVEdXJhdGlvbiA9IEFEVFMuZ2V0RnJhbWVEdXJhdGlvbih0cmFjay5zYW1wbGVyYXRlKTtcblxuICAgIC8vIGlmIGxhc3QgQUFDIGZyYW1lIGlzIG92ZXJmbG93aW5nLCB3ZSBzaG91bGQgZW5zdXJlIHRpbWVzdGFtcHMgYXJlIGNvbnRpZ3VvdXM6XG4gICAgLy8gZmlyc3Qgc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZnJhbWVEdXJhdGlvblxuICAgIGlmIChhYWNPdmVyRmxvdyAmJiBhYWNMYXN0UFRTKSB7XG4gICAgICBsZXQgbmV3UFRTID0gYWFjTGFzdFBUUyArIGZyYW1lRHVyYXRpb247XG4gICAgICBpZiAoTWF0aC5hYnMobmV3UFRTIC0gcHRzKSA+IDEpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgQUFDOiBhbGlnbiBQVFMgZm9yIG92ZXJsYXBwaW5nIGZyYW1lcyBieSAke01hdGgucm91bmQoKG5ld1BUUyAtIHB0cykgLyA5MCl9YCk7XG4gICAgICAgIHB0cyA9IG5ld1BUUztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzY2FuIGZvciBhYWMgc2FtcGxlc1xuICAgIHdoaWxlIChvZmZzZXQgPCBsZW4pIHtcbiAgICAgIGlmIChBRFRTLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkgJiYgKG9mZnNldCArIDUpIDwgbGVuKSB7XG4gICAgICAgIGxldCBmcmFtZSA9IEFEVFMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZyhgJHtNYXRoLnJvdW5kKGZyYW1lLnNhbXBsZS5wdHMpfSA6IEFBQ2ApO1xuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgc3RhbXAgPSBmcmFtZS5zYW1wbGUucHRzO1xuICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdVbmFibGUgdG8gcGFyc2UgQUFDIGZyYW1lJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICBhYWNPdmVyRmxvdyA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBsZW4pO1xuICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDOiBvdmVyZmxvdyBkZXRlY3RlZDoke2xlbi1vZmZzZXR9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmFhY092ZXJGbG93ID0gYWFjT3ZlckZsb3c7XG4gICAgdGhpcy5hYWNMYXN0UFRTID0gc3RhbXA7XG4gIH1cblxuICBfcGFyc2VNUEVHUEVTIChwZXMpIHtcbiAgICBsZXQgZGF0YSA9IHBlcy5kYXRhO1xuICAgIGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICBsZXQgZnJhbWVJbmRleCA9IDA7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgbGV0IHB0cyA9IHBlcy5wdHM7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoTXBlZ0F1ZGlvLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgbGV0IGZyYW1lID0gTXBlZ0F1ZGlvLmFwcGVuZEZyYW1lKHRoaXMuX2F1ZGlvVHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnVW5hYmxlIHRvIHBhcnNlIE1wZWcgYXVkaW8gZnJhbWUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBmb3VuZCwga2VlcCBsb29raW5nXG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9wYXJzZUlEM1BFUyAocGVzKSB7XG4gICAgdGhpcy5faWQzVHJhY2suc2FtcGxlcy5wdXNoKHBlcyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVFNEZW11eGVyO1xuIiwiZXhwb3J0IGNvbnN0IEVycm9yVHlwZXMgPSB7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbmV0d29yayBlcnJvciAobG9hZGluZyBlcnJvciAvIHRpbWVvdXQgLi4uKVxuICBORVRXT1JLX0VSUk9SOiAnbmV0d29ya0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtZWRpYSBFcnJvciAodmlkZW8vcGFyc2luZy9tZWRpYXNvdXJjZSBlcnJvcilcbiAgTUVESUFfRVJST1I6ICdtZWRpYUVycm9yJyxcbiAgLy8gRU1FIChlbmNyeXB0ZWQgbWVkaWEgZXh0ZW5zaW9ucykgZXJyb3JzXG4gIEtFWV9TWVNURU1fRVJST1I6ICdrZXlTeXN0ZW1FcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbXV4IEVycm9yIChkZW11eGluZy9yZW11eGluZylcbiAgTVVYX0VSUk9SOiAnbXV4RXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbGwgb3RoZXIgZXJyb3JzXG4gIE9USEVSX0VSUk9SOiAnb3RoZXJFcnJvcidcbn07XG5cbi8qKlxuICogQGVudW0ge0Vycm9yRGV0YWlsc31cbiAqIEB0eXBlZGVmIHtzdHJpbmd9IEVycm9yRGV0YWlsXG4gKi9cbmV4cG9ydCBjb25zdCBFcnJvckRldGFpbHMgPSB7XG4gIEtFWV9TWVNURU1fTk9fS0VZUzogJ2tleVN5c3RlbU5vS2V5cycsXG4gIEtFWV9TWVNURU1fTk9fQUNDRVNTOiAna2V5U3lzdGVtTm9BY2Nlc3MnLFxuICBLRVlfU1lTVEVNX05PX1NFU1NJT046ICdrZXlTeXN0ZW1Ob1Nlc3Npb24nLFxuICBLRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQ6ICdrZXlTeXN0ZW1MaWNlbnNlUmVxdWVzdEZhaWxlZCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTUFOSUZFU1RfTE9BRF9FUlJPUjogJ21hbmlmZXN0TG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIE1BTklGRVNUX0xPQURfVElNRU9VVDogJ21hbmlmZXN0TG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IHBhcnNpbmcgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlYXNvbiA6IGVycm9yIHJlYXNvbn1cbiAgTUFOSUZFU1RfUEFSU0lOR19FUlJPUjogJ21hbmlmZXN0UGFyc2luZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCB3aXRoIG9ubHkgaW5jb21wYXRpYmxlIGNvZGVjcyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29ufVxuICBNQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SOiAnbWFuaWZlc3RJbmNvbXBhdGlibGVDb2RlY3NFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTEVWRUxfTE9BRF9FUlJPUjogJ2xldmVsTG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIExFVkVMX0xPQURfVElNRU9VVDogJ2xldmVsTG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIHN3aXRjaCBlcnJvciAtIGRhdGE6IHsgbGV2ZWwgOiBmYXVsdHkgbGV2ZWwgSWQsIGV2ZW50IDogZXJyb3IgZGVzY3JpcHRpb259XG4gIExFVkVMX1NXSVRDSF9FUlJPUjogJ2xldmVsU3dpdGNoRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBBVURJT19UUkFDS19MT0FEX0VSUk9SOiAnYXVkaW9UcmFja0xvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGF1ZGlvIHRyYWNrIGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOiAnYXVkaW9UcmFja0xvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgRlJBR19MT0FEX0VSUk9SOiAnZnJhZ0xvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgdGltZW91dCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgRlJBR19MT0FEX1RJTUVPVVQ6ICdmcmFnTG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IGRlY3J5cHRpb24gZXJyb3IgZXZlbnQgLSBkYXRhOiB7aWQgOiBkZW11eGVyIElkLGZyYWc6IGZyYWdtZW50IG9iamVjdCwgcmVhc29uIDogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvbiB9XG4gIEZSQUdfREVDUllQVF9FUlJPUjogJ2ZyYWdEZWNyeXB0RXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IHBhcnNpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBJZCwgcmVhc29uIDogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvbiB9XG4gIC8vIHdpbGwgYmUgcmVuYW1lZCBERU1VWF9QQVJTSU5HX0VSUk9SIGFuZCBzd2l0Y2hlZCB0byBNVVhfRVJST1IgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxuICBGUkFHX1BBUlNJTkdfRVJST1I6ICdmcmFnUGFyc2luZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSByZW11eCBhbGxvYyBlcnJvciBldmVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIElkLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBieXRlcyA6IG5iIG9mIGJ5dGVzIG9uIHdoaWNoIGFsbG9jYXRpb24gZmFpbGVkICwgcmVhc29uIDogZXJyb3IgdGV4dCB9XG4gIFJFTVVYX0FMTE9DX0VSUk9SOiAncmVtdXhBbGxvY0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZGVjcnlwdCBrZXkgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgS0VZX0xPQURfRVJST1I6ICdrZXlMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBkZWNyeXB0IGtleSBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEtFWV9MT0FEX1RJTUVPVVQ6ICdrZXlMb2FkVGltZU91dCcsXG4gIC8vIFRyaWdnZXJlZCB3aGVuIGFuIGV4Y2VwdGlvbiBvY2N1cnMgd2hpbGUgYWRkaW5nIGEgc291cmNlQnVmZmVyIHRvIE1lZGlhU291cmNlIC0gZGF0YSA6IHsgIGVyciA6IGV4Y2VwdGlvbiAsIG1pbWVUeXBlIDogbWltZVR5cGUgfVxuICBCVUZGRVJfQUREX0NPREVDX0VSUk9SOiAnYnVmZmVyQWRkQ29kZWNFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGFwcGVuZCBlcnJvciAtIGRhdGE6IGFwcGVuZCBlcnJvciBkZXNjcmlwdGlvblxuICBCVUZGRVJfQVBQRU5EX0VSUk9SOiAnYnVmZmVyQXBwZW5kRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBhcHBlbmRpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiBhcHBlbmRpbmcgZXJyb3IgZGVzY3JpcHRpb25cbiAgQlVGRkVSX0FQUEVORElOR19FUlJPUjogJ2J1ZmZlckFwcGVuZGluZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgc3RhbGxlZCBlcnJvciBldmVudFxuICBCVUZGRVJfU1RBTExFRF9FUlJPUjogJ2J1ZmZlclN0YWxsZWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGZ1bGwgZXZlbnRcbiAgQlVGRkVSX0ZVTExfRVJST1I6ICdidWZmZXJGdWxsRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBzZWVrIG92ZXIgaG9sZSBldmVudFxuICBCVUZGRVJfU0VFS19PVkVSX0hPTEU6ICdidWZmZXJTZWVrT3ZlckhvbGUnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBudWRnZSBvbiBzdGFsbCAocGxheWJhY2sgaXMgc3R1Y2sgYWx0aG91Z2ggY3VycmVudFRpbWUgaXMgaW4gYSBidWZmZXJlZCBhcmVhKVxuICBCVUZGRVJfTlVER0VfT05fU1RBTEw6ICdidWZmZXJOdWRnZU9uU3RhbGwnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBpbnRlcm5hbCBleGNlcHRpb24gaGFwcGVuaW5nIGluc2lkZSBobHMuanMgd2hpbGUgaGFuZGxpbmcgYW4gZXZlbnRcbiAgSU5URVJOQUxfRVhDRVBUSU9OOiAnaW50ZXJuYWxFeGNlcHRpb24nXG59O1xuIiwiLypcbipcbiogQWxsIG9iamVjdHMgaW4gdGhlIGV2ZW50IGhhbmRsaW5nIGNoYWluIHNob3VsZCBpbmhlcml0IGZyb20gdGhpcyBjbGFzc1xuKlxuKi9cblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4vZXZlbnRzJztcblxuY29uc3QgRk9SQklEREVOX0VWRU5UX05BTUVTID0ge1xuICAnaGxzRXZlbnRHZW5lcmljJzogdHJ1ZSxcbiAgJ2hsc0hhbmRsZXJEZXN0cm95aW5nJzogdHJ1ZSxcbiAgJ2hsc0hhbmRsZXJEZXN0cm95ZWQnOiB0cnVlXG59O1xuXG5jbGFzcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzLCAuLi5ldmVudHMpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLm9uRXZlbnQgPSB0aGlzLm9uRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZWRFdmVudHMgPSBldmVudHM7XG4gICAgdGhpcy51c2VHZW5lcmljSGFuZGxlciA9IHRydWU7XG5cbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLm9uSGFuZGxlckRlc3Ryb3llZCgpO1xuICB9XG5cbiAgb25IYW5kbGVyRGVzdHJveWluZyAoKSB7fVxuICBvbkhhbmRsZXJEZXN0cm95ZWQgKCkge31cblxuICBpc0V2ZW50SGFuZGxlciAoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLmhhbmRsZWRFdmVudHMgPT09ICdvYmplY3QnICYmIHRoaXMuaGFuZGxlZEV2ZW50cy5sZW5ndGggJiYgdHlwZW9mIHRoaXMub25FdmVudCA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIHJlZ2lzdGVyTGlzdGVuZXJzICgpIHtcbiAgICBpZiAodGhpcy5pc0V2ZW50SGFuZGxlcigpKSB7XG4gICAgICB0aGlzLmhhbmRsZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKEZPUkJJRERFTl9FVkVOVF9OQU1FU1tldmVudF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvcmJpZGRlbiBldmVudC1uYW1lOiAnICsgZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5obHMub24oZXZlbnQsIHRoaXMub25FdmVudCk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzICgpIHtcbiAgICBpZiAodGhpcy5pc0V2ZW50SGFuZGxlcigpKSB7XG4gICAgICB0aGlzLmhhbmRsZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5obHMub2ZmKGV2ZW50LCB0aGlzLm9uRXZlbnQpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGFyZ3VtZW50czogZXZlbnQgKHN0cmluZyksIGRhdGEgKGFueSlcbiAgICovXG4gIG9uRXZlbnQgKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5vbkV2ZW50R2VuZXJpYyhldmVudCwgZGF0YSk7XG4gIH1cblxuICBvbkV2ZW50R2VuZXJpYyAoZXZlbnQsIGRhdGEpIHtcbiAgICBsZXQgZXZlbnRUb0Z1bmN0aW9uID0gZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICBsZXQgZnVuY05hbWUgPSAnb24nICsgZXZlbnQucmVwbGFjZSgnaGxzJywgJycpO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzW2Z1bmNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV2ZW50ICR7ZXZlbnR9IGhhcyBubyBnZW5lcmljIGhhbmRsZXIgaW4gdGhpcyAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gY2xhc3MgKHRyaWVkICR7ZnVuY05hbWV9KWApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1tmdW5jTmFtZV0uYmluZCh0aGlzLCBkYXRhKTtcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBldmVudFRvRnVuY3Rpb24uY2FsbCh0aGlzLCBldmVudCwgZGF0YSkuY2FsbCgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyLmVycm9yKGBBbiBpbnRlcm5hbCBlcnJvciBoYXBwZW5lZCB3aGlsZSBoYW5kbGluZyBldmVudCAke2V2ZW50fS4gRXJyb3IgbWVzc2FnZTogXCIke2Vyci5tZXNzYWdlfVwiLiBIZXJlIGlzIGEgc3RhY2t0cmFjZTpgLCBlcnIpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLCBmYXRhbDogZmFsc2UsIGV2ZW50OiBldmVudCwgZXJyOiBlcnIgfSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50SGFuZGxlcjtcbiIsIi8qKlxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5jb25zdCBIbHNFdmVudHMgPSB7XG4gIC8vIGZpcmVkIGJlZm9yZSBNZWRpYVNvdXJjZSBpcyBhdHRhY2hpbmcgdG8gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgbWVkaWEgfVxuICBNRURJQV9BVFRBQ0hJTkc6ICdobHNNZWRpYUF0dGFjaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gTWVkaWFTb3VyY2UgaGFzIGJlZW4gc3VjY2VzZnVsbHkgYXR0YWNoZWQgdG8gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgfVxuICBNRURJQV9BVFRBQ0hFRDogJ2hsc01lZGlhQXR0YWNoZWQnLFxuICAvLyBmaXJlZCBiZWZvcmUgZGV0YWNoaW5nIE1lZGlhU291cmNlIGZyb20gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgfVxuICBNRURJQV9ERVRBQ0hJTkc6ICdobHNNZWRpYURldGFjaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gTWVkaWFTb3VyY2UgaGFzIGJlZW4gZGV0YWNoZWQgZnJvbSBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XG4gIE1FRElBX0RFVEFDSEVEOiAnaGxzTWVkaWFEZXRhY2hlZCcsXG4gIC8vIGZpcmVkIHdoZW4gd2UgYnVmZmVyIGlzIGdvaW5nIHRvIGJlIHJlc2V0IC0gZGF0YTogeyB9XG4gIEJVRkZFUl9SRVNFVDogJ2hsc0J1ZmZlclJlc2V0JyxcbiAgLy8gZmlyZWQgd2hlbiB3ZSBrbm93IGFib3V0IHRoZSBjb2RlY3MgdGhhdCB3ZSBuZWVkIGJ1ZmZlcnMgZm9yIHRvIHB1c2ggaW50byAtIGRhdGE6IHt0cmFja3MgOiB7IGNvbnRhaW5lciwgY29kZWMsIGxldmVsQ29kZWMsIGluaXRTZWdtZW50LCBtZXRhZGF0YSB9fVxuICBCVUZGRVJfQ09ERUNTOiAnaGxzQnVmZmVyQ29kZWNzJyxcbiAgLy8gZmlyZWQgd2hlbiBzb3VyY2VidWZmZXJzIGhhdmUgYmVlbiBjcmVhdGVkIC0gZGF0YTogeyB0cmFja3MgOiB0cmFja3MgfVxuICBCVUZGRVJfQ1JFQVRFRDogJ2hsc0J1ZmZlckNyZWF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGFwcGVuZCBhIHNlZ21lbnQgdG8gdGhlIGJ1ZmZlciAtIGRhdGE6IHsgc2VnbWVudDogc2VnbWVudCBvYmplY3QgfVxuICBCVUZGRVJfQVBQRU5ESU5HOiAnaGxzQnVmZmVyQXBwZW5kaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiB3ZSBhcmUgZG9uZSB3aXRoIGFwcGVuZGluZyBhIG1lZGlhIHNlZ21lbnQgdG8gdGhlIGJ1ZmZlciAtIGRhdGEgOiB7IHBhcmVudCA6IHNlZ21lbnQgcGFyZW50IHRoYXQgdHJpZ2dlcmVkIEJVRkZFUl9BUFBFTkRJTkcsIHBlbmRpbmcgOiBuYiBvZiBzZWdtZW50cyB3YWl0aW5nIGZvciBhcHBlbmRpbmcgZm9yIHRoaXMgc2VnbWVudCBwYXJlbnR9XG4gIEJVRkZFUl9BUFBFTkRFRDogJ2hsc0J1ZmZlckFwcGVuZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkIGFuZCB3ZSB3YW50IHRvIG5vdGlmeSB0aGUgbWVkaWEgYnVmZmVyIHRoYXQgdGhlcmUgd2lsbCBiZSBubyBtb3JlIGRhdGEgLSBkYXRhOiB7IH1cbiAgQlVGRkVSX0VPUzogJ2hsc0J1ZmZlckVvcycsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIG1lZGlhIGJ1ZmZlciBzaG91bGQgYmUgZmx1c2hlZCAtIGRhdGEgeyBzdGFydE9mZnNldCwgZW5kT2Zmc2V0IH1cbiAgQlVGRkVSX0ZMVVNISU5HOiAnaGxzQnVmZmVyRmx1c2hpbmcnLFxuICAvLyBmaXJlZCB3aGVuIHRoZSBtZWRpYSBidWZmZXIgaGFzIGJlZW4gZmx1c2hlZCAtIGRhdGE6IHsgfVxuICBCVUZGRVJfRkxVU0hFRDogJ2hsc0J1ZmZlckZsdXNoZWQnLFxuICAvLyBmaXJlZCB0byBzaWduYWwgdGhhdCBhIG1hbmlmZXN0IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBtYW5pZmVzdFVSTH1cbiAgTUFOSUZFU1RfTE9BRElORzogJ2hsc01hbmlmZXN0TG9hZGluZycsXG4gIC8vIGZpcmVkIGFmdGVyIG1hbmlmZXN0IGhhcyBiZWVuIGxvYWRlZCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10sIGF1ZGlvVHJhY2tzIDogWyBhdmFpbGFibGUgYXVkaW8gdHJhY2tzXSwgdXJsIDogbWFuaWZlc3RVUkwsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWV9fVxuICBNQU5JRkVTVF9MT0FERUQ6ICdobHNNYW5pZmVzdExvYWRlZCcsXG4gIC8vIGZpcmVkIGFmdGVyIG1hbmlmZXN0IGhhcyBiZWVuIHBhcnNlZCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10sIGZpcnN0TGV2ZWwgOiBpbmRleCBvZiBmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiBNYW5pZmVzdH1cbiAgTUFOSUZFU1RfUEFSU0VEOiAnaGxzTWFuaWZlc3RQYXJzZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgc3dpdGNoIGlzIHJlcXVlc3RlZCAtIGRhdGE6IHsgbGV2ZWwgOiBpZCBvZiBuZXcgbGV2ZWwgfVxuICBMRVZFTF9TV0lUQ0hJTkc6ICdobHNMZXZlbFN3aXRjaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBzd2l0Y2ggaXMgZWZmZWN0aXZlIC0gZGF0YTogeyBsZXZlbCA6IGlkIG9mIG5ldyBsZXZlbCB9XG4gIExFVkVMX1NXSVRDSEVEOiAnaGxzTGV2ZWxTd2l0Y2hlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBwbGF5bGlzdCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogbGV2ZWwgVVJMLCBsZXZlbCA6IGlkIG9mIGxldmVsIGJlaW5nIGxvYWRlZH1cbiAgTEVWRUxfTE9BRElORzogJ2hsc0xldmVsTG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBwbGF5bGlzdCBsb2FkaW5nIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiBsb2FkZWQgbGV2ZWwsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWV9IH1cbiAgTEVWRUxfTE9BREVEOiAnaGxzTGV2ZWxMb2FkZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwncyBkZXRhaWxzIGhhdmUgYmVlbiB1cGRhdGVkIGJhc2VkIG9uIHByZXZpb3VzIGRldGFpbHMsIGFmdGVyIGl0IGhhcyBiZWVuIGxvYWRlZCAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgdXBkYXRlZCBsZXZlbCB9XG4gIExFVkVMX1VQREFURUQ6ICdobHNMZXZlbFVwZGF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwncyBQVFMgaW5mb3JtYXRpb24gaGFzIGJlZW4gdXBkYXRlZCBhZnRlciBwYXJzaW5nIGEgZnJhZ21lbnQgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIHVwZGF0ZWQgbGV2ZWwsIGRyaWZ0OiBQVFMgZHJpZnQgb2JzZXJ2ZWQgd2hlbiBwYXJzaW5nIGxhc3QgZnJhZ21lbnQgfVxuICBMRVZFTF9QVFNfVVBEQVRFRDogJ2hsc0xldmVsUHRzVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHRvIG5vdGlmeSB0aGF0IGF1ZGlvIHRyYWNrIGxpc3RzIGhhcyBiZWVuIHVwZGF0ZWQgLSBkYXRhOiB7IGF1ZGlvVHJhY2tzIDogYXVkaW9UcmFja3MgfVxuICBBVURJT19UUkFDS1NfVVBEQVRFRDogJ2hsc0F1ZGlvVHJhY2tzVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgc3dpdGNoaW5nIGlzIHJlcXVlc3RlZCAtIGRhdGE6IHsgaWQgOiBhdWRpbyB0cmFjayBpZCB9XG4gIEFVRElPX1RSQUNLX1NXSVRDSElORzogJ2hsc0F1ZGlvVHJhY2tTd2l0Y2hpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIHN3aXRjaCBhY3R1YWxseSBvY2N1cnMgLSBkYXRhOiB7IGlkIDogYXVkaW8gdHJhY2sgaWQgfVxuICBBVURJT19UUkFDS19TV0lUQ0hFRDogJ2hsc0F1ZGlvVHJhY2tTd2l0Y2hlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IGF1ZGlvIHRyYWNrIFVSTCwgaWQgOiBhdWRpbyB0cmFjayBpZCB9XG4gIEFVRElPX1RSQUNLX0xPQURJTkc6ICdobHNBdWRpb1RyYWNrTG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGlkIDogYXVkaW8gdHJhY2sgaWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWUgfSB9XG4gIEFVRElPX1RSQUNLX0xPQURFRDogJ2hsc0F1ZGlvVHJhY2tMb2FkZWQnLFxuICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBzdWJ0aXRsZSB0cmFjayBsaXN0cyBoYXMgYmVlbiB1cGRhdGVkIC0gZGF0YTogeyBzdWJ0aXRsZVRyYWNrcyA6IHN1YnRpdGxlVHJhY2tzIH1cbiAgU1VCVElUTEVfVFJBQ0tTX1VQREFURUQ6ICdobHNTdWJ0aXRsZVRyYWNrc1VwZGF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGFuIHN1YnRpdGxlIHRyYWNrIHN3aXRjaCBvY2N1cnMgLSBkYXRhOiB7IGlkIDogc3VidGl0bGUgdHJhY2sgaWQgfVxuICBTVUJUSVRMRV9UUkFDS19TV0lUQ0g6ICdobHNTdWJ0aXRsZVRyYWNrU3dpdGNoJyxcbiAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIHRyYWNrIGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBzdWJ0aXRsZSB0cmFjayBVUkwsIGlkIDogc3VidGl0bGUgdHJhY2sgaWQgfVxuICBTVUJUSVRMRV9UUkFDS19MT0FESU5HOiAnaGxzU3VidGl0bGVUcmFja0xvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgdHJhY2sgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGlkIDogc3VidGl0bGUgdHJhY2sgaWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWUgfSB9XG4gIFNVQlRJVExFX1RSQUNLX0xPQURFRDogJ2hsc1N1YnRpdGxlVHJhY2tMb2FkZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgZnJhZ21lbnQgaGFzIGJlZW4gcHJvY2Vzc2VkIC0gZGF0YTogeyBzdWNjZXNzIDogYm9vbGVhbiwgZnJhZyA6IHRoZSBwcm9jZXNzZWQgZnJhZyB9XG4gIFNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VEOiAnaGxzU3VidGl0bGVGcmFnUHJvY2Vzc2VkJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgZmlyc3QgdGltZXN0YW1wIGlzIGZvdW5kIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGluaXRQVFM6IGluaXRQVFMsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBJTklUX1BUU19GT1VORDogJ2hsc0luaXRQdHNGb3VuZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gIEZSQUdfTE9BRElORzogJ2hsc0ZyYWdMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgaXMgcHJvZ3Jlc3NpbmcgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHsgdHJlcXVlc3QsIHRmaXJzdCwgbG9hZGVkIH0gfVxuICBGUkFHX0xPQURfUFJPR1JFU1M6ICdobHNGcmFnTG9hZFByb2dyZXNzJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBhYm9ydGluZyBmb3IgZW1lcmdlbmN5IHN3aXRjaCBkb3duIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVEOiAnaGxzRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBwYXlsb2FkIDogZnJhZ21lbnQgcGF5bG9hZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBsZW5ndGggfSB9XG4gIEZSQUdfTE9BREVEOiAnaGxzRnJhZ0xvYWRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBoYXMgZmluaXNoZWQgZGVjcnlwdGluZyAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHBheWxvYWQgOiBmcmFnbWVudCBwYXlsb2FkLCBzdGF0cyA6IHsgdHN0YXJ0LCB0ZGVjcnlwdCB9IH1cbiAgRlJBR19ERUNSWVBURUQ6ICdobHNGcmFnRGVjcnlwdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBJbml0IFNlZ21lbnQgaGFzIGJlZW4gZXh0cmFjdGVkIGZyb20gZnJhZ21lbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBtb292IDogbW9vdiBNUDQgYm94LCBjb2RlY3MgOiBjb2RlY3MgZm91bmQgd2hpbGUgcGFyc2luZyBmcmFnbWVudCB9XG4gIEZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQ6ICdobHNGcmFnUGFyc2luZ0luaXRTZWdtZW50JyxcbiAgLy8gZmlyZWQgd2hlbiBwYXJzaW5nIHNlaSB0ZXh0IGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHNhbXBsZXMgOiBbIHNlaSBzYW1wbGVzIHBlcyBdIH1cbiAgRlJBR19QQVJTSU5HX1VTRVJEQVRBOiAnaGxzRnJhZ1BhcnNpbmdVc2VyZGF0YScsXG4gIC8vIGZpcmVkIHdoZW4gcGFyc2luZyBpZDMgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgc2FtcGxlcyA6IFsgaWQzIHNhbXBsZXMgcGVzIF0gfVxuICBGUkFHX1BBUlNJTkdfTUVUQURBVEE6ICdobHNGcmFnUGFyc2luZ01ldGFkYXRhJyxcbiAgLy8gZmlyZWQgd2hlbiBkYXRhIGhhdmUgYmVlbiBleHRyYWN0ZWQgZnJvbSBmcmFnbWVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIGRhdGExIDogbW9vZiBNUDQgYm94IG9yIFRTIGZyYWdtZW50cywgZGF0YTIgOiBtZGF0IE1QNCBib3ggb3IgbnVsbH1cbiAgRlJBR19QQVJTSU5HX0RBVEE6ICdobHNGcmFnUGFyc2luZ0RhdGEnLFxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHBhcnNpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCB9XG4gIEZSQUdfUEFSU0VEOiAnaGxzRnJhZ1BhcnNlZCcsXG4gIC8vIGZpcmVkIHdoZW4gZnJhZ21lbnQgcmVtdXhlZCBNUDQgYm94ZXMgaGF2ZSBhbGwgYmVlbiBhcHBlbmRlZCBpbnRvIFNvdXJjZUJ1ZmZlciAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIHRwYXJzZWQsIHRidWZmZXJlZCwgbGVuZ3RoLCBid0VzdGltYXRlIH0gfVxuICBGUkFHX0JVRkZFUkVEOiAnaGxzRnJhZ0J1ZmZlcmVkJyxcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCBtYXRjaGluZyB3aXRoIGN1cnJlbnQgbWVkaWEgcG9zaXRpb24gaXMgY2hhbmdpbmcgLSBkYXRhIDogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBGUkFHX0NIQU5HRUQ6ICdobHNGcmFnQ2hhbmdlZCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgRlBTIGRyb3AgZXZlbnQgLSBkYXRhOiB7IGN1cmVudERyb3BwZWQsIGN1cnJlbnREZWNvZGVkLCB0b3RhbERyb3BwZWRGcmFtZXMgfVxuICBGUFNfRFJPUDogJ2hsc0Zwc0Ryb3AnLFxuICAvLyB0cmlnZ2VyZWQgd2hlbiBGUFMgZHJvcCB0cmlnZ2VycyBhdXRvIGxldmVsIGNhcHBpbmcgLSBkYXRhOiB7IGxldmVsLCBkcm9wcGVkbGV2ZWwgfVxuICBGUFNfRFJPUF9MRVZFTF9DQVBQSU5HOiAnaGxzRnBzRHJvcExldmVsQ2FwcGluZycsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGVycm9yIGV2ZW50IC0gZGF0YTogeyB0eXBlIDogZXJyb3IgdHlwZSwgZGV0YWlscyA6IGVycm9yIGRldGFpbHMsIGZhdGFsIDogaWYgdHJ1ZSwgaGxzLmpzIGNhbm5vdC93aWxsIG5vdCB0cnkgdG8gcmVjb3ZlciwgaWYgZmFsc2UsIGhscy5qcyB3aWxsIHRyeSB0byByZWNvdmVyLG90aGVyIGVycm9yIHNwZWNpZmljIGRhdGEgfVxuICBFUlJPUjogJ2hsc0Vycm9yJyxcbiAgLy8gZmlyZWQgd2hlbiBobHMuanMgaW5zdGFuY2Ugc3RhcnRzIGRlc3Ryb3lpbmcuIERpZmZlcmVudCBmcm9tIE1FRElBX0RFVEFDSEVEIGFzIG9uZSBjb3VsZCB3YW50IHRvIGRldGFjaCBhbmQgcmVhdHRhY2ggYSBtZWRpYSB0byB0aGUgaW5zdGFuY2Ugb2YgaGxzLmpzIHRvIGhhbmRsZSBtaWQtcm9sbHMgZm9yIGV4YW1wbGUgLSBkYXRhOiB7IH1cbiAgREVTVFJPWUlORzogJ2hsc0Rlc3Ryb3lpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgZGVjcnlwdCBrZXkgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBLRVlfTE9BRElORzogJ2hsc0tleUxvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgZGVjcnlwdCBrZXkgbG9hZGluZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHBheWxvYWQgOiBrZXkgcGF5bG9hZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBsZW5ndGggfSB9XG4gIEtFWV9MT0FERUQ6ICdobHNLZXlMb2FkZWQnLFxuICAvLyBmaXJlZCB1cG9uIHN0cmVhbSBjb250cm9sbGVyIHN0YXRlIHRyYW5zaXRpb25zIC0gZGF0YTogeyBwcmV2aW91c1N0YXRlLCBuZXh0U3RhdGUgfVxuICBTVFJFQU1fU1RBVEVfVFJBTlNJVElPTjogJ2hsc1N0cmVhbVN0YXRlVHJhbnNpdGlvbidcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhsc0V2ZW50cztcbiIsImltcG9ydCAqIGFzIFVSTFRvb2xraXQgZnJvbSAndXJsLXRvb2xraXQnO1xuXG5pbXBvcnQge1xuICBFcnJvclR5cGVzLFxuICBFcnJvckRldGFpbHNcbn0gZnJvbSAnLi9lcnJvcnMnO1xuXG5pbXBvcnQgUGxheWxpc3RMb2FkZXIgZnJvbSAnLi9sb2FkZXIvcGxheWxpc3QtbG9hZGVyJztcbmltcG9ydCBGcmFnbWVudExvYWRlciBmcm9tICcuL2xvYWRlci9mcmFnbWVudC1sb2FkZXInO1xuaW1wb3J0IEtleUxvYWRlciBmcm9tICcuL2xvYWRlci9rZXktbG9hZGVyJztcblxuaW1wb3J0IHsgRnJhZ21lbnRUcmFja2VyIH0gZnJvbSAnLi9jb250cm9sbGVyL2ZyYWdtZW50LXRyYWNrZXInO1xuaW1wb3J0IFN0cmVhbUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCBMZXZlbENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2xldmVsLWNvbnRyb2xsZXInO1xuaW1wb3J0IElEM1RyYWNrQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvaWQzLXRyYWNrLWNvbnRyb2xsZXInO1xuXG5pbXBvcnQgeyBpc1N1cHBvcnRlZCB9IGZyb20gJy4vaXMtc3VwcG9ydGVkJztcbmltcG9ydCB7IGxvZ2dlciwgZW5hYmxlTG9ncyB9IGZyb20gJy4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IGhsc0RlZmF1bHRDb25maWcgfSBmcm9tICcuL2NvbmZpZyc7XG5cbmltcG9ydCBIbHNFdmVudHMgZnJvbSAnLi9ldmVudHMnO1xuXG5pbXBvcnQgeyBPYnNlcnZlciB9IGZyb20gJy4vb2JzZXJ2ZXInO1xuXG4vKipcbiAqIEBtb2R1bGUgSGxzXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIbHMgZXh0ZW5kcyBPYnNlcnZlciB7XG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCB2ZXJzaW9uICgpIHtcbiAgICByZXR1cm4gX19WRVJTSU9OX187XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQgKCkge1xuICAgIHJldHVybiBpc1N1cHBvcnRlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtIbHNFdmVudHN9XG4gICAqL1xuICBzdGF0aWMgZ2V0IEV2ZW50cyAoKSB7XG4gICAgcmV0dXJuIEhsc0V2ZW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7SGxzRXJyb3JUeXBlc31cbiAgICovXG4gIHN0YXRpYyBnZXQgRXJyb3JUeXBlcyAoKSB7XG4gICAgcmV0dXJuIEVycm9yVHlwZXM7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0hsc0Vycm9yRGV0YWlsc31cbiAgICovXG4gIHN0YXRpYyBnZXQgRXJyb3JEZXRhaWxzICgpIHtcbiAgICByZXR1cm4gRXJyb3JEZXRhaWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtIbHNDb25maWd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERlZmF1bHRDb25maWcgKCkge1xuICAgIGlmICghSGxzLmRlZmF1bHRDb25maWcpIHtcbiAgICAgIHJldHVybiBobHNEZWZhdWx0Q29uZmlnO1xuICAgIH1cblxuICAgIHJldHVybiBIbHMuZGVmYXVsdENvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7SGxzQ29uZmlnfVxuICAgKi9cbiAgc3RhdGljIHNldCBEZWZhdWx0Q29uZmlnIChkZWZhdWx0Q29uZmlnKSB7XG4gICAgSGxzLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYW4gSExTIGNsaWVudCB0aGF0IGNhbiBhdHRhY2ggdG8gZXhhY3RseSBvbmUgYEhUTUxNZWRpYUVsZW1lbnRgLlxuICAgKlxuICAgKiBAY29uc3RydWN0cyBIbHNcbiAgICogQHBhcmFtIHtIbHNDb25maWd9IGNvbmZpZ1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSBIbHMuRGVmYXVsdENvbmZpZztcblxuICAgIGlmICgoY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50KSAmJiAoY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogZG9uXFwndCBtaXggdXAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50L2xpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCBhbmQgbGl2ZVN5bmNEdXJhdGlvbi9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uJyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgcHJvcCBpbiBkZWZhdWx0Q29uZmlnKSB7XG4gICAgICBpZiAocHJvcCBpbiBjb25maWcpIGNvbnRpbnVlO1xuICAgICAgY29uZmlnW3Byb3BdID0gZGVmYXVsdENvbmZpZ1twcm9wXTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgPD0gY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50XCIgbXVzdCBiZSBndCBcImxpdmVTeW5jRHVyYXRpb25Db3VudFwiJyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgJiYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDw9IGNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8IGNvbmZpZy5saXZlU3luY0R1cmF0aW9uID09PSB1bmRlZmluZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIgbXVzdCBiZSBndCBcImxpdmVTeW5jRHVyYXRpb25cIicpO1xuICAgIH1cblxuICAgIGVuYWJsZUxvZ3MoY29uZmlnLmRlYnVnKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG5cbiAgICAvLyBjb3JlIGNvbnRyb2xsZXJzIGFuZCBuZXR3b3JrIGxvYWRlcnNcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0FickNvbnRyb2xsZXJ9IGFickNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBjb25zdCBhYnJDb250cm9sbGVyID0gdGhpcy5hYnJDb250cm9sbGVyID0gbmV3IGNvbmZpZy5hYnJDb250cm9sbGVyKHRoaXMpO1xuXG4gICAgY29uc3QgYnVmZmVyQ29udHJvbGxlciA9IG5ldyBjb25maWcuYnVmZmVyQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBjYXBMZXZlbENvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmNhcExldmVsQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBmcHNDb250cm9sbGVyID0gbmV3IGNvbmZpZy5mcHNDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IHBsYXlMaXN0TG9hZGVyID0gbmV3IFBsYXlsaXN0TG9hZGVyKHRoaXMpO1xuICAgIGNvbnN0IGZyYWdtZW50TG9hZGVyID0gbmV3IEZyYWdtZW50TG9hZGVyKHRoaXMpO1xuICAgIGNvbnN0IGtleUxvYWRlciA9IG5ldyBLZXlMb2FkZXIodGhpcyk7XG4gICAgY29uc3QgaWQzVHJhY2tDb250cm9sbGVyID0gbmV3IElEM1RyYWNrQ29udHJvbGxlcih0aGlzKTtcblxuICAgIC8vIG5ldHdvcmsgY29udHJvbGxlcnNcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0xldmVsQ29udHJvbGxlcn0gbGV2ZWxDb250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3QgbGV2ZWxDb250cm9sbGVyID0gdGhpcy5sZXZlbENvbnRyb2xsZXIgPSBuZXcgTGV2ZWxDb250cm9sbGVyKHRoaXMpO1xuXG4gICAgLy8gRklYTUU6IEZyYWdtZW50VHJhY2tlciBtdXN0IGJlIGRlZmluZWQgYmVmb3JlIFN0cmVhbUNvbnRyb2xsZXIgYmVjYXVzZSB0aGUgb3JkZXIgb2YgZXZlbnQgaGFuZGxpbmcgaXMgaW1wb3J0YW50XG4gICAgY29uc3QgZnJhZ21lbnRUcmFja2VyID0gbmV3IEZyYWdtZW50VHJhY2tlcih0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmVhbUNvbnRyb2xsZXJ9IHN0cmVhbUNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBjb25zdCBzdHJlYW1Db250cm9sbGVyID0gdGhpcy5zdHJlYW1Db250cm9sbGVyID0gbmV3IFN0cmVhbUNvbnRyb2xsZXIodGhpcywgZnJhZ21lbnRUcmFja2VyKTtcblxuICAgIGxldCBuZXR3b3JrQ29udHJvbGxlcnMgPSBbbGV2ZWxDb250cm9sbGVyLCBzdHJlYW1Db250cm9sbGVyXTtcblxuICAgIC8vIG9wdGlvbmFsIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyXG4gICAgLyoqXG4gICAgICogQHZhciB7SUNvcmVDb21wb25lbnQgfCBDb250cm9sbGVyfVxuICAgICAqL1xuICAgIGxldCBDb250cm9sbGVyID0gY29uZmlnLmF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcbiAgICBpZiAoQ29udHJvbGxlcikge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2gobmV3IENvbnRyb2xsZXIodGhpcywgZnJhZ21lbnRUcmFja2VyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7SU5ldHdvcmtDb250cm9sbGVyW119IG5ldHdvcmtDb250cm9sbGVyc1xuICAgICAqL1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzID0gbmV0d29ya0NvbnRyb2xsZXJzO1xuXG4gICAgLyoqXG4gICAgICogQHZhciB7SUNvcmVDb21wb25lbnRbXX1cbiAgICAgKi9cbiAgICBjb25zdCBjb3JlQ29tcG9uZW50cyA9IFtcbiAgICAgIHBsYXlMaXN0TG9hZGVyLFxuICAgICAgZnJhZ21lbnRMb2FkZXIsXG4gICAgICBrZXlMb2FkZXIsXG4gICAgICBhYnJDb250cm9sbGVyLFxuICAgICAgYnVmZmVyQ29udHJvbGxlcixcbiAgICAgIGNhcExldmVsQ29udHJvbGxlcixcbiAgICAgIGZwc0NvbnRyb2xsZXIsXG4gICAgICBpZDNUcmFja0NvbnRyb2xsZXIsXG4gICAgICBmcmFnbWVudFRyYWNrZXJcbiAgICBdO1xuXG4gICAgLy8gb3B0aW9uYWwgYXVkaW8gdHJhY2sgYW5kIHN1YnRpdGxlIGNvbnRyb2xsZXJcbiAgICBDb250cm9sbGVyID0gY29uZmlnLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChDb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKHRoaXMpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge0F1ZGlvVHJhY2tDb250cm9sbGVyfSBhdWRpb1RyYWNrQ29udHJvbGxlclxuICAgICAgICovXG4gICAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgICBjb3JlQ29tcG9uZW50cy5wdXNoKGF1ZGlvVHJhY2tDb250cm9sbGVyKTtcbiAgICB9XG5cbiAgICBDb250cm9sbGVyID0gY29uZmlnLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChDb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKHRoaXMpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge1N1YnRpdGxlVHJhY2tDb250cm9sbGVyfSBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlclxuICAgICAgICovXG4gICAgICB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcik7XG4gICAgfVxuXG4gICAgQ29udHJvbGxlciA9IGNvbmZpZy5lbWVDb250cm9sbGVyO1xuICAgIGlmIChDb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBlbWVDb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIodGhpcyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7RU1FQ29udHJvbGxlcn0gZW1lQ29udHJvbGxlclxuICAgICAgICovXG4gICAgICB0aGlzLmVtZUNvbnRyb2xsZXIgPSBlbWVDb250cm9sbGVyO1xuICAgICAgY29yZUNvbXBvbmVudHMucHVzaChlbWVDb250cm9sbGVyKTtcbiAgICB9XG5cbiAgICAvLyBvcHRpb25hbCBzdWJ0aXRsZSBjb250cm9sbGVyc1xuICAgIENvbnRyb2xsZXIgPSBjb25maWcuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xuICAgIGlmIChDb250cm9sbGVyKSB7XG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChuZXcgQ29udHJvbGxlcih0aGlzLCBmcmFnbWVudFRyYWNrZXIpKTtcbiAgICB9XG4gICAgQ29udHJvbGxlciA9IGNvbmZpZy50aW1lbGluZUNvbnRyb2xsZXI7XG4gICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgIGNvcmVDb21wb25lbnRzLnB1c2gobmV3IENvbnRyb2xsZXIodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0lDb3JlQ29tcG9uZW50W119XG4gICAgICovXG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cyA9IGNvcmVDb21wb25lbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2Ugb2YgdGhlIGluc3RhbmNlXG4gICAqL1xuICBkZXN0cm95ICgpIHtcbiAgICBsb2dnZXIubG9nKCdkZXN0cm95Jyk7XG4gICAgdGhpcy50cmlnZ2VyKEhsc0V2ZW50cy5ERVNUUk9ZSU5HKTtcbiAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cy5jb25jYXQodGhpcy5uZXR3b3JrQ29udHJvbGxlcnMpLmZvckVhY2goY29tcG9uZW50ID0+IHtcbiAgICAgIGNvbXBvbmVudC5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgdGhpcy51cmwgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBhIG1lZGlhIGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYVxuICAgKi9cbiAgYXR0YWNoTWVkaWEgKG1lZGlhKSB7XG4gICAgbG9nZ2VyLmxvZygnYXR0YWNoTWVkaWEnKTtcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgdGhpcy50cmlnZ2VyKEhsc0V2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHsgbWVkaWE6IG1lZGlhIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFjaCBmcm9tIHRoZSBtZWRpYVxuICAgKi9cbiAgZGV0YWNoTWVkaWEgKCkge1xuICAgIGxvZ2dlci5sb2coJ2RldGFjaE1lZGlhJyk7XG4gICAgdGhpcy50cmlnZ2VyKEhsc0V2ZW50cy5NRURJQV9ERVRBQ0hJTkcpO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIFVSTC4gQ2FuIGJlIHJlbGF0aXZlIG9yIGFic29sdXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqL1xuICBsb2FkU291cmNlICh1cmwpIHtcbiAgICB1cmwgPSBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYsIHVybCwgeyBhbHdheXNOb3JtYWxpemU6IHRydWUgfSk7XG4gICAgbG9nZ2VyLmxvZyhgbG9hZFNvdXJjZToke3VybH1gKTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICAvLyB3aGVuIGF0dGFjaGluZyB0byBhIHNvdXJjZSBVUkwsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkXG4gICAgdGhpcy50cmlnZ2VyKEhsc0V2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB7IHVybDogdXJsIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGxvYWRpbmcgZGF0YSBmcm9tIHRoZSBzdHJlYW0gc291cmNlLlxuICAgKiBEZXBlbmRpbmcgb24gZGVmYXVsdCBjb25maWcsIGNsaWVudCBzdGFydHMgbG9hZGluZyBhdXRvbWF0aWNhbGx5IHdoZW4gYSBzb3VyY2UgaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRQb3NpdGlvbiBTZXQgdGhlIHN0YXJ0IHBvc2l0aW9uIHRvIHN0cmVhbSBmcm9tXG4gICAqIEBkZWZhdWx0IC0xIE5vbmUgKGZyb20gZWFybGllc3QgcG9pbnQpXG4gICAqL1xuICBzdGFydExvYWQgKHN0YXJ0UG9zaXRpb24gPSAtMSkge1xuICAgIGxvZ2dlci5sb2coYHN0YXJ0TG9hZCgke3N0YXJ0UG9zaXRpb259KWApO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goY29udHJvbGxlciA9PiB7XG4gICAgICBjb250cm9sbGVyLnN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGxvYWRpbmcgb2YgYW55IHN0cmVhbSBkYXRhLlxuICAgKi9cbiAgc3RvcExvYWQgKCkge1xuICAgIGxvZ2dlci5sb2coJ3N0b3BMb2FkJyk7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChjb250cm9sbGVyID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuc3RvcExvYWQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2FwIHRocm91Z2ggcG9zc2libGUgYXVkaW8gY29kZWNzIGluIHRoZSBzdHJlYW0gKGZvciBleGFtcGxlIHRvIHN3aXRjaCBmcm9tIHN0ZXJlbyB0byA1LjEpXG4gICAqL1xuICBzd2FwQXVkaW9Db2RlYyAoKSB7XG4gICAgbG9nZ2VyLmxvZygnc3dhcEF1ZGlvQ29kZWMnKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuc3dhcEF1ZGlvQ29kZWMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBtZWRpYS1lbGVtZW50IGZhaWxzLCB0aGlzIGFsbG93cyB0byBkZXRhY2ggYW5kIHRoZW4gcmUtYXR0YWNoIGl0XG4gICAqIGFzIG9uZSBjYWxsIChjb252ZW5pZW5jZSBtZXRob2QpLlxuICAgKlxuICAgKiBBdXRvbWF0aWMgcmVjb3Zlcnkgb2YgbWVkaWEtZXJyb3JzIGJ5IHRoaXMgcHJvY2VzcyBpcyBjb25maWd1cmFibGUuXG4gICAqL1xuICByZWNvdmVyTWVkaWFFcnJvciAoKSB7XG4gICAgbG9nZ2VyLmxvZygncmVjb3Zlck1lZGlhRXJyb3InKTtcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICB0aGlzLmF0dGFjaE1lZGlhKG1lZGlhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7UXVhbGl0eUxldmVsW119XG4gICAqL1xuICBnZXQgbGV2ZWxzICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHF1YWxpdHkgbGV2ZWwgY3VycmVudGx5IHBsYXllZFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRMZXZlbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5jdXJyZW50TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggaW1tZWRpYXRlbHkgLlxuICAgKiBUaGlzIHdpbGwgZmx1c2ggdGhlIGN1cnJlbnQgYnVmZmVyIHRvIHJlcGxhY2UgdGhlIHF1YWxpdHkgYXNhcC5cbiAgICogVGhhdCBtZWFucyBwbGF5YmFjayB3aWxsIGludGVycnVwdCBhdCBsZWFzdCBzaG9ydGx5IHRvIHJlLWJ1ZmZlciBhbmQgcmUtc3luYyBldmVudHVhbGx5LlxuICAgKiBAdHlwZSB7bnVtYmVyfSAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgKi9cbiAgc2V0IGN1cnJlbnRMZXZlbCAobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgY3VycmVudExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sb2FkTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuaW1tZWRpYXRlTGV2ZWxTd2l0Y2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRleCBvZiBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkIGFzIHNjaGVkdWxlZCBieSBzdHJlYW0gY29udHJvbGxlci5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBuZXh0TGV2ZWwgKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBxdWFsaXR5IGxldmVsIGluZGV4IGZvciBuZXh0IGxvYWRlZCBkYXRhLlxuICAgKiBUaGlzIHdpbGwgc3dpdGNoIHRoZSB2aWRlbyBxdWFsaXR5IGFzYXAsIHdpdGhvdXQgaW50ZXJydXB0aW5nIHBsYXliYWNrLlxuICAgKiBNYXkgYWJvcnQgY3VycmVudCBsb2FkaW5nIG9mIGRhdGEsIGFuZCBmbHVzaCBwYXJ0cyBvZiBidWZmZXIgKG91dHNpZGUgY3VycmVudGx5IHBsYXllZCBmcmFnbWVudCByZWdpb24pLlxuICAgKiBAdHlwZSB7bnVtYmVyfSAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgKi9cbiAgc2V0IG5leHRMZXZlbCAobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgbmV4dExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIHRoZSBjdXJyZW50bHkgb3IgbGFzdCAob2Ygbm9uZSBpcyBsb2FkZWQgY3VycmVudGx5KSBzZWdtZW50XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbG9hZExldmVsICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEgaW4gYSBjb25zZXJ2YXRpdmUgd2F5LlxuICAgKiBUaGlzIHdpbGwgc3dpdGNoIHRoZSBxdWFsaXR5IHdpdGhvdXQgZmx1c2hpbmcsIGJ1dCBpbnRlcnJ1cHQgY3VycmVudCBsb2FkaW5nLlxuICAgKiBUaHVzIHRoZSBtb21lbnQgd2hlbiB0aGUgcXVhbGl0eSBzd2l0Y2ggd2lsbCBhcHBlYXIgaW4gZWZmZWN0IHdpbGwgb25seSBiZSBhZnRlciB0aGUgYWxyZWFkeSBleGlzdGluZyBidWZmZXIuXG4gICAqIEB0eXBlIHtudW1iZXJ9IG5ld0xldmVsIC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uXG4gICAqL1xuICBzZXQgbG9hZExldmVsIChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBsb2FkTGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbmV4dExvYWRMZXZlbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgb2YgbmV4dCBsb2FkZWQgc2VnbWVudCBpbiBhIGZ1bGx5IFwibm9uLWRlc3RydWN0aXZlXCIgd2F5LlxuICAgKiBTYW1lIGFzIGBsb2FkTGV2ZWxgIGJ1dCB3aWxsIHdhaXQgZm9yIG5leHQgc3dpdGNoICh1bnRpbCBjdXJyZW50IGxvYWRpbmcgaXMgZG9uZSkuXG4gICAqIEB0eXBlIHtudW1iZXJ9IGxldmVsXG4gICAqL1xuICBzZXQgbmV4dExvYWRMZXZlbCAobGV2ZWwpIHtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsID0gbGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIFwiZmlyc3QgbGV2ZWxcIjogbGlrZSBhIGRlZmF1bHQgbGV2ZWwsIGlmIG5vdCBzZXQsXG4gICAqIGZhbGxzIGJhY2sgdG8gaW5kZXggb2YgZmlyc3QgbGV2ZWwgcmVmZXJlbmNlZCBpbiBtYW5pZmVzdFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGZpcnN0TGV2ZWwgKCkge1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBcImZpcnN0LWxldmVsXCIsIHNlZSBnZXR0ZXIuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzZXQgZmlyc3RMZXZlbCAobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgZmlyc3RMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICogaWYgbm90IG92ZXJyaWRlZCBieSB1c2VyLCBmaXJzdCBsZXZlbCBhcHBlYXJpbmcgaW4gbWFuaWZlc3Qgd2lsbCBiZSB1c2VkIGFzIHN0YXJ0IGxldmVsXG4gICAqIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aFxuICAgKiAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc3RhcnRMZXZlbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogc2V0ICBzdGFydCBsZXZlbCAobGV2ZWwgb2YgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIHBsYXllZCBiYWNrKVxuICAgKiBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcbiAgICogaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoXG4gICAqIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgICogQHR5cGUge251bWJlcn0gbmV3TGV2ZWxcbiAgICovXG4gIHNldCBzdGFydExldmVsIChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBzdGFydExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgY29uc3QgaGxzID0gdGhpcztcbiAgICAvLyBpZiBub3QgaW4gYXV0b21hdGljIHN0YXJ0IGxldmVsIGRldGVjdGlvbiwgZW5zdXJlIHN0YXJ0TGV2ZWwgaXMgZ3JlYXRlciB0aGFuIG1pbkF1dG9MZXZlbFxuICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgIG5ld0xldmVsID0gTWF0aC5tYXgobmV3TGV2ZWwsIGhscy5taW5BdXRvTGV2ZWwpO1xuICAgIH1cblxuICAgIGhscy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBhdXRvTGV2ZWxDYXBwaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b0xldmVsQ2FwcGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtIChgQUJSQ29udHJvbGxlcmApXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzZXQgYXV0b0xldmVsQ2FwcGluZyAobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgYXV0b0xldmVsQ2FwcGluZzoke25ld0xldmVsfWApO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnVlIHdoZW4gYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBlbmFibGVkXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGF1dG9MZXZlbEVuYWJsZWQgKCkge1xuICAgIHJldHVybiAodGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPT09IC0xKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMZXZlbCBzZXQgbWFudWFsbHkgKGlmIGFueSlcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtYW51YWxMZXZlbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIG1pbiBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gY29uZmlnLm1pbkF1dG9CaXRyYXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWluQXV0b0xldmVsICgpIHtcbiAgICBsZXQgaGxzID0gdGhpcywgbGV2ZWxzID0gaGxzLmxldmVscywgbWluQXV0b0JpdHJhdGUgPSBobHMuY29uZmlnLm1pbkF1dG9CaXRyYXRlLCBsZW4gPSBsZXZlbHMgPyBsZXZlbHMubGVuZ3RoIDogMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBsZXZlbE5leHRCaXRyYXRlID0gbGV2ZWxzW2ldLnJlYWxCaXRyYXRlID8gTWF0aC5tYXgobGV2ZWxzW2ldLnJlYWxCaXRyYXRlLCBsZXZlbHNbaV0uYml0cmF0ZSkgOiBsZXZlbHNbaV0uYml0cmF0ZTtcbiAgICAgIGlmIChsZXZlbE5leHRCaXRyYXRlID4gbWluQXV0b0JpdHJhdGUpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIG1heCBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gYXV0b0xldmVsQ2FwcGluZ1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1heEF1dG9MZXZlbCAoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcztcbiAgICBjb25zdCBsZXZlbHMgPSBobHMubGV2ZWxzO1xuICAgIGNvbnN0IGF1dG9MZXZlbENhcHBpbmcgPSBobHMuYXV0b0xldmVsQ2FwcGluZztcbiAgICBsZXQgbWF4QXV0b0xldmVsO1xuICAgIGlmIChhdXRvTGV2ZWxDYXBwaW5nID09PSAtMSAmJiBsZXZlbHMgJiYgbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgbWF4QXV0b0xldmVsID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heEF1dG9MZXZlbCA9IGF1dG9MZXZlbENhcHBpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heEF1dG9MZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBuZXh0IGF1dG9tYXRpY2FsbHkgc2VsZWN0ZWQgcXVhbGl0eSBsZXZlbFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG5leHRBdXRvTGV2ZWwgKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXM7XG4gICAgLy8gZW5zdXJlIG5leHQgYXV0byBsZXZlbCBpcyBiZXR3ZWVuICBtaW4gYW5kIG1heCBhdXRvIGxldmVsXG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGhscy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwsIGhscy5taW5BdXRvTGV2ZWwpLCBobHMubWF4QXV0b0xldmVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGlzIHNldHRlciBpcyB1c2VkIHRvIGZvcmNlIG5leHQgYXV0byBsZXZlbC5cbiAgICogdGhpcyBpcyB1c2VmdWwgdG8gZm9yY2UgYSBzd2l0Y2ggZG93biBpbiBhdXRvIG1vZGU6XG4gICAqIGluIGNhc2Ugb2YgbG9hZCBlcnJvciBvbiBsZXZlbCBOLCBobHMuanMgY2FuIHNldCBuZXh0QXV0b0xldmVsIHRvIE4tMSBmb3IgZXhhbXBsZSlcbiAgICogZm9yY2VkIHZhbHVlIGlzIHZhbGlkIGZvciBvbmUgZnJhZ21lbnQuIHVwb24gc3VjY2VzZnVsIGZyYWcgbG9hZGluZyBhdCBmb3JjZWQgbGV2ZWwsXG4gICAqIHRoaXMgdmFsdWUgd2lsbCBiZSByZXNldHRlZCB0byAtMSBieSBBQlIgY29udHJvbGxlci5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNldCBuZXh0QXV0b0xldmVsIChuZXh0TGV2ZWwpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzO1xuICAgIGhscy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwgPSBNYXRoLm1heChobHMubWluQXV0b0xldmVsLCBuZXh0TGV2ZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBdWRpb1RyYWNrW119XG4gICAqL1xuICBnZXQgYXVkaW9UcmFja3MgKCkge1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gYXVkaW9UcmFja0NvbnRyb2xsZXIgPyBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrcyA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIGluZGV4IG9mIHRoZSBzZWxlY3RlZCBhdWRpbyB0cmFjayAoaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHMpXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgYXVkaW9UcmFjayAoKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgOiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZWxlY3RzIGFuIGF1ZGlvIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHNcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNldCBhdWRpb1RyYWNrIChhdWRpb1RyYWNrSWQpIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKGF1ZGlvVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrID0gYXVkaW9UcmFja0lkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U2Vjb25kc31cbiAgICovXG4gIGdldCBsaXZlU3luY1Bvc2l0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmxpdmVTeW5jUG9zaXRpb247XG4gIH1cblxuICAvKipcbiAgICogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0XG4gICAqIEB0eXBlIHtTdWJ0aXRsZVRyYWNrW119XG4gICAqL1xuICBnZXQgc3VidGl0bGVUcmFja3MgKCkge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrcyA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc3VidGl0bGVUcmFjayAoKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgOiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZWxlY3QgYW4gc3VidGl0bGUgdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0c1xuICAgKiBAdHlwZXtudW1iZXJ9XG4gICAqL1xuICBzZXQgc3VidGl0bGVUcmFjayAoc3VidGl0bGVUcmFja0lkKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcikge1xuICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA9IHN1YnRpdGxlVHJhY2tJZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgc3VidGl0bGVEaXNwbGF5ICgpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVEaXNwbGF5IDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlL2Rpc2FibGUgc3VidGl0bGUgZGlzcGxheSByZW5kZXJpbmdcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzZXQgc3VidGl0bGVEaXNwbGF5ICh2YWx1ZSkge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICBpZiAoc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlRGlzcGxheSA9IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgZ2V0TWVkaWFTb3VyY2UgfSBmcm9tICcuL3V0aWxzL21lZGlhc291cmNlLWhlbHBlcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N1cHBvcnRlZCAoKSB7XG4gIGNvbnN0IG1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UoKTtcbiAgY29uc3Qgc291cmNlQnVmZmVyID0gd2luZG93LlNvdXJjZUJ1ZmZlciB8fCB3aW5kb3cuV2ViS2l0U291cmNlQnVmZmVyO1xuICBjb25zdCBpc1R5cGVTdXBwb3J0ZWQgPSBtZWRpYVNvdXJjZSAmJlxuICAgIHR5cGVvZiBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQgPT09ICdmdW5jdGlvbicgJiZcbiAgICBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS40MkUwMUUsbXA0YS40MC4yXCInKTtcblxuICAvLyBpZiBTb3VyY2VCdWZmZXIgaXMgZXhwb3NlZCBlbnN1cmUgaXRzIEFQSSBpcyB2YWxpZFxuICAvLyBzYWZhcmkgYW5kIG9sZCB2ZXJzaW9uIG9mIENocm9tZSBkb2Ugbm90IGV4cG9zZSBTb3VyY2VCdWZmZXIgZ2xvYmFsbHkgc28gY2hlY2tpbmcgU291cmNlQnVmZmVyLnByb3RvdHlwZSBpcyBpbXBvc3NpYmxlXG4gIGNvbnN0IHNvdXJjZUJ1ZmZlclZhbGlkQVBJID0gIXNvdXJjZUJ1ZmZlciB8fFxuICAgIChzb3VyY2VCdWZmZXIucHJvdG90eXBlICYmXG4gICAgICB0eXBlb2Ygc291cmNlQnVmZmVyLnByb3RvdHlwZS5hcHBlbmRCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBzb3VyY2VCdWZmZXIucHJvdG90eXBlLnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJyk7XG4gIHJldHVybiAhIWlzVHlwZVN1cHBvcnRlZCAmJiAhIXNvdXJjZUJ1ZmZlclZhbGlkQVBJO1xufVxuIiwiLypcbiAqIEZyYWdtZW50IExvYWRlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIEZyYWdtZW50TG9hZGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuRlJBR19MT0FESU5HKTtcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGxldCBsb2FkZXJzID0gdGhpcy5sb2FkZXJzO1xuICAgIGZvciAobGV0IGxvYWRlck5hbWUgaW4gbG9hZGVycykge1xuICAgICAgbGV0IGxvYWRlciA9IGxvYWRlcnNbbG9hZGVyTmFtZV07XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubG9hZGVycyA9IHt9O1xuXG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgb25GcmFnTG9hZGluZyAoZGF0YSkge1xuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICB0eXBlID0gZnJhZy50eXBlLFxuICAgICAgbG9hZGVycyA9IHRoaXMubG9hZGVycyxcbiAgICAgIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZyxcbiAgICAgIEZyYWdtZW50SUxvYWRlciA9IGNvbmZpZy5mTG9hZGVyLFxuICAgICAgRGVmYXVsdElMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuXG4gICAgLy8gcmVzZXQgZnJhZ21lbnQgc3RhdGVcbiAgICBmcmFnLmxvYWRlZCA9IDA7XG5cbiAgICBsZXQgbG9hZGVyID0gbG9hZGVyc1t0eXBlXTtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2dnZXIud2FybihgYWJvcnQgcHJldmlvdXMgZnJhZ21lbnQgbG9hZGVyIGZvciB0eXBlOiAke3R5cGV9YCk7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICBsb2FkZXIgPSBsb2FkZXJzW3R5cGVdID0gZnJhZy5sb2FkZXIgPVxuICAgICAgY29uZmlnLmZMb2FkZXIgPyBuZXcgRnJhZ21lbnRJTG9hZGVyKGNvbmZpZykgOiBuZXcgRGVmYXVsdElMb2FkZXIoY29uZmlnKTtcblxuICAgIGxldCBsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcztcblxuICAgIGxvYWRlckNvbnRleHQgPSB7IHVybDogZnJhZy51cmwsIGZyYWc6IGZyYWcsIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJywgcHJvZ3Jlc3NEYXRhOiBmYWxzZSB9O1xuXG4gICAgbGV0IHN0YXJ0ID0gZnJhZy5ieXRlUmFuZ2VTdGFydE9mZnNldCxcbiAgICAgIGVuZCA9IGZyYWcuYnl0ZVJhbmdlRW5kT2Zmc2V0O1xuXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShzdGFydCkgJiYgTnVtYmVyLmlzRmluaXRlKGVuZCkpIHtcbiAgICAgIGxvYWRlckNvbnRleHQucmFuZ2VTdGFydCA9IHN0YXJ0O1xuICAgICAgbG9hZGVyQ29udGV4dC5yYW5nZUVuZCA9IGVuZDtcbiAgICB9XG5cbiAgICBsb2FkZXJDb25maWcgPSB7XG4gICAgICB0aW1lb3V0OiBjb25maWcuZnJhZ0xvYWRpbmdUaW1lT3V0LFxuICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgbWF4UmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0XG4gICAgfTtcblxuICAgIGxvYWRlckNhbGxiYWNrcyA9IHtcbiAgICAgIG9uU3VjY2VzczogdGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSxcbiAgICAgIG9uVGltZW91dDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLFxuICAgICAgb25Qcm9ncmVzczogdGhpcy5sb2FkcHJvZ3Jlc3MuYmluZCh0aGlzKVxuICAgIH07XG5cbiAgICBsb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gIH1cblxuICBsb2Fkc3VjY2VzcyAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyA9IG51bGwpIHtcbiAgICBsZXQgcGF5bG9hZCA9IHJlc3BvbnNlLmRhdGEsIGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgLy8gZGV0YWNoIGZyYWdtZW50IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcbiAgICBmcmFnLmxvYWRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BREVELCB7IHBheWxvYWQ6IHBheWxvYWQsIGZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0cywgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzIH0pO1xuICB9XG5cbiAgbG9hZGVycm9yIChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMgPSBudWxsKSB7XG4gICAgY29uc3QgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICBsZXQgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogY29udGV4dC5mcmFnLCByZXNwb25zZTogcmVzcG9uc2UsIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyB9KTtcbiAgfVxuXG4gIGxvYWR0aW1lb3V0IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMgPSBudWxsKSB7XG4gICAgY29uc3QgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICBsZXQgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVCwgZmF0YWw6IGZhbHNlLCBmcmFnOiBjb250ZXh0LmZyYWcsIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyB9KTtcbiAgfVxuXG4gIC8vIGRhdGEgd2lsbCBiZSB1c2VkIGZvciBwcm9ncmVzc2l2ZSBwYXJzaW5nXG4gIGxvYWRwcm9ncmVzcyAoc3RhdHMsIGNvbnRleHQsIGRhdGEsIG5ldHdvcmtEZXRhaWxzID0gbnVsbCkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBsZXQgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICBmcmFnLmxvYWRlZCA9IHN0YXRzLmxvYWRlZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRF9QUk9HUkVTUywgeyBmcmFnOiBmcmFnLCBzdGF0czogc3RhdHMsIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGcmFnbWVudExvYWRlcjtcbiIsIlxuaW1wb3J0ICogYXMgVVJMVG9vbGtpdCBmcm9tICd1cmwtdG9vbGtpdCc7XG5cbmltcG9ydCBMZXZlbEtleSBmcm9tICcuL2xldmVsLWtleSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZyYWdtZW50IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgdGhpcy5fYnl0ZVJhbmdlID0gbnVsbDtcbiAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IG51bGw7XG4gICAgdGhpcy50YWdMaXN0ID0gW107XG4gICAgdGhpcy5wcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgIHRoaXMucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcblxuICAgIC8vIEhvbGRzIHRoZSB0eXBlcyBvZiBkYXRhIHRoaXMgZnJhZ21lbnQgc3VwcG9ydHNcbiAgICB0aGlzLl9lbGVtZW50YXJ5U3RyZWFtcyA9IHtcbiAgICAgIFtGcmFnbWVudC5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dOiBmYWxzZSxcbiAgICAgIFtGcmFnbWVudC5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9dOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogYHR5cGVgIHByb3BlcnR5IGZvciB0aGlzLl9lbGVtZW50YXJ5U3RyZWFtc1xuICAgKlxuICAgKiBAZW51bVxuICAgKi9cbiAgc3RhdGljIGdldCBFbGVtZW50YXJ5U3RyZWFtVHlwZXMgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBBVURJTzogJ2F1ZGlvJyxcbiAgICAgIFZJREVPOiAndmlkZW8nXG4gICAgfTtcbiAgfVxuXG4gIGdldCB1cmwgKCkge1xuICAgIGlmICghdGhpcy5fdXJsICYmIHRoaXMucmVsdXJsKSB7XG4gICAgICB0aGlzLl91cmwgPSBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVVUkwodGhpcy5iYXNldXJsLCB0aGlzLnJlbHVybCwgeyBhbHdheXNOb3JtYWxpemU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgfVxuXG4gIHNldCB1cmwgKHZhbHVlKSB7XG4gICAgdGhpcy5fdXJsID0gdmFsdWU7XG4gIH1cblxuICBnZXQgYnl0ZVJhbmdlICgpIHtcbiAgICBpZiAoIXRoaXMuX2J5dGVSYW5nZSAmJiAhdGhpcy5yYXdCeXRlUmFuZ2UpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYnl0ZVJhbmdlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYnl0ZVJhbmdlO1xuICAgIH1cblxuICAgIGxldCBieXRlUmFuZ2UgPSBbXTtcbiAgICBpZiAodGhpcy5yYXdCeXRlUmFuZ2UpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMucmF3Qnl0ZVJhbmdlLnNwbGl0KCdAJywgMik7XG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0ID0gdGhpcy5sYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0O1xuICAgICAgICBieXRlUmFuZ2VbMF0gPSBsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0IHx8IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBieXRlUmFuZ2VbMF0gPSBwYXJzZUludChwYXJhbXNbMV0pO1xuICAgICAgfVxuICAgICAgYnl0ZVJhbmdlWzFdID0gcGFyc2VJbnQocGFyYW1zWzBdKSArIGJ5dGVSYW5nZVswXTtcbiAgICAgIHRoaXMuX2J5dGVSYW5nZSA9IGJ5dGVSYW5nZTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVSYW5nZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJ5dGVSYW5nZVN0YXJ0T2Zmc2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMF07XG4gIH1cblxuICBnZXQgYnl0ZVJhbmdlRW5kT2Zmc2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMV07XG4gIH1cblxuICBnZXQgZGVjcnlwdGRhdGEgKCkge1xuICAgIGlmICghdGhpcy5fZGVjcnlwdGRhdGEpIHtcbiAgICAgIHRoaXMuX2RlY3J5cHRkYXRhID0gdGhpcy5mcmFnbWVudERlY3J5cHRkYXRhRnJvbUxldmVsa2V5KHRoaXMubGV2ZWxrZXksIHRoaXMuc24pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9kZWNyeXB0ZGF0YTtcbiAgfVxuXG4gIGdldCBlbmRQcm9ncmFtRGF0ZVRpbWUgKCkge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHRoaXMucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGR1cmF0aW9uID0gIU51bWJlci5pc0Zpbml0ZSh0aGlzLmR1cmF0aW9uKSA/IDAgOiB0aGlzLmR1cmF0aW9uO1xuXG4gICAgcmV0dXJuIHRoaXMucHJvZ3JhbURhdGVUaW1lICsgKGR1cmF0aW9uICogMTAwMCk7XG4gIH1cblxuICBnZXQgZW5jcnlwdGVkICgpIHtcbiAgICByZXR1cm4gISEoKHRoaXMuZGVjcnlwdGRhdGEgJiYgdGhpcy5kZWNyeXB0ZGF0YS51cmkgIT09IG51bGwpICYmICh0aGlzLmRlY3J5cHRkYXRhLmtleSA9PT0gbnVsbCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudGFyeVN0cmVhbVR5cGV9IHR5cGVcbiAgICovXG4gIGFkZEVsZW1lbnRhcnlTdHJlYW0gKHR5cGUpIHtcbiAgICB0aGlzLl9lbGVtZW50YXJ5U3RyZWFtc1t0eXBlXSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50YXJ5U3RyZWFtVHlwZX0gdHlwZVxuICAgKi9cbiAgaGFzRWxlbWVudGFyeVN0cmVhbSAodHlwZSkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50YXJ5U3RyZWFtc1t0eXBlXSA9PT0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IG1ldGhvZCBmb3IgcGFyc2VMZXZlbFBsYXlsaXN0IHRvIGNyZWF0ZSBhbiBpbml0aWFsaXphdGlvbiB2ZWN0b3IgZm9yIGEgZ2l2ZW4gc2VnbWVudFxuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICovXG4gIGNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yIChzZWdtZW50TnVtYmVyKSB7XG4gICAgbGV0IHVpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KDE2KTtcblxuICAgIGZvciAobGV0IGkgPSAxMjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHVpbnQ4Vmlld1tpXSA9IChzZWdtZW50TnVtYmVyID4+IDggKiAoMTUgLSBpKSkgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiB1aW50OFZpZXc7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBtZXRob2QgZm9yIHBhcnNlTGV2ZWxQbGF5bGlzdCB0byBnZXQgYSBmcmFnbWVudCdzIGRlY3J5cHRpb24gZGF0YSBmcm9tIHRoZSBjdXJyZW50bHkgcGFyc2VkIGVuY3J5cHRpb24ga2V5IGRhdGFcbiAgICogQHBhcmFtIGxldmVsa2V5IC0gYSBwbGF5bGlzdCdzIGVuY3J5cHRpb24gaW5mb1xuICAgKiBAcGFyYW0gc2VnbWVudE51bWJlciAtIHRoZSBmcmFnbWVudCdzIHNlZ21lbnQgbnVtYmVyXG4gICAqIEByZXR1cm5zIHsqfSAtIGFuIG9iamVjdCB0byBiZSBhcHBsaWVkIGFzIGEgZnJhZ21lbnQncyBkZWNyeXB0ZGF0YVxuICAgKi9cbiAgZnJhZ21lbnREZWNyeXB0ZGF0YUZyb21MZXZlbGtleSAobGV2ZWxrZXksIHNlZ21lbnROdW1iZXIpIHtcbiAgICBsZXQgZGVjcnlwdGRhdGEgPSBsZXZlbGtleTtcblxuICAgIGlmIChsZXZlbGtleSAmJiBsZXZlbGtleS5tZXRob2QgJiYgbGV2ZWxrZXkudXJpICYmICFsZXZlbGtleS5pdikge1xuICAgICAgZGVjcnlwdGRhdGEgPSBuZXcgTGV2ZWxLZXkoKTtcbiAgICAgIGRlY3J5cHRkYXRhLm1ldGhvZCA9IGxldmVsa2V5Lm1ldGhvZDtcbiAgICAgIGRlY3J5cHRkYXRhLmJhc2V1cmkgPSBsZXZlbGtleS5iYXNldXJpO1xuICAgICAgZGVjcnlwdGRhdGEucmVsdXJpID0gbGV2ZWxrZXkucmVsdXJpO1xuICAgICAgZGVjcnlwdGRhdGEuaXYgPSB0aGlzLmNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNlZ21lbnROdW1iZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNyeXB0ZGF0YTtcbiAgfVxufVxuIiwiLypcbiAqIERlY3J5cHQga2V5IExvYWRlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIEtleUxvYWRlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsIEV2ZW50LktFWV9MT0FESU5HKTtcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgICB0aGlzLmRlY3J5cHRrZXkgPSBudWxsO1xuICAgIHRoaXMuZGVjcnlwdHVybCA9IG51bGw7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBmb3IgKGxldCBsb2FkZXJOYW1lIGluIHRoaXMubG9hZGVycykge1xuICAgICAgbGV0IGxvYWRlciA9IHRoaXMubG9hZGVyc1tsb2FkZXJOYW1lXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbktleUxvYWRpbmcgKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgIHR5cGUgPSBmcmFnLnR5cGUsXG4gICAgICBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbdHlwZV0sXG4gICAgICBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGEsXG4gICAgICB1cmkgPSBkZWNyeXB0ZGF0YS51cmk7XG4gICAgLy8gaWYgdXJpIGlzIGRpZmZlcmVudCBmcm9tIHByZXZpb3VzIG9uZSBvciBpZiBkZWNyeXB0IGtleSBub3QgcmV0cmlldmVkIHlldFxuICAgIGlmICh1cmkgIT09IHRoaXMuZGVjcnlwdHVybCB8fCB0aGlzLmRlY3J5cHRrZXkgPT09IG51bGwpIHtcbiAgICAgIGxldCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYGFib3J0IHByZXZpb3VzIGtleSBsb2FkZXIgZm9yIHR5cGU6JHt0eXBlfWApO1xuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIGZyYWcubG9hZGVyID0gdGhpcy5sb2FkZXJzW3R5cGVdID0gbmV3IGNvbmZpZy5sb2FkZXIoY29uZmlnKTtcbiAgICAgIHRoaXMuZGVjcnlwdHVybCA9IHVyaTtcbiAgICAgIHRoaXMuZGVjcnlwdGtleSA9IG51bGw7XG5cbiAgICAgIGxldCBsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcztcbiAgICAgIGxvYWRlckNvbnRleHQgPSB7IHVybDogdXJpLCBmcmFnOiBmcmFnLCByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicgfTtcbiAgICAgIC8vIG1heFJldHJ5IGlzIDAgc28gdGhhdCBpbnN0ZWFkIG9mIHJldHJ5aW5nIHRoZSBzYW1lIGtleSBvbiB0aGUgc2FtZSB2YXJpYW50IG11bHRpcGxlIHRpbWVzLFxuICAgICAgLy8ga2V5LWxvYWRlciB3aWxsIHRyaWdnZXIgYW4gZXJyb3IgYW5kIHJlbHkgb24gc3RyZWFtLWNvbnRyb2xsZXIgdG8gaGFuZGxlIHJldHJ5IGxvZ2ljLlxuICAgICAgLy8gdGhpcyB3aWxsIGFsc28gYWxpZ24gcmV0cnkgbG9naWMgd2l0aCBmcmFnbWVudC1sb2FkZXJcbiAgICAgIGxvYWRlckNvbmZpZyA9IHsgdGltZW91dDogY29uZmlnLmZyYWdMb2FkaW5nVGltZU91dCwgbWF4UmV0cnk6IDAsIHJldHJ5RGVsYXk6IGNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksIG1heFJldHJ5RGVsYXk6IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCB9O1xuICAgICAgbG9hZGVyQ2FsbGJhY2tzID0geyBvblN1Y2Nlc3M6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSwgb25FcnJvcjogdGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSwgb25UaW1lb3V0OiB0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcykgfTtcbiAgICAgIGZyYWcubG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kZWNyeXB0a2V5KSB7XG4gICAgICAvLyB3ZSBhbHJlYWR5IGxvYWRlZCB0aGlzIGtleSwgcmV0dXJuIGl0XG4gICAgICBkZWNyeXB0ZGF0YS5rZXkgPSB0aGlzLmRlY3J5cHRrZXk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FERUQsIHsgZnJhZzogZnJhZyB9KTtcbiAgICB9XG4gIH1cblxuICBsb2Fkc3VjY2VzcyAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0KSB7XG4gICAgbGV0IGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgdGhpcy5kZWNyeXB0a2V5ID0gZnJhZy5kZWNyeXB0ZGF0YS5rZXkgPSBuZXcgVWludDhBcnJheShyZXNwb25zZS5kYXRhKTtcbiAgICAvLyBkZXRhY2ggZnJhZ21lbnQgbG9hZGVyIG9uIGxvYWQgc3VjY2Vzc1xuICAgIGZyYWcubG9hZGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubG9hZGVyc1tmcmFnLnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuS0VZX0xPQURFRCwgeyBmcmFnOiBmcmFnIH0pO1xuICB9XG5cbiAgbG9hZGVycm9yIChyZXNwb25zZSwgY29udGV4dCkge1xuICAgIGxldCBmcmFnID0gY29udGV4dC5mcmFnLFxuICAgICAgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgZmF0YWw6IGZhbHNlLCBmcmFnOiBmcmFnLCByZXNwb25zZTogcmVzcG9uc2UgfSk7XG4gIH1cblxuICBsb2FkdGltZW91dCAoc3RhdHMsIGNvbnRleHQpIHtcbiAgICBsZXQgZnJhZyA9IGNvbnRleHQuZnJhZyxcbiAgICAgIGxvYWRlciA9IGZyYWcubG9hZGVyO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVCwgZmF0YWw6IGZhbHNlLCBmcmFnOiBmcmFnIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEtleUxvYWRlcjtcbiIsImltcG9ydCAqIGFzIFVSTFRvb2xraXQgZnJvbSAndXJsLXRvb2xraXQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZXZlbEtleSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLm1ldGhvZCA9IG51bGw7XG4gICAgdGhpcy5rZXkgPSBudWxsO1xuICAgIHRoaXMuaXYgPSBudWxsO1xuICAgIHRoaXMuX3VyaSA9IG51bGw7XG4gIH1cblxuICBnZXQgdXJpICgpIHtcbiAgICBpZiAoIXRoaXMuX3VyaSAmJiB0aGlzLnJlbHVyaSkge1xuICAgICAgdGhpcy5fdXJpID0gVVJMVG9vbGtpdC5idWlsZEFic29sdXRlVVJMKHRoaXMuYmFzZXVyaSwgdGhpcy5yZWx1cmksIHsgYWx3YXlzTm9ybWFsaXplOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl91cmk7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIExldmVsIHtcbiAgY29uc3RydWN0b3IgKGJhc2VVcmwpIHtcbiAgICAvLyBQbGVhc2Uga2VlcCBwcm9wZXJ0aWVzIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgIHRoaXMuZW5kQ0MgPSAwO1xuICAgIHRoaXMuZW5kU04gPSAwO1xuICAgIHRoaXMuZnJhZ21lbnRzID0gW107XG4gICAgdGhpcy5pbml0U2VnbWVudCA9IG51bGw7XG4gICAgdGhpcy5saXZlID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRTaWR4UmFuZ2VzID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydENDID0gMDtcbiAgICB0aGlzLnN0YXJ0U04gPSAwO1xuICAgIHRoaXMuc3RhcnRUaW1lT2Zmc2V0ID0gbnVsbDtcbiAgICB0aGlzLnRhcmdldGR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnRvdGFsZHVyYXRpb24gPSAwO1xuICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgdGhpcy51cmwgPSBiYXNlVXJsO1xuICAgIHRoaXMudmVyc2lvbiA9IG51bGw7XG4gIH1cblxuICBnZXQgaGFzUHJvZ3JhbURhdGVUaW1lICgpIHtcbiAgICByZXR1cm4gISEodGhpcy5mcmFnbWVudHNbMF0gJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMuZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZSkpO1xuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBVUkxUb29sa2l0IGZyb20gJ3VybC10b29sa2l0JztcblxuaW1wb3J0IEZyYWdtZW50IGZyb20gJy4vZnJhZ21lbnQnO1xuaW1wb3J0IExldmVsIGZyb20gJy4vbGV2ZWwnO1xuaW1wb3J0IExldmVsS2V5IGZyb20gJy4vbGV2ZWwta2V5JztcblxuaW1wb3J0IEF0dHJMaXN0IGZyb20gJy4uL3V0aWxzL2F0dHItbGlzdCc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgaXNDb2RlY1R5cGUgfSBmcm9tICcuLi91dGlscy9jb2RlY3MnO1xuXG4vKipcbiAqIE0zVTggcGFyc2VyXG4gKiBAbW9kdWxlXG4gKi9cblxuLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20gaXMgeW91ciBmcmllbmRcbmNvbnN0IE1BU1RFUl9QTEFZTElTVF9SRUdFWCA9IC8jRVhULVgtU1RSRUFNLUlORjooW15cXG5cXHJdKilbXFxyXFxuXSsoW15cXHJcXG5dKykvZztcbmNvbnN0IE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCA9IC8jRVhULVgtTUVESUE6KC4qKS9nO1xuXG5jb25zdCBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNUID0gbmV3IFJlZ0V4cChbXG4gIC8jRVhUSU5GOlxccyooXFxkKig/OlxcLlxcZCspPykoPzosKC4qKVxccyspPy8uc291cmNlLCAvLyBkdXJhdGlvbiAoI0VYVElORjo8ZHVyYXRpb24+LDx0aXRsZT4pLCBncm91cCAxID0+IGR1cmF0aW9uLCBncm91cCAyID0+IHRpdGxlXG4gIC98KD8hIykoW1xcUysgP10rKS8uc291cmNlLCAvLyBzZWdtZW50IFVSSSwgZ3JvdXAgMyA9PiB0aGUgVVJJIChub3RlIG5ld2xpbmUgaXMgbm90IGVhdGVuKVxuICAvfCNFWFQtWC1CWVRFUkFOR0U6KiguKykvLnNvdXJjZSwgLy8gbmV4dCBzZWdtZW50J3MgYnl0ZXJhbmdlLCBncm91cCA0ID0+IHJhbmdlIHNwZWMgKHhAeSlcbiAgL3wjRVhULVgtUFJPR1JBTS1EQVRFLVRJTUU6KC4rKS8uc291cmNlLCAvLyBuZXh0IHNlZ21lbnQncyBwcm9ncmFtIGRhdGUvdGltZSBncm91cCA1ID0+IHRoZSBkYXRldGltZSBzcGVjXG4gIC98Iy4qLy5zb3VyY2UgLy8gQWxsIG90aGVyIG5vbi1zZWdtZW50IG9yaWVudGVkIHRhZ3Mgd2lsbCBtYXRjaCB3aXRoIGFsbCBncm91cHMgZW1wdHlcbl0uam9pbignJyksICdnJyk7XG5cbmNvbnN0IExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cgPSAvKD86KD86IyhFWFRNM1UpKXwoPzojRVhULVgtKFBMQVlMSVNULVRZUEUpOiguKykpfCg/OiNFWFQtWC0oTUVESUEtU0VRVUVOQ0UpOiAqKFxcZCspKXwoPzojRVhULVgtKFRBUkdFVERVUkFUSU9OKTogKihcXGQrKSl8KD86I0VYVC1YLShLRVkpOiguKykpfCg/OiNFWFQtWC0oU1RBUlQpOiguKykpfCg/OiNFWFQtWC0oRU5ETElTVCkpfCg/OiNFWFQtWC0oRElTQ09OVElOVUlUWS1TRVEpVUVOQ0U6KFxcZCspKXwoPzojRVhULVgtKERJUylDT05USU5VSVRZKSl8KD86I0VYVC1YLShWRVJTSU9OKTooXFxkKykpfCg/OiNFWFQtWC0oTUFQKTooLispKXwoPzooIykoW146XSopOiguKikpfCg/OigjKSguKikpKD86LiopXFxyP1xcbj8vO1xuXG5jb25zdCBNUDRfUkVHRVhfU1VGRklYID0gL1xcLihtcDR8bTRzfG00dnxtNGEpJC9pO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNM1U4UGFyc2VyIHtcbiAgc3RhdGljIGZpbmRHcm91cCAoZ3JvdXBzLCBtZWRpYUdyb3VwSWQpIHtcbiAgICBpZiAoIWdyb3Vwcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IG1hdGNoaW5nR3JvdXAgPSBudWxsO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgaWYgKGdyb3VwLmlkID09PSBtZWRpYUdyb3VwSWQpIHtcbiAgICAgICAgbWF0Y2hpbmdHcm91cCA9IGdyb3VwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGluZ0dyb3VwO1xuICB9XG5cbiAgc3RhdGljIGNvbnZlcnRBVkMxVG9BVkNPVEkgKGNvZGVjKSB7XG4gICAgbGV0IHJlc3VsdCwgYXZjZGF0YSA9IGNvZGVjLnNwbGl0KCcuJyk7XG4gICAgaWYgKGF2Y2RhdGEubGVuZ3RoID4gMikge1xuICAgICAgcmVzdWx0ID0gYXZjZGF0YS5zaGlmdCgpICsgJy4nO1xuICAgICAgcmVzdWx0ICs9IHBhcnNlSW50KGF2Y2RhdGEuc2hpZnQoKSkudG9TdHJpbmcoMTYpO1xuICAgICAgcmVzdWx0ICs9ICgnMDAwJyArIHBhcnNlSW50KGF2Y2RhdGEuc2hpZnQoKSkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBjb2RlYztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHN0YXRpYyByZXNvbHZlICh1cmwsIGJhc2VVcmwpIHtcbiAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZEFic29sdXRlVVJMKGJhc2VVcmwsIHVybCwgeyBhbHdheXNOb3JtYWxpemU6IHRydWUgfSk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VNYXN0ZXJQbGF5bGlzdCAoc3RyaW5nLCBiYXNldXJsKSB7XG4gICAgbGV0IGxldmVscyA9IFtdLCByZXN1bHQ7XG4gICAgTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG5cbiAgICBmdW5jdGlvbiBzZXRDb2RlY3MgKGNvZGVjcywgbGV2ZWwpIHtcbiAgICAgIFsndmlkZW8nLCAnYXVkaW8nXS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0gY29kZWNzLmZpbHRlcigoY29kZWMpID0+IGlzQ29kZWNUeXBlKGNvZGVjLCB0eXBlKSk7XG4gICAgICAgIGlmIChmaWx0ZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBwcmVmZXJyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoKGNvZGVjKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY29kZWMubGFzdEluZGV4T2YoJ2F2YzEnLCAwKSA9PT0gMCB8fCBjb2RlYy5sYXN0SW5kZXhPZignbXA0YScsIDApID09PSAwO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxldmVsW2Ake3R5cGV9Q29kZWNgXSA9IHByZWZlcnJlZC5sZW5ndGggPiAwID8gcHJlZmVycmVkWzBdIDogZmlsdGVyZWRbMF07XG5cbiAgICAgICAgICAvLyByZW1vdmUgZnJvbSBsaXN0XG4gICAgICAgICAgY29kZWNzID0gY29kZWNzLmZpbHRlcigoY29kZWMpID0+IGZpbHRlcmVkLmluZGV4T2YoY29kZWMpID09PSAtMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBsZXZlbC51bmtub3duQ29kZWNzID0gY29kZWNzO1xuICAgIH1cblxuICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT0gbnVsbCkge1xuICAgICAgY29uc3QgbGV2ZWwgPSB7fTtcblxuICAgICAgY29uc3QgYXR0cnMgPSBsZXZlbC5hdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0pO1xuICAgICAgbGV2ZWwudXJsID0gTTNVOFBhcnNlci5yZXNvbHZlKHJlc3VsdFsyXSwgYmFzZXVybCk7XG5cbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSBhdHRycy5kZWNpbWFsUmVzb2x1dGlvbignUkVTT0xVVElPTicpO1xuICAgICAgaWYgKHJlc29sdXRpb24pIHtcbiAgICAgICAgbGV2ZWwud2lkdGggPSByZXNvbHV0aW9uLndpZHRoO1xuICAgICAgICBsZXZlbC5oZWlnaHQgPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGxldmVsLmJpdHJhdGUgPSBhdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKSB8fCBhdHRycy5kZWNpbWFsSW50ZWdlcignQkFORFdJRFRIJyk7XG4gICAgICBsZXZlbC5uYW1lID0gYXR0cnMuTkFNRTtcblxuICAgICAgc2V0Q29kZWNzKFtdLmNvbmNhdCgoYXR0cnMuQ09ERUNTIHx8ICcnKS5zcGxpdCgvWyAsXSsvKSksIGxldmVsKTtcblxuICAgICAgaWYgKGxldmVsLnZpZGVvQ29kZWMgJiYgbGV2ZWwudmlkZW9Db2RlYy5pbmRleE9mKCdhdmMxJykgIT09IC0xKSB7XG4gICAgICAgIGxldmVsLnZpZGVvQ29kZWMgPSBNM1U4UGFyc2VyLmNvbnZlcnRBVkMxVG9BVkNPVEkobGV2ZWwudmlkZW9Db2RlYyk7XG4gICAgICB9XG5cbiAgICAgIGxldmVscy5wdXNoKGxldmVsKTtcbiAgICB9XG4gICAgcmV0dXJuIGxldmVscztcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEgKHN0cmluZywgYmFzZXVybCwgdHlwZSwgYXVkaW9Hcm91cHMgPSBbXSkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IG1lZGlhcyA9IFtdO1xuICAgIGxldCBpZCA9IDA7XG4gICAgTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVguZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgbWVkaWEgPSB7fTtcbiAgICAgIGNvbnN0IGF0dHJzID0gbmV3IEF0dHJMaXN0KHJlc3VsdFsxXSk7XG4gICAgICBpZiAoYXR0cnMuVFlQRSA9PT0gdHlwZSkge1xuICAgICAgICBtZWRpYS5ncm91cElkID0gYXR0cnNbJ0dST1VQLUlEJ107XG4gICAgICAgIG1lZGlhLm5hbWUgPSBhdHRycy5OQU1FO1xuICAgICAgICBtZWRpYS50eXBlID0gdHlwZTtcbiAgICAgICAgbWVkaWEuZGVmYXVsdCA9IChhdHRycy5ERUZBVUxUID09PSAnWUVTJyk7XG4gICAgICAgIG1lZGlhLmF1dG9zZWxlY3QgPSAoYXR0cnMuQVVUT1NFTEVDVCA9PT0gJ1lFUycpO1xuICAgICAgICBtZWRpYS5mb3JjZWQgPSAoYXR0cnMuRk9SQ0VEID09PSAnWUVTJyk7XG4gICAgICAgIGlmIChhdHRycy5VUkkpIHtcbiAgICAgICAgICBtZWRpYS51cmwgPSBNM1U4UGFyc2VyLnJlc29sdmUoYXR0cnMuVVJJLCBiYXNldXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lZGlhLmxhbmcgPSBhdHRycy5MQU5HVUFHRTtcbiAgICAgICAgaWYgKCFtZWRpYS5uYW1lKSB7XG4gICAgICAgICAgbWVkaWEubmFtZSA9IG1lZGlhLmxhbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXVkaW9Hcm91cHMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZ3JvdXBDb2RlYyA9IE0zVThQYXJzZXIuZmluZEdyb3VwKGF1ZGlvR3JvdXBzLCBtZWRpYS5ncm91cElkKTtcbiAgICAgICAgICBtZWRpYS5hdWRpb0NvZGVjID0gZ3JvdXBDb2RlYyA/IGdyb3VwQ29kZWMuY29kZWMgOiBhdWRpb0dyb3Vwc1swXS5jb2RlYztcbiAgICAgICAgfVxuICAgICAgICBtZWRpYS5pZCA9IGlkKys7XG4gICAgICAgIG1lZGlhcy5wdXNoKG1lZGlhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lZGlhcztcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZUxldmVsUGxheWxpc3QgKHN0cmluZywgYmFzZXVybCwgaWQsIHR5cGUsIGxldmVsVXJsSWQpIHtcbiAgICBsZXQgY3VycmVudFNOID0gMDtcbiAgICBsZXQgdG90YWxkdXJhdGlvbiA9IDA7XG4gICAgbGV0IGxldmVsID0gbmV3IExldmVsKGJhc2V1cmwpO1xuICAgIGxldCBsZXZlbGtleSA9IG5ldyBMZXZlbEtleSgpO1xuICAgIGxldCBjYyA9IDA7XG4gICAgbGV0IHByZXZGcmFnID0gbnVsbDtcbiAgICBsZXQgZnJhZyA9IG5ldyBGcmFnbWVudCgpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGk7XG5cbiAgICBsZXQgZmlyc3RQZHRJbmRleCA9IG51bGw7XG5cbiAgICBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmxhc3RJbmRleCA9IDA7XG5cbiAgICB3aGlsZSAoKHJlc3VsdCA9IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QuZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSByZXN1bHRbMV07XG4gICAgICBpZiAoZHVyYXRpb24pIHsgLy8gSU5GXG4gICAgICAgIGZyYWcuZHVyYXRpb24gPSBwYXJzZUZsb2F0KGR1cmF0aW9uKTtcbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICBjb25zdCB0aXRsZSA9ICgnICcgKyByZXN1bHRbMl0pLnNsaWNlKDEpO1xuICAgICAgICBmcmFnLnRpdGxlID0gdGl0bGUgfHwgbnVsbDtcbiAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godGl0bGUgPyBbICdJTkYnLCBkdXJhdGlvbiwgdGl0bGUgXSA6IFsgJ0lORicsIGR1cmF0aW9uIF0pO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbM10pIHsgLy8gdXJsXG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZnJhZy5kdXJhdGlvbikpIHtcbiAgICAgICAgICBjb25zdCBzbiA9IGN1cnJlbnRTTisrO1xuICAgICAgICAgIGZyYWcudHlwZSA9IHR5cGU7XG4gICAgICAgICAgZnJhZy5zdGFydCA9IHRvdGFsZHVyYXRpb247XG4gICAgICAgICAgZnJhZy5sZXZlbGtleSA9IGxldmVsa2V5O1xuICAgICAgICAgIGZyYWcuc24gPSBzbjtcbiAgICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgICAgZnJhZy5jYyA9IGNjO1xuICAgICAgICAgIGZyYWcudXJsSWQgPSBsZXZlbFVybElkO1xuICAgICAgICAgIGZyYWcuYmFzZXVybCA9IGJhc2V1cmw7XG4gICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgIGZyYWcucmVsdXJsID0gKCcgJyArIHJlc3VsdFszXSkuc2xpY2UoMSk7XG4gICAgICAgICAgYXNzaWduUHJvZ3JhbURhdGVUaW1lKGZyYWcsIHByZXZGcmFnKTtcblxuICAgICAgICAgIGxldmVsLmZyYWdtZW50cy5wdXNoKGZyYWcpO1xuICAgICAgICAgIHByZXZGcmFnID0gZnJhZztcbiAgICAgICAgICB0b3RhbGR1cmF0aW9uICs9IGZyYWcuZHVyYXRpb247XG5cbiAgICAgICAgICBmcmFnID0gbmV3IEZyYWdtZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzRdKSB7IC8vIFgtQllURVJBTkdFXG4gICAgICAgIGZyYWcucmF3Qnl0ZVJhbmdlID0gKCcgJyArIHJlc3VsdFs0XSkuc2xpY2UoMSk7XG4gICAgICAgIGlmIChwcmV2RnJhZykge1xuICAgICAgICAgIGNvbnN0IGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgPSBwcmV2RnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgaWYgKGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQpIHtcbiAgICAgICAgICAgIGZyYWcubGFzdEJ5dGVSYW5nZUVuZE9mZnNldCA9IGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFs1XSkgeyAvLyBQUk9HUkFNLURBVEUtVElNRVxuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gKCcgJyArIHJlc3VsdFs1XSkuc2xpY2UoMSk7XG4gICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnUFJPR1JBTS1EQVRFLVRJTUUnLCBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZV0pO1xuICAgICAgICBpZiAoZmlyc3RQZHRJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgIGZpcnN0UGR0SW5kZXggPSBsZXZlbC5mcmFnbWVudHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRbMF0ubWF0Y2goTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocmVzdWx0W2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgY29uc3QgdmFsdWUxID0gKCcgJyArIHJlc3VsdFtpICsgMV0pLnNsaWNlKDEpO1xuICAgICAgICBjb25zdCB2YWx1ZTIgPSAoJyAnICsgcmVzdWx0W2kgKyAyXSkuc2xpY2UoMSk7XG5cbiAgICAgICAgc3dpdGNoIChyZXN1bHRbaV0pIHtcbiAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godmFsdWUyID8gWyB2YWx1ZTEsIHZhbHVlMiBdIDogWyB2YWx1ZTEgXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1BMQVlMSVNULVRZUEUnOlxuICAgICAgICAgIGxldmVsLnR5cGUgPSB2YWx1ZTEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTUVESUEtU0VRVUVOQ0UnOlxuICAgICAgICAgIGN1cnJlbnRTTiA9IGxldmVsLnN0YXJ0U04gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdUQVJHRVREVVJBVElPTic6XG4gICAgICAgICAgbGV2ZWwudGFyZ2V0ZHVyYXRpb24gPSBwYXJzZUZsb2F0KHZhbHVlMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1ZFUlNJT04nOlxuICAgICAgICAgIGxldmVsLnZlcnNpb24gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFWFRNM1UnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFTkRMSVNUJzpcbiAgICAgICAgICBsZXZlbC5saXZlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0RJUyc6XG4gICAgICAgICAgY2MrKztcbiAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0RJUyddKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRElTQ09OVElOVUlUWS1TRVEnOlxuICAgICAgICAgIGNjID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnS0VZJzpcbiAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGFudG9zLWh0dHAtbGl2ZS1zdHJlYW1pbmctMDgjc2VjdGlvbi0zLjQuNFxuICAgICAgICAgIHZhciBkZWNyeXB0cGFyYW1zID0gdmFsdWUxO1xuICAgICAgICAgIHZhciBrZXlBdHRycyA9IG5ldyBBdHRyTGlzdChkZWNyeXB0cGFyYW1zKTtcbiAgICAgICAgICB2YXIgZGVjcnlwdG1ldGhvZCA9IGtleUF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ01FVEhPRCcpLFxuICAgICAgICAgICAgZGVjcnlwdHVyaSA9IGtleUF0dHJzLlVSSSxcbiAgICAgICAgICAgIGRlY3J5cHRpdiA9IGtleUF0dHJzLmhleGFkZWNpbWFsSW50ZWdlcignSVYnKTtcbiAgICAgICAgICBpZiAoZGVjcnlwdG1ldGhvZCkge1xuICAgICAgICAgICAgbGV2ZWxrZXkgPSBuZXcgTGV2ZWxLZXkoKTtcbiAgICAgICAgICAgIGlmICgoZGVjcnlwdHVyaSkgJiYgKFsnQUVTLTEyOCcsICdTQU1QTEUtQUVTJywgJ1NBTVBMRS1BRVMtQ0VOQyddLmluZGV4T2YoZGVjcnlwdG1ldGhvZCkgPj0gMCkpIHtcbiAgICAgICAgICAgICAgbGV2ZWxrZXkubWV0aG9kID0gZGVjcnlwdG1ldGhvZDtcbiAgICAgICAgICAgICAgLy8gVVJJIHRvIGdldCB0aGUga2V5XG4gICAgICAgICAgICAgIGxldmVsa2V5LmJhc2V1cmkgPSBiYXNldXJsO1xuICAgICAgICAgICAgICBsZXZlbGtleS5yZWx1cmkgPSBkZWNyeXB0dXJpO1xuICAgICAgICAgICAgICBsZXZlbGtleS5rZXkgPSBudWxsO1xuICAgICAgICAgICAgICAvLyBJbml0aWFsaXphdGlvbiBWZWN0b3IgKElWKVxuICAgICAgICAgICAgICBsZXZlbGtleS5pdiA9IGRlY3J5cHRpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1NUQVJUJzpcbiAgICAgICAgICBsZXQgc3RhcnRQYXJhbXMgPSB2YWx1ZTE7XG4gICAgICAgICAgbGV0IHN0YXJ0QXR0cnMgPSBuZXcgQXR0ckxpc3Qoc3RhcnRQYXJhbXMpO1xuICAgICAgICAgIGxldCBzdGFydFRpbWVPZmZzZXQgPSBzdGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdUSU1FLU9GRlNFVCcpO1xuICAgICAgICAgIC8vIFRJTUUtT0ZGU0VUIGNhbiBiZSAwXG4gICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShzdGFydFRpbWVPZmZzZXQpKSB7XG4gICAgICAgICAgICBsZXZlbC5zdGFydFRpbWVPZmZzZXQgPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01BUCc6XG4gICAgICAgICAgbGV0IG1hcEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgZnJhZy5yZWx1cmwgPSBtYXBBdHRycy5VUkk7XG4gICAgICAgICAgZnJhZy5yYXdCeXRlUmFuZ2UgPSBtYXBBdHRycy5CWVRFUkFOR0U7XG4gICAgICAgICAgZnJhZy5iYXNldXJsID0gYmFzZXVybDtcbiAgICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgICAgZnJhZy50eXBlID0gdHlwZTtcbiAgICAgICAgICBmcmFnLnNuID0gJ2luaXRTZWdtZW50JztcbiAgICAgICAgICBsZXZlbC5pbml0U2VnbWVudCA9IGZyYWc7XG4gICAgICAgICAgZnJhZyA9IG5ldyBGcmFnbWVudCgpO1xuICAgICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gbGV2ZWwuaW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxvZ2dlci53YXJuKGBsaW5lIHBhcnNlZCBidXQgbm90IGhhbmRsZWQ6ICR7cmVzdWx0fWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZyYWcgPSBwcmV2RnJhZztcbiAgICAvLyBsb2dnZXIubG9nKCdmb3VuZCAnICsgbGV2ZWwuZnJhZ21lbnRzLmxlbmd0aCArICcgZnJhZ21lbnRzJyk7XG4gICAgaWYgKGZyYWcgJiYgIWZyYWcucmVsdXJsKSB7XG4gICAgICBsZXZlbC5mcmFnbWVudHMucG9wKCk7XG4gICAgICB0b3RhbGR1cmF0aW9uIC09IGZyYWcuZHVyYXRpb247XG4gICAgfVxuICAgIGxldmVsLnRvdGFsZHVyYXRpb24gPSB0b3RhbGR1cmF0aW9uO1xuICAgIGxldmVsLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb24gLyBsZXZlbC5mcmFnbWVudHMubGVuZ3RoO1xuICAgIGxldmVsLmVuZFNOID0gY3VycmVudFNOIC0gMTtcbiAgICBsZXZlbC5zdGFydENDID0gbGV2ZWwuZnJhZ21lbnRzWzBdID8gbGV2ZWwuZnJhZ21lbnRzWzBdLmNjIDogMDtcbiAgICBsZXZlbC5lbmRDQyA9IGNjO1xuXG4gICAgaWYgKCFsZXZlbC5pbml0U2VnbWVudCAmJiBsZXZlbC5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyB0aGlzIGlzIGEgYml0IGx1cmt5IGJ1dCBITFMgcmVhbGx5IGhhcyBubyBvdGhlciB3YXkgdG8gdGVsbCB1c1xuICAgICAgLy8gaWYgdGhlIGZyYWdtZW50cyBhcmUgVFMgb3IgTVA0LCBleGNlcHQgaWYgd2UgZG93bmxvYWQgdGhlbSA6L1xuICAgICAgLy8gYnV0IHRoaXMgaXMgdG8gYmUgYWJsZSB0byBoYW5kbGUgU0lEWC5cbiAgICAgIGlmIChsZXZlbC5mcmFnbWVudHMuZXZlcnkoKGZyYWcpID0+IE1QNF9SRUdFWF9TVUZGSVgudGVzdChmcmFnLnJlbHVybCkpKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdNUDQgZnJhZ21lbnRzIGZvdW5kIGJ1dCBubyBpbml0IHNlZ21lbnQgKHByb2JhYmx5IG5vIE1BUCwgaW5jb21wbGV0ZSBNM1U4KSwgdHJ5aW5nIHRvIGZldGNoIFNJRFgnKTtcblxuICAgICAgICBmcmFnID0gbmV3IEZyYWdtZW50KCk7XG4gICAgICAgIGZyYWcucmVsdXJsID0gbGV2ZWwuZnJhZ21lbnRzWzBdLnJlbHVybDtcbiAgICAgICAgZnJhZy5iYXNldXJsID0gYmFzZXVybDtcbiAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuICAgICAgICBmcmFnLnR5cGUgPSB0eXBlO1xuICAgICAgICBmcmFnLnNuID0gJ2luaXRTZWdtZW50JztcblxuICAgICAgICBsZXZlbC5pbml0U2VnbWVudCA9IGZyYWc7XG4gICAgICAgIGxldmVsLm5lZWRTaWR4UmFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCYWNrZmlsbCBhbnkgbWlzc2luZyBQRFQgdmFsdWVzXG4gICAgICAgXCJJZiB0aGUgZmlyc3QgRVhULVgtUFJPR1JBTS1EQVRFLVRJTUUgdGFnIGluIGEgUGxheWxpc3QgYXBwZWFycyBhZnRlclxuICAgICAgIG9uZSBvciBtb3JlIE1lZGlhIFNlZ21lbnQgVVJJcywgdGhlIGNsaWVudCBTSE9VTEQgZXh0cmFwb2xhdGVcbiAgICAgICBiYWNrd2FyZCBmcm9tIHRoYXQgdGFnICh1c2luZyBFWFRJTkYgZHVyYXRpb25zIGFuZC9vciBtZWRpYVxuICAgICAgIHRpbWVzdGFtcHMpIHRvIGFzc29jaWF0ZSBkYXRlcyB3aXRoIHRob3NlIHNlZ21lbnRzLlwiXG4gICAgICogV2UgaGF2ZSBhbHJlYWR5IGV4dHJhcG9sYXRlZCBmb3J3YXJkLCBidXQgYWxsIGZyYWdtZW50cyB1cCB0byB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgUERUIGRvIG5vdCBoYXZlIHRoZWlyIFBEVHNcbiAgICAgKiBjb21wdXRlZC5cbiAgICAgKi9cbiAgICBpZiAoZmlyc3RQZHRJbmRleCkge1xuICAgICAgYmFja2ZpbGxQcm9ncmFtRGF0ZVRpbWVzKGxldmVsLmZyYWdtZW50cywgZmlyc3RQZHRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhY2tmaWxsUHJvZ3JhbURhdGVUaW1lcyAoZnJhZ21lbnRzLCBzdGFydEluZGV4KSB7XG4gIGxldCBmcmFnUHJldiA9IGZyYWdtZW50c1tzdGFydEluZGV4XTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudHNbaV07XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBmcmFnUHJldi5wcm9ncmFtRGF0ZVRpbWUgLSAoZnJhZy5kdXJhdGlvbiAqIDEwMDApO1xuICAgIGZyYWdQcmV2ID0gZnJhZztcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUgKGZyYWcsIHByZXZGcmFnKSB7XG4gIGlmIChmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSkge1xuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gRGF0ZS5wYXJzZShmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSk7XG4gIH0gZWxzZSBpZiAocHJldkZyYWcgJiYgcHJldkZyYWcucHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBwcmV2RnJhZy5lbmRQcm9ncmFtRGF0ZVRpbWU7XG4gIH1cblxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFnLnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICB9XG59XG4iLCIvKipcbiAqIFBsYXlsaXN0TG9hZGVyIC0gZGVsZWdhdGUgZm9yIG1lZGlhIG1hbmlmZXN0L3BsYXlsaXN0IGxvYWRpbmcgdGFza3MuIFRha2VzIGNhcmUgb2YgcGFyc2luZyBtZWRpYSB0byBpbnRlcm5hbCBkYXRhLW1vZGVscy5cbiAqXG4gKiBPbmNlIGxvYWRlZCwgZGlzcGF0Y2hlcyBldmVudHMgd2l0aCBwYXJzZWQgZGF0YS1tb2RlbHMgb2YgbWFuaWZlc3QvbGV2ZWxzL2F1ZGlvL3N1YnRpdGxlIHRyYWNrcy5cbiAqXG4gKiBVc2VzIGxvYWRlcihzKSBzZXQgaW4gY29uZmlnIHRvIGRvIGFjdHVhbCBpbnRlcm5hbCBsb2FkaW5nIG9mIHJlc291cmNlIHRhc2tzLlxuICpcbiAqIEBtb2R1bGVcbiAqXG4gKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuaW1wb3J0IE1QNERlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvbXA0ZGVtdXhlcic7XG5pbXBvcnQgTTNVOFBhcnNlciBmcm9tICcuL20zdTgtcGFyc2VyJztcblxuY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gd2luZG93O1xuXG4vKipcbiAqIGB0eXBlYCBwcm9wZXJ0eSB2YWx1ZXMgZm9yIHRoaXMgbG9hZGVycycgY29udGV4dCBvYmplY3RcbiAqIEBlbnVtXG4gKlxuICovXG5jb25zdCBDb250ZXh0VHlwZSA9IHtcbiAgTUFOSUZFU1Q6ICdtYW5pZmVzdCcsXG4gIExFVkVMOiAnbGV2ZWwnLFxuICBBVURJT19UUkFDSzogJ2F1ZGlvVHJhY2snLFxuICBTVUJUSVRMRV9UUkFDSzogJ3N1YnRpdGxlVHJhY2snXG59O1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmNvbnN0IExldmVsVHlwZSA9IHtcbiAgTUFJTjogJ21haW4nLFxuICBBVURJTzogJ2F1ZGlvJyxcbiAgU1VCVElUTEU6ICdzdWJ0aXRsZSdcbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFBsYXlsaXN0TG9hZGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RzXG4gICAqIEBwYXJhbSB7SGxzfSBobHNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxuICAgICAgRXZlbnQuTEVWRUxfTE9BRElORyxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX0xPQURJTkcsXG4gICAgICBFdmVudC5TVUJUSVRMRV9UUkFDS19MT0FESU5HKTtcblxuICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICB9XG5cbiAgc3RhdGljIGdldCBDb250ZXh0VHlwZSAoKSB7XG4gICAgcmV0dXJuIENvbnRleHRUeXBlO1xuICB9XG5cbiAgc3RhdGljIGdldCBMZXZlbFR5cGUgKCkge1xuICAgIHJldHVybiBMZXZlbFR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZXh0VHlwZX0gdHlwZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBjYW5IYXZlUXVhbGl0eUxldmVscyAodHlwZSkge1xuICAgIHJldHVybiAodHlwZSAhPT0gQ29udGV4dFR5cGUuQVVESU9fVFJBQ0sgJiZcbiAgICAgIHR5cGUgIT09IENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXAgY29udGV4dC50eXBlIHRvIExldmVsVHlwZVxuICAgKiBAcGFyYW0ge3t0eXBlOiBDb250ZXh0VHlwZX19IGNvbnRleHRcbiAgICogQHJldHVybnMge0xldmVsVHlwZX1cbiAgICovXG4gIHN0YXRpYyBtYXBDb250ZXh0VG9MZXZlbFR5cGUgKGNvbnRleHQpIHtcbiAgICBjb25zdCB7IHR5cGUgfSA9IGNvbnRleHQ7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgcmV0dXJuIExldmVsVHlwZS5BVURJTztcbiAgICBjYXNlIENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgcmV0dXJuIExldmVsVHlwZS5TVUJUSVRMRTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIExldmVsVHlwZS5NQUlOO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXRSZXNwb25zZVVybCAocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgICBsZXQgdXJsID0gcmVzcG9uc2UudXJsO1xuICAgIC8vIHJlc3BvbnNlVVJMIG5vdCBzdXBwb3J0ZWQgb24gc29tZSBicm93c2VycyAoaXQgaXMgdXNlZCB0byBkZXRlY3QgVVJMIHJlZGlyZWN0aW9uKVxuICAgIC8vIGRhdGEtdXJpIG1vZGUgYWxzbyBub3Qgc3VwcG9ydGVkIChidXQgbm8gbmVlZCB0byBkZXRlY3QgcmVkaXJlY3Rpb24pXG4gICAgaWYgKHVybCA9PT0gdW5kZWZpbmVkIHx8IHVybC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICAvLyBmYWxsYmFjayB0byBpbml0aWFsIFVSTFxuICAgICAgdXJsID0gY29udGV4dC51cmw7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBkZWZhdWx0cyBvciBjb25maWd1cmVkIGxvYWRlci10eXBlIG92ZXJsb2FkcyAocExvYWRlciBhbmQgbG9hZGVyIGNvbmZpZyBwYXJhbXMpXG4gICAqIERlZmF1bHQgbG9hZGVyIGlzIFhIUkxvYWRlciAoc2VlIHV0aWxzKVxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJucyB7WEhSTG9hZGVyfSBvciBvdGhlciBjb21wYXRpYmxlIGNvbmZpZ3VyZWQgb3ZlcmxvYWRcbiAgICovXG4gIGNyZWF0ZUludGVybmFsTG9hZGVyIChjb250ZXh0KSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGNvbnN0IFBMb2FkZXIgPSBjb25maWcucExvYWRlcjtcbiAgICBjb25zdCBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGNvbnN0IEludGVybmFsTG9hZGVyID0gUExvYWRlciB8fCBMb2FkZXI7XG5cbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgSW50ZXJuYWxMb2FkZXIoY29uZmlnKTtcblxuICAgIGNvbnRleHQubG9hZGVyID0gbG9hZGVyO1xuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gbG9hZGVyO1xuXG4gICAgcmV0dXJuIGxvYWRlcjtcbiAgfVxuXG4gIGdldEludGVybmFsTG9hZGVyIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdO1xuICB9XG5cbiAgcmVzZXRJbnRlcm5hbExvYWRlciAoY29udGV4dFR5cGUpIHtcbiAgICBpZiAodGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXSkge1xuICAgICAgZGVsZXRlIHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgYGRlc3Ryb3lgIG9uIGFsbCBpbnRlcm5hbCBsb2FkZXIgaW5zdGFuY2VzIG1hcHBlZCAob25lIHBlciBjb250ZXh0IHR5cGUpXG4gICAqL1xuICBkZXN0cm95SW50ZXJuYWxMb2FkZXJzICgpIHtcbiAgICBmb3IgKGxldCBjb250ZXh0VHlwZSBpbiB0aGlzLmxvYWRlcnMpIHtcbiAgICAgIGxldCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dFR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuZGVzdHJveUludGVybmFsTG9hZGVycygpO1xuXG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgb25NYW5pZmVzdExvYWRpbmcgKGRhdGEpIHtcbiAgICB0aGlzLmxvYWQoZGF0YS51cmwsIHsgdHlwZTogQ29udGV4dFR5cGUuTUFOSUZFU1QsIGxldmVsOiAwLCBpZDogbnVsbCB9KTtcbiAgfVxuXG4gIG9uTGV2ZWxMb2FkaW5nIChkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGU6IENvbnRleHRUeXBlLkxFVkVMLCBsZXZlbDogZGF0YS5sZXZlbCwgaWQ6IGRhdGEuaWQgfSk7XG4gIH1cblxuICBvbkF1ZGlvVHJhY2tMb2FkaW5nIChkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGU6IENvbnRleHRUeXBlLkFVRElPX1RSQUNLLCBsZXZlbDogbnVsbCwgaWQ6IGRhdGEuaWQgfSk7XG4gIH1cblxuICBvblN1YnRpdGxlVHJhY2tMb2FkaW5nIChkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGU6IENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLLCBsZXZlbDogbnVsbCwgaWQ6IGRhdGEuaWQgfSk7XG4gIH1cblxuICBsb2FkICh1cmwsIGNvbnRleHQpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICBsb2dnZXIuZGVidWcoYExvYWRpbmcgcGxheWxpc3Qgb2YgdHlwZSAke2NvbnRleHQudHlwZX0sIGxldmVsOiAke2NvbnRleHQubGV2ZWx9LCBpZDogJHtjb250ZXh0LmlkfWApO1xuXG4gICAgLy8gQ2hlY2sgaWYgYSBsb2FkZXIgZm9yIHRoaXMgY29udGV4dCBhbHJlYWR5IGV4aXN0c1xuICAgIGxldCBsb2FkZXIgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSBsb2FkZXIuY29udGV4dDtcbiAgICAgIGlmIChsb2FkZXJDb250ZXh0ICYmIGxvYWRlckNvbnRleHQudXJsID09PSB1cmwpIHsgLy8gc2FtZSBVUkwgY2FuJ3Qgb3ZlcmxhcFxuICAgICAgICBsb2dnZXIudHJhY2UoJ3BsYXlsaXN0IHJlcXVlc3Qgb25nb2luZycpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybihgYWJvcnRpbmcgcHJldmlvdXMgbG9hZGVyIGZvciB0eXBlOiAke2NvbnRleHQudHlwZX1gKTtcbiAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG1heFJldHJ5LFxuICAgICAgdGltZW91dCxcbiAgICAgIHJldHJ5RGVsYXksXG4gICAgICBtYXhSZXRyeURlbGF5O1xuXG4gICAgLy8gYXBwbHkgZGlmZmVyZW50IGNvbmZpZ3MgZm9yIHJldHJpZXMgZGVwZW5kaW5nIG9uXG4gICAgLy8gY29udGV4dCAobWFuaWZlc3QsIGxldmVsLCBhdWRpby9zdWJzIHBsYXlsaXN0KVxuICAgIHN3aXRjaCAoY29udGV4dC50eXBlKSB7XG4gICAgY2FzZSBDb250ZXh0VHlwZS5NQU5JRkVTVDpcbiAgICAgIG1heFJldHJ5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ01heFJldHJ5O1xuICAgICAgdGltZW91dCA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdUaW1lT3V0O1xuICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENvbnRleHRUeXBlLkxFVkVMOlxuICAgICAgLy8gRGlzYWJsZSBpbnRlcm5hbCBsb2FkZXIgcmV0cnkgbG9naWMsIHNpbmNlIHdlIGFyZSBtYW5hZ2luZyByZXRyaWVzIGluIExldmVsIENvbnRyb2xsZXJcbiAgICAgIG1heFJldHJ5ID0gMDtcbiAgICAgIHRpbWVvdXQgPSBjb25maWcubGV2ZWxMb2FkaW5nVGltZU91dDtcbiAgICAgIC8vIFRPRE8gSW50cm9kdWNlIHJldHJ5IHNldHRpbmdzIGZvciBhdWRpby10cmFjayBhbmQgc3VidGl0bGUtdHJhY2ssIGl0IHNob3VsZCBub3QgdXNlIGxldmVsIHJldHJ5IGNvbmZpZ1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG1heFJldHJ5ID0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5O1xuICAgICAgdGltZW91dCA9IGNvbmZpZy5sZXZlbExvYWRpbmdUaW1lT3V0O1xuICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBsb2FkZXIgPSB0aGlzLmNyZWF0ZUludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuXG4gICAgY29udGV4dC51cmwgPSB1cmw7XG4gICAgY29udGV4dC5yZXNwb25zZVR5cGUgPSBjb250ZXh0LnJlc3BvbnNlVHlwZSB8fCAnJzsgLy8gRklYTUU6IChzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSB0byBkbyB0aGlzKVxuXG4gICAgY29uc3QgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgdGltZW91dCxcbiAgICAgIG1heFJldHJ5LFxuICAgICAgcmV0cnlEZWxheSxcbiAgICAgIG1heFJldHJ5RGVsYXlcbiAgICB9O1xuXG4gICAgY29uc3QgbG9hZGVyQ2FsbGJhY2tzID0ge1xuICAgICAgb25TdWNjZXNzOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLmxvYWRlcnJvci5iaW5kKHRoaXMpLFxuICAgICAgb25UaW1lb3V0OiB0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcylcbiAgICB9O1xuXG4gICAgbG9nZ2VyLmRlYnVnKGBDYWxsaW5nIGludGVybmFsIGxvYWRlciBkZWxlZ2F0ZSBmb3IgVVJMOiAke3VybH1gKTtcblxuICAgIGxvYWRlci5sb2FkKGNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgbG9hZHN1Y2Nlc3MgKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMgPSBudWxsKSB7XG4gICAgaWYgKGNvbnRleHQuaXNTaWR4UmVxdWVzdCkge1xuICAgICAgdGhpcy5faGFuZGxlU2lkeFJlcXVlc3QocmVzcG9uc2UsIGNvbnRleHQpO1xuICAgICAgdGhpcy5faGFuZGxlUGxheWxpc3RMb2FkZWQocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHQudHlwZSk7XG5cbiAgICBjb25zdCBzdHJpbmcgPSByZXNwb25zZS5kYXRhO1xuXG4gICAgc3RhdHMudGxvYWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAvLyBzdGF0cy5tdGltZSA9IG5ldyBEYXRlKHRhcmdldC5nZXRSZXNwb25zZUhlYWRlcignTGFzdC1Nb2RpZmllZCcpKTtcblxuICAgIC8vIFZhbGlkYXRlIGlmIGl0IGlzIGFuIE0zVTggYXQgYWxsXG4gICAgaWYgKHN0cmluZy5pbmRleE9mKCcjRVhUTTNVJykgIT09IDApIHtcbiAgICAgIHRoaXMuX2hhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCAnbm8gRVhUTTNVIGRlbGltaXRlcicsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBjaHVuay1saXN0IG9yIG1hc3Rlci4gaGFuZGxlIGVtcHR5IGNodW5rIGxpc3QgY2FzZSAoZmlyc3QgRVhUSU5GIG5vdCBzaWduYWxlZCwgYnV0IFRBUkdFVERVUkFUSU9OIHByZXNlbnQpXG4gICAgaWYgKHN0cmluZy5pbmRleE9mKCcjRVhUSU5GOicpID4gMCB8fCBzdHJpbmcuaW5kZXhPZignI0VYVC1YLVRBUkdFVERVUkFUSU9OOicpID4gMCkge1xuICAgICAgdGhpcy5faGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hhbmRsZU1hc3RlclBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICAgIH1cbiAgfVxuXG4gIGxvYWRlcnJvciAocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzID0gbnVsbCkge1xuICAgIHRoaXMuX2hhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgZmFsc2UsIHJlc3BvbnNlKTtcbiAgfVxuXG4gIGxvYWR0aW1lb3V0IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMgPSBudWxsKSB7XG4gICAgdGhpcy5faGFuZGxlTmV0d29ya0Vycm9yKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCB0cnVlKTtcbiAgfVxuXG4gIF9oYW5kbGVNYXN0ZXJQbGF5bGlzdCAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IHN0cmluZyA9IHJlc3BvbnNlLmRhdGE7XG5cbiAgICBjb25zdCB1cmwgPSBQbGF5bGlzdExvYWRlci5nZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG5cbiAgICBjb25zdCBsZXZlbHMgPSBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCB1cmwpO1xuICAgIGlmICghbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgdGhpcy5faGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsICdubyBsZXZlbCBmb3VuZCBpbiBtYW5pZmVzdCcsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBtdWx0aSBsZXZlbCBwbGF5bGlzdCwgcGFyc2UgbGV2ZWwgaW5mb1xuXG4gICAgY29uc3QgYXVkaW9Hcm91cHMgPSBsZXZlbHMubWFwKGxldmVsID0+ICh7XG4gICAgICBpZDogbGV2ZWwuYXR0cnMuQVVESU8sXG4gICAgICBjb2RlYzogbGV2ZWwuYXVkaW9Db2RlY1xuICAgIH0pKTtcblxuICAgIGxldCBhdWRpb1RyYWNrcyA9IE0zVThQYXJzZXIucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCAnQVVESU8nLCBhdWRpb0dyb3Vwcyk7XG4gICAgbGV0IHN1YnRpdGxlcyA9IE0zVThQYXJzZXIucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCAnU1VCVElUTEVTJyk7XG5cbiAgICBpZiAoYXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGZvdW5kIGFuIGF1ZGlvIHRyYWNrIGVtYmVkZGVkIGluIG1haW4gcGxheWxpc3QgKGF1ZGlvIHRyYWNrIHdpdGhvdXQgVVJJIGF0dHJpYnV0ZSlcbiAgICAgIGxldCBlbWJlZGRlZEF1ZGlvRm91bmQgPSBmYWxzZTtcbiAgICAgIGF1ZGlvVHJhY2tzLmZvckVhY2goYXVkaW9UcmFjayA9PiB7XG4gICAgICAgIGlmICghYXVkaW9UcmFjay51cmwpIHtcbiAgICAgICAgICBlbWJlZGRlZEF1ZGlvRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gaWYgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgZGVmaW5lZCwgYnV0IGF1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsXG4gICAgICAvLyB3ZSBuZWVkIHRvIHNpZ25hbCB0aGlzIG1haW4gYXVkaW8gdHJhY2sgdGhpcyBjb3VsZCBoYXBwZW4gd2l0aCBwbGF5bGlzdHMgd2l0aFxuICAgICAgLy8gYWx0IGF1ZGlvIHJlbmRpdGlvbiBpbiB3aGljaCBxdWFsaXR5IGxldmVscyAobWFpbilcbiAgICAgIC8vIGNvbnRhaW5zIGJvdGggYXVkaW8rdmlkZW8uIGJ1dCB3aXRoIG1peGVkIGF1ZGlvIHRyYWNrIG5vdCBzaWduYWxlZFxuICAgICAgaWYgKGVtYmVkZGVkQXVkaW9Gb3VuZCA9PT0gZmFsc2UgJiYgbGV2ZWxzWzBdLmF1ZGlvQ29kZWMgJiYgIWxldmVsc1swXS5hdHRycy5BVURJTykge1xuICAgICAgICBsb2dnZXIubG9nKCdhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLCBidXQgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgc2lnbmFsZWQsIGNyZWF0ZSBvbmUnKTtcbiAgICAgICAgYXVkaW9UcmFja3MudW5zaGlmdCh7XG4gICAgICAgICAgdHlwZTogJ21haW4nLFxuICAgICAgICAgIG5hbWU6ICdtYWluJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBobHMudHJpZ2dlcihFdmVudC5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgIGxldmVscyxcbiAgICAgIGF1ZGlvVHJhY2tzLFxuICAgICAgc3VidGl0bGVzLFxuICAgICAgdXJsLFxuICAgICAgc3RhdHMsXG4gICAgICBuZXR3b3JrRGV0YWlsc1xuICAgIH0pO1xuICB9XG5cbiAgX2hhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG5cbiAgICBjb25zdCB7IGlkLCBsZXZlbCwgdHlwZSB9ID0gY29udGV4dDtcblxuICAgIGNvbnN0IHVybCA9IFBsYXlsaXN0TG9hZGVyLmdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IGxldmVsVXJsSWQgPSBOdW1iZXIuaXNGaW5pdGUoaWQpID8gaWQgOiAwO1xuICAgIGNvbnN0IGxldmVsSWQgPSBOdW1iZXIuaXNGaW5pdGUobGV2ZWwpID8gbGV2ZWwgOiBsZXZlbFVybElkO1xuICAgIGNvbnN0IGxldmVsVHlwZSA9IFBsYXlsaXN0TG9hZGVyLm1hcENvbnRleHRUb0xldmVsVHlwZShjb250ZXh0KTtcblxuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IE0zVThQYXJzZXIucGFyc2VMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLmRhdGEsIHVybCwgbGV2ZWxJZCwgbGV2ZWxUeXBlLCBsZXZlbFVybElkKTtcblxuICAgIC8vIHNldCBzdGF0cyBvbiBsZXZlbCBzdHJ1Y3R1cmVcbiAgICBsZXZlbERldGFpbHMudGxvYWQgPSBzdGF0cy50bG9hZDtcblxuICAgIC8vIFdlIGhhdmUgZG9uZSBvdXIgZmlyc3QgcmVxdWVzdCAoTWFuaWZlc3QtdHlwZSkgYW5kIHJlY2VpdmVcbiAgICAvLyBub3QgYSBtYXN0ZXIgcGxheWxpc3QgYnV0IGEgY2h1bmstbGlzdCAodHJhY2svbGV2ZWwpXG4gICAgLy8gV2UgZmlyZSB0aGUgbWFuaWZlc3QtbG9hZGVkIGV2ZW50IGFueXdheSB3aXRoIHRoZSBwYXJzZWQgbGV2ZWwtZGV0YWlsc1xuICAgIC8vIGJ5IGNyZWF0aW5nIGEgc2luZ2xlLWxldmVsIHN0cnVjdHVyZSBmb3IgaXQuXG4gICAgaWYgKHR5cGUgPT09IENvbnRleHRUeXBlLk1BTklGRVNUKSB7XG4gICAgICBjb25zdCBzaW5nbGVMZXZlbCA9IHtcbiAgICAgICAgdXJsLFxuICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHNcbiAgICAgIH07XG5cbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50Lk1BTklGRVNUX0xPQURFRCwge1xuICAgICAgICBsZXZlbHM6IFtzaW5nbGVMZXZlbF0sXG4gICAgICAgIGF1ZGlvVHJhY2tzOiBbXSxcbiAgICAgICAgdXJsLFxuICAgICAgICBzdGF0cyxcbiAgICAgICAgbmV0d29ya0RldGFpbHNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHNhdmUgcGFyc2luZyB0aW1lXG4gICAgc3RhdHMudHBhcnNlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgLy8gaW4gY2FzZSB3ZSBuZWVkIFNJRFggcmFuZ2VzXG4gICAgLy8gcmV0dXJuIGVhcmx5IGFmdGVyIGNhbGxpbmcgbG9hZCBmb3JcbiAgICAvLyB0aGUgU0lEWCBib3guXG4gICAgaWYgKGxldmVsRGV0YWlscy5uZWVkU2lkeFJhbmdlcykge1xuICAgICAgY29uc3Qgc2lkeFVybCA9IGxldmVsRGV0YWlscy5pbml0U2VnbWVudC51cmw7XG4gICAgICB0aGlzLmxvYWQoc2lkeFVybCwge1xuICAgICAgICBpc1NpZHhSZXF1ZXN0OiB0cnVlLFxuICAgICAgICB0eXBlLFxuICAgICAgICBsZXZlbCxcbiAgICAgICAgbGV2ZWxEZXRhaWxzLFxuICAgICAgICBpZCxcbiAgICAgICAgcmFuZ2VTdGFydDogMCxcbiAgICAgICAgcmFuZ2VFbmQ6IDIwNDgsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJ1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZXh0ZW5kIHRoZSBjb250ZXh0IHdpdGggdGhlIG5ldyBsZXZlbERldGFpbHMgcHJvcGVydHlcbiAgICBjb250ZXh0LmxldmVsRGV0YWlscyA9IGxldmVsRGV0YWlscztcblxuICAgIHRoaXMuX2hhbmRsZVBsYXlsaXN0TG9hZGVkKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICB9XG5cbiAgX2hhbmRsZVNpZHhSZXF1ZXN0IChyZXNwb25zZSwgY29udGV4dCkge1xuICAgIGNvbnN0IHNpZHhJbmZvID0gTVA0RGVtdXhlci5wYXJzZVNlZ21lbnRJbmRleChuZXcgVWludDhBcnJheShyZXNwb25zZS5kYXRhKSk7XG4gICAgLy8gaWYgcHJvdmlkZWQgZnJhZ21lbnQgZG9lcyBub3QgY29udGFpbiBzaWR4LCBlYXJseSByZXR1cm5cbiAgICBpZiAoIXNpZHhJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNpZHhSZWZlcmVuY2VzID0gc2lkeEluZm8ucmVmZXJlbmNlcztcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSBjb250ZXh0LmxldmVsRGV0YWlscztcbiAgICBzaWR4UmVmZXJlbmNlcy5mb3JFYWNoKChzZWdtZW50UmVmLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3Qgc2VnUmVmSW5mbyA9IHNlZ21lbnRSZWYuaW5mbztcbiAgICAgIGNvbnN0IGZyYWcgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2luZGV4XTtcblxuICAgICAgaWYgKGZyYWcuYnl0ZVJhbmdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmcmFnLnJhd0J5dGVSYW5nZSA9IFN0cmluZygxICsgc2VnUmVmSW5mby5lbmQgLSBzZWdSZWZJbmZvLnN0YXJ0KSArICdAJyArIFN0cmluZyhzZWdSZWZJbmZvLnN0YXJ0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQucmF3Qnl0ZVJhbmdlID0gU3RyaW5nKHNpZHhJbmZvLm1vb3ZFbmRPZmZzZXQpICsgJ0AwJztcbiAgfVxuXG4gIF9oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvciAocmVzcG9uc2UsIGNvbnRleHQsIHJlYXNvbiwgbmV0d29ya0RldGFpbHMpIHtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfUEFSU0lOR19FUlJPUixcbiAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICByZWFzb24sXG4gICAgICBuZXR3b3JrRGV0YWlsc1xuICAgIH0pO1xuICB9XG5cbiAgX2hhbmRsZU5ldHdvcmtFcnJvciAoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHRpbWVvdXQgPSBmYWxzZSwgcmVzcG9uc2UgPSBudWxsKSB7XG4gICAgbG9nZ2VyLmluZm8oYEEgbmV0d29yayBlcnJvciBvY2N1cmVkIHdoaWxlIGxvYWRpbmcgYSAke2NvbnRleHQudHlwZX0tdHlwZSBwbGF5bGlzdGApO1xuXG4gICAgbGV0IGRldGFpbHM7XG4gICAgbGV0IGZhdGFsO1xuXG4gICAgY29uc3QgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcblxuICAgIHN3aXRjaCAoY29udGV4dC50eXBlKSB7XG4gICAgY2FzZSBDb250ZXh0VHlwZS5NQU5JRkVTVDpcbiAgICAgIGRldGFpbHMgPSAodGltZW91dCA/IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX1RJTUVPVVQgOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9FUlJPUik7XG4gICAgICBmYXRhbCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENvbnRleHRUeXBlLkxFVkVMOlxuICAgICAgZGV0YWlscyA9ICh0aW1lb3V0ID8gRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVCA6IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SKTtcbiAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgZGV0YWlscyA9ICh0aW1lb3V0ID8gRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVCA6IEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SKTtcbiAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZGV0YWlscyA9IC4uLj9cbiAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dC50eXBlKTtcbiAgICB9XG5cbiAgICBsZXQgZXJyb3JEYXRhID0ge1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgZGV0YWlscyxcbiAgICAgIGZhdGFsLFxuICAgICAgdXJsOiBsb2FkZXIudXJsLFxuICAgICAgbG9hZGVyLFxuICAgICAgY29udGV4dCxcbiAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgfTtcblxuICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgZXJyb3JEYXRhLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZXJyb3JEYXRhKTtcbiAgfVxuXG4gIF9oYW5kbGVQbGF5bGlzdExvYWRlZCAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgIGNvbnN0IHsgdHlwZSwgbGV2ZWwsIGlkLCBsZXZlbERldGFpbHMgfSA9IGNvbnRleHQ7XG5cbiAgICBpZiAoIWxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikge1xuICAgICAgdGhpcy5faGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsICdpbnZhbGlkIHRhcmdldCBkdXJhdGlvbicsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjYW5IYXZlTGV2ZWxzID0gUGxheWxpc3RMb2FkZXIuY2FuSGF2ZVF1YWxpdHlMZXZlbHMoY29udGV4dC50eXBlKTtcbiAgICBpZiAoY2FuSGF2ZUxldmVscykge1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5MRVZFTF9MT0FERUQsIHtcbiAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICBsZXZlbDogbGV2ZWwgfHwgMCxcbiAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgIHN0YXRzLFxuICAgICAgICBuZXR3b3JrRGV0YWlsc1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19MT0FERUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQbGF5bGlzdExvYWRlcjtcbiIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuXG4vKipcbiAqIEBjbGFzc1xuICpcbiAqIFNpbXBsZSBhZGFwdGVyIHN1Yi1jbGFzcyBvZiBOb2RlanMtbGlrZSBFdmVudEVtaXR0ZXIuXG4gKlxuICogV2Ugc2ltcGx5IHdhbnQgdG8gcGFzcyBhbG9uZyB0aGUgZXZlbnQtbmFtZSBpdHNlbGZcbiAqIGluIGV2ZXJ5IGNhbGwgdG8gYSBoYW5kbGVyLCB3aGljaCBpcyB0aGUgcHVycG9zZSBvZiBvdXIgYHRyaWdnZXJgIG1ldGhvZFxuICogZXh0ZW5kaW5nIHRoZSBzdGFuZGFyZCBBUEkuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgT2JzZXJ2ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7YW55fSBkYXRhXG4gICAqL1xuICB0cmlnZ2VyIChldmVudCwgLi4uZGF0YSkge1xuICAgIHRoaXMuZW1pdChldmVudCwgZXZlbnQsIC4uLmRhdGEpO1xuICB9XG59XG4iLCIvKipcbiAqICBBQUMgaGVscGVyXG4gKi9cblxuY2xhc3MgQUFDIHtcbiAgc3RhdGljIGdldFNpbGVudEZyYW1lIChjb2RlYywgY2hhbm5lbENvdW50KSB7XG4gICAgc3dpdGNoIChjb2RlYykge1xuICAgIGNhc2UgJ21wNGEuNDAuMic6XG4gICAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMywgMHg4MF0pO1xuICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDIxLCAweDAwLCAweDQ5LCAweDkwLCAweDAyLCAweDE5LCAweDAwLCAweDIzLCAweDgwXSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4OGVdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MCwgMHgyYywgMHg4MCwgMHgwOCwgMHgwMiwgMHgzOF0pO1xuICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDM4XSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNikge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MDAsIDB4YjIsIDB4MDAsIDB4MjAsIDB4MDgsIDB4ZTBdKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgLy8gaGFuZGxlIEhFLUFBQyBiZWxvdyAobXA0YS40MC41IC8gbXA0YS40MC4yOSlcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZSAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg0ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDFjLCAweDYsIDB4ZjEsIDB4YzEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xuICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MHwwOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZV92MiAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XG4gICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MHwwOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZV92MiAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBQUM7XG4iLCIvKipcbiAqIEdlbmVyYXRlIE1QNCBCb3hcbiovXG5cbmNvbnN0IFVJTlQzMl9NQVggPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuXG5jbGFzcyBNUDQge1xuICBzdGF0aWMgaW5pdCAoKSB7XG4gICAgTVA0LnR5cGVzID0ge1xuICAgICAgYXZjMTogW10sIC8vIGNvZGluZ25hbWVcbiAgICAgIGF2Y0M6IFtdLFxuICAgICAgYnRydDogW10sXG4gICAgICBkaW5mOiBbXSxcbiAgICAgIGRyZWY6IFtdLFxuICAgICAgZXNkczogW10sXG4gICAgICBmdHlwOiBbXSxcbiAgICAgIGhkbHI6IFtdLFxuICAgICAgbWRhdDogW10sXG4gICAgICBtZGhkOiBbXSxcbiAgICAgIG1kaWE6IFtdLFxuICAgICAgbWZoZDogW10sXG4gICAgICBtaW5mOiBbXSxcbiAgICAgIG1vb2Y6IFtdLFxuICAgICAgbW9vdjogW10sXG4gICAgICBtcDRhOiBbXSxcbiAgICAgICcubXAzJzogW10sXG4gICAgICBtdmV4OiBbXSxcbiAgICAgIG12aGQ6IFtdLFxuICAgICAgcGFzcDogW10sXG4gICAgICBzZHRwOiBbXSxcbiAgICAgIHN0Ymw6IFtdLFxuICAgICAgc3RjbzogW10sXG4gICAgICBzdHNjOiBbXSxcbiAgICAgIHN0c2Q6IFtdLFxuICAgICAgc3RzejogW10sXG4gICAgICBzdHRzOiBbXSxcbiAgICAgIHRmZHQ6IFtdLFxuICAgICAgdGZoZDogW10sXG4gICAgICB0cmFmOiBbXSxcbiAgICAgIHRyYWs6IFtdLFxuICAgICAgdHJ1bjogW10sXG4gICAgICB0cmV4OiBbXSxcbiAgICAgIHRraGQ6IFtdLFxuICAgICAgdm1oZDogW10sXG4gICAgICBzbWhkOiBbXVxuICAgIH07XG5cbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgaW4gTVA0LnR5cGVzKSB7XG4gICAgICBpZiAoTVA0LnR5cGVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIE1QNC50eXBlc1tpXSA9IFtcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMCksXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDEpLFxuICAgICAgICAgIGkuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMylcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgdmlkZW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgIDB4NzYsIDB4NjksIDB4NjQsIDB4NjUsIC8vIGhhbmRsZXJfdHlwZTogJ3ZpZGUnXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDU2LCAweDY5LCAweDY0LCAweDY1LFxuICAgICAgMHg2ZiwgMHg0OCwgMHg2MSwgMHg2ZSxcbiAgICAgIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1ZpZGVvSGFuZGxlcidcbiAgICBdKTtcblxuICAgIGxldCBhdWRpb0hkbHIgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHg3MywgMHg2ZiwgMHg3NSwgMHg2ZSwgLy8gaGFuZGxlcl90eXBlOiAnc291bidcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4NTMsIDB4NmYsIDB4NzUsIDB4NmUsXG4gICAgICAweDY0LCAweDQ4LCAweDYxLCAweDZlLFxuICAgICAgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnU291bmRIYW5kbGVyJ1xuICAgIF0pO1xuXG4gICAgTVA0LkhETFJfVFlQRVMgPSB7XG4gICAgICAndmlkZW8nOiB2aWRlb0hkbHIsXG4gICAgICAnYXVkaW8nOiBhdWRpb0hkbHJcbiAgICB9O1xuXG4gICAgbGV0IGRyZWYgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyBlbnRyeV9jb3VudFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwYywgLy8gZW50cnlfc2l6ZVxuICAgICAgMHg3NSwgMHg3MiwgMHg2YywgMHgyMCwgLy8gJ3VybCcgdHlwZVxuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAxIC8vIGVudHJ5X2ZsYWdzXG4gICAgXSk7XG5cbiAgICBsZXQgc3RjbyA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIGVudHJ5X2NvdW50XG4gICAgXSk7XG5cbiAgICBNUDQuU1RUUyA9IE1QNC5TVFNDID0gTVA0LlNUQ08gPSBzdGNvO1xuXG4gICAgTVA0LlNUU1ogPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gc2FtcGxlX3NpemVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gc2FtcGxlX2NvdW50XG4gICAgXSk7XG4gICAgTVA0LlZNSEQgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAxLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgLy8gZ3JhcGhpY3Ntb2RlXG4gICAgICAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAgLy8gb3Bjb2xvclxuICAgIF0pO1xuICAgIE1QNC5TTUhEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGJhbGFuY2VcbiAgICAgIDB4MDAsIDB4MDAgLy8gcmVzZXJ2ZWRcbiAgICBdKTtcblxuICAgIE1QNC5TVFNEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMV0pOy8vIGVudHJ5X2NvdW50XG5cbiAgICBsZXQgbWFqb3JCcmFuZCA9IG5ldyBVaW50OEFycmF5KFsxMDUsIDExNSwgMTExLCAxMDldKTsgLy8gaXNvbVxuICAgIGxldCBhdmMxQnJhbmQgPSBuZXcgVWludDhBcnJheShbOTcsIDExOCwgOTksIDQ5XSk7IC8vIGF2YzFcbiAgICBsZXQgbWlub3JWZXJzaW9uID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDFdKTtcblxuICAgIE1QNC5GVFlQID0gTVA0LmJveChNUDQudHlwZXMuZnR5cCwgbWFqb3JCcmFuZCwgbWlub3JWZXJzaW9uLCBtYWpvckJyYW5kLCBhdmMxQnJhbmQpO1xuICAgIE1QNC5ESU5GID0gTVA0LmJveChNUDQudHlwZXMuZGluZiwgTVA0LmJveChNUDQudHlwZXMuZHJlZiwgZHJlZikpO1xuICB9XG5cbiAgc3RhdGljIGJveCAodHlwZSkge1xuICAgIGxldFxuICAgICAgcGF5bG9hZCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICBzaXplID0gOCxcbiAgICAgIGkgPSBwYXlsb2FkLmxlbmd0aCxcbiAgICAgIGxlbiA9IGksXG4gICAgICByZXN1bHQ7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBzaXplIHdlIG5lZWQgdG8gYWxsb2NhdGVcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICByZXN1bHRbMF0gPSAoc2l6ZSA+PiAyNCkgJiAweGZmO1xuICAgIHJlc3VsdFsxXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzdWx0WzJdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgIHJlc3VsdFszXSA9IHNpemUgJiAweGZmO1xuICAgIHJlc3VsdC5zZXQodHlwZSwgNCk7XG4gICAgLy8gY29weSB0aGUgcGF5bG9hZCBpbnRvIHRoZSByZXN1bHRcbiAgICBmb3IgKGkgPSAwLCBzaXplID0gODsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBjb3B5IHBheWxvYWRbaV0gYXJyYXkgQCBvZmZzZXQgc2l6ZVxuICAgICAgcmVzdWx0LnNldChwYXlsb2FkW2ldLCBzaXplKTtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgc3RhdGljIGhkbHIgKHR5cGUpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuaGRsciwgTVA0LkhETFJfVFlQRVNbdHlwZV0pO1xuICB9XG5cbiAgc3RhdGljIG1kYXQgKGRhdGEpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRhdCwgZGF0YSk7XG4gIH1cblxuICBzdGF0aWMgbWRoZCAodGltZXNjYWxlLCBkdXJhdGlvbikge1xuICAgIGR1cmF0aW9uICo9IHRpbWVzY2FsZTtcbiAgICBjb25zdCB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICBjb25zdCBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMiwgLy8gY3JlYXRpb25fdGltZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgICh0aW1lc2NhbGUgPj4gMjQpICYgMHhGRixcbiAgICAgICh0aW1lc2NhbGUgPj4gMTYpICYgMHhGRixcbiAgICAgICh0aW1lc2NhbGUgPj4gOCkgJiAweEZGLFxuICAgICAgdGltZXNjYWxlICYgMHhGRiwgLy8gdGltZXNjYWxlXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMjQpLFxuICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweEZGLFxuICAgICAgdXBwZXJXb3JkRHVyYXRpb24gJiAweEZGLFxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDI0KSxcbiAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDgpICYgMHhGRixcbiAgICAgIGxvd2VyV29yZER1cmF0aW9uICYgMHhGRixcbiAgICAgIDB4NTUsIDB4YzQsIC8vICd1bmQnIGxhbmd1YWdlICh1bmRldGVybWluZWQpXG4gICAgICAweDAwLCAweDAwXG4gICAgXSkpO1xuICB9XG5cbiAgc3RhdGljIG1kaWEgKHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaWEsIE1QNC5tZGhkKHRyYWNrLnRpbWVzY2FsZSwgdHJhY2suZHVyYXRpb24pLCBNUDQuaGRscih0cmFjay50eXBlKSwgTVA0Lm1pbmYodHJhY2spKTtcbiAgfVxuXG4gIHN0YXRpYyBtZmhkIChzZXF1ZW5jZU51bWJlcikge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZmhkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIChzZXF1ZW5jZU51bWJlciA+PiAyNCksXG4gICAgICAoc2VxdWVuY2VOdW1iZXIgPj4gMTYpICYgMHhGRixcbiAgICAgIChzZXF1ZW5jZU51bWJlciA+PiA4KSAmIDB4RkYsXG4gICAgICBzZXF1ZW5jZU51bWJlciAmIDB4RkYgLy8gc2VxdWVuY2VfbnVtYmVyXG4gICAgXSkpO1xuICB9XG5cbiAgc3RhdGljIG1pbmYgKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5taW5mLCBNUDQuYm94KE1QNC50eXBlcy5zbWhkLCBNUDQuU01IRCksIE1QNC5ESU5GLCBNUDQuc3RibCh0cmFjaykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMudm1oZCwgTVA0LlZNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgbW9vZiAoc24sIGJhc2VNZWRpYURlY29kZVRpbWUsIHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1vb2YsIE1QNC5tZmhkKHNuKSwgTVA0LnRyYWYodHJhY2ssIGJhc2VNZWRpYURlY29kZVRpbWUpKTtcbiAgfVxuICAvKipcbiAqIEBwYXJhbSB0cmFja3MuLi4gKG9wdGlvbmFsKSB7YXJyYXl9IHRoZSB0cmFja3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbW92aWVcbiAqL1xuICBzdGF0aWMgbW9vdiAodHJhY2tzKSB7XG4gICAgbGV0XG4gICAgICBpID0gdHJhY2tzLmxlbmd0aCxcbiAgICAgIGJveGVzID0gW107XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBib3hlc1tpXSA9IE1QNC50cmFrKHRyYWNrc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1QNC5ib3guYXBwbHkobnVsbCwgW01QNC50eXBlcy5tb292LCBNUDQubXZoZCh0cmFja3NbMF0udGltZXNjYWxlLCB0cmFja3NbMF0uZHVyYXRpb24pXS5jb25jYXQoYm94ZXMpLmNvbmNhdChNUDQubXZleCh0cmFja3MpKSk7XG4gIH1cblxuICBzdGF0aWMgbXZleCAodHJhY2tzKSB7XG4gICAgbGV0XG4gICAgICBpID0gdHJhY2tzLmxlbmd0aCxcbiAgICAgIGJveGVzID0gW107XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBib3hlc1tpXSA9IE1QNC50cmV4KHRyYWNrc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1QNC5ib3guYXBwbHkobnVsbCwgW01QNC50eXBlcy5tdmV4XS5jb25jYXQoYm94ZXMpKTtcbiAgfVxuXG4gIHN0YXRpYyBtdmhkICh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xuICAgIGNvbnN0IHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGxldFxuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MDEsIC8vIHZlcnNpb24gMVxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICAgICh0aW1lc2NhbGUgPj4gMjQpICYgMHhGRixcbiAgICAgICAgKHRpbWVzY2FsZSA+PiAxNikgJiAweEZGLFxuICAgICAgICAodGltZXNjYWxlID4+IDgpICYgMHhGRixcbiAgICAgICAgdGltZXNjYWxlICYgMHhGRiwgLy8gdGltZXNjYWxlXG4gICAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAyNCksXG4gICAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweEZGLFxuICAgICAgICB1cHBlcldvcmREdXJhdGlvbiAmIDB4RkYsXG4gICAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAyNCksXG4gICAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweEZGLFxuICAgICAgICBsb3dlcldvcmREdXJhdGlvbiAmIDB4RkYsXG4gICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIC8vIDEuMCByYXRlXG4gICAgICAgIDB4MDEsIDB4MDAsIC8vIDEuMCB2b2x1bWVcbiAgICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgICAweGZmLCAweGZmLCAweGZmLCAweGZmIC8vIG5leHRfdHJhY2tfSURcbiAgICAgIF0pO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tdmhkLCBieXRlcyk7XG4gIH1cblxuICBzdGF0aWMgc2R0cCAodHJhY2spIHtcbiAgICBsZXRcbiAgICAgIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdLFxuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheSg0ICsgc2FtcGxlcy5sZW5ndGgpLFxuICAgICAgZmxhZ3MsXG4gICAgICBpO1xuICAgIC8vIGxlYXZlIHRoZSBmdWxsIGJveCBoZWFkZXIgKDQgYnl0ZXMpIGFsbCB6ZXJvXG4gICAgLy8gd3JpdGUgdGhlIHNhbXBsZSB0YWJsZVxuICAgIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmbGFncyA9IHNhbXBsZXNbaV0uZmxhZ3M7XG4gICAgICBieXRlc1tpICsgNF0gPSAoZmxhZ3MuZGVwZW5kc09uIDw8IDQpIHxcbiAgICAgICAgKGZsYWdzLmlzRGVwZW5kZWRPbiA8PCAyKSB8XG4gICAgICAgIChmbGFncy5oYXNSZWR1bmRhbmN5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc2R0cCwgYnl0ZXMpO1xuICB9XG5cbiAgc3RhdGljIHN0YmwgKHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0YmwsIE1QNC5zdHNkKHRyYWNrKSwgTVA0LmJveChNUDQudHlwZXMuc3R0cywgTVA0LlNUVFMpLCBNUDQuYm94KE1QNC50eXBlcy5zdHNjLCBNUDQuU1RTQyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c3osIE1QNC5TVFNaKSwgTVA0LmJveChNUDQudHlwZXMuc3RjbywgTVA0LlNUQ08pKTtcbiAgfVxuXG4gIHN0YXRpYyBhdmMxICh0cmFjaykge1xuICAgIGxldCBzcHMgPSBbXSwgcHBzID0gW10sIGksIGRhdGEsIGxlbjtcbiAgICAvLyBhc3NlbWJsZSB0aGUgU1BTc1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnNwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSA9IHRyYWNrLnNwc1tpXTtcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHNwcy5wdXNoKChsZW4gPj4+IDgpICYgMHhGRik7XG4gICAgICBzcHMucHVzaCgobGVuICYgMHhGRikpO1xuXG4gICAgICAvLyBTUFNcbiAgICAgIHNwcyA9IHNwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xuICAgIH1cblxuICAgIC8vIGFzc2VtYmxlIHRoZSBQUFNzXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnBwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSA9IHRyYWNrLnBwc1tpXTtcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHBwcy5wdXNoKChsZW4gPj4+IDgpICYgMHhGRik7XG4gICAgICBwcHMucHVzaCgobGVuICYgMHhGRikpO1xuXG4gICAgICBwcHMgPSBwcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTtcbiAgICB9XG5cbiAgICBsZXQgYXZjYyA9IE1QNC5ib3goTVA0LnR5cGVzLmF2Y0MsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMHgwMSwgLy8gdmVyc2lvblxuICAgICAgICBzcHNbM10sIC8vIHByb2ZpbGVcbiAgICAgICAgc3BzWzRdLCAvLyBwcm9maWxlIGNvbXBhdFxuICAgICAgICBzcHNbNV0sIC8vIGxldmVsXG4gICAgICAgIDB4ZmMgfCAzLCAvLyBsZW5ndGhTaXplTWludXNPbmUsIGhhcmQtY29kZWQgdG8gNCBieXRlc1xuICAgICAgICAweEUwIHwgdHJhY2suc3BzLmxlbmd0aCAvLyAzYml0IHJlc2VydmVkICgxMTEpICsgbnVtT2ZTZXF1ZW5jZVBhcmFtZXRlclNldHNcbiAgICAgIF0uY29uY2F0KHNwcykuY29uY2F0KFtcbiAgICAgICAgdHJhY2sucHBzLmxlbmd0aCAvLyBudW1PZlBpY3R1cmVQYXJhbWV0ZXJTZXRzXG4gICAgICBdKS5jb25jYXQocHBzKSkpLCAvLyBcIlBQU1wiXG4gICAgICB3aWR0aCA9IHRyYWNrLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0LFxuICAgICAgaFNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzBdLFxuICAgICAgdlNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzFdO1xuXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmF2YzEsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgKHdpZHRoID4+IDgpICYgMHhGRixcbiAgICAgIHdpZHRoICYgMHhmZiwgLy8gd2lkdGhcbiAgICAgIChoZWlnaHQgPj4gOCkgJiAweEZGLFxuICAgICAgaGVpZ2h0ICYgMHhmZiwgLy8gaGVpZ2h0XG4gICAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLCAvLyBob3JpenJlc29sdXRpb25cbiAgICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIHZlcnRyZXNvbHV0aW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgLy8gZnJhbWVfY291bnRcbiAgICAgIDB4MTIsXG4gICAgICAweDY0LCAweDYxLCAweDY5LCAweDZDLCAvLyBkYWlseW1vdGlvbi9obHMuanNcbiAgICAgIDB4NzksIDB4NkQsIDB4NkYsIDB4NzQsXG4gICAgICAweDY5LCAweDZGLCAweDZFLCAweDJGLFxuICAgICAgMHg2OCwgMHg2QywgMHg3MywgMHgyRSxcbiAgICAgIDB4NkEsIDB4NzMsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGNvbXByZXNzb3JuYW1lXG4gICAgICAweDAwLCAweDE4LCAvLyBkZXB0aCA9IDI0XG4gICAgICAweDExLCAweDExXSksIC8vIHByZV9kZWZpbmVkID0gLTFcbiAgICBhdmNjLFxuICAgIE1QNC5ib3goTVA0LnR5cGVzLmJ0cnQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIDB4MWMsIDB4OWMsIDB4ODAsIC8vIGJ1ZmZlclNpemVEQlxuICAgICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMCwgLy8gbWF4Qml0cmF0ZVxuICAgICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMF0pKSwgLy8gYXZnQml0cmF0ZVxuICAgIE1QNC5ib3goTVA0LnR5cGVzLnBhc3AsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIChoU3BhY2luZyA+PiAyNCksIC8vIGhTcGFjaW5nXG4gICAgICAoaFNwYWNpbmcgPj4gMTYpICYgMHhGRixcbiAgICAgIChoU3BhY2luZyA+PiA4KSAmIDB4RkYsXG4gICAgICBoU3BhY2luZyAmIDB4RkYsXG4gICAgICAodlNwYWNpbmcgPj4gMjQpLCAvLyB2U3BhY2luZ1xuICAgICAgKHZTcGFjaW5nID4+IDE2KSAmIDB4RkYsXG4gICAgICAodlNwYWNpbmcgPj4gOCkgJiAweEZGLFxuICAgICAgdlNwYWNpbmcgJiAweEZGXSkpXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBlc2RzICh0cmFjaykge1xuICAgIGxldCBjb25maWdsZW4gPSB0cmFjay5jb25maWcubGVuZ3RoO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG5cbiAgICAgIDB4MDMsIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgICAgMHgxNyArIGNvbmZpZ2xlbiwgLy8gbGVuZ3RoXG4gICAgICAweDAwLCAweDAxLCAvLyBlc19pZFxuICAgICAgMHgwMCwgLy8gc3RyZWFtX3ByaW9yaXR5XG5cbiAgICAgIDB4MDQsIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgICAgMHgwZiArIGNvbmZpZ2xlbiwgLy8gbGVuZ3RoXG4gICAgICAweDQwLCAvLyBjb2RlYyA6IG1wZWc0X2F1ZGlvXG4gICAgICAweDE1LCAvLyBzdHJlYW1fdHlwZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gYnVmZmVyX3NpemVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIG1heEJpdHJhdGVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGF2Z0JpdHJhdGVcblxuICAgICAgMHgwNSAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICBdLmNvbmNhdChbY29uZmlnbGVuXSkuY29uY2F0KHRyYWNrLmNvbmZpZykuY29uY2F0KFsweDA2LCAweDAxLCAweDAyXSkpOyAvLyBHQVNwZWNpZmljQ29uZmlnKSk7IC8vIGxlbmd0aCArIGF1ZGlvIGNvbmZpZyBkZXNjcmlwdG9yXG4gIH1cblxuICBzdGF0aWMgbXA0YSAodHJhY2spIHtcbiAgICBsZXQgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGU7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1wNGEsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LCAvLyBjaGFubmVsY291bnRcbiAgICAgIDB4MDAsIDB4MTAsIC8vIHNhbXBsZVNpemU6MTZiaXRzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDJcbiAgICAgIChzYW1wbGVyYXRlID4+IDgpICYgMHhGRixcbiAgICAgIHNhbXBsZXJhdGUgJiAweGZmLCAvL1xuICAgICAgMHgwMCwgMHgwMF0pLFxuICAgIE1QNC5ib3goTVA0LnR5cGVzLmVzZHMsIE1QNC5lc2RzKHRyYWNrKSkpO1xuICB9XG5cbiAgc3RhdGljIG1wMyAodHJhY2spIHtcbiAgICBsZXQgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGU7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzWycubXAzJ10sIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LCAvLyBjaGFubmVsY291bnRcbiAgICAgIDB4MDAsIDB4MTAsIC8vIHNhbXBsZVNpemU6MTZiaXRzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDJcbiAgICAgIChzYW1wbGVyYXRlID4+IDgpICYgMHhGRixcbiAgICAgIHNhbXBsZXJhdGUgJiAweGZmLCAvL1xuICAgICAgMHgwMCwgMHgwMF0pKTtcbiAgfVxuXG4gIHN0YXRpYyBzdHNkICh0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICBpZiAoIXRyYWNrLmlzQUFDICYmIHRyYWNrLmNvZGVjID09PSAnbXAzJykge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDModHJhY2spKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQubXA0YSh0cmFjaykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5hdmMxKHRyYWNrKSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHRraGQgKHRyYWNrKSB7XG4gICAgbGV0IGlkID0gdHJhY2suaWQsXG4gICAgICBkdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uICogdHJhY2sudGltZXNjYWxlLFxuICAgICAgd2lkdGggPSB0cmFjay53aWR0aCxcbiAgICAgIGhlaWdodCA9IHRyYWNrLmhlaWdodCxcbiAgICAgIHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpLFxuICAgICAgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRraGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDEsIC8vIHZlcnNpb24gMVxuICAgICAgMHgwMCwgMHgwMCwgMHgwNywgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICAoaWQgPj4gMjQpICYgMHhGRixcbiAgICAgIChpZCA+PiAxNikgJiAweEZGLFxuICAgICAgKGlkID4+IDgpICYgMHhGRixcbiAgICAgIGlkICYgMHhGRiwgLy8gdHJhY2tfSURcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMjQpLFxuICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweEZGLFxuICAgICAgdXBwZXJXb3JkRHVyYXRpb24gJiAweEZGLFxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDI0KSxcbiAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDgpICYgMHhGRixcbiAgICAgIGxvd2VyV29yZER1cmF0aW9uICYgMHhGRixcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgLy8gbGF5ZXJcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGFsdGVybmF0ZV9ncm91cFxuICAgICAgMHgwMCwgMHgwMCwgLy8gbm9uLWF1ZGlvIHRyYWNrIHZvbHVtZVxuICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgICAgKHdpZHRoID4+IDgpICYgMHhGRixcbiAgICAgIHdpZHRoICYgMHhGRixcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHdpZHRoXG4gICAgICAoaGVpZ2h0ID4+IDgpICYgMHhGRixcbiAgICAgIGhlaWdodCAmIDB4RkYsXG4gICAgICAweDAwLCAweDAwIC8vIGhlaWdodFxuICAgIF0pKTtcbiAgfVxuXG4gIHN0YXRpYyB0cmFmICh0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSkge1xuICAgIGxldCBzYW1wbGVEZXBlbmRlbmN5VGFibGUgPSBNUDQuc2R0cCh0cmFjayksXG4gICAgICBpZCA9IHRyYWNrLmlkLFxuICAgICAgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYICsgMSkpLFxuICAgICAgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFmLFxuICAgICAgTVA0LmJveChNUDQudHlwZXMudGZoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgICAgKGlkID4+IDI0KSxcbiAgICAgICAgKGlkID4+IDE2KSAmIDBYRkYsXG4gICAgICAgIChpZCA+PiA4KSAmIDBYRkYsXG4gICAgICAgIChpZCAmIDB4RkYpIC8vIHRyYWNrX0lEXG4gICAgICBdKSksXG4gICAgICBNUDQuYm94KE1QNC50eXBlcy50ZmR0LCBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MDEsIC8vIHZlcnNpb24gMVxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgICAodXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAyNCksXG4gICAgICAgICh1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDE2KSAmIDBYRkYsXG4gICAgICAgICh1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDgpICYgMFhGRixcbiAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweEZGKSxcbiAgICAgICAgKGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMjQpLFxuICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNikgJiAwWEZGLFxuICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4KSAmIDBYRkYsXG4gICAgICAgIChsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhGRilcbiAgICAgIF0pKSxcbiAgICAgIE1QNC50cnVuKHRyYWNrLFxuICAgICAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAgICAgMTYgKyAvLyB0ZmhkXG4gICAgICAgICAgICAgICAgICAgIDIwICsgLy8gdGZkdFxuICAgICAgICAgICAgICAgICAgICA4ICsgLy8gdHJhZiBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgMTYgKyAvLyBtZmhkXG4gICAgICAgICAgICAgICAgICAgIDggKyAvLyBtb29mIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICA4KSwgLy8gbWRhdCBoZWFkZXJcbiAgICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFjayBib3guXG4gICAqIEBwYXJhbSB0cmFjayB7b2JqZWN0fSBhIHRyYWNrIGRlZmluaXRpb25cbiAgICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIHRyYWNrIGJveFxuICAgKi9cbiAgc3RhdGljIHRyYWsgKHRyYWNrKSB7XG4gICAgdHJhY2suZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiB8fCAweGZmZmZmZmZmO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFrLCBNUDQudGtoZCh0cmFjayksIE1QNC5tZGlhKHRyYWNrKSk7XG4gIH1cblxuICBzdGF0aWMgdHJleCAodHJhY2spIHtcbiAgICBsZXQgaWQgPSB0cmFjay5pZDtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJleCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgKGlkID4+IDI0KSxcbiAgICAgIChpZCA+PiAxNikgJiAwWEZGLFxuICAgICAgKGlkID4+IDgpICYgMFhGRixcbiAgICAgIChpZCAmIDB4RkYpLCAvLyB0cmFja19JRFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9zaXplXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAxIC8vIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXG4gICAgXSkpO1xuICB9XG5cbiAgc3RhdGljIHRydW4gKHRyYWNrLCBvZmZzZXQpIHtcbiAgICBsZXQgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW10sXG4gICAgICBsZW4gPSBzYW1wbGVzLmxlbmd0aCxcbiAgICAgIGFycmF5bGVuID0gMTIgKyAoMTYgKiBsZW4pLFxuICAgICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheWxlbiksXG4gICAgICBpLCBzYW1wbGUsIGR1cmF0aW9uLCBzaXplLCBmbGFncywgY3RzO1xuICAgIG9mZnNldCArPSA4ICsgYXJyYXlsZW47XG4gICAgYXJyYXkuc2V0KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwZiwgMHgwMSwgLy8gZmxhZ3NcbiAgICAgIChsZW4gPj4+IDI0KSAmIDB4RkYsXG4gICAgICAobGVuID4+PiAxNikgJiAweEZGLFxuICAgICAgKGxlbiA+Pj4gOCkgJiAweEZGLFxuICAgICAgbGVuICYgMHhGRiwgLy8gc2FtcGxlX2NvdW50XG4gICAgICAob2Zmc2V0ID4+PiAyNCkgJiAweEZGLFxuICAgICAgKG9mZnNldCA+Pj4gMTYpICYgMHhGRixcbiAgICAgIChvZmZzZXQgPj4+IDgpICYgMHhGRixcbiAgICAgIG9mZnNldCAmIDB4RkYgLy8gZGF0YV9vZmZzZXRcbiAgICBdLCAwKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNhbXBsZSA9IHNhbXBsZXNbaV07XG4gICAgICBkdXJhdGlvbiA9IHNhbXBsZS5kdXJhdGlvbjtcbiAgICAgIHNpemUgPSBzYW1wbGUuc2l6ZTtcbiAgICAgIGZsYWdzID0gc2FtcGxlLmZsYWdzO1xuICAgICAgY3RzID0gc2FtcGxlLmN0cztcbiAgICAgIGFycmF5LnNldChbXG4gICAgICAgIChkdXJhdGlvbiA+Pj4gMjQpICYgMHhGRixcbiAgICAgICAgKGR1cmF0aW9uID4+PiAxNikgJiAweEZGLFxuICAgICAgICAoZHVyYXRpb24gPj4+IDgpICYgMHhGRixcbiAgICAgICAgZHVyYXRpb24gJiAweEZGLCAvLyBzYW1wbGVfZHVyYXRpb25cbiAgICAgICAgKHNpemUgPj4+IDI0KSAmIDB4RkYsXG4gICAgICAgIChzaXplID4+PiAxNikgJiAweEZGLFxuICAgICAgICAoc2l6ZSA+Pj4gOCkgJiAweEZGLFxuICAgICAgICBzaXplICYgMHhGRiwgLy8gc2FtcGxlX3NpemVcbiAgICAgICAgKGZsYWdzLmlzTGVhZGluZyA8PCAyKSB8IGZsYWdzLmRlcGVuZHNPbixcbiAgICAgICAgKGZsYWdzLmlzRGVwZW5kZWRPbiA8PCA2KSB8XG4gICAgICAgICAgKGZsYWdzLmhhc1JlZHVuZGFuY3kgPDwgNCkgfFxuICAgICAgICAgIChmbGFncy5wYWRkaW5nVmFsdWUgPDwgMSkgfFxuICAgICAgICAgIGZsYWdzLmlzTm9uU3luYyxcbiAgICAgICAgZmxhZ3MuZGVncmFkUHJpbyAmIDB4RjAgPDwgOCxcbiAgICAgICAgZmxhZ3MuZGVncmFkUHJpbyAmIDB4MEYsIC8vIHNhbXBsZV9mbGFnc1xuICAgICAgICAoY3RzID4+PiAyNCkgJiAweEZGLFxuICAgICAgICAoY3RzID4+PiAxNikgJiAweEZGLFxuICAgICAgICAoY3RzID4+PiA4KSAmIDB4RkYsXG4gICAgICAgIGN0cyAmIDB4RkYgLy8gc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgICBdLCAxMiArIDE2ICogaSk7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cnVuLCBhcnJheSk7XG4gIH1cblxuICBzdGF0aWMgaW5pdFNlZ21lbnQgKHRyYWNrcykge1xuICAgIGlmICghTVA0LnR5cGVzKSB7XG4gICAgICBNUDQuaW5pdCgpO1xuICAgIH1cblxuICAgIGxldCBtb3ZpZSA9IE1QNC5tb292KHRyYWNrcyksIHJlc3VsdDtcbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShNUDQuRlRZUC5ieXRlTGVuZ3RoICsgbW92aWUuYnl0ZUxlbmd0aCk7XG4gICAgcmVzdWx0LnNldChNUDQuRlRZUCk7XG4gICAgcmVzdWx0LnNldChtb3ZpZSwgTVA0LkZUWVAuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNUDQ7XG4iLCIvKipcbiAqIGZNUDQgcmVtdXhlclxuKi9cblxuaW1wb3J0IEFBQyBmcm9tICcuL2FhYy1oZWxwZXInO1xuaW1wb3J0IE1QNCBmcm9tICcuL21wNC1nZW5lcmF0b3InO1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbi8vIDEwIHNlY29uZHNcbmNvbnN0IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gPSAxMCAqIDEwMDA7XG5cbmNsYXNzIE1QNFJlbXV4ZXIge1xuICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgdmVuZG9yKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICB0aGlzLmlzU2FmYXJpID0gdmVuZG9yICYmIHZlbmRvci5pbmRleE9mKCdBcHBsZScpID4gLTEgJiYgdXNlckFnZW50ICYmICF1c2VyQWdlbnQubWF0Y2goJ0NyaU9TJyk7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gIH1cblxuICByZXNldFRpbWVTdGFtcCAoZGVmYXVsdFRpbWVTdGFtcCkge1xuICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gZGVmYXVsdFRpbWVTdGFtcDtcbiAgfVxuXG4gIHJlc2V0SW5pdFNlZ21lbnQgKCkge1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHJlbXV4IChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICAvLyBnZW5lcmF0ZSBJbml0IFNlZ21lbnQgaWYgbmVlZGVkXG4gICAgaWYgKCF0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgIGNvbnN0IG5iQXVkaW9TYW1wbGVzID0gYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5iVmlkZW9TYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aDtcbiAgICAgIGxldCBhdWRpb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgICAgbGV0IHZpZGVvVGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG4gICAgICBpZiAobmJBdWRpb1NhbXBsZXMgJiYgbmJWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgLy8gdGltZU9mZnNldCBpcyBleHBlY3RlZCB0byBiZSB0aGUgb2Zmc2V0IG9mIHRoZSBmaXJzdCB0aW1lc3RhbXAgb2YgdGhpcyBmcmFnbWVudCAoZmlyc3QgRFRTKVxuICAgICAgICAvLyBpZiBmaXJzdCBhdWRpbyBEVFMgaXMgbm90IGFsaWduZWQgd2l0aCBmaXJzdCB2aWRlbyBEVFMgdGhlbiB3ZSBuZWVkIHRvIHRha2UgdGhhdCBpbnRvIGFjY291bnRcbiAgICAgICAgLy8gd2hlbiBwcm92aWRpbmcgdGltZU9mZnNldCB0byByZW11eEF1ZGlvIC8gcmVtdXhWaWRlby4gaWYgd2UgZG9uJ3QgZG8gdGhhdCwgdGhlcmUgbWlnaHQgYmUgYSBwZXJtYW5lbnQgLyBzbWFsbFxuICAgICAgICAvLyBkcmlmdCBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbyBzdHJlYW1zXG4gICAgICAgIGxldCBhdWRpb3ZpZGVvRGVsdGFEdHMgPSAoYXVkaW9UcmFjay5zYW1wbGVzWzBdLnB0cyAtIHZpZGVvVHJhY2suc2FtcGxlc1swXS5wdHMpIC8gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgYXVkaW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIGF1ZGlvdmlkZW9EZWx0YUR0cyk7XG4gICAgICAgIHZpZGVvVGltZU9mZnNldCArPSBNYXRoLm1heCgwLCAtYXVkaW92aWRlb0RlbHRhRHRzKTtcbiAgICAgIH1cbiAgICAgIC8vIFB1cnBvc2VmdWxseSByZW11eGluZyBhdWRpbyBiZWZvcmUgdmlkZW8sIHNvIHRoYXQgcmVtdXhWaWRlbyBjYW4gdXNlIG5leHRBdWRpb1B0cywgd2hpY2ggaXNcbiAgICAgIC8vIGNhbGN1bGF0ZWQgaW4gcmVtdXhBdWRpby5cbiAgICAgIC8vIGxvZ2dlci5sb2coJ25iIEFBQyBzYW1wbGVzOicgKyBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICAgIGlmIChuYkF1ZGlvU2FtcGxlcykge1xuICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgdmlkZW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxuICAgICAgICBpZiAoIWF1ZGlvVHJhY2sudGltZXNjYWxlKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ3JlZ2VuZXJhdGUgSW5pdFNlZ21lbnQgYXMgYXVkaW8gZGV0ZWN0ZWQnKTtcbiAgICAgICAgICB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGF1ZGlvRGF0YSA9IHRoaXMucmVtdXhBdWRpbyhhdWRpb1RyYWNrLCBhdWRpb1RpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ25iIEFWQyBzYW1wbGVzOicgKyB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKG5iVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgbGV0IGF1ZGlvVHJhY2tMZW5ndGg7XG4gICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xuICAgICAgICAgICAgYXVkaW9UcmFja0xlbmd0aCA9IGF1ZGlvRGF0YS5lbmRQVFMgLSBhdWRpb0RhdGEuc3RhcnRQVFM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IHZpZGVvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cbiAgICAgICAgICBpZiAoIXZpZGVvVHJhY2sudGltZXNjYWxlKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybigncmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyB2aWRlbyBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjaywgdmlkZW9UaW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhdWRpb1RyYWNrTGVuZ3RoLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsb2dnZXIubG9nKCduYiBBVkMgc2FtcGxlczonICsgdmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgICAgIGlmIChuYlZpZGVvU2FtcGxlcykge1xuICAgICAgICAgIGxldCB2aWRlb0RhdGEgPSB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjaywgdmlkZW9UaW1lT2Zmc2V0LCBjb250aWd1b3VzLCAwLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICAgIGlmICh2aWRlb0RhdGEgJiYgYXVkaW9UcmFjay5jb2RlYykge1xuICAgICAgICAgICAgdGhpcy5yZW11eEVtcHR5QXVkaW8oYXVkaW9UcmFjaywgYXVkaW9UaW1lT2Zmc2V0LCBjb250aWd1b3VzLCB2aWRlb0RhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBsb2dnZXIubG9nKCduYiBJRDMgc2FtcGxlczonICsgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgaWYgKGlkM1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJlbXV4SUQzKGlkM1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICB9XG5cbiAgICAvLyBsb2dnZXIubG9nKCduYiBJRDMgc2FtcGxlczonICsgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgaWYgKHRleHRUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5yZW11eFRleHQodGV4dFRyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICB9XG5cbiAgICAvLyBub3RpZnkgZW5kIG9mIHBhcnNpbmdcbiAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTRUQpO1xuICB9XG5cbiAgZ2VuZXJhdGVJUyAoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCkge1xuICAgIGxldCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIsXG4gICAgICBhdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXMsXG4gICAgICB2aWRlb1NhbXBsZXMgPSB2aWRlb1RyYWNrLnNhbXBsZXMsXG4gICAgICB0eXBlU3VwcG9ydGVkID0gdGhpcy50eXBlU3VwcG9ydGVkLFxuICAgICAgY29udGFpbmVyID0gJ2F1ZGlvL21wNCcsXG4gICAgICB0cmFja3MgPSB7fSxcbiAgICAgIGRhdGEgPSB7IHRyYWNrczogdHJhY2tzIH0sXG4gICAgICBjb21wdXRlUFRTRFRTID0gKHRoaXMuX2luaXRQVFMgPT09IHVuZGVmaW5lZCksXG4gICAgICBpbml0UFRTLCBpbml0RFRTO1xuXG4gICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgaWYgKGF1ZGlvVHJhY2suY29uZmlnICYmIGF1ZGlvU2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIC8vIGxldCdzIHVzZSBhdWRpbyBzYW1wbGluZyByYXRlIGFzIE1QNCB0aW1lIHNjYWxlLlxuICAgICAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgdGhlcmUgaXMgYSBpbnRlZ2VyIG5iIG9mIGF1ZGlvIGZyYW1lcyBwZXIgYXVkaW8gc2FtcGxlICgxMDI0IGZvciBBQUMpXG4gICAgICAvLyB1c2luZyBhdWRpbyBzYW1wbGluZyByYXRlIGhlcmUgaGVscHMgaGF2aW5nIGFuIGludGVnZXIgTVA0IGZyYW1lIGR1cmF0aW9uXG4gICAgICAvLyB0aGlzIGF2b2lkcyBwb3RlbnRpYWwgcm91bmRpbmcgaXNzdWUgYW5kIEFWIHN5bmMgaXNzdWVcbiAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gYXVkaW9UcmFjay5zYW1wbGVyYXRlO1xuICAgICAgbG9nZ2VyLmxvZyhgYXVkaW8gc2FtcGxpbmcgcmF0ZSA6ICR7YXVkaW9UcmFjay5zYW1wbGVyYXRlfWApO1xuICAgICAgaWYgKCFhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICAgIGlmICh0eXBlU3VwcG9ydGVkLm1wZWcpIHsgLy8gQ2hyb21lIGFuZCBTYWZhcmlcbiAgICAgICAgICBjb250YWluZXIgPSAnYXVkaW8vbXBlZyc7XG4gICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVTdXBwb3J0ZWQubXAzKSB7IC8vIEZpcmVmb3hcbiAgICAgICAgICBhdWRpb1RyYWNrLmNvZGVjID0gJ21wMyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyYWNrcy5hdWRpbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIGNvZGVjOiBhdWRpb1RyYWNrLmNvZGVjLFxuICAgICAgICBpbml0U2VnbWVudDogIWF1ZGlvVHJhY2suaXNBQUMgJiYgdHlwZVN1cHBvcnRlZC5tcGVnID8gbmV3IFVpbnQ4QXJyYXkoKSA6IE1QNC5pbml0U2VnbWVudChbYXVkaW9UcmFja10pLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGNoYW5uZWxDb3VudDogYXVkaW9UcmFjay5jaGFubmVsQ291bnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiB0aGlzIGRlbXV4aW5nIGNvbnRleHQuIGZvciBhdWRpbywgUFRTID0gRFRTXG4gICAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gYXVkaW9TYW1wbGVzWzBdLnB0cyAtIGF1ZGlvVHJhY2suaW5wdXRUaW1lU2NhbGUgKiB0aW1lT2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2aWRlb1RyYWNrLnNwcyAmJiB2aWRlb1RyYWNrLnBwcyAmJiB2aWRlb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAvLyBsZXQncyB1c2UgaW5wdXQgdGltZSBzY2FsZSBhcyBNUDQgdmlkZW8gdGltZXNjYWxlXG4gICAgICAvLyB3ZSB1c2UgaW5wdXQgdGltZSBzY2FsZSBzdHJhaWdodCBhd2F5IHRvIGF2b2lkIHJvdW5kaW5nIGlzc3VlcyBvbiBmcmFtZSBkdXJhdGlvbiAvIGN0cyBjb21wdXRhdGlvblxuICAgICAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgdmlkZW9UcmFjay50aW1lc2NhbGUgPSBpbnB1dFRpbWVTY2FsZTtcbiAgICAgIHRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgY29kZWM6IHZpZGVvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50OiBNUDQuaW5pdFNlZ21lbnQoW3ZpZGVvVHJhY2tdKSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICB3aWR0aDogdmlkZW9UcmFjay53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHZpZGVvVHJhY2suaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICBpbml0UFRTID0gTWF0aC5taW4oaW5pdFBUUywgdmlkZW9TYW1wbGVzWzBdLnB0cyAtIGlucHV0VGltZVNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgIGluaXREVFMgPSBNYXRoLm1pbihpbml0RFRTLCB2aWRlb1NhbXBsZXNbMF0uZHRzIC0gaW5wdXRUaW1lU2NhbGUgKiB0aW1lT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LklOSVRfUFRTX0ZPVU5ELCB7IGluaXRQVFM6IGluaXRQVFMgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHRyYWNrcykubGVuZ3RoKSB7XG4gICAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIGRhdGEpO1xuICAgICAgdGhpcy5JU0dlbmVyYXRlZCA9IHRydWU7XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICB0aGlzLl9pbml0UFRTID0gaW5pdFBUUztcbiAgICAgICAgdGhpcy5faW5pdERUUyA9IGluaXREVFM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdubyBhdWRpby92aWRlbyBzYW1wbGVzIGZvdW5kJyB9KTtcbiAgICB9XG4gIH1cblxuICByZW11eFZpZGVvICh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYXVkaW9UcmFja0xlbmd0aCwgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgbGV0IG9mZnNldCA9IDg7XG4gICAgbGV0IG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgIGxldCBtZGF0O1xuICAgIGxldCBtb29mO1xuICAgIGxldCBmaXJzdFBUUztcbiAgICBsZXQgZmlyc3REVFM7XG4gICAgbGV0IGxhc3RQVFM7XG4gICAgbGV0IGxhc3REVFM7XG4gICAgY29uc3QgdGltZVNjYWxlID0gdHJhY2sudGltZXNjYWxlO1xuICAgIGNvbnN0IGlucHV0U2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgY29uc3Qgb3V0cHV0U2FtcGxlcyA9IFtdO1xuICAgIGNvbnN0IG5iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7XG4gICAgY29uc3QgcHRzTm9ybWFsaXplID0gdGhpcy5fUFRTTm9ybWFsaXplO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuXG4gICAgLy8gaWYgcGFyc2VkIGZyYWdtZW50IGlzIGNvbnRpZ3VvdXMgd2l0aCBsYXN0IG9uZSwgbGV0J3MgdXNlIGxhc3QgRFRTIHZhbHVlIGFzIHJlZmVyZW5jZVxuICAgIGxldCBuZXh0QXZjRHRzID0gdGhpcy5uZXh0QXZjRHRzO1xuXG4gICAgY29uc3QgaXNTYWZhcmkgPSB0aGlzLmlzU2FmYXJpO1xuXG4gICAgaWYgKG5iU2FtcGxlcyA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNhZmFyaSBkb2VzIG5vdCBsaWtlIG92ZXJsYXBwaW5nIERUUyBvbiBjb25zZWN1dGl2ZSBmcmFnbWVudHMuIGxldCdzIHVzZSBuZXh0QXZjRHRzIHRvIG92ZXJjb21lIHRoaXMgaWYgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZVxuICAgIGlmIChpc1NhZmFyaSkge1xuICAgICAgLy8gYWxzbyBjb25zaWRlciBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXMgYmVpbmcgY29udGlndW91cyAoZXZlbiBpZiBhIGxldmVsIHN3aXRjaCBvY2N1cnMpLFxuICAgICAgLy8gZm9yIHNha2Ugb2YgY2xhcml0eTpcbiAgICAgIC8vIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcmUgZnJhZ3Mgd2l0aFxuICAgICAgLy8gIC0gbGVzcyB0aGFuIDEwMG1zIGdhcHMgYmV0d2VlbiBuZXcgdGltZSBvZmZzZXQgKGlmIGFjY3VyYXRlKSBhbmQgbmV4dCBleHBlY3RlZCBQVFMgT1JcbiAgICAgIC8vICAtIGxlc3MgdGhhbiAyMDAgbXMgUFRTIGdhcHMgKHRpbWVTY2FsZS81KVxuICAgICAgY29udGlndW91cyB8PSAoaW5wdXRTYW1wbGVzLmxlbmd0aCAmJiBuZXh0QXZjRHRzICYmXG4gICAgICAgICAgICAgICAgICAgICAoKGFjY3VyYXRlVGltZU9mZnNldCAmJiBNYXRoLmFicyh0aW1lT2Zmc2V0IC0gbmV4dEF2Y0R0cyAvIHRpbWVTY2FsZSkgPCAwLjEpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoKGlucHV0U2FtcGxlc1swXS5wdHMgLSBuZXh0QXZjRHRzIC0gaW5pdFBUUykpIDwgdGltZVNjYWxlIC8gNSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb250aWd1b3VzKSB7XG4gICAgICAvLyBpZiBub3QgY29udGlndW91cywgbGV0J3MgdXNlIHRhcmdldCB0aW1lT2Zmc2V0XG4gICAgICBuZXh0QXZjRHRzID0gdGltZU9mZnNldCAqIHRpbWVTY2FsZTtcbiAgICB9XG5cbiAgICAvLyBQVFMgaXMgY29kZWQgb24gMzNiaXRzLCBhbmQgY2FuIGxvb3AgZnJvbSAtMl4zMiB0byAyXjMyXG4gICAgLy8gcHRzTm9ybWFsaXplIHdpbGwgbWFrZSBQVFMvRFRTIHZhbHVlIG1vbm90b25pYywgd2UgdXNlIGxhc3Qga25vd24gRFRTIHZhbHVlIGFzIHJlZmVyZW5jZSB2YWx1ZVxuICAgIGlucHV0U2FtcGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgIHNhbXBsZS5wdHMgPSBwdHNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIGluaXRQVFMsIG5leHRBdmNEdHMpO1xuICAgICAgc2FtcGxlLmR0cyA9IHB0c05vcm1hbGl6ZShzYW1wbGUuZHRzIC0gaW5pdFBUUywgbmV4dEF2Y0R0cyk7XG4gICAgfSk7XG5cbiAgICAvLyBzb3J0IHZpZGVvIHNhbXBsZXMgYnkgRFRTIHRoZW4gUFRTIHRoZW4gZGVtdXggaWQgb3JkZXJcbiAgICBpbnB1dFNhbXBsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgY29uc3QgZGVsdGFkdHMgPSBhLmR0cyAtIGIuZHRzO1xuICAgICAgY29uc3QgZGVsdGFwdHMgPSBhLnB0cyAtIGIucHRzO1xuICAgICAgcmV0dXJuIGRlbHRhZHRzIHx8IChkZWx0YXB0cyB8fCAoYS5pZCAtIGIuaWQpKTtcbiAgICB9KTtcblxuICAgIC8vIGhhbmRsZSBicm9rZW4gc3RyZWFtcyB3aXRoIFBUUyA8IERUUywgdG9sZXJhbmNlIHVwIDIwMG1zICgxODAwMCBpbiA5MGtIeiB0aW1lc2NhbGUpXG4gICAgbGV0IFBUU0RUU3NoaWZ0ID0gaW5wdXRTYW1wbGVzLnJlZHVjZSgocHJldiwgY3VycikgPT4gTWF0aC5tYXgoTWF0aC5taW4ocHJldiwgY3Vyci5wdHMgLSBjdXJyLmR0cyksIC0xODAwMCksIDApO1xuICAgIGlmIChQVFNEVFNzaGlmdCA8IDApIHtcbiAgICAgIGxvZ2dlci53YXJuKGBQVFMgPCBEVFMgZGV0ZWN0ZWQgaW4gdmlkZW8gc2FtcGxlcywgc2hpZnRpbmcgRFRTIGJ5ICR7TWF0aC5yb3VuZChQVFNEVFNzaGlmdCAvIDkwKX0gbXMgdG8gb3ZlcmNvbWUgdGhpcyBpc3N1ZWApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW5wdXRTYW1wbGVzW2ldLmR0cyArPSBQVFNEVFNzaGlmdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIGZpcnN0IERUUyBhbmQgbGFzdCBEVFMsIG5vcm1hbGl6ZSB0aGVtIGFnYWluc3QgcmVmZXJlbmNlIHZhbHVlXG4gICAgbGV0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1swXTtcbiAgICBmaXJzdERUUyA9IE1hdGgubWF4KHNhbXBsZS5kdHMsIDApO1xuICAgIGZpcnN0UFRTID0gTWF0aC5tYXgoc2FtcGxlLnB0cywgMCk7XG5cbiAgICAvLyBjaGVjayB0aW1lc3RhbXAgY29udGludWl0eSBhY2Nyb3NzIGNvbnNlY3V0aXZlIGZyYWdtZW50cyAodGhpcyBpcyB0byByZW1vdmUgaW50ZXItZnJhZ21lbnQgZ2FwL2hvbGUpXG4gICAgbGV0IGRlbHRhID0gTWF0aC5yb3VuZCgoZmlyc3REVFMgLSBuZXh0QXZjRHRzKSAvIDkwKTtcbiAgICAvLyBpZiBmcmFnbWVudCBhcmUgY29udGlndW91cywgZGV0ZWN0IGhvbGUvb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHNcbiAgICBpZiAoY29udGlndW91cykge1xuICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgIGlmIChkZWx0YSA+IDEpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBBVkM6JHtkZWx0YX0gbXMgaG9sZSBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCxmaWxsaW5nIGl0YCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPCAtMSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coYEFWQzokeygtZGVsdGEpfSBtcyBvdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGhvbGUvZ2FwIDogc2V0IERUUyB0byBuZXh0IGV4cGVjdGVkIERUU1xuICAgICAgICBmaXJzdERUUyA9IG5leHRBdmNEdHM7XG4gICAgICAgIGlucHV0U2FtcGxlc1swXS5kdHMgPSBmaXJzdERUUztcbiAgICAgICAgLy8gb2Zmc2V0IFBUUyBhcyB3ZWxsLCBlbnN1cmUgdGhhdCBQVFMgaXMgc21hbGxlciBvciBlcXVhbCB0aGFuIG5ldyBEVFNcbiAgICAgICAgZmlyc3RQVFMgPSBNYXRoLm1heChmaXJzdFBUUyAtIGRlbHRhLCBuZXh0QXZjRHRzKTtcbiAgICAgICAgaW5wdXRTYW1wbGVzWzBdLnB0cyA9IGZpcnN0UFRTO1xuICAgICAgICBsb2dnZXIubG9nKGBWaWRlby9QVFMvRFRTIGFkanVzdGVkOiAke01hdGgucm91bmQoZmlyc3RQVFMgLyA5MCl9LyR7TWF0aC5yb3VuZChmaXJzdERUUyAvIDkwKX0sZGVsdGE6JHtkZWx0YX0gbXNgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIGxhc3RQVFMvbGFzdERUU1xuICAgIHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpbnB1dFNhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgbGFzdERUUyA9IE1hdGgubWF4KHNhbXBsZS5kdHMsIDApO1xuICAgIGxhc3RQVFMgPSBNYXRoLm1heChzYW1wbGUucHRzLCAwLCBsYXN0RFRTKTtcblxuICAgIC8vIG9uIFNhZmFyaSBsZXQncyBzaWduYWwgdGhlIHNhbWUgc2FtcGxlIGR1cmF0aW9uIGZvciBhbGwgc2FtcGxlc1xuICAgIC8vIHNhbXBsZSBkdXJhdGlvbiAoYXMgZXhwZWN0ZWQgYnkgdHJ1biBNUDQgYm94ZXMpLCBzaG91bGQgYmUgdGhlIGRlbHRhIGJldHdlZW4gc2FtcGxlIERUU1xuICAgIC8vIHNldCB0aGlzIGNvbnN0YW50IGR1cmF0aW9uIGFzIGJlaW5nIHRoZSBhdmcgZGVsdGEgYmV0d2VlbiBjb25zZWN1dGl2ZSBEVFMuXG4gICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IE1hdGgucm91bmQoKGxhc3REVFMgLSBmaXJzdERUUykgLyAoaW5wdXRTYW1wbGVzLmxlbmd0aCAtIDEpKTtcbiAgICB9XG5cbiAgICBsZXQgbmJOYWx1ID0gMCwgbmFsdUxlbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgLy8gY29tcHV0ZSB0b3RhbC9hdmMgc2FtcGxlIGxlbmd0aCBhbmQgbmIgb2YgTkFMIHVuaXRzXG4gICAgICBsZXQgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldLCB1bml0cyA9IHNhbXBsZS51bml0cywgbmJVbml0cyA9IHVuaXRzLmxlbmd0aCwgc2FtcGxlTGVuID0gMDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmJVbml0czsgaisrKSB7XG4gICAgICAgIHNhbXBsZUxlbiArPSB1bml0c1tqXS5kYXRhLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgbmFsdUxlbiArPSBzYW1wbGVMZW47XG4gICAgICBuYk5hbHUgKz0gbmJVbml0cztcbiAgICAgIHNhbXBsZS5sZW5ndGggPSBzYW1wbGVMZW47XG5cbiAgICAgIC8vIG5vcm1hbGl6ZSBQVFMvRFRTXG4gICAgICBpZiAoaXNTYWZhcmkpIHtcbiAgICAgICAgLy8gc2FtcGxlIERUUyBpcyBjb21wdXRlZCB1c2luZyBhIGNvbnN0YW50IGRlY29kaW5nIG9mZnNldCAobXA0U2FtcGxlRHVyYXRpb24pIGJldHdlZW4gc2FtcGxlc1xuICAgICAgICBzYW1wbGUuZHRzID0gZmlyc3REVFMgKyBpICogbXA0U2FtcGxlRHVyYXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbnN1cmUgc2FtcGxlIG1vbm90b25pYyBEVFNcbiAgICAgICAgc2FtcGxlLmR0cyA9IE1hdGgubWF4KHNhbXBsZS5kdHMsIGZpcnN0RFRTKTtcbiAgICAgIH1cbiAgICAgIC8vIGVuc3VyZSB0aGF0IGNvbXB1dGVkIHZhbHVlIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiBzYW1wbGUgRFRTXG4gICAgICBzYW1wbGUucHRzID0gTWF0aC5tYXgoc2FtcGxlLnB0cywgc2FtcGxlLmR0cyk7XG4gICAgfVxuXG4gICAgLyogY29uY2F0ZW5hdGUgdGhlIHZpZGVvIGRhdGEgYW5kIGNvbnN0cnVjdCB0aGUgbWRhdCBpbiBwbGFjZVxuICAgICAgKG5lZWQgOCBtb3JlIGJ5dGVzIHRvIGZpbGwgbGVuZ3RoIGFuZCBtcGRhdCB0eXBlKSAqL1xuICAgIGxldCBtZGF0U2l6ZSA9IG5hbHVMZW4gKyAoNCAqIG5iTmFsdSkgKyA4O1xuICAgIHRyeSB7XG4gICAgICBtZGF0ID0gbmV3IFVpbnQ4QXJyYXkobWRhdFNpemUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTVVYX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1IsIGZhdGFsOiBmYWxzZSwgYnl0ZXM6IG1kYXRTaXplLCByZWFzb246IGBmYWlsIGFsbG9jYXRpbmcgdmlkZW8gbWRhdCAke21kYXRTaXplfWAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcbiAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgbWRhdC5zZXQoTVA0LnR5cGVzLm1kYXQsIDQpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgbGV0IGF2Y1NhbXBsZSA9IGlucHV0U2FtcGxlc1tpXSxcbiAgICAgICAgYXZjU2FtcGxlVW5pdHMgPSBhdmNTYW1wbGUudW5pdHMsXG4gICAgICAgIG1wNFNhbXBsZUxlbmd0aCA9IDAsXG4gICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldDtcbiAgICAgIC8vIGNvbnZlcnQgTkFMVSBiaXRzdHJlYW0gdG8gTVA0IGZvcm1hdCAocHJlcGVuZCBOQUxVIHdpdGggc2l6ZSBmaWVsZClcbiAgICAgIGZvciAobGV0IGogPSAwLCBuYlVuaXRzID0gYXZjU2FtcGxlVW5pdHMubGVuZ3RoOyBqIDwgbmJVbml0czsgaisrKSB7XG4gICAgICAgIGxldCB1bml0ID0gYXZjU2FtcGxlVW5pdHNbal0sXG4gICAgICAgICAgdW5pdERhdGEgPSB1bml0LmRhdGEsXG4gICAgICAgICAgdW5pdERhdGFMZW4gPSB1bml0LmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCB1bml0RGF0YUxlbik7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBtZGF0LnNldCh1bml0RGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IHVuaXREYXRhTGVuO1xuICAgICAgICBtcDRTYW1wbGVMZW5ndGggKz0gNCArIHVuaXREYXRhTGVuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzU2FmYXJpKSB7XG4gICAgICAgIC8vIGV4cGVjdGVkIHNhbXBsZSBkdXJhdGlvbiBpcyB0aGUgRGVjb2RpbmcgVGltZXN0YW1wIGRpZmYgb2YgY29uc2VjdXRpdmUgc2FtcGxlc1xuICAgICAgICBpZiAoaSA8IG5iU2FtcGxlcyAtIDEpIHtcbiAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGlucHV0U2FtcGxlc1tpICsgMV0uZHRzIC0gYXZjU2FtcGxlLmR0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgICAgICBsYXN0RnJhbWVEdXJhdGlvbiA9IGF2Y1NhbXBsZS5kdHMgLSBpbnB1dFNhbXBsZXNbaSA+IDAgPyBpIC0gMSA6IGldLmR0cztcbiAgICAgICAgICBpZiAoY29uZmlnLnN0cmV0Y2hTaG9ydFZpZGVvVHJhY2spIHtcbiAgICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMsIGEgc2VnbWVudCdzIGF1ZGlvIHRyYWNrIGR1cmF0aW9uIG1heSBleGNlZWQgdGhlIHZpZGVvIHRyYWNrIGR1cmF0aW9uLlxuICAgICAgICAgICAgLy8gU2luY2Ugd2UndmUgYWxyZWFkeSByZW11eGVkIGF1ZGlvLCBhbmQgd2Uga25vdyBob3cgbG9uZyB0aGUgYXVkaW8gdHJhY2sgaXMsIHdlIGxvb2sgdG9cbiAgICAgICAgICAgIC8vIHNlZSBpZiB0aGUgZGVsdGEgdG8gdGhlIG5leHQgc2VnbWVudCBpcyBsb25nZXIgdGhhbiBtYXhCdWZmZXJIb2xlLlxuICAgICAgICAgICAgLy8gSWYgc28sIHBsYXliYWNrIHdvdWxkIHBvdGVudGlhbGx5IGdldCBzdHVjaywgc28gd2UgYXJ0aWZpY2lhbGx5IGluZmxhdGVcbiAgICAgICAgICAgIC8vIHRoZSBkdXJhdGlvbiBvZiB0aGUgbGFzdCBmcmFtZSB0byBtaW5pbWl6ZSBhbnkgcG90ZW50aWFsIGdhcCBiZXR3ZWVuIHNlZ21lbnRzLlxuICAgICAgICAgICAgbGV0IG1heEJ1ZmZlckhvbGUgPSBjb25maWcubWF4QnVmZmVySG9sZSxcbiAgICAgICAgICAgICAgZ2FwVG9sZXJhbmNlID0gTWF0aC5mbG9vcihtYXhCdWZmZXJIb2xlICogdGltZVNjYWxlKSxcbiAgICAgICAgICAgICAgZGVsdGFUb0ZyYW1lRW5kID0gKGF1ZGlvVHJhY2tMZW5ndGggPyBmaXJzdFBUUyArIGF1ZGlvVHJhY2tMZW5ndGggKiB0aW1lU2NhbGUgOiB0aGlzLm5leHRBdWRpb1B0cykgLSBhdmNTYW1wbGUucHRzO1xuICAgICAgICAgICAgaWYgKGRlbHRhVG9GcmFtZUVuZCA+IGdhcFRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAvLyBXZSBzdWJ0cmFjdCBsYXN0RnJhbWVEdXJhdGlvbiBmcm9tIGRlbHRhVG9GcmFtZUVuZCB0byB0cnkgdG8gcHJldmVudCBhbnkgdmlkZW9cbiAgICAgICAgICAgICAgLy8gZnJhbWUgb3ZlcmxhcC4gbWF4QnVmZmVySG9sZSBzaG91bGQgYmUgPj4gbGFzdEZyYW1lRHVyYXRpb24gYW55d2F5LlxuICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGRlbHRhVG9GcmFtZUVuZCAtIGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgICBpZiAobXA0U2FtcGxlRHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYEl0IGlzIGFwcHJveGltYXRlbHkgJHtkZWx0YVRvRnJhbWVFbmQgLyA5MH0gbXMgdG8gdGhlIG5leHQgc2VnbWVudDsgdXNpbmcgZHVyYXRpb24gJHttcDRTYW1wbGVEdXJhdGlvbiAvIDkwfSBtcyBmb3IgdGhlIGxhc3QgdmlkZW8gZnJhbWUuYCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSBNYXRoLnJvdW5kKGF2Y1NhbXBsZS5wdHMgLSBhdmNTYW1wbGUuZHRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgubWF4KDAsIG1wNFNhbXBsZUR1cmF0aW9uICogTWF0aC5yb3VuZCgoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpIC8gbXA0U2FtcGxlRHVyYXRpb24pKTtcbiAgICAgIH1cblxuICAgICAgLy8gY29uc29sZS5sb2coJ1BUUy9EVFMvaW5pdERUUy9ub3JtUFRTL25vcm1EVFMvcmVsYXRpdmUgUFRTIDogJHthdmNTYW1wbGUucHRzfS8ke2F2Y1NhbXBsZS5kdHN9LyR7aW5pdERUU30vJHtwdHNub3JtfS8ke2R0c25vcm19LyR7KGF2Y1NhbXBsZS5wdHMvNDI5NDk2NzI5NikudG9GaXhlZCgzKX0nKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBhdmNTYW1wbGUuZHRzOiAke2F2Y1NhbXBsZS5kdHMgLyA5MH0sIGF2Y1NhbXBsZS5wdHM6ICR7YXZjU2FtcGxlLnB0cyAvIDkwfSwgbXA0U2FtcGxlRHVyYXRpb246ICR7bXA0U2FtcGxlRHVyYXRpb24gLyA5MH1gLCBhdmNTYW1wbGUpXG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2goe1xuICAgICAgICBzaXplOiBtcDRTYW1wbGVMZW5ndGgsXG4gICAgICAgIC8vIGNvbnN0YW50IGR1cmF0aW9uXG4gICAgICAgIGR1cmF0aW9uOiBtcDRTYW1wbGVEdXJhdGlvbixcbiAgICAgICAgY3RzOiBjb21wb3NpdGlvblRpbWVPZmZzZXQsXG4gICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgICAgIGRlZ3JhZFByaW86IDAsXG4gICAgICAgICAgZGVwZW5kc09uOiBhdmNTYW1wbGUua2V5ID8gMiA6IDEsXG4gICAgICAgICAgaXNOb25TeW5jOiBhdmNTYW1wbGUua2V5ID8gMCA6IDFcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIG5leHQgQVZDIHNhbXBsZSBEVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIERUUyArIGxhc3Qgc2FtcGxlIGR1cmF0aW9uIChpbiBQRVMgdGltZXNjYWxlKVxuICAgIHRoaXMubmV4dEF2Y0R0cyA9IGxhc3REVFMgKyBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICBsZXQgZHJvcHBlZCA9IHRyYWNrLmRyb3BwZWQ7XG4gICAgdHJhY2subGVuID0gMDtcbiAgICB0cmFjay5uYk5hbHUgPSAwO1xuICAgIHRyYWNrLmRyb3BwZWQgPSAwO1xuICAgIGlmIChvdXRwdXRTYW1wbGVzLmxlbmd0aCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY2hyb21lJykgPiAtMSkge1xuICAgICAgbGV0IGZsYWdzID0gb3V0cHV0U2FtcGxlc1swXS5mbGFncztcbiAgICAgIC8vIGNocm9tZSB3b3JrYXJvdW5kLCBtYXJrIGZpcnN0IHNhbXBsZSBhcyBiZWluZyBhIFJhbmRvbSBBY2Nlc3MgUG9pbnQgdG8gYXZvaWQgc291cmNlYnVmZmVyIGFwcGVuZCBpc3N1ZVxuICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTQxMlxuICAgICAgZmxhZ3MuZGVwZW5kc09uID0gMjtcbiAgICAgIGZsYWdzLmlzTm9uU3luYyA9IDA7XG4gICAgfVxuICAgIHRyYWNrLnNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzO1xuICAgIG1vb2YgPSBNUDQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdERUUywgdHJhY2spO1xuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcblxuICAgIGxldCBkYXRhID0ge1xuICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICBkYXRhMjogbWRhdCxcbiAgICAgIHN0YXJ0UFRTOiBmaXJzdFBUUyAvIHRpbWVTY2FsZSxcbiAgICAgIGVuZFBUUzogKGxhc3RQVFMgKyBtcDRTYW1wbGVEdXJhdGlvbikgLyB0aW1lU2NhbGUsXG4gICAgICBzdGFydERUUzogZmlyc3REVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmREVFM6IHRoaXMubmV4dEF2Y0R0cyAvIHRpbWVTY2FsZSxcbiAgICAgIHR5cGU6ICd2aWRlbycsXG4gICAgICBoYXNBdWRpbzogZmFsc2UsXG4gICAgICBoYXNWaWRlbzogdHJ1ZSxcbiAgICAgIG5iOiBvdXRwdXRTYW1wbGVzLmxlbmd0aCxcbiAgICAgIGRyb3BwZWQ6IGRyb3BwZWRcbiAgICB9O1xuICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfREFUQSwgZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICByZW11eEF1ZGlvICh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBtcDR0aW1lU2NhbGUgPSB0cmFjay50aW1lc2NhbGU7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZTtcbiAgICBjb25zdCBtcDRTYW1wbGVEdXJhdGlvbiA9IHRyYWNrLmlzQUFDID8gMTAyNCA6IDExNTI7XG4gICAgY29uc3QgaW5wdXRTYW1wbGVEdXJhdGlvbiA9IG1wNFNhbXBsZUR1cmF0aW9uICogc2NhbGVGYWN0b3I7XG4gICAgY29uc3QgcHRzTm9ybWFsaXplID0gdGhpcy5fUFRTTm9ybWFsaXplO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIGNvbnN0IHJhd01QRUcgPSAhdHJhY2suaXNBQUMgJiYgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWc7XG5cbiAgICBsZXQgb2Zmc2V0LFxuICAgICAgbXA0U2FtcGxlLFxuICAgICAgZmlsbEZyYW1lLFxuICAgICAgbWRhdCwgbW9vZixcbiAgICAgIGZpcnN0UFRTLCBsYXN0UFRTLFxuICAgICAgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcyxcbiAgICAgIG91dHB1dFNhbXBsZXMgPSBbXSxcbiAgICAgIG5leHRBdWRpb1B0cyA9IHRoaXMubmV4dEF1ZGlvUHRzO1xuXG4gICAgLy8gZm9yIGF1ZGlvIHNhbXBsZXMsIGFsc28gY29uc2lkZXIgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFzIGJlaW5nIGNvbnRpZ3VvdXMgKGV2ZW4gaWYgYSBsZXZlbCBzd2l0Y2ggb2NjdXJzKSxcbiAgICAvLyBmb3Igc2FrZSBvZiBjbGFyaXR5OlxuICAgIC8vIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcmUgZnJhZ3Mgd2l0aFxuICAgIC8vICAtIGxlc3MgdGhhbiAxMDBtcyBnYXBzIGJldHdlZW4gbmV3IHRpbWUgb2Zmc2V0IChpZiBhY2N1cmF0ZSkgYW5kIG5leHQgZXhwZWN0ZWQgUFRTIE9SXG4gICAgLy8gIC0gbGVzcyB0aGFuIDIwIGF1ZGlvIGZyYW1lcyBkaXN0YW5jZVxuICAgIC8vIGNvbnRpZ3VvdXMgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZSBmcmFnbWVudHMgZnJvbSBzYW1lIHF1YWxpdHkgbGV2ZWwgKHNhbWUgbGV2ZWwsIG5ldyBTTiA9IG9sZCBTTiArIDEpXG4gICAgLy8gdGhpcyBoZWxwcyBlbnN1cmluZyBhdWRpbyBjb250aW51aXR5XG4gICAgLy8gYW5kIHRoaXMgYWxzbyBhdm9pZHMgYXVkaW8gZ2xpdGNoZXMvY3V0IHdoZW4gc3dpdGNoaW5nIHF1YWxpdHksIG9yIHJlcG9ydGluZyB3cm9uZyBkdXJhdGlvbiBvbiBmaXJzdCBhdWRpbyBmcmFtZVxuICAgIGNvbnRpZ3VvdXMgfD0gKGlucHV0U2FtcGxlcy5sZW5ndGggJiYgbmV4dEF1ZGlvUHRzICYmXG4gICAgICAgICAgICAgICAgICAgKChhY2N1cmF0ZVRpbWVPZmZzZXQgJiYgTWF0aC5hYnModGltZU9mZnNldCAtIG5leHRBdWRpb1B0cyAvIGlucHV0VGltZVNjYWxlKSA8IDAuMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoKGlucHV0U2FtcGxlc1swXS5wdHMgLSBuZXh0QXVkaW9QdHMgLSBpbml0UFRTKSkgPCAyMCAqIGlucHV0U2FtcGxlRHVyYXRpb24pXG4gICAgKTtcblxuICAgIC8vIGNvbXB1dGUgbm9ybWFsaXplZCBQVFNcbiAgICBpbnB1dFNhbXBsZXMuZm9yRWFjaChmdW5jdGlvbiAoc2FtcGxlKSB7XG4gICAgICBzYW1wbGUucHRzID0gc2FtcGxlLmR0cyA9IHB0c05vcm1hbGl6ZShzYW1wbGUucHRzIC0gaW5pdFBUUywgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlKTtcbiAgICB9KTtcblxuICAgIC8vIGZpbHRlciBvdXQgc2FtcGxlIHdpdGggbmVnYXRpdmUgUFRTIHRoYXQgYXJlIG5vdCBwbGF5YWJsZSBhbnl3YXlcbiAgICAvLyBpZiB3ZSBkb24ndCByZW1vdmUgdGhlc2UgbmVnYXRpdmUgc2FtcGxlcywgdGhleSB3aWxsIHNoaWZ0IGFsbCBhdWRpbyBzYW1wbGVzIGZvcndhcmQuXG4gICAgLy8gbGVhZGluZyB0byBhdWRpbyBvdmVybGFwIGJldHdlZW4gY3VycmVudCAvIG5leHQgZnJhZ21lbnRcbiAgICBpbnB1dFNhbXBsZXMgPSBpbnB1dFNhbXBsZXMuZmlsdGVyKGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgIHJldHVybiBzYW1wbGUucHRzID49IDA7XG4gICAgfSk7XG5cbiAgICAvLyBpbiBjYXNlIGFsbCBzYW1wbGVzIGhhdmUgbmVnYXRpdmUgUFRTLCBhbmQgaGF2ZSBiZWVuIGZpbHRlcmVkIG91dCwgcmV0dXJuIG5vd1xuICAgIGlmIChpbnB1dFNhbXBsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFjb250aWd1b3VzKSB7XG4gICAgICBpZiAoIWFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgICAvLyBpZiBmcmFnIGFyZSBtb3QgY29udGlndW91cyBhbmQgaWYgd2UgY2FudCB0cnVzdCB0aW1lIG9mZnNldCwgbGV0J3MgdXNlIGZpcnN0IHNhbXBsZSBQVFMgYXMgbmV4dCBhdWRpbyBQVFNcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gaW5wdXRTYW1wbGVzWzBdLnB0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHRpbWVPZmZzZXQgaXMgYWNjdXJhdGUsIGxldCdzIHVzZSBpdCBhcyBwcmVkaWN0ZWQgbmV4dCBhdWRpbyBQVFNcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBhdWRpbyB0cmFjayBpcyBtaXNzaW5nIHNhbXBsZXMsIHRoZSBmcmFtZXMgc2VlbSB0byBnZXQgXCJsZWZ0LXNoaWZ0ZWRcIiB3aXRoaW4gdGhlXG4gICAgLy8gcmVzdWx0aW5nIG1wNCBzZWdtZW50LCBjYXVzaW5nIHN5bmMgaXNzdWVzIGFuZCBsZWF2aW5nIGdhcHMgYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gc2VnbWVudC5cbiAgICAvLyBJbiBhbiBlZmZvcnQgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nLCB3ZSBpbmplY3QgZnJhbWVzIGhlcmUgd2hlcmUgdGhlcmUgYXJlIGdhcHMuXG4gICAgLy8gV2hlbiBwb3NzaWJsZSwgd2UgaW5qZWN0IGEgc2lsZW50IGZyYW1lOyB3aGVuIHRoYXQncyBub3QgcG9zc2libGUsIHdlIGR1cGxpY2F0ZSB0aGUgbGFzdFxuICAgIC8vIGZyYW1lLlxuXG4gICAgaWYgKHRyYWNrLmlzQUFDKSB7XG4gICAgICBjb25zdCBtYXhBdWRpb0ZyYW1lc0RyaWZ0ID0gdGhpcy5jb25maWcubWF4QXVkaW9GcmFtZXNEcmlmdDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBuZXh0UHRzID0gbmV4dEF1ZGlvUHRzOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDspIHtcbiAgICAgICAgLy8gRmlyc3QsIGxldCdzIHNlZSBob3cgZmFyIG9mZiB0aGlzIGZyYW1lIGlzIGZyb20gd2hlcmUgd2UgZXhwZWN0IGl0IHRvIGJlXG4gICAgICAgIHZhciBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV0sIGRlbHRhO1xuICAgICAgICBsZXQgcHRzID0gc2FtcGxlLnB0cztcbiAgICAgICAgZGVsdGEgPSBwdHMgLSBuZXh0UHRzO1xuXG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gTWF0aC5hYnMoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpO1xuXG4gICAgICAgIC8vIElmIHdlJ3JlIG92ZXJsYXBwaW5nIGJ5IG1vcmUgdGhhbiBhIGR1cmF0aW9uLCBkcm9wIHRoaXMgc2FtcGxlXG4gICAgICAgIGlmIChkZWx0YSA8PSAtbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24pIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgRHJvcHBpbmcgMSBhdWRpbyBmcmFtZSBAICR7KG5leHRQdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKX1zIGR1ZSB0byAke01hdGgucm91bmQoZHVyYXRpb24pfSBtcyBvdmVybGFwLmApO1xuICAgICAgICAgIGlucHV0U2FtcGxlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgdHJhY2subGVuIC09IHNhbXBsZS51bml0Lmxlbmd0aDtcbiAgICAgICAgICAvLyBEb24ndCB0b3VjaCBuZXh0UHRzTm9ybSBvciBpXG4gICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBicmFjZS1zdHlsZVxuXG4gICAgICAgIC8vIEluc2VydCBtaXNzaW5nIGZyYW1lcyBpZjpcbiAgICAgICAgLy8gMTogV2UncmUgbW9yZSB0aGFuIG1heEF1ZGlvRnJhbWVzRHJpZnQgZnJhbWUgYXdheVxuICAgICAgICAvLyAyOiBOb3QgbW9yZSB0aGFuIE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gYXdheVxuICAgICAgICAvLyAzOiBjdXJyZW50VGltZSAoYWthIG5leHRQdHNOb3JtKSBpcyBub3QgMFxuICAgICAgICBlbHNlIGlmIChkZWx0YSA+PSBtYXhBdWRpb0ZyYW1lc0RyaWZ0ICogaW5wdXRTYW1wbGVEdXJhdGlvbiAmJiBkdXJhdGlvbiA8IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gJiYgbmV4dFB0cykge1xuICAgICAgICAgIGxldCBtaXNzaW5nID0gTWF0aC5yb3VuZChkZWx0YSAvIGlucHV0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBJbmplY3RpbmcgJHttaXNzaW5nfSBhdWRpbyBmcmFtZSBAICR7KG5leHRQdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKX1zIGR1ZSB0byAke01hdGgucm91bmQoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpfSBtcyBnYXAuYCk7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtaXNzaW5nOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBuZXdTdGFtcCA9IE1hdGgubWF4KG5leHRQdHMsIDApO1xuICAgICAgICAgICAgZmlsbEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKCdVbmFibGUgdG8gZ2V0IHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWM7IGR1cGxpY2F0aW5nIGxhc3QgZnJhbWUgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgZmlsbEZyYW1lID0gc2FtcGxlLnVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0U2FtcGxlcy5zcGxpY2UoaSwgMCwgeyB1bml0OiBmaWxsRnJhbWUsIHB0czogbmV3U3RhbXAsIGR0czogbmV3U3RhbXAgfSk7XG4gICAgICAgICAgICB0cmFjay5sZW4gKz0gZmlsbEZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBZGp1c3Qgc2FtcGxlIHRvIG5leHQgZXhwZWN0ZWQgcHRzXG4gICAgICAgICAgc2FtcGxlLnB0cyA9IHNhbXBsZS5kdHMgPSBuZXh0UHRzO1xuICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwganVzdCBhZGp1c3QgcHRzXG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA+ICgwLjEgKiBpbnB1dFNhbXBsZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZyhgSW52YWxpZCBmcmFtZSBkZWx0YSAke01hdGgucm91bmQoZGVsdGEgKyBpbnB1dFNhbXBsZUR1cmF0aW9uKX0gYXQgUFRTICR7TWF0aC5yb3VuZChwdHMgLyA5MCl9IChzaG91bGQgYmUgJHtNYXRoLnJvdW5kKGlucHV0U2FtcGxlRHVyYXRpb24pfSkuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGUuZHRzID0gbmV4dFB0cztcbiAgICAgICAgICBuZXh0UHRzICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaiA9IDAsIG5iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7IGogPCBuYlNhbXBsZXM7IGorKykge1xuICAgICAgbGV0IGF1ZGlvU2FtcGxlID0gaW5wdXRTYW1wbGVzW2pdO1xuICAgICAgbGV0IHVuaXQgPSBhdWRpb1NhbXBsZS51bml0O1xuICAgICAgbGV0IHB0cyA9IGF1ZGlvU2FtcGxlLnB0cztcbiAgICAgIC8vIGxvZ2dlci5sb2coYEF1ZGlvL1BUUzoke01hdGgucm91bmQocHRzLzkwKX1gKTtcbiAgICAgIC8vIGlmIG5vdCBmaXJzdCBzYW1wbGVcbiAgICAgIGlmIChsYXN0UFRTICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbXA0U2FtcGxlLmR1cmF0aW9uID0gTWF0aC5yb3VuZCgocHRzIC0gbGFzdFBUUykgLyBzY2FsZUZhY3Rvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGVsdGEgPSBNYXRoLnJvdW5kKDEwMDAgKiAocHRzIC0gbmV4dEF1ZGlvUHRzKSAvIGlucHV0VGltZVNjYWxlKSxcbiAgICAgICAgICBudW1NaXNzaW5nRnJhbWVzID0gMDtcbiAgICAgICAgLy8gaWYgZnJhZ21lbnQgYXJlIGNvbnRpZ3VvdXMsIGRldGVjdCBob2xlL292ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzXG4gICAgICAgIC8vIGNvbnRpZ3VvdXMgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZSBmcmFnbWVudHMgZnJvbSBzYW1lIHF1YWxpdHkgbGV2ZWwgKHNhbWUgbGV2ZWwsIG5ldyBTTiA9IG9sZCBTTiArIDEpXG4gICAgICAgIGlmIChjb250aWd1b3VzICYmIHRyYWNrLmlzQUFDKSB7XG4gICAgICAgICAgLy8gbG9nIGRlbHRhXG4gICAgICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgICAgICBpZiAoZGVsdGEgPiAwICYmIGRlbHRhIDwgTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTikge1xuICAgICAgICAgICAgICBudW1NaXNzaW5nRnJhbWVzID0gTWF0aC5yb3VuZCgocHRzIC0gbmV4dEF1ZGlvUHRzKSAvIGlucHV0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGAke2RlbHRhfSBtcyBob2xlIGJldHdlZW4gQUFDIHNhbXBsZXMgZGV0ZWN0ZWQsZmlsbGluZyBpdGApO1xuICAgICAgICAgICAgICBpZiAobnVtTWlzc2luZ0ZyYW1lcyA+IDApIHtcbiAgICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgICAgICAgZmlsbEZyYW1lID0gdW5pdC5zdWJhcnJheSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyYWNrLmxlbiArPSBudW1NaXNzaW5nRnJhbWVzICogZmlsbEZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGZyYW1lIG92ZXJsYXAsIG92ZXJsYXBwaW5nIGZvciBtb3JlIHRoYW4gaGFsZiBhIGZyYW1lIGR1cmFpb25cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPCAtMTIpIHtcbiAgICAgICAgICAgICAgLy8gZHJvcCBvdmVybGFwcGluZyBhdWRpbyBmcmFtZXMuLi4gYnJvd3NlciB3aWxsIGRlYWwgd2l0aCBpdFxuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBkcm9wIG92ZXJsYXBwaW5nIEFBQyBzYW1wbGUsIGV4cGVjdGVkL3BhcnNlZC9kZWx0YTokeyhuZXh0QXVkaW9QdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKX1zLyR7KHB0cyAvIGlucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpfXMvJHsoLWRlbHRhKX1tc2ApO1xuICAgICAgICAgICAgICB0cmFjay5sZW4gLT0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBQVFMvRFRTIHRvIGV4cGVjdGVkIFBUUy9EVFNcbiAgICAgICAgICAgIHB0cyA9IG5leHRBdWRpb1B0cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIG91ciBhdWRpb1NhbXBsZXNcbiAgICAgICAgZmlyc3RQVFMgPSBwdHM7XG4gICAgICAgIGlmICh0cmFjay5sZW4gPiAwKSB7XG4gICAgICAgICAgLyogY29uY2F0ZW5hdGUgdGhlIGF1ZGlvIGRhdGEgYW5kIGNvbnN0cnVjdCB0aGUgbWRhdCBpbiBwbGFjZVxuICAgICAgICAgICAgKG5lZWQgOCBtb3JlIGJ5dGVzIHRvIGZpbGwgbGVuZ3RoIGFuZCBtZGF0IHR5cGUpICovXG4gICAgICAgICAgbGV0IG1kYXRTaXplID0gcmF3TVBFRyA/IHRyYWNrLmxlbiA6IHRyYWNrLmxlbiArIDg7XG4gICAgICAgICAgb2Zmc2V0ID0gcmF3TVBFRyA/IDAgOiA4O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZGF0ID0gbmV3IFVpbnQ4QXJyYXkobWRhdFNpemUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTVVYX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1IsIGZhdGFsOiBmYWxzZSwgYnl0ZXM6IG1kYXRTaXplLCByZWFzb246IGBmYWlsIGFsbG9jYXRpbmcgYXVkaW8gbWRhdCAke21kYXRTaXplfWAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmF3TVBFRykge1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgICAgICAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIGF1ZGlvIHNhbXBsZXNcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1NaXNzaW5nRnJhbWVzOyBpKyspIHtcbiAgICAgICAgICBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyB0aGlzIGZyYW1lIGluc3RlYWQuJyk7XG4gICAgICAgICAgICBmaWxsRnJhbWUgPSB1bml0LnN1YmFycmF5KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1kYXQuc2V0KGZpbGxGcmFtZSwgb2Zmc2V0KTtcbiAgICAgICAgICBvZmZzZXQgKz0gZmlsbEZyYW1lLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgbXA0U2FtcGxlID0ge1xuICAgICAgICAgICAgc2l6ZTogZmlsbEZyYW1lLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICBjdHM6IDAsXG4gICAgICAgICAgICBkdXJhdGlvbjogMTAyNCxcbiAgICAgICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgICAgICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgICAgICAgICBkZXBlbmRzT246IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIG91dHB1dFNhbXBsZXMucHVzaChtcDRTYW1wbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZGF0LnNldCh1bml0LCBvZmZzZXQpO1xuICAgICAgbGV0IHVuaXRMZW4gPSB1bml0LmJ5dGVMZW5ndGg7XG4gICAgICBvZmZzZXQgKz0gdW5pdExlbjtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdQVFMvRFRTL2luaXREVFMvbm9ybVBUUy9ub3JtRFRTL3JlbGF0aXZlIFBUUyA6ICR7YXVkaW9TYW1wbGUucHRzfS8ke2F1ZGlvU2FtcGxlLmR0c30vJHtpbml0RFRTfS8ke3B0c25vcm19LyR7ZHRzbm9ybX0vJHsoYXVkaW9TYW1wbGUucHRzLzQyOTQ5NjcyOTYpLnRvRml4ZWQoMyl9Jyk7XG4gICAgICBtcDRTYW1wbGUgPSB7XG4gICAgICAgIHNpemU6IHVuaXRMZW4sXG4gICAgICAgIGN0czogMCxcbiAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgICAgIGRlZ3JhZFByaW86IDAsXG4gICAgICAgICAgZGVwZW5kc09uOiAxXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobXA0U2FtcGxlKTtcbiAgICAgIGxhc3RQVFMgPSBwdHM7XG4gICAgfVxuICAgIGxldCBsYXN0U2FtcGxlRHVyYXRpb24gPSAwO1xuICAgIGxldCBuYlNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzLmxlbmd0aDtcbiAgICAvLyBzZXQgbGFzdCBzYW1wbGUgZHVyYXRpb24gYXMgYmVpbmcgaWRlbnRpY2FsIHRvIHByZXZpb3VzIHNhbXBsZVxuICAgIGlmIChuYlNhbXBsZXMgPj0gMikge1xuICAgICAgbGFzdFNhbXBsZUR1cmF0aW9uID0gb3V0cHV0U2FtcGxlc1tuYlNhbXBsZXMgLSAyXS5kdXJhdGlvbjtcbiAgICAgIG1wNFNhbXBsZS5kdXJhdGlvbiA9IGxhc3RTYW1wbGVEdXJhdGlvbjtcbiAgICB9XG4gICAgaWYgKG5iU2FtcGxlcykge1xuICAgICAgLy8gbmV4dCBhdWRpbyBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBkdXJhdGlvblxuICAgICAgdGhpcy5uZXh0QXVkaW9QdHMgPSBuZXh0QXVkaW9QdHMgPSBsYXN0UFRTICsgc2NhbGVGYWN0b3IgKiBsYXN0U2FtcGxlRHVyYXRpb247XG4gICAgICAvLyBsb2dnZXIubG9nKCdBdWRpby9QVFMvUFRTZW5kOicgKyBhdWRpb1NhbXBsZS5wdHMudG9GaXhlZCgwKSArICcvJyArIHRoaXMubmV4dEFhY0R0cy50b0ZpeGVkKDApKTtcbiAgICAgIHRyYWNrLmxlbiA9IDA7XG4gICAgICB0cmFjay5zYW1wbGVzID0gb3V0cHV0U2FtcGxlcztcbiAgICAgIGlmIChyYXdNUEVHKSB7XG4gICAgICAgIG1vb2YgPSBuZXcgVWludDhBcnJheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9vZiA9IE1QNC5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0UFRTIC8gc2NhbGVGYWN0b3IsIHRyYWNrKTtcbiAgICAgIH1cblxuICAgICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgICAgY29uc3Qgc3RhcnQgPSBmaXJzdFBUUyAvIGlucHV0VGltZVNjYWxlO1xuICAgICAgY29uc3QgZW5kID0gbmV4dEF1ZGlvUHRzIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgICBjb25zdCBhdWRpb0RhdGEgPSB7XG4gICAgICAgIGRhdGExOiBtb29mLFxuICAgICAgICBkYXRhMjogbWRhdCxcbiAgICAgICAgc3RhcnRQVFM6IHN0YXJ0LFxuICAgICAgICBlbmRQVFM6IGVuZCxcbiAgICAgICAgc3RhcnREVFM6IHN0YXJ0LFxuICAgICAgICBlbmREVFM6IGVuZCxcbiAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgaGFzQXVkaW86IHRydWUsXG4gICAgICAgIGhhc1ZpZGVvOiBmYWxzZSxcbiAgICAgICAgbmI6IG5iU2FtcGxlc1xuICAgICAgfTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfREFUQSwgYXVkaW9EYXRhKTtcbiAgICAgIHJldHVybiBhdWRpb0RhdGE7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmVtdXhFbXB0eUF1ZGlvICh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgdmlkZW9EYXRhKSB7XG4gICAgbGV0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGUsXG4gICAgICBtcDR0aW1lU2NhbGUgPSB0cmFjay5zYW1wbGVyYXRlID8gdHJhY2suc2FtcGxlcmF0ZSA6IGlucHV0VGltZVNjYWxlLFxuICAgICAgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZSxcbiAgICAgIG5leHRBdWRpb1B0cyA9IHRoaXMubmV4dEF1ZGlvUHRzLFxuXG4gICAgICAvLyBzeW5jIHdpdGggdmlkZW8ncyB0aW1lc3RhbXBcbiAgICAgIHN0YXJ0RFRTID0gKG5leHRBdWRpb1B0cyAhPT0gdW5kZWZpbmVkID8gbmV4dEF1ZGlvUHRzIDogdmlkZW9EYXRhLnN0YXJ0RFRTICogaW5wdXRUaW1lU2NhbGUpICsgdGhpcy5faW5pdERUUyxcbiAgICAgIGVuZERUUyA9IHZpZGVvRGF0YS5lbmREVFMgKiBpbnB1dFRpbWVTY2FsZSArIHRoaXMuX2luaXREVFMsXG4gICAgICAvLyBvbmUgc2FtcGxlJ3MgZHVyYXRpb24gdmFsdWVcbiAgICAgIHNhbXBsZUR1cmF0aW9uID0gMTAyNCxcbiAgICAgIGZyYW1lRHVyYXRpb24gPSBzY2FsZUZhY3RvciAqIHNhbXBsZUR1cmF0aW9uLFxuXG4gICAgICAvLyBzYW1wbGVzIGNvdW50IG9mIHRoaXMgc2VnbWVudCdzIGR1cmF0aW9uXG4gICAgICBuYlNhbXBsZXMgPSBNYXRoLmNlaWwoKGVuZERUUyAtIHN0YXJ0RFRTKSAvIGZyYW1lRHVyYXRpb24pLFxuXG4gICAgICAvLyBzaWxlbnQgZnJhbWVcbiAgICAgIHNpbGVudEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG5cbiAgICBsb2dnZXIud2FybigncmVtdXggZW1wdHkgQXVkaW8nKTtcbiAgICAvLyBDYW4ndCByZW11eCBpZiB3ZSBjYW4ndCBnZW5lcmF0ZSBhIHNpbGVudCBmcmFtZS4uLlxuICAgIGlmICghc2lsZW50RnJhbWUpIHtcbiAgICAgIGxvZ2dlci50cmFjZSgnVW5hYmxlIHRvIHJlbXV4RW1wdHlBdWRpbyBzaW5jZSB3ZSB3ZXJlIHVuYWJsZSB0byBnZXQgYSBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjIScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBzYW1wbGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgbGV0IHN0YW1wID0gc3RhcnREVFMgKyBpICogZnJhbWVEdXJhdGlvbjtcbiAgICAgIHNhbXBsZXMucHVzaCh7IHVuaXQ6IHNpbGVudEZyYW1lLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wIH0pO1xuICAgICAgdHJhY2subGVuICs9IHNpbGVudEZyYW1lLmxlbmd0aDtcbiAgICB9XG4gICAgdHJhY2suc2FtcGxlcyA9IHNhbXBsZXM7XG5cbiAgICB0aGlzLnJlbXV4QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMpO1xuICB9XG5cbiAgcmVtdXhJRDMgKHRyYWNrKSB7XG4gICAgbGV0IGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoLCBzYW1wbGU7XG4gICAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICBjb25zdCBpbml0RFRTID0gdGhpcy5faW5pdERUUztcbiAgICAvLyBjb25zdW1lIHNhbXBsZXNcbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xuICAgICAgICAvLyBzZXR0aW5nIGlkMyBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcbiAgICAgICAgc2FtcGxlLnB0cyA9ICgoc2FtcGxlLnB0cyAtIGluaXRQVFMpIC8gaW5wdXRUaW1lU2NhbGUpO1xuICAgICAgICBzYW1wbGUuZHRzID0gKChzYW1wbGUuZHRzIC0gaW5pdERUUykgLyBpbnB1dFRpbWVTY2FsZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCB7XG4gICAgICAgIHNhbXBsZXM6IHRyYWNrLnNhbXBsZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgfVxuXG4gIHJlbXV4VGV4dCAodHJhY2spIHtcbiAgICB0cmFjay5zYW1wbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiAoYS5wdHMgLSBiLnB0cyk7XG4gICAgfSk7XG5cbiAgICBsZXQgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGgsIHNhbXBsZTtcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIC8vIGNvbnN1bWUgc2FtcGxlc1xuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XG4gICAgICAgIC8vIHNldHRpbmcgdGV4dCBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcbiAgICAgICAgc2FtcGxlLnB0cyA9ICgoc2FtcGxlLnB0cyAtIGluaXRQVFMpIC8gaW5wdXRUaW1lU2NhbGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19VU0VSREFUQSwge1xuICAgICAgICBzYW1wbGVzOiB0cmFjay5zYW1wbGVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gIH1cblxuICBfUFRTTm9ybWFsaXplICh2YWx1ZSwgcmVmZXJlbmNlKSB7XG4gICAgbGV0IG9mZnNldDtcbiAgICBpZiAocmVmZXJlbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAocmVmZXJlbmNlIDwgdmFsdWUpIHtcbiAgICAgIC8vIC0gMl4zM1xuICAgICAgb2Zmc2V0ID0gLTg1ODk5MzQ1OTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICsgMl4zM1xuICAgICAgb2Zmc2V0ID0gODU4OTkzNDU5MjtcbiAgICB9XG4gICAgLyogUFRTIGlzIDMzYml0IChmcm9tIDAgdG8gMl4zMyAtMSlcbiAgICAgIGlmIGRpZmYgYmV0d2VlbiB2YWx1ZSBhbmQgcmVmZXJlbmNlIGlzIGJpZ2dlciB0aGFuIGhhbGYgb2YgdGhlIGFtcGxpdHVkZSAoMl4zMikgdGhlbiBpdCBtZWFucyB0aGF0XG4gICAgICBQVFMgbG9vcGluZyBvY2N1cmVkLiBmaWxsIHRoZSBnYXAgKi9cbiAgICB3aGlsZSAoTWF0aC5hYnModmFsdWUgLSByZWZlcmVuY2UpID4gNDI5NDk2NzI5Nikge1xuICAgICAgdmFsdWUgKz0gb2Zmc2V0O1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNUDRSZW11eGVyO1xuIiwiLyoqXG4gKiBwYXNzdGhyb3VnaCByZW11eGVyXG4qL1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5cbmNsYXNzIFBhc3NUaHJvdWdoUmVtdXhlciB7XG4gIGNvbnN0cnVjdG9yIChvYnNlcnZlcikge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICB9XG5cbiAgcmVzZXRUaW1lU3RhbXAgKCkge1xuICB9XG5cbiAgcmVzZXRJbml0U2VnbWVudCAoKSB7XG4gIH1cblxuICByZW11eCAoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCByYXdEYXRhKSB7XG4gICAgbGV0IG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcbiAgICBsZXQgc3RyZWFtVHlwZSA9ICcnO1xuICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICBzdHJlYW1UeXBlICs9ICdhdWRpbyc7XG4gICAgfVxuXG4gICAgaWYgKHZpZGVvVHJhY2spIHtcbiAgICAgIHN0cmVhbVR5cGUgKz0gJ3ZpZGVvJztcbiAgICB9XG5cbiAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCB7XG4gICAgICBkYXRhMTogcmF3RGF0YSxcbiAgICAgIHN0YXJ0UFRTOiB0aW1lT2Zmc2V0LFxuICAgICAgc3RhcnREVFM6IHRpbWVPZmZzZXQsXG4gICAgICB0eXBlOiBzdHJlYW1UeXBlLFxuICAgICAgaGFzQXVkaW86ICEhYXVkaW9UcmFjayxcbiAgICAgIGhhc1ZpZGVvOiAhIXZpZGVvVHJhY2ssXG4gICAgICBuYjogMSxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9KTtcbiAgICAvLyBub3RpZnkgZW5kIG9mIHBhcnNpbmdcbiAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0VEKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXNzVGhyb3VnaFJlbXV4ZXI7XG4iLCJpbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4vZXZlbnQtaGFuZGxlcic7XG5cbi8qKlxuICogU3ViLWNsYXNzIHNwZWNpYWxpemF0aW9uIG9mIEV2ZW50SGFuZGxlciBiYXNlIGNsYXNzLlxuICpcbiAqIFRhc2tMb29wIGFsbG93cyB0byBzY2hlZHVsZSBhIHRhc2sgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIChvcHRpb25uYWx5IHJlcGVhdGVkbHkpIG9uIHRoZSBtYWluIGxvb3AsXG4gKiBzY2hlZHVsZWQgYXN5bmNocm9uZW91c2x5LCBhdm9pZGluZyByZWN1cnNpdmUgY2FsbHMgaW4gdGhlIHNhbWUgdGljay5cbiAqXG4gKiBUaGUgdGFzayBpdHNlbGYgaXMgaW1wbGVtZW50ZWQgaW4gYGRvVGlja2AuIEl0IGNhbiBiZSByZXF1ZXN0ZWQgYW5kIGNhbGxlZCBmb3Igc2luZ2xlIGV4ZWN1dGlvblxuICogdXNpbmcgdGhlIGB0aWNrYCBtZXRob2QuXG4gKlxuICogSXQgd2lsbCBiZSBhc3N1cmVkIHRoYXQgdGhlIHRhc2sgZXhlY3V0aW9uIG1ldGhvZCAoYHRpY2tgKSBvbmx5IGdldHMgY2FsbGVkIG9uY2UgcGVyIG1haW4gbG9vcCBcInRpY2tcIixcbiAqIG5vIG1hdHRlciBob3cgb2Z0ZW4gaXQgZ2V0cyByZXF1ZXN0ZWQgZm9yIGV4ZWN1dGlvbi4gRXhlY3V0aW9uIGluIGZ1cnRoZXIgdGlja3Mgd2lsbCBiZSBzY2hlZHVsZWQgYWNjb3JkaW5nbHkuXG4gKlxuICogSWYgZnVydGhlciBleGVjdXRpb24gcmVxdWVzdHMgaGF2ZSBhbHJlYWR5IGJlZW4gc2NoZWR1bGVkIG9uIHRoZSBuZXh0IHRpY2ssIGl0IGNhbiBiZSBjaGVja2VkIHdpdGggYGhhc05leHRUaWNrYCxcbiAqIGFuZCBjYW5jZWxsZWQgd2l0aCBgY2xlYXJOZXh0VGlja2AuXG4gKlxuICogVGhlIHRhc2sgY2FuIGJlIHNjaGVkdWxlZCBhcyBhbiBpbnRlcnZhbCByZXBlYXRlZGx5IHdpdGggYSBwZXJpb2QgYXMgcGFyYW1ldGVyIChzZWUgYHNldEludGVydmFsYCwgYGNsZWFySW50ZXJ2YWxgKS5cbiAqXG4gKiBTdWItY2xhc3NlcyBuZWVkIHRvIGltcGxlbWVudCB0aGUgYGRvVGlja2AgbWV0aG9kIHdoaWNoIHdpbGwgZWZmZWN0aXZlbHkgaGF2ZSB0aGUgdGFzayBleGVjdXRpb24gcm91dGluZS5cbiAqXG4gKiBGdXJ0aGVyIGV4cGxhbmF0aW9uczpcbiAqXG4gKiBUaGUgYmFzZWNsYXNzIGhhcyBhIGB0aWNrYCBtZXRob2QgdGhhdCB3aWxsIHNjaGVkdWxlIHRoZSBkb1RpY2sgY2FsbC4gSXQgbWF5IGJlIGNhbGxlZCBzeW5jaHJvbmVvdXNseVxuICogb25seSBmb3IgYSBzdGFjay1kZXB0aCBvZiBvbmUuIE9uIHJlLWVudHJhbnQgY2FsbHMsIHN1Yi1zZXF1ZW50IGNhbGxzIGFyZSBzY2hlZHVsZWQgZm9yIG5leHQgbWFpbiBsb29wIHRpY2tzLlxuICpcbiAqIFdoZW4gdGhlIHRhc2sgZXhlY3V0aW9uIChgdGlja2AgbWV0aG9kKSBpcyBjYWxsZWQgaW4gcmUtZW50cmFudCB3YXkgdGhpcyBpcyBkZXRlY3RlZCBhbmRcbiAqIHdlIGFyZSBsaW1pdGluZyB0aGUgdGFzayBleGVjdXRpb24gcGVyIGNhbGwgc3RhY2sgdG8gZXhhY3RseSBvbmUsIGJ1dCBzY2hlZHVsaW5nL3Bvc3QtcG9uaW5nIGZ1cnRoZXJcbiAqIHRhc2sgcHJvY2Vzc2luZyBvbiB0aGUgbmV4dCBtYWluIGxvb3AgaXRlcmF0aW9uIChhbHNvIGtub3duIGFzIFwibmV4dCB0aWNrXCIgaW4gdGhlIE5vZGUvSlMgcnVudGltZSBsaW5nbykuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFza0xvb3AgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzLCAuLi5ldmVudHMpIHtcbiAgICBzdXBlcihobHMsIC4uLmV2ZW50cyk7XG5cbiAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgIHRoaXMuX3RpY2tUaW1lciA9IG51bGw7XG4gICAgdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XG4gICAgdGhpcy5fYm91bmRUaWNrID0gdGhpcy50aWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBvbkhhbmRsZXJEZXN0cm95aW5nICgpIHtcbiAgICAvLyBjbGVhciBhbGwgdGltZXJzIGJlZm9yZSB1bnJlZ2lzdGVyaW5nIGZyb20gZXZlbnQgYnVzXG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBoYXNJbnRlcnZhbCAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fdGlja0ludGVydmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaGFzTmV4dFRpY2sgKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3RpY2tUaW1lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzIEludGVydmFsIHRpbWUgKG1zKVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIGludGVydmFsIGhhcyBiZWVuIHNjaGVkdWxlZCwgZmFsc2Ugd2hlbiBhbHJlYWR5IHNjaGVkdWxlZCAobm8gZWZmZWN0KVxuICAgKi9cbiAgc2V0SW50ZXJ2YWwgKG1pbGxpcykge1xuICAgIGlmICghdGhpcy5fdGlja0ludGVydmFsKSB7XG4gICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLl9ib3VuZFRpY2ssIG1pbGxpcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHdoZW4gaW50ZXJ2YWwgd2FzIGNsZWFyZWQsIGZhbHNlIHdoZW4gbm9uZSB3YXMgc2V0IChubyBlZmZlY3QpXG4gICAqL1xuICBjbGVhckludGVydmFsICgpIHtcbiAgICBpZiAodGhpcy5fdGlja0ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3RpY2tJbnRlcnZhbCk7XG4gICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIHRpbWVvdXQgd2FzIGNsZWFyZWQsIGZhbHNlIHdoZW4gbm9uZSB3YXMgc2V0IChubyBlZmZlY3QpXG4gICAqL1xuICBjbGVhck5leHRUaWNrICgpIHtcbiAgICBpZiAodGhpcy5fdGlja1RpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGlja1RpbWVyKTtcbiAgICAgIHRoaXMuX3RpY2tUaW1lciA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgY2FsbCB0aGUgc3ViY2xhc3MgZG9UaWNrIGltcGxlbWVudGF0aW9uIGluIHRoaXMgbWFpbiBsb29wIHRpY2tcbiAgICogb3IgaW4gdGhlIG5leHQgb25lICh2aWEgc2V0VGltZW91dCgsMCkpIGluIGNhc2UgaXQgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcbiAgICogaW4gdGhpcyB0aWNrIChpbiBjYXNlIHRoaXMgaXMgYSByZS1lbnRyYW50IGNhbGwpLlxuICAgKi9cbiAgdGljayAoKSB7XG4gICAgdGhpcy5fdGlja0NhbGxDb3VudCsrO1xuICAgIGlmICh0aGlzLl90aWNrQ2FsbENvdW50ID09PSAxKSB7XG4gICAgICB0aGlzLmRvVGljaygpO1xuICAgICAgLy8gcmUtZW50cmFudCBjYWxsIHRvIHRpY2sgZnJvbSBwcmV2aW91cyBkb1RpY2sgY2FsbCBzdGFja1xuICAgICAgLy8gLT4gc2NoZWR1bGUgYSBjYWxsIG9uIHRoZSBuZXh0IG1haW4gbG9vcCBpdGVyYXRpb24gdG8gcHJvY2VzcyB0aGlzIHRhc2sgcHJvY2Vzc2luZyByZXF1ZXN0XG4gICAgICBpZiAodGhpcy5fdGlja0NhbGxDb3VudCA+IDEpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIG9ubHkgb25lIHRpbWVyIGV4aXN0cyBhdCBhbnkgdGltZSBhdCBtYXhcbiAgICAgICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgICAgIHRoaXMuX3RpY2tUaW1lciA9IHNldFRpbWVvdXQodGhpcy5fYm91bmRUaWNrLCAwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3Igc3ViY2xhc3MgdG8gaW1wbGVtZW50IHRhc2sgbG9naWNcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBkb1RpY2sgKCkge31cbn1cbiIsImNvbnN0IERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWCA9IC9eKFxcZCspeChcXGQrKSQvOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5jb25zdCBBVFRSX0xJU1RfUkVHRVggPSAvXFxzKiguKz8pXFxzKj0oKD86XFxcIi4qP1xcXCIpfC4qPykoPzosfCQpL2c7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcblxuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5vbmdpbC9ub2RlLW0zdThwYXJzZS9ibG9iL21hc3Rlci9hdHRybGlzdC5qc1xuY2xhc3MgQXR0ckxpc3Qge1xuICBjb25zdHJ1Y3RvciAoYXR0cnMpIHtcbiAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xuICAgICAgYXR0cnMgPSBBdHRyTGlzdC5wYXJzZUF0dHJMaXN0KGF0dHJzKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBhdHRyIGluIGF0dHJzKSB7XG4gICAgICBpZiAoYXR0cnMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgdGhpc1thdHRyXSA9IGF0dHJzW2F0dHJdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlY2ltYWxJbnRlZ2VyIChhdHRyTmFtZSkge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDEwKTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cblxuICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgfVxuXG4gIGhleGFkZWNpbWFsSW50ZWdlciAoYXR0ck5hbWUpIHtcbiAgICBpZiAodGhpc1thdHRyTmFtZV0pIHtcbiAgICAgIGxldCBzdHJpbmdWYWx1ZSA9ICh0aGlzW2F0dHJOYW1lXSB8fCAnMHgnKS5zbGljZSgyKTtcbiAgICAgIHN0cmluZ1ZhbHVlID0gKChzdHJpbmdWYWx1ZS5sZW5ndGggJiAxKSA/ICcwJyA6ICcnKSArIHN0cmluZ1ZhbHVlO1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSBwYXJzZUludChzdHJpbmdWYWx1ZS5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGhleGFkZWNpbWFsSW50ZWdlckFzTnVtYmVyIChhdHRyTmFtZSkge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDE2KTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cblxuICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgfVxuXG4gIGRlY2ltYWxGbG9hdGluZ1BvaW50IChhdHRyTmFtZSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXNbYXR0ck5hbWVdKTtcbiAgfVxuXG4gIGVudW1lcmF0ZWRTdHJpbmcgKGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXNbYXR0ck5hbWVdO1xuICB9XG5cbiAgZGVjaW1hbFJlc29sdXRpb24gKGF0dHJOYW1lKSB7XG4gICAgY29uc3QgcmVzID0gREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYLmV4ZWModGhpc1thdHRyTmFtZV0pO1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBwYXJzZUludChyZXNbMV0sIDEwKSxcbiAgICAgIGhlaWdodDogcGFyc2VJbnQocmVzWzJdLCAxMClcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIHBhcnNlQXR0ckxpc3QgKGlucHV0KSB7XG4gICAgbGV0IG1hdGNoLCBhdHRycyA9IHt9O1xuICAgIEFUVFJfTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlICgobWF0Y2ggPSBBVFRSX0xJU1RfUkVHRVguZXhlYyhpbnB1dCkpICE9PSBudWxsKSB7XG4gICAgICBsZXQgdmFsdWUgPSBtYXRjaFsyXSwgcXVvdGUgPSAnXCInO1xuXG4gICAgICBpZiAodmFsdWUuaW5kZXhPZihxdW90ZSkgPT09IDAgJiZcbiAgICAgICAgICB2YWx1ZS5sYXN0SW5kZXhPZihxdW90ZSkgPT09ICh2YWx1ZS5sZW5ndGggLSAxKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICAgIH1cblxuICAgICAgYXR0cnNbbWF0Y2hbMV1dID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhdHRycztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdHRyTGlzdDtcbiIsImxldCBCaW5hcnlTZWFyY2ggPSB7XG4gIC8qKlxuICAgICAqIFNlYXJjaGVzIGZvciBhbiBpdGVtIGluIGFuIGFycmF5IHdoaWNoIG1hdGNoZXMgYSBjZXJ0YWluIGNvbmRpdGlvbi5cbiAgICAgKiBUaGlzIHJlcXVpcmVzIHRoZSBjb25kaXRpb24gdG8gb25seSBtYXRjaCBvbmUgaXRlbSBpbiB0aGUgYXJyYXksXG4gICAgICogYW5kIGZvciB0aGUgYXJyYXkgdG8gYmUgb3JkZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJpc29uRnVuY3Rpb25cbiAgICAgKiAgICAgIENhbGxlZCBhbmQgcHJvdmlkZWQgYSBjYW5kaWRhdGUgaXRlbSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAgICogICAgICBTaG91bGQgcmV0dXJuOlxuICAgICAqICAgICAgICAgID4gLTEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBsb3dlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgICAqICAgICAgICAgID4gMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGhpZ2hlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgICAqICAgICAgICAgID4gMCBpZiB0aGUgaXRlbSBpcyB0aGUgaXRlbSB5b3UncmUgbG9va2luZyBmb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgb2JqZWN0IGlmIGl0IGlzIGZvdW5kIG9yIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICBzZWFyY2g6IGZ1bmN0aW9uIChsaXN0LCBjb21wYXJpc29uRnVuY3Rpb24pIHtcbiAgICBsZXQgbWluSW5kZXggPSAwO1xuICAgIGxldCBtYXhJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICBsZXQgY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICBsZXQgY3VycmVudEVsZW1lbnQgPSBudWxsO1xuXG4gICAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICBjdXJyZW50SW5kZXggPSAobWluSW5kZXggKyBtYXhJbmRleCkgLyAyIHwgMDtcbiAgICAgIGN1cnJlbnRFbGVtZW50ID0gbGlzdFtjdXJyZW50SW5kZXhdO1xuXG4gICAgICBsZXQgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmlzb25GdW5jdGlvbihjdXJyZW50RWxlbWVudCk7XG4gICAgICBpZiAoY29tcGFyaXNvblJlc3VsdCA+IDApIHtcbiAgICAgICAgbWluSW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgICAgfSBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xuICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJpbmFyeVNlYXJjaDtcbiIsIi8qKlxuICogQG1vZHVsZSBCdWZmZXJIZWxwZXJcbiAqXG4gKiBQcm92aWRpbmcgbWV0aG9kcyBkZWFsaW5nIHdpdGggYnVmZmVyIGxlbmd0aCByZXRyaWV2YWwgZm9yIGV4YW1wbGUuXG4gKlxuICogSW4gZ2VuZXJhbCwgYSBoZWxwZXIgYXJvdW5kIEhUTUw1IE1lZGlhRWxlbWVudCBUaW1lUmFuZ2VzIGdhdGhlcmVkIGZyb20gYGJ1ZmZlcmVkYCBwcm9wZXJ0eS5cbiAqXG4gKiBBbHNvIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvYnVmZmVyZWRcbiovXG5cbmV4cG9ydCBjbGFzcyBCdWZmZXJIZWxwZXIge1xuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgYG1lZGlhYCdzIGJ1ZmZlcmVkIGluY2x1ZGUgYHBvc2l0aW9uYFxuICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR8U291cmNlQnVmZmVyfSBtZWRpYVxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNCdWZmZXJlZCAobWVkaWEsIHBvc2l0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBsZXQgYnVmZmVyZWQgPSBtZWRpYS5idWZmZXJlZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBidWZmZXJlZC5zdGFydChpKSAmJiBwb3NpdGlvbiA8PSBidWZmZXJlZC5lbmQoaSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyB0aGlzIGlzIHRvIGNhdGNoXG4gICAgICAvLyBJbnZhbGlkU3RhdGVFcnJvcjogRmFpbGVkIHRvIHJlYWQgdGhlICdidWZmZXJlZCcgcHJvcGVydHkgZnJvbSAnU291cmNlQnVmZmVyJzpcbiAgICAgIC8vIFRoaXMgU291cmNlQnVmZmVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IG1lZGlhIHNvdXJjZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgYnVmZmVySW5mbyAobWVkaWEsIHBvcywgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBsZXQgdmJ1ZmZlcmVkID0gbWVkaWEuYnVmZmVyZWQsIGJ1ZmZlcmVkID0gW10sIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBidWZmZXJlZC5wdXNoKHsgc3RhcnQ6IHZidWZmZXJlZC5zdGFydChpKSwgZW5kOiB2YnVmZmVyZWQuZW5kKGkpIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLCBwb3MsIG1heEhvbGVEdXJhdGlvbik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHRoaXMgaXMgdG8gY2F0Y2hcbiAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxuICAgICAgLy8gVGhpcyBTb3VyY2VCdWZmZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgbWVkaWEgc291cmNlXG4gICAgfVxuICAgIHJldHVybiB7IGxlbjogMCwgc3RhcnQ6IHBvcywgZW5kOiBwb3MsIG5leHRTdGFydDogdW5kZWZpbmVkIH07XG4gIH1cblxuICBzdGF0aWMgYnVmZmVyZWRJbmZvIChidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICBsZXQgYnVmZmVyZWQyID0gW10sXG4gICAgICAvLyBidWZmZXJTdGFydCBhbmQgYnVmZmVyRW5kIGFyZSBidWZmZXIgYm91bmRhcmllcyBhcm91bmQgY3VycmVudCB2aWRlbyBwb3NpdGlvblxuICAgICAgYnVmZmVyTGVuLCBidWZmZXJTdGFydCwgYnVmZmVyRW5kLCBidWZmZXJTdGFydE5leHQsIGk7XG4gICAgLy8gc29ydCBvbiBidWZmZXIuc3RhcnQvc21hbGxlciBlbmQgKElFIGRvZXMgbm90IGFsd2F5cyByZXR1cm4gc29ydGVkIGJ1ZmZlcmVkIHJhbmdlKVxuICAgIGJ1ZmZlcmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGxldCBkaWZmID0gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICBpZiAoZGlmZikge1xuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiLmVuZCAtIGEuZW5kO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHRoZXJlIG1pZ2h0IGJlIHNvbWUgc21hbGwgaG9sZXMgYmV0d2VlbiBidWZmZXIgdGltZSByYW5nZVxuICAgIC8vIGNvbnNpZGVyIHRoYXQgaG9sZXMgc21hbGxlciB0aGFuIG1heEhvbGVEdXJhdGlvbiBhcmUgaXJyZWxldmFudCBhbmQgYnVpbGQgYW5vdGhlclxuICAgIC8vIGJ1ZmZlciB0aW1lIHJhbmdlIHJlcHJlc2VudGF0aW9ucyB0aGF0IGRpc2NhcmRzIHRob3NlIGhvbGVzXG4gICAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYnVmMmxlbiA9IGJ1ZmZlcmVkMi5sZW5ndGg7XG4gICAgICBpZiAoYnVmMmxlbikge1xuICAgICAgICBsZXQgYnVmMmVuZCA9IGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kO1xuICAgICAgICAvLyBpZiBzbWFsbCBob2xlICh2YWx1ZSBiZXR3ZWVuIDAgb3IgbWF4SG9sZUR1cmF0aW9uICkgb3Igb3ZlcmxhcHBpbmcgKG5lZ2F0aXZlKVxuICAgICAgICBpZiAoKGJ1ZmZlcmVkW2ldLnN0YXJ0IC0gYnVmMmVuZCkgPCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAvLyBtZXJnZSBvdmVybGFwcGluZyB0aW1lIHJhbmdlc1xuICAgICAgICAgIC8vIHVwZGF0ZSBsYXN0UmFuZ2UuZW5kIG9ubHkgaWYgc21hbGxlciB0aGFuIGl0ZW0uZW5kXG4gICAgICAgICAgLy8gZS5nLiAgWyAxLCAxNV0gd2l0aCAgWyAyLDhdID0+IFsgMSwxNV0gKG5vIG5lZWQgdG8gbW9kaWZ5IGxhc3RSYW5nZS5lbmQpXG4gICAgICAgICAgLy8gd2hlcmVhcyBbIDEsIDhdIHdpdGggIFsgMiwxNV0gPT4gWyAxLDE1XSAoIGxhc3RSYW5nZSBzaG91bGQgc3dpdGNoIGZyb20gWzEsOF0gdG8gWzEsMTVdKVxuICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5lbmQgPiBidWYyZW5kKSB7XG4gICAgICAgICAgICBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZCA9IGJ1ZmZlcmVkW2ldLmVuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYmlnIGhvbGVcbiAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZpcnN0IHZhbHVlXG4gICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMCwgYnVmZmVyTGVuID0gMCwgYnVmZmVyU3RhcnQgPSBidWZmZXJFbmQgPSBwb3M7IGkgPCBidWZmZXJlZDIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzdGFydCA9IGJ1ZmZlcmVkMltpXS5zdGFydCxcbiAgICAgICAgZW5kID0gYnVmZmVyZWQyW2ldLmVuZDtcbiAgICAgIC8vIGxvZ2dlci5sb2coJ2J1ZiBzdGFydC9lbmQ6JyArIGJ1ZmZlcmVkLnN0YXJ0KGkpICsgJy8nICsgYnVmZmVyZWQuZW5kKGkpKTtcbiAgICAgIGlmICgocG9zICsgbWF4SG9sZUR1cmF0aW9uKSA+PSBzdGFydCAmJiBwb3MgPCBlbmQpIHtcbiAgICAgICAgLy8gcGxheSBwb3NpdGlvbiBpcyBpbnNpZGUgdGhpcyBidWZmZXIgVGltZVJhbmdlLCByZXRyaWV2ZSBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uIGFuZCBidWZmZXIgbGVuZ3RoXG4gICAgICAgIGJ1ZmZlclN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIGJ1ZmZlckVuZCA9IGVuZDtcbiAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVyRW5kIC0gcG9zO1xuICAgICAgfSBlbHNlIGlmICgocG9zICsgbWF4SG9sZUR1cmF0aW9uKSA8IHN0YXJ0KSB7XG4gICAgICAgIGJ1ZmZlclN0YXJ0TmV4dCA9IHN0YXJ0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbGVuOiBidWZmZXJMZW4sIHN0YXJ0OiBidWZmZXJTdGFydCwgZW5kOiBidWZmZXJFbmQsIG5leHRTdGFydDogYnVmZmVyU3RhcnROZXh0IH07XG4gIH1cbn1cbiIsIi8qKlxuICpcbiAqIFRoaXMgY29kZSB3YXMgcG9ydGVkIGZyb20gdGhlIGRhc2guanMgcHJvamVjdCBhdDpcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vZGFzaC5qcy9ibG9iL2RldmVsb3BtZW50L2V4dGVybmFscy9jZWE2MDgtcGFyc2VyLmpzXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvY29tbWl0LzgyNjliMjZhNzYxZTA4NTNiYjIxZDc4NzgwZWQ5NDUxNDRlY2RkNGQjZGlmZi03MWJjMjk1YTJkNmI2YjcwOTNhMWQzMjkwZDUzYTRiMlxuICpcbiAqIFRoZSBvcmlnaW5hbCBjb3B5cmlnaHQgYXBwZWFycyBiZWxvdzpcbiAqXG4gKiBUaGUgY29weXJpZ2h0IGluIHRoaXMgc29mdHdhcmUgaXMgYmVpbmcgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLFxuICogaW5jbHVkZWQgYmVsb3cuIFRoaXMgc29mdHdhcmUgbWF5IGJlIHN1YmplY3QgdG8gb3RoZXIgdGhpcmQgcGFydHkgYW5kIGNvbnRyaWJ1dG9yXG4gKiByaWdodHMsIGluY2x1ZGluZyBwYXRlbnQgcmlnaHRzLCBhbmQgbm8gc3VjaCByaWdodHMgYXJlIGdyYW50ZWQgdW5kZXIgdGhpcyBsaWNlbnNlLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDE2LCBEQVNIIEluZHVzdHJ5IEZvcnVtLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICogIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yXG4gKiAgb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAyLiBOZWl0aGVyIHRoZSBuYW1lIG9mIERhc2ggSW5kdXN0cnkgRm9ydW0gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gKiAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgQVMgSVMgQU5EIEFOWVxuICogIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuXG4gKiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCxcbiAqICBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUXG4gKiAgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLFxuICogIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqICBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG4vKipcbiAgICAgKiAgRXhjZXB0aW9ucyBmcm9tIHJlZ3VsYXIgQVNDSUkuIENvZGVQb2ludHMgYXJlIG1hcHBlZCB0byBVVEYtMTYgY29kZXNcbiAgICAgKi9cblxubGV0IHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzID0ge1xuICAweDJhOiAweGUxLCAvLyBsb3dlcmNhc2UgYSwgYWN1dGUgYWNjZW50XG4gIDB4NWM6IDB4ZTksIC8vIGxvd2VyY2FzZSBlLCBhY3V0ZSBhY2NlbnRcbiAgMHg1ZTogMHhlZCwgLy8gbG93ZXJjYXNlIGksIGFjdXRlIGFjY2VudFxuICAweDVmOiAweGYzLCAvLyBsb3dlcmNhc2UgbywgYWN1dGUgYWNjZW50XG4gIDB4NjA6IDB4ZmEsIC8vIGxvd2VyY2FzZSB1LCBhY3V0ZSBhY2NlbnRcbiAgMHg3YjogMHhlNywgLy8gbG93ZXJjYXNlIGMgd2l0aCBjZWRpbGxhXG4gIDB4N2M6IDB4ZjcsIC8vIGRpdmlzaW9uIHN5bWJvbFxuICAweDdkOiAweGQxLCAvLyB1cHBlcmNhc2UgTiB0aWxkZVxuICAweDdlOiAweGYxLCAvLyBsb3dlcmNhc2UgbiB0aWxkZVxuICAweDdmOiAweDI1ODgsIC8vIEZ1bGwgYmxvY2tcbiAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMTYgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDExIEFORCBMT1cgQkVUV0VFTiAweDMwIEFORCAweDNGXG4gIC8vIFRISVMgTUVBTlMgVEhBVCBcXHg1MCBNVVNUIEJFIEFEREVEIFRPIFRIRSBWQUxVRVNcbiAgMHg4MDogMHhhZSwgLy8gUmVnaXN0ZXJlZCBzeW1ib2wgKFIpXG4gIDB4ODE6IDB4YjAsIC8vIGRlZ3JlZSBzaWduXG4gIDB4ODI6IDB4YmQsIC8vIDEvMiBzeW1ib2xcbiAgMHg4MzogMHhiZiwgLy8gSW52ZXJ0ZWQgKG9wZW4pIHF1ZXN0aW9uIG1hcmtcbiAgMHg4NDogMHgyMTIyLCAvLyBUcmFkZW1hcmsgc3ltYm9sIChUTSlcbiAgMHg4NTogMHhhMiwgLy8gQ2VudHMgc3ltYm9sXG4gIDB4ODY6IDB4YTMsIC8vIFBvdW5kcyBzdGVybGluZ1xuICAweDg3OiAweDI2NmEsIC8vIE11c2ljIDgndGggbm90ZVxuICAweDg4OiAweGUwLCAvLyBsb3dlcmNhc2UgYSwgZ3JhdmUgYWNjZW50XG4gIDB4ODk6IDB4MjAsIC8vIHRyYW5zcGFyZW50IHNwYWNlIChyZWd1bGFyKVxuICAweDhhOiAweGU4LCAvLyBsb3dlcmNhc2UgZSwgZ3JhdmUgYWNjZW50XG4gIDB4OGI6IDB4ZTIsIC8vIGxvd2VyY2FzZSBhLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhjOiAweGVhLCAvLyBsb3dlcmNhc2UgZSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4ZDogMHhlZSwgLy8gbG93ZXJjYXNlIGksIGNpcmN1bWZsZXggYWNjZW50XG4gIDB4OGU6IDB4ZjQsIC8vIGxvd2VyY2FzZSBvLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhmOiAweGZiLCAvLyBsb3dlcmNhc2UgdSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEyIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXG4gIDB4OTA6IDB4YzEsIC8vIGNhcGl0YWwgbGV0dGVyIEEgd2l0aCBhY3V0ZVxuICAweDkxOiAweGM5LCAvLyBjYXBpdGFsIGxldHRlciBFIHdpdGggYWN1dGVcbiAgMHg5MjogMHhkMywgLy8gY2FwaXRhbCBsZXR0ZXIgTyB3aXRoIGFjdXRlXG4gIDB4OTM6IDB4ZGEsIC8vIGNhcGl0YWwgbGV0dGVyIFUgd2l0aCBhY3V0ZVxuICAweDk0OiAweGRjLCAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggZGlhcmVzaXNcbiAgMHg5NTogMHhmYywgLy8gbG93ZXJjYXNlIGxldHRlciBVIHdpdGggZGlhZXJlc2lzXG4gIDB4OTY6IDB4MjAxOCwgLy8gb3BlbmluZyBzaW5nbGUgcXVvdGVcbiAgMHg5NzogMHhhMSwgLy8gaW52ZXJ0ZWQgZXhjbGFtYXRpb24gbWFya1xuICAweDk4OiAweDJhLCAvLyBhc3Rlcmlza1xuICAweDk5OiAweDIwMTksIC8vIGNsb3Npbmcgc2luZ2xlIHF1b3RlXG4gIDB4OWE6IDB4MjUwMSwgLy8gYm94IGRyYXdpbmdzIGhlYXZ5IGhvcml6b250YWxcbiAgMHg5YjogMHhhOSwgLy8gY29weXJpZ2h0IHNpZ25cbiAgMHg5YzogMHgyMTIwLCAvLyBTZXJ2aWNlIG1hcmtcbiAgMHg5ZDogMHgyMDIyLCAvLyAocm91bmQpIGJ1bGxldFxuICAweDllOiAweDIwMWMsIC8vIExlZnQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXG4gIDB4OWY6IDB4MjAxZCwgLy8gUmlnaHQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXG4gIDB4YTA6IDB4YzAsIC8vIHVwcGVyY2FzZSBBLCBncmF2ZSBhY2NlbnRcbiAgMHhhMTogMHhjMiwgLy8gdXBwZXJjYXNlIEEsIGNpcmN1bWZsZXhcbiAgMHhhMjogMHhjNywgLy8gdXBwZXJjYXNlIEMgd2l0aCBjZWRpbGxhXG4gIDB4YTM6IDB4YzgsIC8vIHVwcGVyY2FzZSBFLCBncmF2ZSBhY2NlbnRcbiAgMHhhNDogMHhjYSwgLy8gdXBwZXJjYXNlIEUsIGNpcmN1bWZsZXhcbiAgMHhhNTogMHhjYiwgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGRpYXJlc2lzXG4gIDB4YTY6IDB4ZWIsIC8vIGxvd2VyY2FzZSBsZXR0ZXIgZSB3aXRoIGRpYXJlc2lzXG4gIDB4YTc6IDB4Y2UsIC8vIHVwcGVyY2FzZSBJLCBjaXJjdW1mbGV4XG4gIDB4YTg6IDB4Y2YsIC8vIHVwcGVyY2FzZSBJLCB3aXRoIGRpYXJlc2lzXG4gIDB4YTk6IDB4ZWYsIC8vIGxvd2VyY2FzZSBpLCB3aXRoIGRpYXJlc2lzXG4gIDB4YWE6IDB4ZDQsIC8vIHVwcGVyY2FzZSBPLCBjaXJjdW1mbGV4XG4gIDB4YWI6IDB4ZDksIC8vIHVwcGVyY2FzZSBVLCBncmF2ZSBhY2NlbnRcbiAgMHhhYzogMHhmOSwgLy8gbG93ZXJjYXNlIHUsIGdyYXZlIGFjY2VudFxuICAweGFkOiAweGRiLCAvLyB1cHBlcmNhc2UgVSwgY2lyY3VtZmxleFxuICAweGFlOiAweGFiLCAvLyBsZWZ0LXBvaW50aW5nIGRvdWJsZSBhbmdsZSBxdW90YXRpb24gbWFya1xuICAweGFmOiAweGJiLCAvLyByaWdodC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEzIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXG4gIDB4YjA6IDB4YzMsIC8vIFVwcGVyY2FzZSBBLCB0aWxkZVxuICAweGIxOiAweGUzLCAvLyBMb3dlcmNhc2UgYSwgdGlsZGVcbiAgMHhiMjogMHhjZCwgLy8gVXBwZXJjYXNlIEksIGFjdXRlIGFjY2VudFxuICAweGIzOiAweGNjLCAvLyBVcHBlcmNhc2UgSSwgZ3JhdmUgYWNjZW50XG4gIDB4YjQ6IDB4ZWMsIC8vIExvd2VyY2FzZSBpLCBncmF2ZSBhY2NlbnRcbiAgMHhiNTogMHhkMiwgLy8gVXBwZXJjYXNlIE8sIGdyYXZlIGFjY2VudFxuICAweGI2OiAweGYyLCAvLyBMb3dlcmNhc2UgbywgZ3JhdmUgYWNjZW50XG4gIDB4Yjc6IDB4ZDUsIC8vIFVwcGVyY2FzZSBPLCB0aWxkZVxuICAweGI4OiAweGY1LCAvLyBMb3dlcmNhc2UgbywgdGlsZGVcbiAgMHhiOTogMHg3YiwgLy8gT3BlbiBjdXJseSBicmFjZVxuICAweGJhOiAweDdkLCAvLyBDbG9zaW5nIGN1cmx5IGJyYWNlXG4gIDB4YmI6IDB4NWMsIC8vIEJhY2tzbGFzaFxuICAweGJjOiAweDVlLCAvLyBDYXJldFxuICAweGJkOiAweDVmLCAvLyBVbmRlcnNjb3JlXG4gIDB4YmU6IDB4N2MsIC8vIFBpcGUgKHZlcnRpY2FsIGxpbmUpXG4gIDB4YmY6IDB4MjIzYywgLy8gVGlsZGUgb3BlcmF0b3JcbiAgMHhjMDogMHhjNCwgLy8gVXBwZXJjYXNlIEEsIHVtbGF1dFxuICAweGMxOiAweGU0LCAvLyBMb3dlcmNhc2UgQSwgdW1sYXV0XG4gIDB4YzI6IDB4ZDYsIC8vIFVwcGVyY2FzZSBPLCB1bWxhdXRcbiAgMHhjMzogMHhmNiwgLy8gTG93ZXJjYXNlIG8sIHVtbGF1dFxuICAweGM0OiAweGRmLCAvLyBFc3N6ZXR0IChzaGFycCBTKVxuICAweGM1OiAweGE1LCAvLyBZZW4gc3ltYm9sXG4gIDB4YzY6IDB4YTQsIC8vIEdlbmVyaWMgY3VycmVuY3kgc2lnblxuICAweGM3OiAweDI1MDMsIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB2ZXJ0aWNhbFxuICAweGM4OiAweGM1LCAvLyBVcHBlcmNhc2UgQSwgcmluZ1xuICAweGM5OiAweGU1LCAvLyBMb3dlcmNhc2UgQSwgcmluZ1xuICAweGNhOiAweGQ4LCAvLyBVcHBlcmNhc2UgTywgc3Ryb2tlXG4gIDB4Y2I6IDB4ZjgsIC8vIExvd2VyY2FzZSBvLCBzdHJva1xuICAweGNjOiAweDI1MGYsIC8vIEJveCBkcmF3aW5ncyBoZWF2eSBkb3duIGFuZCByaWdodFxuICAweGNkOiAweDI1MTMsIC8vIEJveCBkcmF3aW5ncyBoZWF2eSBkb3duIGFuZCBsZWZ0XG4gIDB4Y2U6IDB4MjUxNywgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHVwIGFuZCByaWdodFxuICAweGNmOiAweDI1MWIgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHVwIGFuZCBsZWZ0XG59O1xuXG4vKipcbiAqIFV0aWxzXG4gKi9cbmxldCBnZXRDaGFyRm9yQnl0ZSA9IGZ1bmN0aW9uIChieXRlKSB7XG4gIGxldCBjaGFyQ29kZSA9IGJ5dGU7XG4gIGlmIChzcGVjaWFsQ2VhNjA4Q2hhcnNDb2Rlcy5oYXNPd25Qcm9wZXJ0eShieXRlKSkge1xuICAgIGNoYXJDb2RlID0gc3BlY2lhbENlYTYwOENoYXJzQ29kZXNbYnl0ZV07XG4gIH1cblxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG59O1xuXG5sZXQgTlJfUk9XUyA9IDE1LFxuICBOUl9DT0xTID0gMTAwO1xuLy8gVGFibGVzIHRvIGxvb2sgdXAgcm93IGZyb20gUEFDIGRhdGFcbmxldCByb3dzTG93Q2gxID0geyAweDExOiAxLCAweDEyOiAzLCAweDE1OiA1LCAweDE2OiA3LCAweDE3OiA5LCAweDEwOiAxMSwgMHgxMzogMTIsIDB4MTQ6IDE0IH07XG5sZXQgcm93c0hpZ2hDaDEgPSB7IDB4MTE6IDIsIDB4MTI6IDQsIDB4MTU6IDYsIDB4MTY6IDgsIDB4MTc6IDEwLCAweDEzOiAxMywgMHgxNDogMTUgfTtcbmxldCByb3dzTG93Q2gyID0geyAweDE5OiAxLCAweDFBOiAzLCAweDFEOiA1LCAweDFFOiA3LCAweDFGOiA5LCAweDE4OiAxMSwgMHgxQjogMTIsIDB4MUM6IDE0IH07XG5sZXQgcm93c0hpZ2hDaDIgPSB7IDB4MTk6IDIsIDB4MUE6IDQsIDB4MUQ6IDYsIDB4MUU6IDgsIDB4MUY6IDEwLCAweDFCOiAxMywgMHgxQzogMTUgfTtcblxubGV0IGJhY2tncm91bmRDb2xvcnMgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnLCAnYmxhY2snLCAndHJhbnNwYXJlbnQnXTtcblxuLyoqXG4gKiBTaW1wbGUgbG9nZ2VyIGNsYXNzIHRvIGJlIGFibGUgdG8gd3JpdGUgd2l0aCB0aW1lLXN0YW1wcyBhbmQgZmlsdGVyIG9uIGxldmVsLlxuICovXG5sZXQgbG9nZ2VyID0ge1xuICB2ZXJib3NlRmlsdGVyOiB7ICdEQVRBJzogMywgJ0RFQlVHJzogMywgJ0lORk8nOiAyLCAnV0FSTklORyc6IDIsICdURVhUJzogMSwgJ0VSUk9SJzogMCB9LFxuICB0aW1lOiBudWxsLFxuICB2ZXJib3NlTGV2ZWw6IDAsIC8vIE9ubHkgd3JpdGUgZXJyb3JzXG4gIHNldFRpbWU6IGZ1bmN0aW9uIChuZXdUaW1lKSB7XG4gICAgdGhpcy50aW1lID0gbmV3VGltZTtcbiAgfSxcbiAgbG9nOiBmdW5jdGlvbiAoc2V2ZXJpdHksIG1zZykge1xuICAgIGxldCBtaW5MZXZlbCA9IHRoaXMudmVyYm9zZUZpbHRlcltzZXZlcml0eV07XG4gICAgaWYgKHRoaXMudmVyYm9zZUxldmVsID49IG1pbkxldmVsKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnRpbWUgKyAnIFsnICsgc2V2ZXJpdHkgKyAnXSAnICsgbXNnKTtcbiAgICB9XG4gIH1cbn07XG5cbmxldCBudW1BcnJheVRvSGV4QXJyYXkgPSBmdW5jdGlvbiAobnVtQXJyYXkpIHtcbiAgbGV0IGhleEFycmF5ID0gW107XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbnVtQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICBoZXhBcnJheS5wdXNoKG51bUFycmF5W2pdLnRvU3RyaW5nKDE2KSk7XG4gIH1cblxuICByZXR1cm4gaGV4QXJyYXk7XG59O1xuXG5jbGFzcyBQZW5TdGF0ZSB7XG4gIGNvbnN0cnVjdG9yIChmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZCB8fCAnd2hpdGUnO1xuICAgIHRoaXMudW5kZXJsaW5lID0gdW5kZXJsaW5lIHx8IGZhbHNlO1xuICAgIHRoaXMuaXRhbGljcyA9IGl0YWxpY3MgfHwgZmFsc2U7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZCB8fCAnYmxhY2snO1xuICAgIHRoaXMuZmxhc2ggPSBmbGFzaCB8fCBmYWxzZTtcbiAgfVxuXG4gIHJlc2V0ICgpIHtcbiAgICB0aGlzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xuICAgIHRoaXMudW5kZXJsaW5lID0gZmFsc2U7XG4gICAgdGhpcy5pdGFsaWNzID0gZmFsc2U7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gJ2JsYWNrJztcbiAgICB0aGlzLmZsYXNoID0gZmFsc2U7XG4gIH1cblxuICBzZXRTdHlsZXMgKHN0eWxlcykge1xuICAgIGxldCBhdHRyaWJzID0gWydmb3JlZ3JvdW5kJywgJ3VuZGVybGluZScsICdpdGFsaWNzJywgJ2JhY2tncm91bmQnLCAnZmxhc2gnXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzdHlsZSA9IGF0dHJpYnNbaV07XG4gICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICB0aGlzW3N0eWxlXSA9IHN0eWxlc1tzdHlsZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNEZWZhdWx0ICgpIHtcbiAgICByZXR1cm4gKHRoaXMuZm9yZWdyb3VuZCA9PT0gJ3doaXRlJyAmJiAhdGhpcy51bmRlcmxpbmUgJiYgIXRoaXMuaXRhbGljcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZCA9PT0gJ2JsYWNrJyAmJiAhdGhpcy5mbGFzaCk7XG4gIH1cblxuICBlcXVhbHMgKG90aGVyKSB7XG4gICAgcmV0dXJuICgodGhpcy5mb3JlZ3JvdW5kID09PSBvdGhlci5mb3JlZ3JvdW5kKSAmJlxuICAgICAgICAgICAgICAgICAodGhpcy51bmRlcmxpbmUgPT09IG90aGVyLnVuZGVybGluZSkgJiZcbiAgICAgICAgICAgICAgICAgKHRoaXMuaXRhbGljcyA9PT0gb3RoZXIuaXRhbGljcykgJiZcbiAgICAgICAgICAgICAgICAgKHRoaXMuYmFja2dyb3VuZCA9PT0gb3RoZXIuYmFja2dyb3VuZCkgJiZcbiAgICAgICAgICAgICAgICAgKHRoaXMuZmxhc2ggPT09IG90aGVyLmZsYXNoKSk7XG4gIH1cblxuICBjb3B5IChuZXdQZW5TdGF0ZSkge1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IG5ld1BlblN0YXRlLmZvcmVncm91bmQ7XG4gICAgdGhpcy51bmRlcmxpbmUgPSBuZXdQZW5TdGF0ZS51bmRlcmxpbmU7XG4gICAgdGhpcy5pdGFsaWNzID0gbmV3UGVuU3RhdGUuaXRhbGljcztcbiAgICB0aGlzLmJhY2tncm91bmQgPSBuZXdQZW5TdGF0ZS5iYWNrZ3JvdW5kO1xuICAgIHRoaXMuZmxhc2ggPSBuZXdQZW5TdGF0ZS5mbGFzaDtcbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gKCdjb2xvcj0nICsgdGhpcy5mb3JlZ3JvdW5kICsgJywgdW5kZXJsaW5lPScgKyB0aGlzLnVuZGVybGluZSArICcsIGl0YWxpY3M9JyArIHRoaXMuaXRhbGljcyArXG4gICAgICAgICAgICAnLCBiYWNrZ3JvdW5kPScgKyB0aGlzLmJhY2tncm91bmQgKyAnLCBmbGFzaD0nICsgdGhpcy5mbGFzaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBVbmljb2RlIGNoYXJhY3RlciB3aXRoIHN0eWxpbmcgYW5kIGJhY2tncm91bmQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgU3R5bGVkVW5pY29kZUNoYXIge1xuICBjb25zdHJ1Y3RvciAodWNoYXIsIGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpIHtcbiAgICB0aGlzLnVjaGFyID0gdWNoYXIgfHwgJyAnOyAvLyB1bmljb2RlIGNoYXJhY3RlclxuICAgIHRoaXMucGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCk7XG4gIH1cblxuICByZXNldCAoKSB7XG4gICAgdGhpcy51Y2hhciA9ICcgJztcbiAgICB0aGlzLnBlblN0YXRlLnJlc2V0KCk7XG4gIH1cblxuICBzZXRDaGFyICh1Y2hhciwgbmV3UGVuU3RhdGUpIHtcbiAgICB0aGlzLnVjaGFyID0gdWNoYXI7XG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgfVxuXG4gIHNldFBlblN0YXRlIChuZXdQZW5TdGF0ZSkge1xuICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdQZW5TdGF0ZSk7XG4gIH1cblxuICBlcXVhbHMgKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudWNoYXIgPT09IG90aGVyLnVjaGFyICYmIHRoaXMucGVuU3RhdGUuZXF1YWxzKG90aGVyLnBlblN0YXRlKTtcbiAgfVxuXG4gIGNvcHkgKG5ld0NoYXIpIHtcbiAgICB0aGlzLnVjaGFyID0gbmV3Q2hhci51Y2hhcjtcbiAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3Q2hhci5wZW5TdGF0ZSk7XG4gIH1cblxuICBpc0VtcHR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gJyAnICYmIHRoaXMucGVuU3RhdGUuaXNEZWZhdWx0KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDRUEtNjA4IHJvdyBjb25zaXN0aW5nIG9mIE5SX0NPTFMgaW5zdGFuY2VzIG9mIFN0eWxlZFVuaWNvZGVDaGFyLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFJvdyB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmNoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIHRoaXMuY2hhcnMucHVzaChuZXcgU3R5bGVkVW5pY29kZUNoYXIoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuY3VyclBlblN0YXRlID0gbmV3IFBlblN0YXRlKCk7XG4gIH1cblxuICBlcXVhbHMgKG90aGVyKSB7XG4gICAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLmNoYXJzW2ldLmVxdWFscyhvdGhlci5jaGFyc1tpXSkpIHtcbiAgICAgICAgZXF1YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcXVhbDtcbiAgfVxuXG4gIGNvcHkgKG90aGVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIHRoaXMuY2hhcnNbaV0uY29weShvdGhlci5jaGFyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgaXNFbXB0eSAoKSB7XG4gICAgbGV0IGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLmNoYXJzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5O1xuICB9XG5cbiAgLyoqXG4gICAgICogIFNldCB0aGUgY3Vyc29yIHRvIGEgdmFsaWQgY29sdW1uLlxuICAgICAqL1xuICBzZXRDdXJzb3IgKGFic1Bvcykge1xuICAgIGlmICh0aGlzLnBvcyAhPT0gYWJzUG9zKSB7XG4gICAgICB0aGlzLnBvcyA9IGFic1BvcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wb3MgPCAwKSB7XG4gICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdOZWdhdGl2ZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucG9zID4gTlJfQ09MUykge1xuICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnVG9vIGxhcmdlIGN1cnNvciBwb3NpdGlvbiAnICsgdGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MgPSBOUl9DT0xTO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgICAqIE1vdmUgdGhlIGN1cnNvciByZWxhdGl2ZSB0byBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAqL1xuICBtb3ZlQ3Vyc29yIChyZWxQb3MpIHtcbiAgICBsZXQgbmV3UG9zID0gdGhpcy5wb3MgKyByZWxQb3M7XG4gICAgaWYgKHJlbFBvcyA+IDEpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLnBvcyArIDE7IGkgPCBuZXdQb3MgKyAxOyBpKyspIHtcbiAgICAgICAgdGhpcy5jaGFyc1tpXS5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKG5ld1Bvcyk7XG4gIH1cblxuICAvKipcbiAgICAgKiBCYWNrc3BhY2UsIG1vdmUgb25lIHN0ZXAgYmFjayBhbmQgY2xlYXIgY2hhcmFjdGVyLlxuICAgICAqL1xuICBiYWNrU3BhY2UgKCkge1xuICAgIHRoaXMubW92ZUN1cnNvcigtMSk7XG4gICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcignICcsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgfVxuXG4gIGluc2VydENoYXIgKGJ5dGUpIHtcbiAgICBpZiAoYnl0ZSA+PSAweDkwKSB7IC8vIEV4dGVuZGVkIGNoYXJcbiAgICAgIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgfVxuICAgIGxldCBjaGFyID0gZ2V0Q2hhckZvckJ5dGUoYnl0ZSk7XG4gICAgaWYgKHRoaXMucG9zID49IE5SX0NPTFMpIHtcbiAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ0Nhbm5vdCBpbnNlcnQgJyArIGJ5dGUudG9TdHJpbmcoMTYpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgKCcgKyBjaGFyICsgJykgYXQgcG9zaXRpb24gJyArIHRoaXMucG9zICsgJy4gU2tpcHBpbmcgaXQhJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2hhcnNbdGhpcy5wb3NdLnNldENoYXIoY2hhciwgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgIHRoaXMubW92ZUN1cnNvcigxKTtcbiAgfVxuXG4gIGNsZWFyRnJvbVBvcyAoc3RhcnRQb3MpIHtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSBzdGFydFBvczsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgdGhpcy5jaGFyc1tpXS5yZXNldCgpO1xuICAgIH1cbiAgfVxuXG4gIGNsZWFyICgpIHtcbiAgICB0aGlzLmNsZWFyRnJvbVBvcygwKTtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5jdXJyUGVuU3RhdGUucmVzZXQoKTtcbiAgfVxuXG4gIGNsZWFyVG9FbmRPZlJvdyAoKSB7XG4gICAgdGhpcy5jbGVhckZyb21Qb3ModGhpcy5wb3MpO1xuICB9XG5cbiAgZ2V0VGV4dFN0cmluZyAoKSB7XG4gICAgbGV0IGNoYXJzID0gW107XG4gICAgbGV0IGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgbGV0IGNoYXIgPSB0aGlzLmNoYXJzW2ldLnVjaGFyO1xuICAgICAgaWYgKGNoYXIgIT09ICcgJykge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjaGFycy5wdXNoKGNoYXIpO1xuICAgIH1cbiAgICBpZiAoZW1wdHkpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgIH1cbiAgfVxuXG4gIHNldFBlblN0eWxlcyAoc3R5bGVzKSB7XG4gICAgdGhpcy5jdXJyUGVuU3RhdGUuc2V0U3R5bGVzKHN0eWxlcyk7XG4gICAgbGV0IGN1cnJDaGFyID0gdGhpcy5jaGFyc1t0aGlzLnBvc107XG4gICAgY3VyckNoYXIuc2V0UGVuU3RhdGUodGhpcy5jdXJyUGVuU3RhdGUpO1xuICB9XG59XG5cbi8qKlxuICogS2VlcCBhIENFQS02MDggc2NyZWVuIG9mIDMyeDE1IHN0eWxlZCBjaGFyYWN0ZXJzXG4gKiBAY29uc3RydWN0b3JcbiovXG5jbGFzcyBDYXB0aW9uU2NyZWVuIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMucm93cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICB0aGlzLnJvd3MucHVzaChuZXcgUm93KCkpO1xuICAgIH0gLy8gTm90ZSB0aGF0IHdlIHVzZSB6ZXJvLWJhc2VkIG51bWJlcmluZyAoMC0xNClcblxuICAgIHRoaXMuY3VyclJvdyA9IE5SX1JPV1MgLSAxO1xuICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICByZXNldCAoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xuICAgIH1cblxuICAgIHRoaXMuY3VyclJvdyA9IE5SX1JPV1MgLSAxO1xuICB9XG5cbiAgZXF1YWxzIChvdGhlcikge1xuICAgIGxldCBlcXVhbCA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5yb3dzW2ldLmVxdWFscyhvdGhlci5yb3dzW2ldKSkge1xuICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVxdWFsO1xuICB9XG5cbiAgY29weSAob3RoZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgdGhpcy5yb3dzW2ldLmNvcHkob3RoZXIucm93c1tpXSk7XG4gICAgfVxuICB9XG5cbiAgaXNFbXB0eSAoKSB7XG4gICAgbGV0IGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uaXNFbXB0eSgpKSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cblxuICBiYWNrU3BhY2UgKCkge1xuICAgIGxldCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuYmFja1NwYWNlKCk7XG4gIH1cblxuICBjbGVhclRvRW5kT2ZSb3cgKCkge1xuICAgIGxldCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuY2xlYXJUb0VuZE9mUm93KCk7XG4gIH1cblxuICAvKipcbiAgICAgKiBJbnNlcnQgYSBjaGFyYWN0ZXIgKHdpdGhvdXQgc3R5bGluZykgaW4gdGhlIGN1cnJlbnQgcm93LlxuICAgICAqL1xuICBpbnNlcnRDaGFyIChjaGFyKSB7XG4gICAgbGV0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5pbnNlcnRDaGFyKGNoYXIpO1xuICB9XG5cbiAgc2V0UGVuIChzdHlsZXMpIHtcbiAgICBsZXQgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LnNldFBlblN0eWxlcyhzdHlsZXMpO1xuICB9XG5cbiAgbW92ZUN1cnNvciAocmVsUG9zKSB7XG4gICAgbGV0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5tb3ZlQ3Vyc29yKHJlbFBvcyk7XG4gIH1cblxuICBzZXRDdXJzb3IgKGFic1Bvcykge1xuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnc2V0Q3Vyc29yOiAnICsgYWJzUG9zKTtcbiAgICBsZXQgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LnNldEN1cnNvcihhYnNQb3MpO1xuICB9XG5cbiAgc2V0UEFDIChwYWNEYXRhKSB7XG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdwYWNEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KHBhY0RhdGEpKTtcbiAgICBsZXQgbmV3Um93ID0gcGFjRGF0YS5yb3cgLSAxO1xuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiBuZXdSb3cgPCB0aGlzLm5yUm9sbFVwUm93cyAtIDEpIHtcbiAgICAgIG5ld1JvdyA9IHRoaXMubnJSb2xsVXBSb3dzIC0gMTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhpcyBvbmx5IGFmZmVjdHMgUm9sbC11cCBDYXB0aW9ucyBieSBjaGVja2luZyB0aGlzLm5yUm9sbFVwUm93c1xuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiB0aGlzLmN1cnJSb3cgIT09IG5ld1Jvdykge1xuICAgICAgLy8gY2xlYXIgYWxsIHJvd3MgZmlyc3RcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3B5IHRoaXMubnJSb2xsVXBSb3dzIHJvd3MgZnJvbSBsYXN0T3V0cHV0U2NyZWVuIGFuZCBwbGFjZSBpdCBpbiB0aGUgbmV3Um93IGxvY2F0aW9uXG4gICAgICAvLyB0b3BSb3dJbmRleCAtIHRoZSBzdGFydCBvZiByb3dzIHRvIGNvcHkgKGluY2x1c2l2ZSBpbmRleClcbiAgICAgIGxldCB0b3BSb3dJbmRleCA9IHRoaXMuY3VyclJvdyArIDEgLSAodGhpcy5uclJvbGxVcFJvd3MpO1xuICAgICAgLy8gV2Ugb25seSBjb3B5IGlmIHRoZSBsYXN0IHBvc2l0aW9uIHdhcyBhbHJlYWR5IHNob3duLlxuICAgICAgLy8gV2UgdXNlIHRoZSBjdWVTdGFydFRpbWUgdmFsdWUgdG8gY2hlY2sgdGhpcy5cbiAgICAgIGNvbnN0IGxhc3RPdXRwdXRTY3JlZW4gPSB0aGlzLmxhc3RPdXRwdXRTY3JlZW47XG4gICAgICBpZiAobGFzdE91dHB1dFNjcmVlbikge1xuICAgICAgICBsZXQgcHJldkxpbmVUaW1lID0gbGFzdE91dHB1dFNjcmVlbi5yb3dzW3RvcFJvd0luZGV4XS5jdWVTdGFydFRpbWU7XG4gICAgICAgIGlmIChwcmV2TGluZVRpbWUgJiYgcHJldkxpbmVUaW1lIDwgbG9nZ2VyLnRpbWUpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnJSb2xsVXBSb3dzOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucm93c1tuZXdSb3cgLSB0aGlzLm5yUm9sbFVwUm93cyArIGkgKyAxXS5jb3B5KGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleCArIGldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmN1cnJSb3cgPSBuZXdSb3c7XG4gICAgbGV0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIGlmIChwYWNEYXRhLmluZGVudCAhPT0gbnVsbCkge1xuICAgICAgbGV0IGluZGVudCA9IHBhY0RhdGEuaW5kZW50O1xuICAgICAgbGV0IHByZXZQb3MgPSBNYXRoLm1heChpbmRlbnQgLSAxLCAwKTtcbiAgICAgIHJvdy5zZXRDdXJzb3IocGFjRGF0YS5pbmRlbnQpO1xuICAgICAgcGFjRGF0YS5jb2xvciA9IHJvdy5jaGFyc1twcmV2UG9zXS5wZW5TdGF0ZS5mb3JlZ3JvdW5kO1xuICAgIH1cbiAgICBsZXQgc3R5bGVzID0geyBmb3JlZ3JvdW5kOiBwYWNEYXRhLmNvbG9yLCB1bmRlcmxpbmU6IHBhY0RhdGEudW5kZXJsaW5lLCBpdGFsaWNzOiBwYWNEYXRhLml0YWxpY3MsIGJhY2tncm91bmQ6ICdibGFjaycsIGZsYXNoOiBmYWxzZSB9O1xuICAgIHRoaXMuc2V0UGVuKHN0eWxlcyk7XG4gIH1cblxuICAvKipcbiAgICAgKiBTZXQgYmFja2dyb3VuZC9leHRyYSBmb3JlZ3JvdW5kLCBidXQgZmlyc3QgZG8gYmFja19zcGFjZSwgYW5kIHRoZW4gaW5zZXJ0IHNwYWNlIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkuXG4gICAgICovXG4gIHNldEJrZ0RhdGEgKGJrZ0RhdGEpIHtcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ2JrZ0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkoYmtnRGF0YSkpO1xuICAgIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgdGhpcy5zZXRQZW4oYmtnRGF0YSk7XG4gICAgdGhpcy5pbnNlcnRDaGFyKDB4MjApOyAvLyBTcGFjZVxuICB9XG5cbiAgc2V0Um9sbFVwUm93cyAobnJSb3dzKSB7XG4gICAgdGhpcy5uclJvbGxVcFJvd3MgPSBuclJvd3M7XG4gIH1cblxuICByb2xsVXAgKCkge1xuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyA9PT0gbnVsbCkge1xuICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAncm9sbF91cCBidXQgbnJSb2xsVXBSb3dzIG5vdCBzZXQgeWV0Jyk7XG4gICAgICByZXR1cm47IC8vIE5vdCBwcm9wZXJseSBzZXR1cFxuICAgIH1cbiAgICBsb2dnZXIubG9nKCdURVhUJywgdGhpcy5nZXREaXNwbGF5VGV4dCgpKTtcbiAgICBsZXQgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gdGhpcy5uclJvbGxVcFJvd3M7XG4gICAgbGV0IHRvcFJvdyA9IHRoaXMucm93cy5zcGxpY2UodG9wUm93SW5kZXgsIDEpWzBdO1xuICAgIHRvcFJvdy5jbGVhcigpO1xuICAgIHRoaXMucm93cy5zcGxpY2UodGhpcy5jdXJyUm93LCAwLCB0b3BSb3cpO1xuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUm9sbGluZyB1cCcpO1xuICAgIC8vIGxvZ2dlci5sb2coJ1RFWFQnLCB0aGlzLmdldF9kaXNwbGF5X3RleHQoKSlcbiAgfVxuXG4gIC8qKlxuICAgICogR2V0IGFsbCBub24tZW1wdHkgcm93cyB3aXRoIGFzIHVuaWNvZGUgdGV4dC5cbiAgICAqL1xuICBnZXREaXNwbGF5VGV4dCAoYXNPbmVSb3cpIHtcbiAgICBhc09uZVJvdyA9IGFzT25lUm93IHx8IGZhbHNlO1xuICAgIGxldCBkaXNwbGF5VGV4dCA9IFtdO1xuICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgbGV0IHJvd05yID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIGxldCByb3dUZXh0ID0gdGhpcy5yb3dzW2ldLmdldFRleHRTdHJpbmcoKTtcbiAgICAgIGlmIChyb3dUZXh0KSB7XG4gICAgICAgIHJvd05yID0gaSArIDE7XG4gICAgICAgIGlmIChhc09uZVJvdykge1xuICAgICAgICAgIGRpc3BsYXlUZXh0LnB1c2goJ1JvdyAnICsgcm93TnIgKyAnOiBcXCcnICsgcm93VGV4dCArICdcXCcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKHJvd1RleHQudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlzcGxheVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgIHRleHQgPSAnWycgKyBkaXNwbGF5VGV4dC5qb2luKCcgfCAnKSArICddJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBkaXNwbGF5VGV4dC5qb2luKCdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICBnZXRUZXh0QW5kRm9ybWF0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5yb3dzO1xuICB9XG59XG5cbi8vIHZhciBtb2RlcyA9IFsnTU9ERV9ST0xMLVVQJywgJ01PREVfUE9QLU9OJywgJ01PREVfUEFJTlQtT04nLCAnTU9ERV9URVhUJ107XG5cbmNsYXNzIENlYTYwOENoYW5uZWwge1xuICBjb25zdHJ1Y3RvciAoY2hhbm5lbE51bWJlciwgb3V0cHV0RmlsdGVyKSB7XG4gICAgdGhpcy5jaE5yID0gY2hhbm5lbE51bWJlcjtcbiAgICB0aGlzLm91dHB1dEZpbHRlciA9IG91dHB1dEZpbHRlcjtcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgIHRoaXMudmVyYm9zZSA9IDA7XG4gICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gbmV3IENhcHRpb25TY3JlZW4oKTtcbiAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LnJvd3NbTlJfUk9XUyAtIDFdO1xuICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gbnVsbDsgLy8gS2VlcHMgdHJhY2sgb2Ygd2hlcmUgYSBjdWUgc3RhcnRlZC5cbiAgfVxuXG4gIHJlc2V0ICgpIHtcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4ucmVzZXQoKTtcbiAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MgLSAxXTtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy5sYXN0Q3VlRW5kVGltZSA9IG51bGw7XG4gIH1cblxuICBnZXRIYW5kbGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRGaWx0ZXI7XG4gIH1cblxuICBzZXRIYW5kbGVyIChuZXdIYW5kbGVyKSB7XG4gICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBuZXdIYW5kbGVyO1xuICB9XG5cbiAgc2V0UEFDIChwYWNEYXRhKSB7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQQUMocGFjRGF0YSk7XG4gIH1cblxuICBzZXRCa2dEYXRhIChia2dEYXRhKSB7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRCa2dEYXRhKGJrZ0RhdGEpO1xuICB9XG5cbiAgc2V0TW9kZSAobmV3TW9kZSkge1xuICAgIGlmIChuZXdNb2RlID09PSB0aGlzLm1vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnTU9ERT0nICsgbmV3TW9kZSk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUE9QLU9OJykge1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuLnJlc2V0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vZGUgIT09ICdNT0RFX1JPTEwtVVAnKSB7XG4gICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgfVxuXG4gIGluc2VydENoYXJzIChjaGFycykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4uaW5zZXJ0Q2hhcihjaGFyc1tpXSk7XG4gICAgfVxuXG4gICAgbGV0IHNjcmVlbiA9IHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5ID8gJ0RJU1AnIDogJ05PTl9ESVNQJztcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgc2NyZWVuICsgJzogJyArIHRoaXMud3JpdGVTY3JlZW4uZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BBSU5ULU9OJyB8fCB0aGlzLm1vZGUgPT09ICdNT0RFX1JPTEwtVVAnKSB7XG4gICAgICBsb2dnZXIubG9nKCdURVhUJywgJ0RJU1BMQVlFRDogJyArIHRoaXMuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KHRydWUpKTtcbiAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGNjUkNMICgpIHsgLy8gUmVzdW1lIENhcHRpb24gTG9hZGluZyAoc3dpdGNoIG1vZGUgdG8gUG9wIE9uKVxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUkNMIC0gUmVzdW1lIENhcHRpb24gTG9hZGluZycpO1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9QT1AtT04nKTtcbiAgfVxuXG4gIGNjQlMgKCkgeyAvLyBCYWNrU3BhY2VcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0JTIC0gQmFja1NwYWNlJyk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfVEVYVCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLndyaXRlU2NyZWVuLmJhY2tTcGFjZSgpO1xuICAgIGlmICh0aGlzLndyaXRlU2NyZWVuID09PSB0aGlzLmRpc3BsYXllZE1lbW9yeSkge1xuICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgY2NBT0YgKCkgeyAvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT2ZmKVxuXG4gIH1cblxuICBjY0FPTiAoKSB7IC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPbilcblxuICB9XG5cbiAgY2NERVIgKCkgeyAvLyBEZWxldGUgdG8gRW5kIG9mIFJvd1xuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnREVSLSBEZWxldGUgdG8gRW5kIG9mIFJvdycpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uY2xlYXJUb0VuZE9mUm93KCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gIH1cblxuICBjY1JVIChuclJvd3MpIHsgLy8gUm9sbC1VcCBDYXB0aW9ucy0yLDMsb3IgNCBSb3dzXG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdSVSgnICsgbnJSb3dzICsgJykgLSBSb2xsIFVwJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9ST0xMLVVQJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRSb2xsVXBSb3dzKG5yUm93cyk7XG4gIH1cblxuICBjY0ZPTiAoKSB7IC8vIEZsYXNoIE9uXG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdGT04gLSBGbGFzaCBPbicpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHsgZmxhc2g6IHRydWUgfSk7XG4gIH1cblxuICBjY1JEQyAoKSB7IC8vIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZyAoc3dpdGNoIG1vZGUgdG8gUGFpbnRPbilcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JEQyAtIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZycpO1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9QQUlOVC1PTicpO1xuICB9XG5cbiAgY2NUUiAoKSB7IC8vIFRleHQgUmVzdGFydCBpbiB0ZXh0IG1vZGUgKG5vdCBzdXBwb3J0ZWQsIGhvd2V2ZXIpXG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdUUicpO1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XG4gIH1cblxuICBjY1JURCAoKSB7IC8vIFJlc3VtZSBUZXh0IERpc3BsYXkgaW4gVGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUlREJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcbiAgfVxuXG4gIGNjRURNICgpIHsgLy8gRXJhc2UgRGlzcGxheWVkIE1lbW9yeVxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRURNIC0gRXJhc2UgRGlzcGxheWVkIE1lbW9yeScpO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICB9XG5cbiAgY2NDUiAoKSB7IC8vIENhcnJpYWdlIFJldHVyblxuICAgIGxvZ2dlci5sb2coJ0NSIC0gQ2FycmlhZ2UgUmV0dXJuJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5yb2xsVXAoKTtcbiAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUodHJ1ZSk7XG4gIH1cblxuICBjY0VOTSAoKSB7IC8vIEVyYXNlIE5vbi1EaXNwbGF5ZWQgTWVtb3J5XG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdFTk0gLSBFcmFzZSBOb24tZGlzcGxheWVkIE1lbW9yeScpO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gIH1cblxuICBjY0VPQyAoKSB7IC8vIEVuZCBvZiBDYXB0aW9uIChGbGlwIE1lbW9yaWVzKVxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRU9DIC0gRW5kIE9mIENhcHRpb24nKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XG4gICAgICBsZXQgdG1wID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSB0bXA7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgICBsb2dnZXIubG9nKCdURVhUJywgJ0RJU1A6ICcgKyB0aGlzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCgpKTtcbiAgICB9XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICB9XG5cbiAgY2NUTyAobnJDb2xzKSB7IC8vIFRhYiBPZmZzZXQgMSwyLCBvciAzIGNvbHVtbnNcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1RPKCcgKyBuckNvbHMgKyAnKSAtIFRhYiBPZmZzZXQnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLm1vdmVDdXJzb3IobnJDb2xzKTtcbiAgfVxuXG4gIGNjTUlEUk9XIChzZWNvbmRCeXRlKSB7IC8vIFBhcnNlIE1JRFJPVyBjb21tYW5kXG4gICAgbGV0IHN0eWxlcyA9IHsgZmxhc2g6IGZhbHNlIH07XG4gICAgc3R5bGVzLnVuZGVybGluZSA9IHNlY29uZEJ5dGUgJSAyID09PSAxO1xuICAgIHN0eWxlcy5pdGFsaWNzID0gc2Vjb25kQnl0ZSA+PSAweDJlO1xuICAgIGlmICghc3R5bGVzLml0YWxpY3MpIHtcbiAgICAgIGxldCBjb2xvckluZGV4ID0gTWF0aC5mbG9vcihzZWNvbmRCeXRlIC8gMikgLSAweDEwO1xuICAgICAgbGV0IGNvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YSddO1xuICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSBjb2xvcnNbY29sb3JJbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICB9XG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdNSURST1c6ICcgKyBKU09OLnN0cmluZ2lmeShzdHlsZXMpKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbihzdHlsZXMpO1xuICB9XG5cbiAgb3V0cHV0RGF0YVVwZGF0ZSAoZGlzcGF0Y2ggPSBmYWxzZSkge1xuICAgIGxldCB0ID0gbG9nZ2VyLnRpbWU7XG4gICAgaWYgKHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIpIHtcbiAgICAgIGlmICh0aGlzLmN1ZVN0YXJ0VGltZSA9PT0gbnVsbCAmJiAhdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7IC8vIFN0YXJ0IG9mIGEgbmV3IGN1ZVxuICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmVxdWFscyh0aGlzLmxhc3RPdXRwdXRTY3JlZW4pKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0LCB0aGlzLmxhc3RPdXRwdXRTY3JlZW4pO1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoID09PSB0cnVlICYmIHRoaXMub3V0cHV0RmlsdGVyLmRpc3BhdGNoQ3VlKSB7XG4gICAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLmRpc3BhdGNoQ3VlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpID8gbnVsbCA6IHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5jb3B5KHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICB9XG4gIH1cblxuICBjdWVTcGxpdEF0VGltZSAodCkge1xuICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSkge1xuICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSwgdCwgdGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBDZWE2MDhQYXJzZXIge1xuICBjb25zdHJ1Y3RvciAoZmllbGQsIG91dDEsIG91dDIpIHtcbiAgICB0aGlzLmZpZWxkID0gZmllbGQgfHwgMTtcbiAgICB0aGlzLm91dHB1dHMgPSBbb3V0MSwgb3V0Ml07XG4gICAgdGhpcy5jaGFubmVscyA9IFtuZXcgQ2VhNjA4Q2hhbm5lbCgxLCBvdXQxKSwgbmV3IENlYTYwOENoYW5uZWwoMiwgb3V0MildO1xuICAgIHRoaXMuY3VyckNoTnIgPSAtMTsgLy8gV2lsbCBiZSAxIG9yIDJcbiAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDsgLy8gRmlyc3QgYnl0ZSBvZiBsYXN0IGNvbW1hbmRcbiAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDsgLy8gU2Vjb25kIGJ5dGUgb2YgbGFzdCBjb21tYW5kXG4gICAgdGhpcy5idWZmZXJlZERhdGEgPSBbXTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy5sYXN0VGltZSA9IG51bGw7XG4gICAgdGhpcy5kYXRhQ291bnRlcnMgPSB7ICdwYWRkaW5nJzogMCwgJ2NoYXInOiAwLCAnY21kJzogMCwgJ290aGVyJzogMCB9O1xuICB9XG5cbiAgZ2V0SGFuZGxlciAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsc1tpbmRleF0uZ2V0SGFuZGxlcigpO1xuICB9XG5cbiAgc2V0SGFuZGxlciAoaW5kZXgsIG5ld0hhbmRsZXIpIHtcbiAgICB0aGlzLmNoYW5uZWxzW2luZGV4XS5zZXRIYW5kbGVyKG5ld0hhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAgICogQWRkIGRhdGEgZm9yIHRpbWUgdCBpbiBmb3JtcyBvZiBsaXN0IG9mIGJ5dGVzICh1bnNpZ25lZCBpbnRzKS4gVGhlIGJ5dGVzIGFyZSB0cmVhdGVkIGFzIHBhaXJzLlxuICAgICAqL1xuICBhZGREYXRhICh0LCBieXRlTGlzdCkge1xuICAgIGxldCBjbWRGb3VuZCwgYSwgYixcbiAgICAgIGNoYXJzRm91bmQgPSBmYWxzZTtcblxuICAgIHRoaXMubGFzdFRpbWUgPSB0O1xuICAgIGxvZ2dlci5zZXRUaW1lKHQpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlTGlzdC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgYSA9IGJ5dGVMaXN0W2ldICYgMHg3ZjtcbiAgICAgIGIgPSBieXRlTGlzdFtpICsgMV0gJiAweDdmO1xuICAgICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5wYWRkaW5nICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnREFUQScsICdbJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2kgKyAxXV0pICsgJ10gLT4gKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJyk7XG4gICAgICB9XG4gICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VDbWQoYSwgYik7XG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZU1pZHJvdyhhLCBiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VQQUMoYSwgYik7XG4gICAgICB9XG5cbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYik7XG4gICAgICB9XG5cbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY2hhcnNGb3VuZCA9IHRoaXMucGFyc2VDaGFycyhhLCBiKTtcbiAgICAgICAgaWYgKGNoYXJzRm91bmQpIHtcbiAgICAgICAgICBpZiAodGhpcy5jdXJyQ2hOciAmJiB0aGlzLmN1cnJDaE5yID49IDApIHtcbiAgICAgICAgICAgIGxldCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1t0aGlzLmN1cnJDaE5yIC0gMV07XG4gICAgICAgICAgICBjaGFubmVsLmluc2VydENoYXJzKGNoYXJzRm91bmQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdXQVJOSU5HJywgJ05vIGNoYW5uZWwgZm91bmQgeWV0LiBURVhULU1PREU/Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY21kRm91bmQpIHtcbiAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMuY21kICs9IDI7XG4gICAgICB9IGVsc2UgaWYgKGNoYXJzRm91bmQpIHtcbiAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMuY2hhciArPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMub3RoZXIgKz0gMjtcbiAgICAgICAgbG9nZ2VyLmxvZygnV0FSTklORycsICdDb3VsZG5cXCd0IHBhcnNlIGNsZWFuZWQgZGF0YSAnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgb3JpZzogJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2kgKyAxXV0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICAgKiBQYXJzZSBDb21tYW5kLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBhIGNvbW1hbmQgd2FzIGZvdW5kXG4gICAgICovXG4gIHBhcnNlQ21kIChhLCBiKSB7XG4gICAgbGV0IGNoTnIgPSBudWxsO1xuXG4gICAgbGV0IGNvbmQxID0gKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxQykgJiYgKGIgPj0gMHgyMCAmJiBiIDw9IDB4MkYpO1xuICAgIGxldCBjb25kMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MUYpICYmIChiID49IDB4MjEgJiYgYiA8PSAweDIzKTtcbiAgICBpZiAoIShjb25kMSB8fCBjb25kMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gdGhpcy5sYXN0Q21kQSAmJiBiID09PSB0aGlzLmxhc3RDbWRCKSB7XG4gICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsOyAvLyBSZXBlYXRlZCBjb21tYW5kcyBhcmUgZHJvcHBlZCAob25jZSlcbiAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ1JlcGVhdGVkIGNvbW1hbmQgKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpIGlzIGRyb3BwZWQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChhID09PSAweDE0IHx8IGEgPT09IDB4MTcpIHtcbiAgICAgIGNoTnIgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaE5yID0gMjtcbiAgICB9IC8vIChhID09PSAweDFDIHx8IGE9PT0gMHgxZilcblxuICAgIGxldCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XG5cbiAgICBpZiAoYSA9PT0gMHgxNCB8fCBhID09PSAweDFDKSB7XG4gICAgICBpZiAoYiA9PT0gMHgyMCkge1xuICAgICAgICBjaGFubmVsLmNjUkNMKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjEpIHtcbiAgICAgICAgY2hhbm5lbC5jY0JTKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjIpIHtcbiAgICAgICAgY2hhbm5lbC5jY0FPRigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDIzKSB7XG4gICAgICAgIGNoYW5uZWwuY2NBT04oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNCkge1xuICAgICAgICBjaGFubmVsLmNjREVSKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjUpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JVKDIpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI2KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVSgzKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNykge1xuICAgICAgICBjaGFubmVsLmNjUlUoNCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjgpIHtcbiAgICAgICAgY2hhbm5lbC5jY0ZPTigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI5KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSREMoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyQSkge1xuICAgICAgICBjaGFubmVsLmNjVFIoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyQikge1xuICAgICAgICBjaGFubmVsLmNjUlREKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkMpIHtcbiAgICAgICAgY2hhbm5lbC5jY0VETSgpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJEKSB7XG4gICAgICAgIGNoYW5uZWwuY2NDUigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJFKSB7XG4gICAgICAgIGNoYW5uZWwuY2NFTk0oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyRikge1xuICAgICAgICBjaGFubmVsLmNjRU9DKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gYSA9PSAweDE3IHx8IGEgPT0gMHgxRlxuICAgICAgY2hhbm5lbC5jY1RPKGIgLSAweDIwKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0Q21kQSA9IGE7XG4gICAgdGhpcy5sYXN0Q21kQiA9IGI7XG4gICAgdGhpcy5jdXJyQ2hOciA9IGNoTnI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICAgKiBQYXJzZSBtaWRyb3cgc3R5bGluZyBjb21tYW5kXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gIHBhcnNlTWlkcm93IChhLCBiKSB7XG4gICAgbGV0IGNoTnIgPSBudWxsO1xuXG4gICAgaWYgKCgoYSA9PT0gMHgxMSkgfHwgKGEgPT09IDB4MTkpKSAmJiBiID49IDB4MjAgJiYgYiA8PSAweDJmKSB7XG4gICAgICBpZiAoYSA9PT0gMHgxMSkge1xuICAgICAgICBjaE5yID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoTnIgPSAyO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hOciAhPT0gdGhpcy5jdXJyQ2hOcikge1xuICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdNaXNtYXRjaCBjaGFubmVsIGluIG1pZHJvdyBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XG4gICAgICBjaGFubmVsLmNjTUlEUk9XKGIpO1xuICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAnTUlEUk9XICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICAgKiBQYXJzZSBQcmVhYmxlIEFjY2VzcyBDb2RlcyAoVGFibGUgNTMpLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBQQUMgZm91bmRcbiAgICAgKi9cbiAgcGFyc2VQQUMgKGEsIGIpIHtcbiAgICBsZXQgY2hOciA9IG51bGw7XG4gICAgbGV0IHJvdyA9IG51bGw7XG5cbiAgICBsZXQgY2FzZTEgPSAoKGEgPj0gMHgxMSAmJiBhIDw9IDB4MTcpIHx8IChhID49IDB4MTkgJiYgYSA8PSAweDFGKSkgJiYgKGIgPj0gMHg0MCAmJiBiIDw9IDB4N0YpO1xuICAgIGxldCBjYXNlMiA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmIChiID49IDB4NDAgJiYgYiA8PSAweDVGKTtcbiAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gdGhpcy5sYXN0Q21kQSAmJiBiID09PSB0aGlzLmxhc3RDbWRCKSB7XG4gICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7IC8vIFJlcGVhdGVkIGNvbW1hbmRzIGFyZSBkcm9wcGVkIChvbmNlKVxuICAgIH1cblxuICAgIGNoTnIgPSAoYSA8PSAweDE3KSA/IDEgOiAyO1xuXG4gICAgaWYgKGIgPj0gMHg0MCAmJiBiIDw9IDB4NUYpIHtcbiAgICAgIHJvdyA9IChjaE5yID09PSAxKSA/IHJvd3NMb3dDaDFbYV0gOiByb3dzTG93Q2gyW2FdO1xuICAgIH0gZWxzZSB7IC8vIDB4NjAgPD0gYiA8PSAweDdGXG4gICAgICByb3cgPSAoY2hOciA9PT0gMSkgPyByb3dzSGlnaENoMVthXSA6IHJvd3NIaWdoQ2gyW2FdO1xuICAgIH1cbiAgICBsZXQgcGFjRGF0YSA9IHRoaXMuaW50ZXJwcmV0UEFDKHJvdywgYik7XG4gICAgbGV0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnIgLSAxXTtcbiAgICBjaGFubmVsLnNldFBBQyhwYWNEYXRhKTtcbiAgICB0aGlzLmxhc3RDbWRBID0gYTtcbiAgICB0aGlzLmxhc3RDbWRCID0gYjtcbiAgICB0aGlzLmN1cnJDaE5yID0gY2hOcjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIEludGVycHJldCB0aGUgc2Vjb25kIGJ5dGUgb2YgdGhlIHBhYywgYW5kIHJldHVybiB0aGUgaW5mb3JtYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gcGFjRGF0YSB3aXRoIHN0eWxlIHBhcmFtZXRlcnMuXG4gICAgICovXG4gIGludGVycHJldFBBQyAocm93LCBieXRlKSB7XG4gICAgbGV0IHBhY0luZGV4ID0gYnl0ZTtcbiAgICBsZXQgcGFjRGF0YSA9IHsgY29sb3I6IG51bGwsIGl0YWxpY3M6IGZhbHNlLCBpbmRlbnQ6IG51bGwsIHVuZGVybGluZTogZmFsc2UsIHJvdzogcm93IH07XG5cbiAgICBpZiAoYnl0ZSA+IDB4NUYpIHtcbiAgICAgIHBhY0luZGV4ID0gYnl0ZSAtIDB4NjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY0luZGV4ID0gYnl0ZSAtIDB4NDA7XG4gICAgfVxuXG4gICAgcGFjRGF0YS51bmRlcmxpbmUgPSAocGFjSW5kZXggJiAxKSA9PT0gMTtcbiAgICBpZiAocGFjSW5kZXggPD0gMHhkKSB7XG4gICAgICBwYWNEYXRhLmNvbG9yID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ3doaXRlJ11bTWF0aC5mbG9vcihwYWNJbmRleCAvIDIpXTtcbiAgICB9IGVsc2UgaWYgKHBhY0luZGV4IDw9IDB4Zikge1xuICAgICAgcGFjRGF0YS5pdGFsaWNzID0gdHJ1ZTtcbiAgICAgIHBhY0RhdGEuY29sb3IgPSAnd2hpdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNEYXRhLmluZGVudCA9IChNYXRoLmZsb29yKChwYWNJbmRleCAtIDB4MTApIC8gMikpICogNDtcbiAgICB9XG4gICAgcmV0dXJuIHBhY0RhdGE7IC8vIE5vdGUgdGhhdCByb3cgaGFzIHplcm8gb2Zmc2V0LiBUaGUgc3BlYyB1c2VzIDEuXG4gIH1cblxuICAvKipcbiAgICAgKiBQYXJzZSBjaGFyYWN0ZXJzLlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggMSB0byAyIGNvZGVzIGNvcnJlc3BvbmRpbmcgdG8gY2hhcnMsIGlmIGZvdW5kLiBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgcGFyc2VDaGFycyAoYSwgYikge1xuICAgIGxldCBjaGFubmVsTnIgPSBudWxsLFxuICAgICAgY2hhckNvZGVzID0gbnVsbCxcbiAgICAgIGNoYXJDb2RlMSA9IG51bGw7XG5cbiAgICBpZiAoYSA+PSAweDE5KSB7XG4gICAgICBjaGFubmVsTnIgPSAyO1xuICAgICAgY2hhckNvZGUxID0gYSAtIDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5uZWxOciA9IDE7XG4gICAgICBjaGFyQ29kZTEgPSBhO1xuICAgIH1cbiAgICBpZiAoY2hhckNvZGUxID49IDB4MTEgJiYgY2hhckNvZGUxIDw9IDB4MTMpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2hhcmFjdGVyXG4gICAgICBsZXQgb25lQ29kZSA9IGI7XG4gICAgICBpZiAoY2hhckNvZGUxID09PSAweDExKSB7XG4gICAgICAgIG9uZUNvZGUgPSBiICsgMHg1MDtcbiAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUxID09PSAweDEyKSB7XG4gICAgICAgIG9uZUNvZGUgPSBiICsgMHg3MDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uZUNvZGUgPSBiICsgMHg5MDtcbiAgICAgIH1cblxuICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdTcGVjaWFsIGNoYXIgXFwnJyArIGdldENoYXJGb3JCeXRlKG9uZUNvZGUpICsgJ1xcJyBpbiBjaGFubmVsICcgKyBjaGFubmVsTnIpO1xuICAgICAgY2hhckNvZGVzID0gW29uZUNvZGVdO1xuICAgIH0gZWxzZSBpZiAoYSA+PSAweDIwICYmIGEgPD0gMHg3Zikge1xuICAgICAgY2hhckNvZGVzID0gKGIgPT09IDApID8gW2FdIDogW2EsIGJdO1xuICAgIH1cbiAgICBpZiAoY2hhckNvZGVzKSB7XG4gICAgICBsZXQgaGV4Q29kZXMgPSBudW1BcnJheVRvSGV4QXJyYXkoY2hhckNvZGVzKTtcbiAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ0NoYXIgY29kZXMgPSAgJyArIGhleENvZGVzLmpvaW4oJywnKSk7XG4gICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY2hhckNvZGVzO1xuICB9XG5cbiAgLyoqXG4gICAgKiBQYXJzZSBleHRlbmRlZCBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXMgd2VsbCBhcyBuZXcgZm9yZWdyb3VuZCBjb2xvciBibGFjay5cbiAgICAqIEByZXR1cm5ze0Jvb2xlYW59IFRlbGxzIGlmIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcmUgZm91bmRcbiAgICAqL1xuICBwYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzIChhLCBiKSB7XG4gICAgbGV0IGJrZ0RhdGEsXG4gICAgICBpbmRleCxcbiAgICAgIGNoTnIsXG4gICAgICBjaGFubmVsO1xuXG4gICAgbGV0IGNhc2UxID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgKGIgPj0gMHgyMCAmJiBiIDw9IDB4MmYpO1xuICAgIGxldCBjYXNlMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MWYpICYmIChiID49IDB4MmQgJiYgYiA8PSAweDJmKTtcbiAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBia2dEYXRhID0ge307XG4gICAgaWYgKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkge1xuICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChiIC0gMHgyMCkgLyAyKTtcbiAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9IGJhY2tncm91bmRDb2xvcnNbaW5kZXhdO1xuICAgICAgaWYgKGIgJSAyID09PSAxKSB7XG4gICAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9IGJrZ0RhdGEuYmFja2dyb3VuZCArICdfc2VtaSc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChiID09PSAweDJkKSB7XG4gICAgICBia2dEYXRhLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBia2dEYXRhLmZvcmVncm91bmQgPSAnYmxhY2snO1xuICAgICAgaWYgKGIgPT09IDB4MmYpIHtcbiAgICAgICAgYmtnRGF0YS51bmRlcmxpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjaE5yID0gKGEgPCAweDE4KSA/IDEgOiAyO1xuICAgIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnIgLSAxXTtcbiAgICBjaGFubmVsLnNldEJrZ0RhdGEoYmtnRGF0YSk7XG4gICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICAgKiBSZXNldCBzdGF0ZSBvZiBwYXJzZXIgYW5kIGl0cyBjaGFubmVscy5cbiAgICAgKi9cbiAgcmVzZXQgKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuY2hhbm5lbHNbaV0pIHtcbiAgICAgICAgdGhpcy5jaGFubmVsc1tpXS5yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFRyaWdnZXIgdGhlIGdlbmVyYXRpb24gb2YgYSBjdWUsIGFuZCB0aGUgc3RhcnQgb2YgYSBuZXcgb25lIGlmIGRpc3BsYXlTY3JlZW5zIGFyZSBub3QgZW1wdHkuXG4gICAgICovXG4gIGN1ZVNwbGl0QXRUaW1lICh0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5jaGFubmVsc1tpXSkge1xuICAgICAgICB0aGlzLmNoYW5uZWxzW2ldLmN1ZVNwbGl0QXRUaW1lKHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDZWE2MDhQYXJzZXI7XG4iLCIvLyBmcm9tIGh0dHA6Ly9tcDRyYS5vcmcvY29kZWNzLmh0bWxcbmNvbnN0IHNhbXBsZUVudHJ5Q29kZXNJU08gPSB7XG4gIGF1ZGlvOiB7XG4gICAgJ2EzZHMnOiB0cnVlLFxuICAgICdhYy0zJzogdHJ1ZSxcbiAgICAnYWMtNCc6IHRydWUsXG4gICAgJ2FsYWMnOiB0cnVlLFxuICAgICdhbGF3JzogdHJ1ZSxcbiAgICAnZHJhMSc6IHRydWUsXG4gICAgJ2R0cysnOiB0cnVlLFxuICAgICdkdHMtJzogdHJ1ZSxcbiAgICAnZHRzYyc6IHRydWUsXG4gICAgJ2R0c2UnOiB0cnVlLFxuICAgICdkdHNoJzogdHJ1ZSxcbiAgICAnZWMtMyc6IHRydWUsXG4gICAgJ2VuY2EnOiB0cnVlLFxuICAgICdnNzE5JzogdHJ1ZSxcbiAgICAnZzcyNic6IHRydWUsXG4gICAgJ200YWUnOiB0cnVlLFxuICAgICdtaGExJzogdHJ1ZSxcbiAgICAnbWhhMic6IHRydWUsXG4gICAgJ21obTEnOiB0cnVlLFxuICAgICdtaG0yJzogdHJ1ZSxcbiAgICAnbWxwYSc6IHRydWUsXG4gICAgJ21wNGEnOiB0cnVlLFxuICAgICdyYXcgJzogdHJ1ZSxcbiAgICAnT3B1cyc6IHRydWUsXG4gICAgJ3NhbXInOiB0cnVlLFxuICAgICdzYXdiJzogdHJ1ZSxcbiAgICAnc2F3cCc6IHRydWUsXG4gICAgJ3NldmMnOiB0cnVlLFxuICAgICdzcWNwJzogdHJ1ZSxcbiAgICAnc3Ntdic6IHRydWUsXG4gICAgJ3R3b3MnOiB0cnVlLFxuICAgICd1bGF3JzogdHJ1ZVxuICB9LFxuICB2aWRlbzoge1xuICAgICdhdmMxJzogdHJ1ZSxcbiAgICAnYXZjMic6IHRydWUsXG4gICAgJ2F2YzMnOiB0cnVlLFxuICAgICdhdmM0JzogdHJ1ZSxcbiAgICAnYXZjcCc6IHRydWUsXG4gICAgJ2RyYWMnOiB0cnVlLFxuICAgICdkdmF2JzogdHJ1ZSxcbiAgICAnZHZoZSc6IHRydWUsXG4gICAgJ2VuY3YnOiB0cnVlLFxuICAgICdoZXYxJzogdHJ1ZSxcbiAgICAnaHZjMSc6IHRydWUsXG4gICAgJ21qcDInOiB0cnVlLFxuICAgICdtcDR2JzogdHJ1ZSxcbiAgICAnbXZjMSc6IHRydWUsXG4gICAgJ212YzInOiB0cnVlLFxuICAgICdtdmMzJzogdHJ1ZSxcbiAgICAnbXZjNCc6IHRydWUsXG4gICAgJ3Jlc3YnOiB0cnVlLFxuICAgICdydjYwJzogdHJ1ZSxcbiAgICAnczI2Myc6IHRydWUsXG4gICAgJ3N2YzEnOiB0cnVlLFxuICAgICdzdmMyJzogdHJ1ZSxcbiAgICAndmMtMSc6IHRydWUsXG4gICAgJ3ZwMDgnOiB0cnVlLFxuICAgICd2cDA5JzogdHJ1ZVxuICB9XG59O1xuXG5mdW5jdGlvbiBpc0NvZGVjVHlwZSAoY29kZWMsIHR5cGUpIHtcbiAgY29uc3QgdHlwZUNvZGVzID0gc2FtcGxlRW50cnlDb2Rlc0lTT1t0eXBlXTtcbiAgcmV0dXJuICEhdHlwZUNvZGVzICYmIHR5cGVDb2Rlc1tjb2RlYy5zbGljZSgwLCA0KV0gPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzQ29kZWNTdXBwb3J0ZWRJbk1wNCAoY29kZWMsIHR5cGUpIHtcbiAgcmV0dXJuIHdpbmRvdy5NZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoYCR7dHlwZSB8fCAndmlkZW8nfS9tcDQ7Y29kZWNzPVwiJHtjb2RlY31cImApO1xufVxuXG5leHBvcnQgeyBpc0NvZGVjVHlwZSwgaXNDb2RlY1N1cHBvcnRlZEluTXA0IH07XG4iLCJpbXBvcnQgeyBmaXhMaW5lQnJlYWtzIH0gZnJvbSAnLi92dHRwYXJzZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gbmV3Q3VlICh0cmFjaywgc3RhcnRUaW1lLCBlbmRUaW1lLCBjYXB0aW9uU2NyZWVuKSB7XG4gIGxldCByb3c7XG4gIGxldCBjdWU7XG4gIGxldCBpbmRlbnRpbmc7XG4gIGxldCBpbmRlbnQ7XG4gIGxldCB0ZXh0O1xuICBsZXQgVlRUQ3VlID0gd2luZG93LlZUVEN1ZSB8fCB3aW5kb3cuVGV4dFRyYWNrQ3VlO1xuXG4gIGZvciAobGV0IHIgPSAwOyByIDwgY2FwdGlvblNjcmVlbi5yb3dzLmxlbmd0aDsgcisrKSB7XG4gICAgcm93ID0gY2FwdGlvblNjcmVlbi5yb3dzW3JdO1xuICAgIGluZGVudGluZyA9IHRydWU7XG4gICAgaW5kZW50ID0gMDtcbiAgICB0ZXh0ID0gJyc7XG5cbiAgICBpZiAoIXJvdy5pc0VtcHR5KCkpIHtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgcm93LmNoYXJzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgIGlmIChyb3cuY2hhcnNbY10udWNoYXIubWF0Y2goL1xccy8pICYmIGluZGVudGluZykge1xuICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHQgKz0gcm93LmNoYXJzW2NdLnVjaGFyO1xuICAgICAgICAgIGluZGVudGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBUbyBiZSB1c2VkIGZvciBjbGVhbmluZy11cCBvcnBoYW5lZCByb2xsLXVwIGNhcHRpb25zXG4gICAgICByb3cuY3VlU3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuXG4gICAgICAvLyBHaXZlIGEgc2xpZ2h0IGJ1bXAgdG8gdGhlIGVuZFRpbWUgaWYgaXQncyBlcXVhbCB0byBzdGFydFRpbWUgdG8gYXZvaWQgYSBTeW50YXhFcnJvciBpbiBJRVxuICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gZW5kVGltZSkge1xuICAgICAgICBlbmRUaW1lICs9IDAuMDAwMTtcbiAgICAgIH1cblxuICAgICAgY3VlID0gbmV3IFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIGZpeExpbmVCcmVha3ModGV4dC50cmltKCkpKTtcblxuICAgICAgaWYgKGluZGVudCA+PSAxNikge1xuICAgICAgICBpbmRlbnQtLTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGVudCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBWVFRDdWUubGluZSBnZXQncyBmbGFrZXkgd2hlbiB1c2luZyBjb250cm9scywgc28gbGV0J3Mgbm93IGluY2x1ZGUgbGluZSAxMyYxNFxuICAgICAgLy8gYWxzbywgZHJvcCBsaW5lIDEgc2luY2UgaXQncyB0byBjbG9zZSB0byB0aGUgdG9wXG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLy8pKSB7XG4gICAgICAgIGN1ZS5saW5lID0gciArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdWUubGluZSA9IChyID4gNyA/IHIgLSAyIDogciArIDEpO1xuICAgICAgfVxuXG4gICAgICBjdWUuYWxpZ24gPSAnbGVmdCc7XG4gICAgICAvLyBDbGFtcCB0aGUgcG9zaXRpb24gYmV0d2VlbiAwIGFuZCAxMDAgLSBpZiBvdXQgb2YgdGhlc2UgYm91bmRzLCBGaXJlZm94IHRocm93cyBhbiBleGNlcHRpb24gYW5kIGNhcHRpb25zIGJyZWFrXG4gICAgICBjdWUucG9zaXRpb24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIDEwMCAqIChpbmRlbnQgLyAzMikgKyAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLy8pID8gNTAgOiAwKSkpO1xuICAgICAgdHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgQmluYXJ5U2VhcmNoIGZyb20gJy4vYmluYXJ5LXNlYXJjaCc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZEZpcnN0RnJhZ1dpdGhDQyAoZnJhZ21lbnRzLCBjYykge1xuICBsZXQgZmlyc3RGcmFnID0gbnVsbDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYWdtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGN1cnJlbnRGcmFnID0gZnJhZ21lbnRzW2ldO1xuICAgIGlmIChjdXJyZW50RnJhZyAmJiBjdXJyZW50RnJhZy5jYyA9PT0gY2MpIHtcbiAgICAgIGZpcnN0RnJhZyA9IGN1cnJlbnRGcmFnO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpcnN0RnJhZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGcmFnV2l0aENDIChmcmFnbWVudHMsIENDKSB7XG4gIHJldHVybiBCaW5hcnlTZWFyY2guc2VhcmNoKGZyYWdtZW50cywgKGNhbmRpZGF0ZSkgPT4ge1xuICAgIGlmIChjYW5kaWRhdGUuY2MgPCBDQykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChjYW5kaWRhdGUuY2MgPiBDQykge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyAobGFzdEZyYWcsIGxhc3RMZXZlbCwgZGV0YWlscykge1xuICBsZXQgc2hvdWxkQWxpZ24gPSBmYWxzZTtcbiAgaWYgKGxhc3RMZXZlbCAmJiBsYXN0TGV2ZWwuZGV0YWlscyAmJiBkZXRhaWxzKSB7XG4gICAgaWYgKGRldGFpbHMuZW5kQ0MgPiBkZXRhaWxzLnN0YXJ0Q0MgfHwgKGxhc3RGcmFnICYmIGxhc3RGcmFnLmNjIDwgZGV0YWlscy5zdGFydENDKSkge1xuICAgICAgc2hvdWxkQWxpZ24gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2hvdWxkQWxpZ247XG59XG5cbi8vIEZpbmQgdGhlIGZpcnN0IGZyYWcgaW4gdGhlIHByZXZpb3VzIGxldmVsIHdoaWNoIG1hdGNoZXMgdGhlIENDIG9mIHRoZSBmaXJzdCBmcmFnIG9mIHRoZSBuZXcgbGV2ZWxcbmV4cG9ydCBmdW5jdGlvbiBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWcgKHByZXZEZXRhaWxzLCBjdXJEZXRhaWxzKSB7XG4gIGNvbnN0IHByZXZGcmFncyA9IHByZXZEZXRhaWxzLmZyYWdtZW50cztcbiAgY29uc3QgY3VyRnJhZ3MgPSBjdXJEZXRhaWxzLmZyYWdtZW50cztcblxuICBpZiAoIWN1ckZyYWdzLmxlbmd0aCB8fCAhcHJldkZyYWdzLmxlbmd0aCkge1xuICAgIGxvZ2dlci5sb2coJ05vIGZyYWdtZW50cyB0byBhbGlnbicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHByZXZTdGFydEZyYWcgPSBmaW5kRmlyc3RGcmFnV2l0aENDKHByZXZGcmFncywgY3VyRnJhZ3NbMF0uY2MpO1xuXG4gIGlmICghcHJldlN0YXJ0RnJhZyB8fCAocHJldlN0YXJ0RnJhZyAmJiAhcHJldlN0YXJ0RnJhZy5zdGFydFBUUykpIHtcbiAgICBsb2dnZXIubG9nKCdObyBmcmFnIGluIHByZXZpb3VzIGxldmVsIHRvIGFsaWduIG9uJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIHByZXZTdGFydEZyYWc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RQdHMgKHNsaWRpbmcsIGRldGFpbHMpIHtcbiAgZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaCgoZnJhZykgPT4ge1xuICAgIGlmIChmcmFnKSB7XG4gICAgICBsZXQgc3RhcnQgPSBmcmFnLnN0YXJ0ICsgc2xpZGluZztcbiAgICAgIGZyYWcuc3RhcnQgPSBmcmFnLnN0YXJ0UFRTID0gc3RhcnQ7XG4gICAgICBmcmFnLmVuZFBUUyA9IHN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgICB9XG4gIH0pO1xuICBkZXRhaWxzLlBUU0tub3duID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVc2luZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgbGFzdCBsZXZlbCwgdGhpcyBmdW5jdGlvbiBjb21wdXRlcyBQVFMnIG9mIHRoZSBuZXcgZnJhZ21lbnRzIHNvIHRoYXQgdGhleSBmb3JtIGFcbiAqIGNvbnRpZ3VvdXMgc3RyZWFtIHdpdGggdGhlIGxhc3QgZnJhZ21lbnRzLlxuICogVGhlIFBUUyBvZiBhIGZyYWdtZW50IGxldHMgSGxzLmpzIGtub3cgd2hlcmUgaXQgZml0cyBpbnRvIGEgc3RyZWFtIC0gYnkga25vd2luZyBldmVyeSBQVFMsIHdlIGtub3cgd2hpY2ggZnJhZ21lbnQgdG9cbiAqIGRvd25sb2FkIGF0IGFueSBnaXZlbiB0aW1lLiBQVFMgaXMgbm9ybWFsbHkgY29tcHV0ZWQgd2hlbiB0aGUgZnJhZ21lbnQgaXMgZGVtdXhlZCwgc28gdGFraW5nIHRoaXMgc3RlcCBzYXZlcyB1cyB0aW1lXG4gKiBhbmQgYW4gZXh0cmEgZG93bmxvYWQuXG4gKiBAcGFyYW0gbGFzdEZyYWdcbiAqIEBwYXJhbSBsYXN0TGV2ZWxcbiAqIEBwYXJhbSBkZXRhaWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGlnblN0cmVhbSAobGFzdEZyYWcsIGxhc3RMZXZlbCwgZGV0YWlscykge1xuICBhbGlnbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgZGV0YWlscywgbGFzdExldmVsKTtcbiAgaWYgKCFkZXRhaWxzLlBUU0tub3duICYmIGxhc3RMZXZlbCkge1xuICAgIC8vIElmIHRoZSBQVFMgd2Fzbid0IGZpZ3VyZWQgb3V0IHZpYSBkaXNjb250aW51aXR5IHNlcXVlbmNlIHRoYXQgbWVhbnMgdGhlcmUgd2FzIG5vIENDIGluY3JlYXNlIHdpdGhpbiB0aGUgbGV2ZWwuXG4gICAgLy8gQWxpZ25pbmcgdmlhIFByb2dyYW0gRGF0ZSBUaW1lIHNob3VsZCB0aGVyZWZvcmUgYmUgcmVsaWFibGUsIHNpbmNlIFBEVCBzaG91bGQgYmUgdGhlIHNhbWUgd2l0aGluIHRoZSBzYW1lXG4gICAgLy8gZGlzY29udGludWl0eSBzZXF1ZW5jZS5cbiAgICBhbGlnblBEVChkZXRhaWxzLCBsYXN0TGV2ZWwuZGV0YWlscyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUFRTIGlmIGEgbmV3IGxldmVsJ3MgZnJhZ21lbnRzIHVzaW5nIHRoZSBQVFMgb2YgYSBmcmFnbWVudCBpbiB0aGUgbGFzdCBsZXZlbCB3aGljaCBzaGFyZXMgdGhlIHNhbWVcbiAqIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UuXG4gKiBAcGFyYW0gbGFzdExldmVsIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBuZXcgbGV2ZWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFsaWduRGlzY29udGludWl0aWVzIChsYXN0RnJhZywgZGV0YWlscywgbGFzdExldmVsKSB7XG4gIGlmIChzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBsYXN0TGV2ZWwsIGRldGFpbHMpKSB7XG4gICAgY29uc3QgcmVmZXJlbmNlRnJhZyA9IGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyhsYXN0TGV2ZWwuZGV0YWlscywgZGV0YWlscyk7XG4gICAgaWYgKHJlZmVyZW5jZUZyYWcpIHtcbiAgICAgIGxvZ2dlci5sb2coJ0FkanVzdGluZyBQVFMgdXNpbmcgbGFzdCBsZXZlbCBkdWUgdG8gQ0MgaW5jcmVhc2Ugd2l0aGluIGN1cnJlbnQgbGV2ZWwnKTtcbiAgICAgIGFkanVzdFB0cyhyZWZlcmVuY2VGcmFnLnN0YXJ0LCBkZXRhaWxzKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUFRTIG9mIGEgbmV3IGxldmVsJ3MgZnJhZ21lbnRzIHVzaW5nIHRoZSBkaWZmZXJlbmNlIGluIFByb2dyYW0gRGF0ZSBUaW1lIGZyb20gdGhlIGxhc3QgbGV2ZWwuXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBuZXcgbGV2ZWxcbiAqIEBwYXJhbSBsYXN0RGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBsYXN0IGxvYWRlZCBsZXZlbFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWxpZ25QRFQgKGRldGFpbHMsIGxhc3REZXRhaWxzKSB7XG4gIGlmIChsYXN0RGV0YWlscyAmJiBsYXN0RGV0YWlscy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgaWYgKCFkZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSB8fCAhbGFzdERldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGlmIGxhc3QgbGV2ZWwgc2xpZGluZyBpcyAxMDAwIGFuZCBpdHMgZmlyc3QgZnJhZyBQUk9HUkFNLURBVEUtVElNRSBpcyAyMDE3LTA4LTIwIDE6MTA6MDAgQU1cbiAgICAvLyBhbmQgaWYgbmV3IGRldGFpbHMgZmlyc3QgZnJhZyBQUk9HUkFNIERBVEUtVElNRSBpcyAyMDE3LTA4LTIwIDE6MTA6MDggQU1cbiAgICAvLyB0aGVuIHdlIGNhbiBkZWR1Y2UgdGhhdCBwbGF5bGlzdCBCIHNsaWRpbmcgaXMgMTAwMCs4ID0gMTAwOHNcbiAgICBsZXQgbGFzdFBEVCA9IGxhc3REZXRhaWxzLmZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7XG4gICAgbGV0IG5ld1BEVCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZTtcbiAgICAvLyBkYXRlIGRpZmYgaXMgaW4gbXMuIGZyYWcuc3RhcnQgaXMgaW4gc2Vjb25kc1xuICAgIGxldCBzbGlkaW5nID0gKG5ld1BEVCAtIGxhc3RQRFQpIC8gMTAwMCArIGxhc3REZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHNsaWRpbmcpKSB7XG4gICAgICBsb2dnZXIubG9nKGBhZGp1c3RpbmcgUFRTIHVzaW5nIHByb2dyYW1EYXRlVGltZSBkZWx0YSwgc2xpZGluZzoke3NsaWRpbmcudG9GaXhlZCgzKX1gKTtcbiAgICAgIGFkanVzdFB0cyhzbGlkaW5nLCBkZXRhaWxzKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBFV01BIEJhbmR3aWR0aCBFc3RpbWF0b3JcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAqIFRyYWNrcyBiYW5kd2lkdGggc2FtcGxlcyBhbmQgZXN0aW1hdGVzIGF2YWlsYWJsZSBiYW5kd2lkdGguXG4gKiBCYXNlZCBvbiB0aGUgbWluaW11bSBvZiB0d28gZXhwb25lbnRpYWxseS13ZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZXMgd2l0aFxuICogZGlmZmVyZW50IGhhbGYtbGl2ZXMuXG4gKi9cblxuaW1wb3J0IEVXTUEgZnJvbSAnLi4vdXRpbHMvZXdtYSc7XG5cbmNsYXNzIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3Ige1xuICBjb25zdHJ1Y3RvciAoaGxzLCBzbG93LCBmYXN0LCBkZWZhdWx0RXN0aW1hdGUpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmRlZmF1bHRFc3RpbWF0ZV8gPSBkZWZhdWx0RXN0aW1hdGU7XG4gICAgdGhpcy5taW5XZWlnaHRfID0gMC4wMDE7XG4gICAgdGhpcy5taW5EZWxheU1zXyA9IDUwO1xuICAgIHRoaXMuc2xvd18gPSBuZXcgRVdNQShzbG93KTtcbiAgICB0aGlzLmZhc3RfID0gbmV3IEVXTUEoZmFzdCk7XG4gIH1cblxuICBzYW1wbGUgKGR1cmF0aW9uTXMsIG51bUJ5dGVzKSB7XG4gICAgZHVyYXRpb25NcyA9IE1hdGgubWF4KGR1cmF0aW9uTXMsIHRoaXMubWluRGVsYXlNc18pO1xuICAgIGxldCBiYW5kd2lkdGggPSA4MDAwICogbnVtQnl0ZXMgLyBkdXJhdGlvbk1zLFxuICAgICAgLy8gY29uc29sZS5sb2coJ2luc3RhbnQgYnc6JysgTWF0aC5yb3VuZChiYW5kd2lkdGgpKTtcbiAgICAgIC8vIHdlIHdlaWdodCBzYW1wbGUgdXNpbmcgbG9hZGluZyBkdXJhdGlvbi4uLi5cbiAgICAgIHdlaWdodCA9IGR1cmF0aW9uTXMgLyAxMDAwO1xuICAgIHRoaXMuZmFzdF8uc2FtcGxlKHdlaWdodCwgYmFuZHdpZHRoKTtcbiAgICB0aGlzLnNsb3dfLnNhbXBsZSh3ZWlnaHQsIGJhbmR3aWR0aCk7XG4gIH1cblxuICBjYW5Fc3RpbWF0ZSAoKSB7XG4gICAgbGV0IGZhc3QgPSB0aGlzLmZhc3RfO1xuICAgIHJldHVybiAoZmFzdCAmJiBmYXN0LmdldFRvdGFsV2VpZ2h0KCkgPj0gdGhpcy5taW5XZWlnaHRfKTtcbiAgfVxuXG4gIGdldEVzdGltYXRlICgpIHtcbiAgICBpZiAodGhpcy5jYW5Fc3RpbWF0ZSgpKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnc2xvdyBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ2Zhc3QgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLmZhc3RfLmdldEVzdGltYXRlKCkpKTtcbiAgICAgIC8vIFRha2UgdGhlIG1pbmltdW0gb2YgdGhlc2UgdHdvIGVzdGltYXRlcy4gIFRoaXMgc2hvdWxkIGhhdmUgdGhlIGVmZmVjdCBvZlxuICAgICAgLy8gYWRhcHRpbmcgZG93biBxdWlja2x5LCBidXQgdXAgbW9yZSBzbG93bHkuXG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpLCB0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXN0aW1hdGVfO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBFd21hQmFuZFdpZHRoRXN0aW1hdG9yO1xuIiwiLypcbiAqIGNvbXB1dGUgYW4gRXhwb25lbnRpYWwgV2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VcbiAqIC0gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW92aW5nX2F2ZXJhZ2UjRXhwb25lbnRpYWxfbW92aW5nX2F2ZXJhZ2VcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAqL1xuXG5jbGFzcyBFV01BIHtcbiAgLy8gIEFib3V0IGhhbGYgb2YgdGhlIGVzdGltYXRlZCB2YWx1ZSB3aWxsIGJlIGZyb20gdGhlIGxhc3QgfGhhbGZMaWZlfCBzYW1wbGVzIGJ5IHdlaWdodC5cbiAgY29uc3RydWN0b3IgKGhhbGZMaWZlKSB7XG4gICAgLy8gTGFyZ2VyIHZhbHVlcyBvZiBhbHBoYSBleHBpcmUgaGlzdG9yaWNhbCBkYXRhIG1vcmUgc2xvd2x5LlxuICAgIHRoaXMuYWxwaGFfID0gaGFsZkxpZmUgPyBNYXRoLmV4cChNYXRoLmxvZygwLjUpIC8gaGFsZkxpZmUpIDogMDtcbiAgICB0aGlzLmVzdGltYXRlXyA9IDA7XG4gICAgdGhpcy50b3RhbFdlaWdodF8gPSAwO1xuICB9XG5cbiAgc2FtcGxlICh3ZWlnaHQsIHZhbHVlKSB7XG4gICAgbGV0IGFkakFscGhhID0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHdlaWdodCk7XG4gICAgdGhpcy5lc3RpbWF0ZV8gPSB2YWx1ZSAqICgxIC0gYWRqQWxwaGEpICsgYWRqQWxwaGEgKiB0aGlzLmVzdGltYXRlXztcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyArPSB3ZWlnaHQ7XG4gIH1cblxuICBnZXRUb3RhbFdlaWdodCAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG90YWxXZWlnaHRfO1xuICB9XG5cbiAgZ2V0RXN0aW1hdGUgKCkge1xuICAgIGlmICh0aGlzLmFscGhhXykge1xuICAgICAgbGV0IHplcm9GYWN0b3IgPSAxIC0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHRoaXMudG90YWxXZWlnaHRfKTtcbiAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlXyAvIHplcm9GYWN0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlXztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRVdNQTtcbiIsImV4cG9ydCBmdW5jdGlvbiBnZXRTZWxmU2NvcGUgKCkge1xuICAvLyBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExMjM3MjU5LzU4OTQ5M1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWYgKi9cbiAgICByZXR1cm4gc2VsZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG59XG4iLCJpbXBvcnQgeyBnZXRTZWxmU2NvcGUgfSBmcm9tICcuL2dldC1zZWxmLXNjb3BlJztcblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5jb25zdCBmYWtlTG9nZ2VyID0ge1xuICB0cmFjZTogbm9vcCxcbiAgZGVidWc6IG5vb3AsXG4gIGxvZzogbm9vcCxcbiAgd2Fybjogbm9vcCxcbiAgaW5mbzogbm9vcCxcbiAgZXJyb3I6IG5vb3Bcbn07XG5cbmxldCBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG5cbi8vIGxldCBsYXN0Q2FsbFRpbWU7XG4vLyBmdW5jdGlvbiBmb3JtYXRNc2dXaXRoVGltZUluZm8odHlwZSwgbXNnKSB7XG4vLyAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4vLyAgIGNvbnN0IGRpZmYgPSBsYXN0Q2FsbFRpbWUgPyAnKycgKyAobm93IC0gbGFzdENhbGxUaW1lKSA6ICcwJztcbi8vICAgbGFzdENhbGxUaW1lID0gbm93O1xuLy8gICBtc2cgPSAobmV3IERhdGUobm93KSkudG9JU09TdHJpbmcoKSArICcgfCBbJyArICB0eXBlICsgJ10gPiAnICsgbXNnICsgJyAoICcgKyBkaWZmICsgJyBtcyApJztcbi8vICAgcmV0dXJuIG1zZztcbi8vIH1cblxuZnVuY3Rpb24gZm9ybWF0TXNnICh0eXBlLCBtc2cpIHtcbiAgbXNnID0gJ1snICsgdHlwZSArICddID4gJyArIG1zZztcbiAgcmV0dXJuIG1zZztcbn1cblxuY29uc3QgZ2xvYmFsID0gZ2V0U2VsZlNjb3BlKCk7XG5cbmZ1bmN0aW9uIGNvbnNvbGVQcmludEZuICh0eXBlKSB7XG4gIGNvbnN0IGZ1bmMgPSBnbG9iYWwuY29uc29sZVt0eXBlXTtcbiAgaWYgKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgIGlmIChhcmdzWzBdKSB7XG4gICAgICAgIGFyZ3NbMF0gPSBmb3JtYXRNc2codHlwZSwgYXJnc1swXSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmMuYXBwbHkoZ2xvYmFsLmNvbnNvbGUsIGFyZ3MpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIG5vb3A7XG59XG5cbmZ1bmN0aW9uIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyAoZGVidWdDb25maWcsIC4uLmZ1bmN0aW9ucykge1xuICBmdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGV4cG9ydGVkTG9nZ2VyW3R5cGVdID0gZGVidWdDb25maWdbdHlwZV0gPyBkZWJ1Z0NvbmZpZ1t0eXBlXS5iaW5kKGRlYnVnQ29uZmlnKSA6IGNvbnNvbGVQcmludEZuKHR5cGUpO1xuICB9KTtcbn1cblxuZXhwb3J0IHZhciBlbmFibGVMb2dzID0gZnVuY3Rpb24gKGRlYnVnQ29uZmlnKSB7XG4gIGlmIChkZWJ1Z0NvbmZpZyA9PT0gdHJ1ZSB8fCB0eXBlb2YgZGVidWdDb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgZXhwb3J0TG9nZ2VyRnVuY3Rpb25zKGRlYnVnQ29uZmlnLFxuICAgICAgLy8gUmVtb3ZlIG91dCBmcm9tIGxpc3QgaGVyZSB0byBoYXJkLWRpc2FibGUgYSBsb2ctbGV2ZWxcbiAgICAgIC8vICd0cmFjZScsXG4gICAgICAnZGVidWcnLFxuICAgICAgJ2xvZycsXG4gICAgICAnaW5mbycsXG4gICAgICAnd2FybicsXG4gICAgICAnZXJyb3InXG4gICAgKTtcbiAgICAvLyBTb21lIGJyb3dzZXJzIGRvbid0IGFsbG93IHRvIHVzZSBiaW5kIG9uIGNvbnNvbGUgb2JqZWN0IGFueXdheVxuICAgIC8vIGZhbGxiYWNrIHRvIGRlZmF1bHQgaWYgbmVlZGVkXG4gICAgdHJ5IHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyLmxvZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIGxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xuIiwiY29uc3QgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MuYmluZCh3aW5kb3cubmF2aWdhdG9yKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufSkoKTtcblxuZXhwb3J0IHtcbiAgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzXG59O1xuIiwiLyoqXG4gKiBNZWRpYVNvdXJjZSBoZWxwZXJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVkaWFTb3VyY2UgKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gd2luZG93Lk1lZGlhU291cmNlIHx8IHdpbmRvdy5XZWJLaXRNZWRpYVNvdXJjZTtcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3V0cHV0RmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKHRpbWVsaW5lQ29udHJvbGxlciwgdHJhY2tOYW1lKSB7XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSB0aW1lbGluZUNvbnRyb2xsZXI7XG4gICAgdGhpcy50cmFja05hbWUgPSB0cmFja05hbWU7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgIHRoaXMuZW5kVGltZSA9IG51bGw7XG4gICAgdGhpcy5zY3JlZW4gPSBudWxsO1xuICB9XG5cbiAgZGlzcGF0Y2hDdWUgKCkge1xuICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyLmFkZEN1ZXModGhpcy50cmFja05hbWUsIHRoaXMuc3RhcnRUaW1lLCB0aGlzLmVuZFRpbWUsIHRoaXMuc2NyZWVuKTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gIH1cblxuICBuZXdDdWUgKHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRUaW1lID09PSBudWxsIHx8IHRoaXMuc3RhcnRUaW1lID4gc3RhcnRUaW1lKSB7XG4gICAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICB9XG5cbiAgICB0aGlzLmVuZFRpbWUgPSBlbmRUaW1lO1xuICAgIHRoaXMuc2NyZWVuID0gc2NyZWVuO1xuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyLmNyZWF0ZUNhcHRpb25zVHJhY2sodGhpcy50cmFja05hbWUpO1xuICB9XG59XG4iLCJcbmV4cG9ydCBmdW5jdGlvbiBzZW5kQWRkVHJhY2tFdmVudCAodHJhY2ssIHZpZGVvRWwpIHtcbiAgbGV0IGV2ZW50ID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBldmVudCA9IG5ldyB3aW5kb3cuRXZlbnQoJ2FkZHRyYWNrJyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIGZvciBJRTExXG4gICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoJ2FkZHRyYWNrJywgZmFsc2UsIGZhbHNlKTtcbiAgfVxuICBldmVudC50cmFjayA9IHRyYWNrO1xuICB2aWRlb0VsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDdXJyZW50Q3VlcyAodHJhY2spIHtcbiAgaWYgKHRyYWNrICYmIHRyYWNrLmN1ZXMpIHtcbiAgICB3aGlsZSAodHJhY2suY3Vlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0cmFjay5yZW1vdmVDdWUodHJhY2suY3Vlc1swXSk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqICBUaW1lUmFuZ2VzIHRvIHN0cmluZyBoZWxwZXJcbiAqL1xuXG5jb25zdCBUaW1lUmFuZ2VzID0ge1xuICB0b1N0cmluZzogZnVuY3Rpb24gKHIpIHtcbiAgICBsZXQgbG9nID0gJycsIGxlbiA9IHIubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxvZyArPSAnWycgKyByLnN0YXJ0KGkpLnRvRml4ZWQoMykgKyAnLCcgKyByLmVuZChpKS50b0ZpeGVkKDMpICsgJ10nO1xuICAgIH1cblxuICAgIHJldHVybiBsb2c7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVSYW5nZXM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVlRUQ3VlKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5WVFRDdWU7XG4gIH1cblxuICBsZXQgYXV0b0tleXdvcmQgPSAnYXV0byc7XG4gIGxldCBkaXJlY3Rpb25TZXR0aW5nID0ge1xuICAgICcnOiB0cnVlLFxuICAgIGxyOiB0cnVlLFxuICAgIHJsOiB0cnVlXG4gIH07XG4gIGxldCBhbGlnblNldHRpbmcgPSB7XG4gICAgc3RhcnQ6IHRydWUsXG4gICAgbWlkZGxlOiB0cnVlLFxuICAgIGVuZDogdHJ1ZSxcbiAgICBsZWZ0OiB0cnVlLFxuICAgIHJpZ2h0OiB0cnVlXG4gIH07XG5cbiAgZnVuY3Rpb24gZmluZERpcmVjdGlvblNldHRpbmcgKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgZGlyID0gZGlyZWN0aW9uU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcbiAgICByZXR1cm4gZGlyID8gdmFsdWUudG9Mb3dlckNhc2UoKSA6IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEFsaWduU2V0dGluZyAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBhbGlnbiA9IGFsaWduU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcbiAgICByZXR1cm4gYWxpZ24gPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQgKG9iaikge1xuICAgIGxldCBpID0gMTtcbiAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGNvYmogPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKGxldCBwIGluIGNvYmopIHtcbiAgICAgICAgb2JqW3BdID0gY29ialtwXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gVlRUQ3VlIChzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcbiAgICBsZXQgY3VlID0gdGhpcztcbiAgICBsZXQgaXNJRTggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgvTVNJRVxcczhcXC4wLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9KSgpO1xuICAgIGxldCBiYXNlT2JqID0ge307XG5cbiAgICBpZiAoaXNJRTgpIHtcbiAgICAgIGN1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlT2JqLmVudW1lcmFibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNoaW0gaW1wbGVtZW50YXRpb24gc3BlY2lmaWMgcHJvcGVydGllcy4gVGhlc2UgcHJvcGVydGllcyBhcmUgbm90IGluXG4gICAgICogdGhlIHNwZWMuXG4gICAgICovXG5cbiAgICAvLyBMZXRzIHVzIGtub3cgd2hlbiB0aGUgVlRUQ3VlJ3MgZGF0YSBoYXMgY2hhbmdlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgbmVlZFxuICAgIC8vIHRvIHJlY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZS4gVGhpcyBsZXRzIHVzIGNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGVcbiAgICAvLyBsYXppbHkuXG4gICAgY3VlLmhhc0JlZW5SZXNldCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVlRUQ3VlIGFuZCBUZXh0VHJhY2tDdWUgcHJvcGVydGllc1xuICAgICAqIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0Y3VlLWludGVyZmFjZVxuICAgICAqL1xuXG4gICAgbGV0IF9pZCA9ICcnO1xuICAgIGxldCBfcGF1c2VPbkV4aXQgPSBmYWxzZTtcbiAgICBsZXQgX3N0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICBsZXQgX2VuZFRpbWUgPSBlbmRUaW1lO1xuICAgIGxldCBfdGV4dCA9IHRleHQ7XG4gICAgbGV0IF9yZWdpb24gPSBudWxsO1xuICAgIGxldCBfdmVydGljYWwgPSAnJztcbiAgICBsZXQgX3NuYXBUb0xpbmVzID0gdHJ1ZTtcbiAgICBsZXQgX2xpbmUgPSAnYXV0byc7XG4gICAgbGV0IF9saW5lQWxpZ24gPSAnc3RhcnQnO1xuICAgIGxldCBfcG9zaXRpb24gPSA1MDtcbiAgICBsZXQgX3Bvc2l0aW9uQWxpZ24gPSAnbWlkZGxlJztcbiAgICBsZXQgX3NpemUgPSA1MDtcbiAgICBsZXQgX2FsaWduID0gJ21pZGRsZSc7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnaWQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2lkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF9pZCA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3BhdXNlT25FeGl0JywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9wYXVzZU9uRXhpdDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfcGF1c2VPbkV4aXQgPSAhIXZhbHVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzdGFydFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3N0YXJ0VGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0YXJ0IHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfc3RhcnRUaW1lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnZW5kVGltZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZW5kVGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuZCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2VuZFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICd0ZXh0JywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90ZXh0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF90ZXh0ID0gJycgKyB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdyZWdpb24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2lvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfcmVnaW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndmVydGljYWwnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3ZlcnRpY2FsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGxldCBzZXR0aW5nID0gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpO1xuICAgICAgICAvLyBIYXZlIHRvIGNoZWNrIGZvciBmYWxzZSBiZWNhdXNlIHRoZSBzZXR0aW5nIGFuIGJlIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgaWYgKHNldHRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfdmVydGljYWwgPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NuYXBUb0xpbmVzJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwVG9MaW5lcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfc25hcFRvTGluZXMgPSAhIXZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2xpbmUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2xpbmU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgJiYgdmFsdWUgIT09IGF1dG9LZXl3b3JkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG51bWJlciBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2xpbmUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdsaW5lQWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2xpbmVBbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBsZXQgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9saW5lQWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NpdGlvbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3Bvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncG9zaXRpb25BbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcG9zaXRpb25BbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBsZXQgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wb3NpdGlvbkFsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzaXplJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpemUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zaXplID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnYWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2FsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGxldCBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2FsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIE90aGVyIDx0cmFjaz4gc3BlYyBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICAgKi9cblxuICAgIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS12aWRlby1lbGVtZW50Lmh0bWwjdGV4dC10cmFjay1jdWUtZGlzcGxheS1zdGF0ZVxuICAgIGN1ZS5kaXNwbGF5U3RhdGUgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNJRTgpIHtcbiAgICAgIHJldHVybiBjdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZUVEN1ZSBtZXRob2RzXG4gICAqL1xuXG4gIFZUVEN1ZS5wcm90b3R5cGUuZ2V0Q3VlQXNIVE1MID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEFzc3VtZSBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSBpcyBvbiB0aGUgZ2xvYmFsLlxuICAgIGxldCBXZWJWVFQgPSB3aW5kb3cuV2ViVlRUO1xuICAgIHJldHVybiBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSh3aW5kb3csIHRoaXMudGV4dCk7XG4gIH07XG5cbiAgcmV0dXJuIFZUVEN1ZTtcbn0pKCk7XG4iLCIvKlxuICogU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS92dHQuanMvYmxvYi9tYXN0ZXIvZGlzdC92dHQuanMjTDE3MTZcbiAqL1xuXG5pbXBvcnQgVlRUQ3VlIGZyb20gJy4vdnR0Y3VlJztcblxuY29uc3QgU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uIFN0cmluZ0RlY29kZXIgKCkge1xuICByZXR1cm4ge1xuICAgIGRlY29kZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIGV4cGVjdGVkIHN0cmluZyBkYXRhLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudChkYXRhKSk7XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gVlRUUGFyc2VyICgpIHtcbiAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gIHRoaXMuc3RhdGUgPSAnSU5JVElBTCc7XG4gIHRoaXMuYnVmZmVyID0gJyc7XG4gIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCk7XG4gIHRoaXMucmVnaW9uTGlzdCA9IFtdO1xufVxuXG4vLyBUcnkgdG8gcGFyc2UgaW5wdXQgYXMgYSB0aW1lIHN0YW1wLlxuZnVuY3Rpb24gcGFyc2VUaW1lU3RhbXAgKGlucHV0KSB7XG4gIGZ1bmN0aW9uIGNvbXB1dGVTZWNvbmRzIChoLCBtLCBzLCBmKSB7XG4gICAgcmV0dXJuIChoIHwgMCkgKiAzNjAwICsgKG0gfCAwKSAqIDYwICsgKHMgfCAwKSArIChmIHwgMCkgLyAxMDAwO1xuICB9XG5cbiAgbGV0IG0gPSBpbnB1dC5tYXRjaCgvXihcXGQrKTooXFxkezJ9KSg6XFxkezJ9KT9cXC4oXFxkezN9KS8pO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChtWzNdKSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCBtWzNdLnJlcGxhY2UoJzonLCAnJyksIG1bNF0pO1xuICB9IGVsc2UgaWYgKG1bMV0gPiA1OSkge1xuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXS5bbWlsbGlzZWNvbmRzXVxuICAgIC8vIEZpcnN0IHBvc2l0aW9uIGlzIGhvdXJzIGFzIGl0J3Mgb3ZlciA1OS5cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsxXSwgbVsyXSwgMCwgbVs0XSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMoMCwgbVsxXSwgbVsyXSwgbVs0XSk7XG4gIH1cbn1cblxuLy8gQSBzZXR0aW5ncyBvYmplY3QgaG9sZHMga2V5L3ZhbHVlIHBhaXJzIGFuZCB3aWxsIGlnbm9yZSBhbnl0aGluZyBidXQgdGhlIGZpcnN0XG4vLyBhc3NpZ25tZW50IHRvIGEgc3BlY2lmaWMga2V5LlxuZnVuY3Rpb24gU2V0dGluZ3MgKCkge1xuICB0aGlzLnZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cblNldHRpbmdzLnByb3RvdHlwZSA9IHtcbiAgLy8gT25seSBhY2NlcHQgdGhlIGZpcnN0IGFzc2lnbm1lbnQgdG8gYW55IGtleS5cbiAgc2V0OiBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICghdGhpcy5nZXQoaykgJiYgdiAhPT0gJycpIHtcbiAgICAgIHRoaXMudmFsdWVzW2tdID0gdjtcbiAgICB9XG4gIH0sXG4gIC8vIFJldHVybiB0aGUgdmFsdWUgZm9yIGEga2V5LCBvciBhIGRlZmF1bHQgdmFsdWUuXG4gIC8vIElmICdkZWZhdWx0S2V5JyBpcyBwYXNzZWQgdGhlbiAnZGZsdCcgaXMgYXNzdW1lZCB0byBiZSBhbiBvYmplY3Qgd2l0aFxuICAvLyBhIG51bWJlciBvZiBwb3NzaWJsZSBkZWZhdWx0IHZhbHVlcyBhcyBwcm9wZXJ0aWVzIHdoZXJlICdkZWZhdWx0S2V5JyBpc1xuICAvLyB0aGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgY2hvc2VuOyBvdGhlcndpc2UgaXQncyBhc3N1bWVkIHRvIGJlXG4gIC8vIGEgc2luZ2xlIHZhbHVlLlxuICBnZXQ6IGZ1bmN0aW9uIChrLCBkZmx0LCBkZWZhdWx0S2V5KSB7XG4gICAgaWYgKGRlZmF1bHRLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdFtkZWZhdWx0S2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHQ7XG4gIH0sXG4gIC8vIENoZWNrIHdoZXRoZXIgd2UgaGF2ZSBhIHZhbHVlIGZvciBhIGtleS5cbiAgaGFzOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrIGluIHRoaXMudmFsdWVzO1xuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cbiAgYWx0OiBmdW5jdGlvbiAoaywgdiwgYSkge1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgYS5sZW5ndGg7ICsrbikge1xuICAgICAgaWYgKHYgPT09IGFbbl0pIHtcbiAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCAoc2lnbmVkKSBpbnRlZ2VyLlxuICBpbnRlZ2VyOiBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICgvXi0/XFxkKyQvLnRlc3QodikpIHsgLy8gaW50ZWdlclxuICAgICAgdGhpcy5zZXQoaywgcGFyc2VJbnQodiwgMTApKTtcbiAgICB9XG4gIH0sXG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIGEgdmFsaWQgcGVyY2VudGFnZS5cbiAgcGVyY2VudDogZnVuY3Rpb24gKGssIHYpIHtcbiAgICBsZXQgbTtcbiAgICBpZiAoKG0gPSB2Lm1hdGNoKC9eKFtcXGRdezEsM30pKFxcLltcXGRdKik/JSQvKSkpIHtcbiAgICAgIHYgPSBwYXJzZUZsb2F0KHYpO1xuICAgICAgaWYgKHYgPj0gMCAmJiB2IDw9IDEwMCkge1xuICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGlucHV0IGludG8gZ3JvdXBzIHNlcGFyYXRlZCBieSAnZ3JvdXBEZWxpbScsIGFuZFxuLy8gaW50ZXJwcmV0ZSBlYWNoIGdyb3VwIGFzIGEga2V5L3ZhbHVlIHBhaXIgc2VwYXJhdGVkIGJ5ICdrZXlWYWx1ZURlbGltJy5cbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyAoaW5wdXQsIGNhbGxiYWNrLCBrZXlWYWx1ZURlbGltLCBncm91cERlbGltKSB7XG4gIGxldCBncm91cHMgPSBncm91cERlbGltID8gaW5wdXQuc3BsaXQoZ3JvdXBEZWxpbSkgOiBbaW5wdXRdO1xuICBmb3IgKGxldCBpIGluIGdyb3Vwcykge1xuICAgIGlmICh0eXBlb2YgZ3JvdXBzW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbGV0IGt2ID0gZ3JvdXBzW2ldLnNwbGl0KGtleVZhbHVlRGVsaW0pO1xuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBrID0ga3ZbMF07XG4gICAgbGV0IHYgPSBrdlsxXTtcbiAgICBjYWxsYmFjayhrLCB2KTtcbiAgfVxufVxuXG5sZXQgZGVmYXVsdHMgPSBuZXcgVlRUQ3VlKDAsIDAsIDApO1xuLy8gJ21pZGRsZScgd2FzIGNoYW5nZWQgdG8gJ2NlbnRlcicgaW4gdGhlIHNwZWM6IGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvd2VidnR0L3B1bGwvMjQ0XG4vLyAgU2FmYXJpIGRvZXNuJ3QgeWV0IHN1cHBvcnQgdGhpcyBjaGFuZ2UsIGJ1dCBGRiBhbmQgQ2hyb21lIGRvLlxubGV0IGNlbnRlciA9IGRlZmF1bHRzLmFsaWduID09PSAnbWlkZGxlJyA/ICdtaWRkbGUnIDogJ2NlbnRlcic7XG5cbmZ1bmN0aW9uIHBhcnNlQ3VlIChpbnB1dCwgY3VlLCByZWdpb25MaXN0KSB7XG4gIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCBpbnB1dCBpZiB3ZSBuZWVkIHRvIHRocm93IGFuIGVycm9yLlxuICBsZXQgb0lucHV0ID0gaW5wdXQ7XG4gIC8vIDQuMSBXZWJWVFQgdGltZXN0YW1wXG4gIGZ1bmN0aW9uIGNvbnN1bWVUaW1lU3RhbXAgKCkge1xuICAgIGxldCB0cyA9IHBhcnNlVGltZVN0YW1wKGlucHV0KTtcbiAgICBpZiAodHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIHRpbWVzdGFtcDogJyArIG9JbnB1dCk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHRpbWUgc3RhbXAgZnJvbSBpbnB1dC5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15bXlxcc2EtekEtWi1dKy8sICcnKTtcbiAgICByZXR1cm4gdHM7XG4gIH1cblxuICAvLyA0LjQuMiBXZWJWVFQgY3VlIHNldHRpbmdzXG4gIGZ1bmN0aW9uIGNvbnN1bWVDdWVTZXR0aW5ncyAoaW5wdXQsIGN1ZSkge1xuICAgIGxldCBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuXG4gICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgc3dpdGNoIChrKSB7XG4gICAgICBjYXNlICdyZWdpb24nOlxuICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IHJlZ2lvbiB3ZSBwYXJzZWQgd2l0aCB0aGUgc2FtZSByZWdpb24gaWQuXG4gICAgICAgIGZvciAobGV0IGkgPSByZWdpb25MaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKHJlZ2lvbkxpc3RbaV0uaWQgPT09IHYpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNldChrLCByZWdpb25MaXN0W2ldLnJlZ2lvbik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3JsJywgJ2xyJ10pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgICB2YXIgdmFscyA9IHYuc3BsaXQoJywnKSxcbiAgICAgICAgICB2YWxzMCA9IHZhbHNbMF07XG4gICAgICAgIHNldHRpbmdzLmludGVnZXIoaywgdmFsczApO1xuICAgICAgICBpZiAoc2V0dGluZ3MucGVyY2VudChrLCB2YWxzMCkpIHtcbiAgICAgICAgICBzZXR0aW5ncy5zZXQoJ3NuYXBUb0xpbmVzJywgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGluZ3MuYWx0KGssIHZhbHMwLCBbJ2F1dG8nXSk7XG4gICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHNldHRpbmdzLmFsdCgnbGluZUFsaWduJywgdmFsc1sxXSwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICB2YWxzID0gdi5zcGxpdCgnLCcpO1xuICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHZhbHNbMF0pO1xuICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoJ3Bvc2l0aW9uQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJywgJ2xpbmUtbGVmdCcsICdsaW5lLXJpZ2h0JywgJ2F1dG8nXSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NpemUnOlxuICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHYpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2FsaWduJzpcbiAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnLCAnbGVmdCcsICdyaWdodCddKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSwgLzovLCAvXFxzLyk7XG5cbiAgICAvLyBBcHBseSBkZWZhdWx0IHZhbHVlcyBmb3IgYW55IG1pc3NpbmcgZmllbGRzLlxuICAgIGN1ZS5yZWdpb24gPSBzZXR0aW5ncy5nZXQoJ3JlZ2lvbicsIG51bGwpO1xuICAgIGN1ZS52ZXJ0aWNhbCA9IHNldHRpbmdzLmdldCgndmVydGljYWwnLCAnJyk7XG4gICAgbGV0IGxpbmUgPSBzZXR0aW5ncy5nZXQoJ2xpbmUnLCAnYXV0bycpO1xuICAgIGlmIChsaW5lID09PSAnYXV0bycgJiYgZGVmYXVsdHMubGluZSA9PT0gLTEpIHtcbiAgICAgIC8vIHNldCBudW1lcmljIGxpbmUgbnVtYmVyIGZvciBTYWZhcmlcbiAgICAgIGxpbmUgPSAtMTtcbiAgICB9XG4gICAgY3VlLmxpbmUgPSBsaW5lO1xuICAgIGN1ZS5saW5lQWxpZ24gPSBzZXR0aW5ncy5nZXQoJ2xpbmVBbGlnbicsICdzdGFydCcpO1xuICAgIGN1ZS5zbmFwVG9MaW5lcyA9IHNldHRpbmdzLmdldCgnc25hcFRvTGluZXMnLCB0cnVlKTtcbiAgICBjdWUuc2l6ZSA9IHNldHRpbmdzLmdldCgnc2l6ZScsIDEwMCk7XG4gICAgY3VlLmFsaWduID0gc2V0dGluZ3MuZ2V0KCdhbGlnbicsIGNlbnRlcik7XG4gICAgbGV0IHBvc2l0aW9uID0gc2V0dGluZ3MuZ2V0KCdwb3NpdGlvbicsICdhdXRvJyk7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgZGVmYXVsdHMucG9zaXRpb24gPT09IDUwKSB7XG4gICAgICAvLyBzZXQgbnVtZXJpYyBwb3NpdGlvbiBmb3IgU2FmYXJpXG4gICAgICBwb3NpdGlvbiA9IGN1ZS5hbGlnbiA9PT0gJ3N0YXJ0JyB8fCBjdWUuYWxpZ24gPT09ICdsZWZ0JyA/IDAgOiBjdWUuYWxpZ24gPT09ICdlbmQnIHx8IGN1ZS5hbGlnbiA9PT0gJ3JpZ2h0JyA/IDEwMCA6IDUwO1xuICAgIH1cbiAgICBjdWUucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlICgpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15cXHMrLywgJycpO1xuICB9XG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgdGltaW5ncy5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY3VlLnN0YXJ0VGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDEpIGNvbGxlY3QgY3VlIHN0YXJ0IHRpbWVcbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgaWYgKGlucHV0LnN1YnN0cigwLCAzKSAhPT0gJy0tPicpIHsgLy8gKDMpIG5leHQgY2hhcmFjdGVycyBtdXN0IG1hdGNoICctLT4nXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgdGltZSBzdGFtcCAodGltZSBzdGFtcHMgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgXFwnLS0+XFwnKTogJyArXG4gICAgICBvSW5wdXQpO1xuICB9XG4gIGlucHV0ID0gaW5wdXQuc3Vic3RyKDMpO1xuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuZW5kVGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDUpIGNvbGxlY3QgY3VlIGVuZCB0aW1lXG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgc2V0dGluZ3MgbGlzdC5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpO1xufVxuXG5mdW5jdGlvbiBmaXhMaW5lQnJlYWtzIChpbnB1dCkge1xuICByZXR1cm4gaW5wdXQucmVwbGFjZSgvPGJyKD86IFxcLyk/Pi9naSwgJ1xcbicpO1xufVxuXG5WVFRQYXJzZXIucHJvdG90eXBlID0ge1xuICBwYXJzZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBkYXRhIHRoZW4gd2Ugd29uJ3QgZGVjb2RlIGl0LCBidXQgd2lsbCBqdXN0IHRyeSB0byBwYXJzZVxuICAgIC8vIHdoYXRldmVyIGlzIGluIGJ1ZmZlciBhbHJlYWR5LiBUaGlzIG1heSBvY2N1ciBpbiBjaXJjdW1zdGFuY2VzLCBmb3JcbiAgICAvLyBleGFtcGxlIHdoZW4gZmx1c2goKSBpcyBjYWxsZWQuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIGRhdGEgdGhhdCB3ZSByZWNlaXZlZC5cbiAgICAgIHNlbGYuYnVmZmVyICs9IHNlbGYuZGVjb2Rlci5kZWNvZGUoZGF0YSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdE5leHRMaW5lICgpIHtcbiAgICAgIGxldCBidWZmZXIgPSBzZWxmLmJ1ZmZlcjtcbiAgICAgIGxldCBwb3MgPSAwO1xuXG4gICAgICBidWZmZXIgPSBmaXhMaW5lQnJlYWtzKGJ1ZmZlcik7XG5cbiAgICAgIHdoaWxlIChwb3MgPCBidWZmZXIubGVuZ3RoICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxyJyAmJiBidWZmZXJbcG9zXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG5cbiAgICAgIGxldCBsaW5lID0gYnVmZmVyLnN1YnN0cigwLCBwb3MpO1xuICAgICAgLy8gQWR2YW5jZSB0aGUgYnVmZmVyIGVhcmx5IGluIGNhc2Ugd2UgZmFpbCBiZWxvdy5cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xccicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG5cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuYnVmZmVyID0gYnVmZmVyLnN1YnN0cihwb3MpO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuXG4gICAgLy8gMy4yIFdlYlZUVCBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgZnVuY3Rpb24gcGFyc2VIZWFkZXIgKGlucHV0KSB7XG4gICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICBjYXNlICdSZWdpb24nOlxuICAgICAgICAgIC8vIDMuMyBXZWJWVFQgcmVnaW9uIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygncGFyc2UgcmVnaW9uJywgdik7XG4gICAgICAgICAgLy8gcGFyc2VSZWdpb24odik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0sIC86Lyk7XG4gICAgfVxuXG4gICAgLy8gNS4xIFdlYlZUVCBmaWxlIHBhcnNpbmcuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBsaW5lO1xuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJykge1xuICAgICAgICAvLyBXZSBjYW4ndCBzdGFydCBwYXJzaW5nIHVudGlsIHdlIGhhdmUgdGhlIGZpcnN0IGxpbmUuXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3Qoc2VsZi5idWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG4gICAgICAgIC8vIHN0cmlwIG9mIFVURi04IEJPTSBpZiBhbnlcbiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnl0ZV9vcmRlcl9tYXJrI1VURi04XG4gICAgICAgIGxldCBtID0gbGluZS5tYXRjaCgvXijDr8K7wr8pP1dFQlZUVChbIFxcdF0uKik/JC8pO1xuICAgICAgICBpZiAoIW0gfHwgIW1bMF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zdGF0ZSA9ICdIRUFERVInO1xuICAgICAgfVxuXG4gICAgICBsZXQgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChzZWxmLmJ1ZmZlcikge1xuICAgICAgICAvLyBXZSBjYW4ndCBwYXJzZSBhIGxpbmUgdW50aWwgd2UgaGF2ZSB0aGUgZnVsbCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KHNlbGYuYnVmZmVyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhbHJlYWR5Q29sbGVjdGVkTGluZSkge1xuICAgICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChzZWxmLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgJ0hFQURFUic6XG4gICAgICAgICAgLy8gMTMtMTggLSBBbGxvdyBhIGhlYWRlciAobWV0YWRhdGEpIHVuZGVyIHRoZSBXRUJWVFQgbGluZS5cbiAgICAgICAgICBpZiAoLzovLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIHBhcnNlSGVhZGVyKGxpbmUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgIC8vIEFuIGVtcHR5IGxpbmUgdGVybWluYXRlcyB0aGUgaGVhZGVyIGFuZCBzdGFydHMgdGhlIGJvZHkgKGN1ZXMpLlxuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlICdOT1RFJzpcbiAgICAgICAgICAvLyBJZ25vcmUgTk9URSBibG9ja3MuXG4gICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSAnSUQnOlxuICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgTk9URSBibG9ja3MuXG4gICAgICAgICAgaWYgKC9eTk9URSgkfFsgXFx0XSkvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnTk9URSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gMTktMjkgLSBBbGxvdyBhbnkgbnVtYmVyIG9mIGxpbmUgdGVybWluYXRvcnMsIHRoZW4gaW5pdGlhbGl6ZSBuZXcgY3VlIHZhbHVlcy5cbiAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuY3VlID0gbmV3IFZUVEN1ZSgwLCAwLCAnJyk7XG4gICAgICAgICAgc2VsZi5zdGF0ZSA9ICdDVUUnO1xuICAgICAgICAgIC8vIDMwLTM5IC0gQ2hlY2sgaWYgc2VsZiBsaW5lIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGlkZW50aWZpZXIgb3IgdGltaW5nIGRhdGEuXG4gICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignLS0+JykgPT09IC0xKSB7XG4gICAgICAgICAgICBzZWxmLmN1ZS5pZCA9IGxpbmU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUHJvY2VzcyBsaW5lIGFzIHN0YXJ0IG9mIGEgY3VlLlxuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnQ1VFJzpcbiAgICAgICAgICAvLyA0MCAtIENvbGxlY3QgY3VlIHRpbWluZ3MgYW5kIHNldHRpbmdzLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXJzZUN1ZShsaW5lLCBzZWxmLmN1ZSwgc2VsZi5yZWdpb25MaXN0KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXG4gICAgICAgICAgICBzZWxmLmN1ZSA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0JBRENVRSc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5zdGF0ZSA9ICdDVUVURVhUJztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSAnQ1VFVEVYVCc6XG4gICAgICAgICAgdmFyIGhhc1N1YnN0cmluZyA9IGxpbmUuaW5kZXhPZignLS0+JykgIT09IC0xO1xuICAgICAgICAgIC8vIDM0IC0gSWYgd2UgaGF2ZSBhbiBlbXB0eSBsaW5lIHRoZW4gcmVwb3J0IHRoZSBjdWUuXG4gICAgICAgICAgLy8gMzUgLSBJZiB3ZSBoYXZlIHRoZSBzcGVjaWFsIHN1YnN0cmluZyAnLS0+JyB0aGVuIHJlcG9ydCB0aGUgY3VlLFxuICAgICAgICAgIC8vIGJ1dCBkbyBub3QgY29sbGVjdCB0aGUgbGluZSBhcyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIGN1cnJlbnRcbiAgICAgICAgICAvLyBvbmUgYXMgYSBuZXcgY3VlLlxuICAgICAgICAgIGlmICghbGluZSB8fCBoYXNTdWJzdHJpbmcgJiYgKGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZSBkb25lIHBhcnNpbmcgc2VsZiBjdWUuXG4gICAgICAgICAgICBpZiAoc2VsZi5vbmN1ZSkge1xuICAgICAgICAgICAgICBzZWxmLm9uY3VlKHNlbGYuY3VlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jdWUgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlbGYuY3VlLnRleHQpIHtcbiAgICAgICAgICAgIHNlbGYuY3VlLnRleHQgKz0gJ1xcbic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5jdWUudGV4dCArPSBsaW5lO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlICdCQURDVUUnOiAvLyBCQURDVUVcbiAgICAgICAgICAvLyA1NC02MiAtIENvbGxlY3QgYW5kIGRpc2NhcmQgdGhlIHJlbWFpbmluZyBjdWUuXG4gICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgcGFyc2luZyBhIGN1ZSwgcmVwb3J0IHdoYXQgd2UgaGF2ZS5cbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSAnQ1VFVEVYVCcgJiYgc2VsZi5jdWUgJiYgc2VsZi5vbmN1ZSkge1xuICAgICAgICBzZWxmLm9uY3VlKHNlbGYuY3VlKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5jdWUgPSBudWxsO1xuICAgICAgLy8gRW50ZXIgQkFEV0VCVlRUIHN0YXRlIGlmIGhlYWRlciB3YXMgbm90IHBhcnNlZCBjb3JyZWN0bHkgb3RoZXJ3aXNlXG4gICAgICAvLyBhbm90aGVyIGV4Y2VwdGlvbiBvY2N1cnJlZCBzbyBlbnRlciBCQURDVUUgc3RhdGUuXG4gICAgICBzZWxmLnN0YXRlID0gc2VsZi5zdGF0ZSA9PT0gJ0lOSVRJQUwnID8gJ0JBRFdFQlZUVCcgOiAnQkFEQ1VFJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cbiAgICAgIHNlbGYuYnVmZmVyICs9IHNlbGYuZGVjb2Rlci5kZWNvZGUoKTtcbiAgICAgIC8vIFN5bnRoZXNpemUgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjdWUgb3IgcmVnaW9uLlxuICAgICAgaWYgKHNlbGYuY3VlIHx8IHNlbGYuc3RhdGUgPT09ICdIRUFERVInKSB7XG4gICAgICAgIHNlbGYuYnVmZmVyICs9ICdcXG5cXG4nO1xuICAgICAgICBzZWxmLnBhcnNlKCk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSd2ZSBmbHVzaGVkLCBwYXJzZWQsIGFuZCB3ZSdyZSBzdGlsbCBvbiB0aGUgSU5JVElBTCBzdGF0ZSB0aGVuXG4gICAgICAvLyB0aGF0IG1lYW5zIHdlIGRvbid0IGhhdmUgZW5vdWdoIG9mIHRoZSBzdHJlYW0gdG8gcGFyc2UgdGhlIGZpcnN0XG4gICAgICAvLyBsaW5lLlxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGlmIChzZWxmLm9uZmx1c2gpIHtcbiAgICAgIHNlbGYub25mbHVzaCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG5leHBvcnQgeyBmaXhMaW5lQnJlYWtzIH07XG5cbmV4cG9ydCBkZWZhdWx0IFZUVFBhcnNlcjtcbiIsImltcG9ydCBWVFRQYXJzZXIgZnJvbSAnLi92dHRwYXJzZXInO1xuaW1wb3J0IHsgdXRmOEFycmF5VG9TdHIgfSBmcm9tICcuLi9kZW11eC9pZDMnO1xuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggaXMgbm90IHN1cHBvcnRlZCBpbiBJRTExXG5jb25zdCBzdGFydHNXaXRoID0gZnVuY3Rpb24gKGlucHV0U3RyaW5nLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gIHJldHVybiBpbnB1dFN0cmluZy5zdWJzdHIocG9zaXRpb24gfHwgMCwgc2VhcmNoU3RyaW5nLmxlbmd0aCkgPT09IHNlYXJjaFN0cmluZztcbn07XG5cbmNvbnN0IGN1ZVN0cmluZzJtaWxsaXMgPSBmdW5jdGlvbiAodGltZVN0cmluZykge1xuICBsZXQgdHMgPSBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigtMykpO1xuICBsZXQgc2VjcyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKC02LCAyKSk7XG4gIGxldCBtaW5zID0gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoLTksIDIpKTtcbiAgbGV0IGhvdXJzID0gdGltZVN0cmluZy5sZW5ndGggPiA5ID8gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoMCwgdGltZVN0cmluZy5pbmRleE9mKCc6JykpKSA6IDA7XG5cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodHMpIHx8ICFOdW1iZXIuaXNGaW5pdGUoc2VjcykgfHwgIU51bWJlci5pc0Zpbml0ZShtaW5zKSB8fCAhTnVtYmVyLmlzRmluaXRlKGhvdXJzKSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHRzICs9IDEwMDAgKiBzZWNzO1xuICB0cyArPSA2MCAqIDEwMDAgKiBtaW5zO1xuICB0cyArPSA2MCAqIDYwICogMTAwMCAqIGhvdXJzO1xuXG4gIHJldHVybiB0cztcbn07XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2hcbmNvbnN0IGhhc2ggPSBmdW5jdGlvbiAodGV4dCkge1xuICBsZXQgaGFzaCA9IDUzODE7XG4gIGxldCBpID0gdGV4dC5sZW5ndGg7XG4gIHdoaWxlIChpKSB7XG4gICAgaGFzaCA9IChoYXNoICogMzMpIF4gdGV4dC5jaGFyQ29kZUF0KC0taSk7XG4gIH1cblxuICByZXR1cm4gKGhhc2ggPj4+IDApLnRvU3RyaW5nKCk7XG59O1xuXG5jb25zdCBjYWxjdWxhdGVPZmZzZXQgPSBmdW5jdGlvbiAodnR0Q0NzLCBjYywgcHJlc2VudGF0aW9uVGltZSkge1xuICBsZXQgY3VyckNDID0gdnR0Q0NzW2NjXTtcbiAgbGV0IHByZXZDQyA9IHZ0dENDc1tjdXJyQ0MucHJldkNDXTtcblxuICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBkaXNjb250aW51aXR5IG9yIGN1ZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCBzaW5jZSB0aGUgbGFzdCBkaXNjb250aW51aXR5XG4gIC8vIE9mZnNldCA9IGN1cnJlbnQgZGlzY29udGludWl0eSB0aW1lXG4gIGlmICghcHJldkNDIHx8ICghcHJldkNDLm5ldyAmJiBjdXJyQ0MubmV3KSkge1xuICAgIHZ0dENDcy5jY09mZnNldCA9IHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XG4gICAgY3VyckNDLm5ldyA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRoZXJlIGhhdmUgYmVlbiBkaXNjb250aW51aXRpZXMgc2luY2UgY3VlcyB3ZXJlIGxhc3QgcGFyc2VkLlxuICAvLyBPZmZzZXQgPSB0aW1lIGVsYXBzZWRcbiAgd2hpbGUgKHByZXZDQyAmJiBwcmV2Q0MubmV3KSB7XG4gICAgdnR0Q0NzLmNjT2Zmc2V0ICs9IGN1cnJDQy5zdGFydCAtIHByZXZDQy5zdGFydDtcbiAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgY3VyckNDID0gcHJldkNDO1xuICAgIHByZXZDQyA9IHZ0dENDc1tjdXJyQ0MucHJldkNDXTtcbiAgfVxuXG4gIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBwcmVzZW50YXRpb25UaW1lO1xufTtcblxuY29uc3QgV2ViVlRUUGFyc2VyID0ge1xuICBwYXJzZTogZnVuY3Rpb24gKHZ0dEJ5dGVBcnJheSwgc3luY1BUUywgdnR0Q0NzLCBjYywgY2FsbEJhY2ssIGVycm9yQ2FsbEJhY2spIHtcbiAgICAvLyBDb252ZXJ0IGJ5dGVBcnJheSBpbnRvIHN0cmluZywgcmVwbGFjaW5nIGFueSBzb21ld2hhdCBleG90aWMgbGluZWZlZWRzIHdpdGggXCJcXG5cIiwgdGhlbiBzcGxpdCBvbiB0aGF0IGNoYXJhY3Rlci5cbiAgICBsZXQgcmUgPSAvXFxyXFxufFxcblxccnxcXG58XFxyL2c7XG4gICAgLy8gVWludDhBcnJheS5wcm90b3R5cGUucmVkdWNlIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBJRTExXG4gICAgbGV0IHZ0dExpbmVzID0gdXRmOEFycmF5VG9TdHIobmV3IFVpbnQ4QXJyYXkodnR0Qnl0ZUFycmF5KSkudHJpbSgpLnJlcGxhY2UocmUsICdcXG4nKS5zcGxpdCgnXFxuJyk7XG5cbiAgICBsZXQgY3VlVGltZSA9ICcwMDowMC4wMDAnO1xuICAgIGxldCBtcGVnVHMgPSAwO1xuICAgIGxldCBsb2NhbFRpbWUgPSAwO1xuICAgIGxldCBwcmVzZW50YXRpb25UaW1lID0gMDtcbiAgICBsZXQgY3VlcyA9IFtdO1xuICAgIGxldCBwYXJzaW5nRXJyb3I7XG4gICAgbGV0IGluSGVhZGVyID0gdHJ1ZTtcbiAgICAvLyBsZXQgVlRUQ3VlID0gVlRUQ3VlIHx8IHdpbmRvdy5UZXh0VHJhY2tDdWU7XG5cbiAgICAvLyBDcmVhdGUgcGFyc2VyIG9iamVjdCB1c2luZyBWVFRDdWUgd2l0aCBUZXh0VHJhY2tDdWUgZmFsbGJhY2sgb24gY2VydGFpbiBicm93c2Vycy5cbiAgICBsZXQgcGFyc2VyID0gbmV3IFZUVFBhcnNlcigpO1xuXG4gICAgcGFyc2VyLm9uY3VlID0gZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgLy8gQWRqdXN0IGN1ZSB0aW1pbmc7IGNsYW1wIGN1ZXMgdG8gc3RhcnQgbm8gZWFybGllciB0aGFuIC0gYW5kIGRyb3AgY3VlcyB0aGF0IGRvbid0IGVuZCBhZnRlciAtIDAgb24gdGltZWxpbmUuXG4gICAgICBsZXQgY3VyckNDID0gdnR0Q0NzW2NjXTtcbiAgICAgIGxldCBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQ7XG5cbiAgICAgIC8vIFVwZGF0ZSBvZmZzZXRzIGZvciBuZXcgZGlzY29udGludWl0aWVzXG4gICAgICBpZiAoY3VyckNDICYmIGN1cnJDQy5uZXcpIHtcbiAgICAgICAgaWYgKGxvY2FsVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBsb2NhbCB0aW1lIGlzIHByb3ZpZGVkLCBvZmZzZXQgPSBkaXNjb250aW51aXR5IHN0YXJ0IHRpbWUgLSBsb2NhbCB0aW1lXG4gICAgICAgICAgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0ID0gY3VyckNDLnN0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCBwcmVzZW50YXRpb25UaW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJlc2VudGF0aW9uVGltZSkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIE1QRUdUUywgb2Zmc2V0ID0gcHJlc2VudGF0aW9uIHRpbWUgKyBkaXNjb250aW51aXR5IG9mZnNldFxuICAgICAgICBjdWVPZmZzZXQgPSBwcmVzZW50YXRpb25UaW1lIC0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldDtcbiAgICAgIH1cblxuICAgICAgY3VlLnN0YXJ0VGltZSArPSBjdWVPZmZzZXQgLSBsb2NhbFRpbWU7XG4gICAgICBjdWUuZW5kVGltZSArPSBjdWVPZmZzZXQgLSBsb2NhbFRpbWU7XG5cbiAgICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBoYXNoIGlkIGZvciBhIGN1ZSBiYXNlZCBvbiBzdGFydC9lbmQgdGltZXMgYW5kIHRleHQuXG4gICAgICAvLyBUaGlzIGhlbHBzIHRpbWVsaW5lLWNvbnRyb2xsZXIgdG8gYXZvaWQgc2hvd2luZyByZXBlYXRlZCBjYXB0aW9ucy5cbiAgICAgIGN1ZS5pZCA9IGhhc2goY3VlLnN0YXJ0VGltZS50b1N0cmluZygpKSArIGhhc2goY3VlLmVuZFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKGN1ZS50ZXh0KTtcblxuICAgICAgLy8gRml4IGVuY29kaW5nIG9mIHNwZWNpYWwgY2hhcmFjdGVycy4gVE9ETzogVGVzdCB3aXRoIGFsbCBzb3J0cyBvZiB3ZWlyZCBjaGFyYWN0ZXJzLlxuICAgICAgY3VlLnRleHQgPSBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlVVJJQ29tcG9uZW50KGN1ZS50ZXh0KSk7XG4gICAgICBpZiAoY3VlLmVuZFRpbWUgPiAwKSB7XG4gICAgICAgIGN1ZXMucHVzaChjdWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBwYXJzZXIub25wYXJzaW5nZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcGFyc2luZ0Vycm9yID0gZTtcbiAgICB9O1xuXG4gICAgcGFyc2VyLm9uZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocGFyc2luZ0Vycm9yICYmIGVycm9yQ2FsbEJhY2spIHtcbiAgICAgICAgZXJyb3JDYWxsQmFjayhwYXJzaW5nRXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYWxsQmFjayhjdWVzKTtcbiAgICB9O1xuXG4gICAgLy8gR28gdGhyb3VnaCBjb250ZW50cyBsaW5lIGJ5IGxpbmUuXG4gICAgdnR0TGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgIGlmIChpbkhlYWRlcikge1xuICAgICAgICAvLyBMb29rIGZvciBYLVRJTUVTVEFNUC1NQVAgaW4gaGVhZGVyLlxuICAgICAgICBpZiAoc3RhcnRzV2l0aChsaW5lLCAnWC1USU1FU1RBTVAtTUFQPScpKSB7XG4gICAgICAgICAgLy8gT25jZSBmb3VuZCwgbm8gbW9yZSBhcmUgYWxsb3dlZCBhbnl3YXksIHNvIHN0b3Agc2VhcmNoaW5nLlxuICAgICAgICAgIGluSGVhZGVyID0gZmFsc2U7XG4gICAgICAgICAgLy8gRXh0cmFjdCBMT0NBTCBhbmQgTVBFR1RTLlxuICAgICAgICAgIGxpbmUuc3Vic3RyKDE2KS5zcGxpdCgnLCcpLmZvckVhY2godGltZXN0YW1wID0+IHtcbiAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHRpbWVzdGFtcCwgJ0xPQ0FMOicpKSB7XG4gICAgICAgICAgICAgIGN1ZVRpbWUgPSB0aW1lc3RhbXAuc3Vic3RyKDYpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydHNXaXRoKHRpbWVzdGFtcCwgJ01QRUdUUzonKSkge1xuICAgICAgICAgICAgICBtcGVnVHMgPSBwYXJzZUludCh0aW1lc3RhbXAuc3Vic3RyKDcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHN1YnRpdGxlIG9mZnNldCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgICBpZiAoc3luY1BUUyArICgodnR0Q0NzW2NjXS5zdGFydCAqIDkwMDAwKSB8fCAwKSA8IDApIHtcbiAgICAgICAgICAgICAgc3luY1BUUyArPSA4NTg5OTM0NTkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRqdXN0IE1QRUdUUyBieSBzeW5jIFBUUy5cbiAgICAgICAgICAgIG1wZWdUcyAtPSBzeW5jUFRTO1xuICAgICAgICAgICAgLy8gQ29udmVydCBjdWUgdGltZSB0byBzZWNvbmRzXG4gICAgICAgICAgICBsb2NhbFRpbWUgPSBjdWVTdHJpbmcybWlsbGlzKGN1ZVRpbWUpIC8gMTAwMDtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgTVBFR1RTIHRvIHNlY29uZHMgZnJvbSA5MGtIei5cbiAgICAgICAgICAgIHByZXNlbnRhdGlvblRpbWUgPSBtcGVnVHMgLyA5MDAwMDtcblxuICAgICAgICAgICAgaWYgKGxvY2FsVGltZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGBNYWxmb3JtZWQgWC1USU1FU1RBTVAtTUFQOiAke2xpbmV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGBNYWxmb3JtZWQgWC1USU1FU1RBTVAtTUFQOiAke2xpbmV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiB3aXRob3V0IHBhcnNpbmcgWC1USU1FU1RBTVAtTUFQIGxpbmUuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgICAgICAgaW5IZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUGFyc2UgbGluZSBieSBkZWZhdWx0LlxuICAgICAgcGFyc2VyLnBhcnNlKGxpbmUgKyAnXFxuJyk7XG4gICAgfSk7XG5cbiAgICBwYXJzZXIuZmx1c2goKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2ViVlRUUGFyc2VyO1xuIiwiLyoqXG4gKiBYSFIgYmFzZWQgbG9nZ2VyXG4qL1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jb25zdCB7IHBlcmZvcm1hbmNlLCBYTUxIdHRwUmVxdWVzdCB9ID0gd2luZG93O1xuXG5jbGFzcyBYaHJMb2FkZXIge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAmJiBjb25maWcueGhyU2V0dXApIHtcbiAgICAgIHRoaXMueGhyU2V0dXAgPSBjb25maWcueGhyU2V0dXA7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5hYm9ydCgpO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgfVxuXG4gIGFib3J0ICgpIHtcbiAgICBsZXQgbG9hZGVyID0gdGhpcy5sb2FkZXI7XG4gICAgaWYgKGxvYWRlciAmJiBsb2FkZXIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgdGhpcy5zdGF0cy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG51bGw7XG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCk7XG4gICAgdGhpcy5yZXRyeVRpbWVvdXQgPSBudWxsO1xuICB9XG5cbiAgbG9hZCAoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIHRoaXMuc3RhdHMgPSB7IHRyZXF1ZXN0OiBwZXJmb3JtYW5jZS5ub3coKSwgcmV0cnk6IDAgfTtcbiAgICB0aGlzLnJldHJ5RGVsYXkgPSBjb25maWcucmV0cnlEZWxheTtcbiAgICB0aGlzLmxvYWRJbnRlcm5hbCgpO1xuICB9XG5cbiAgbG9hZEludGVybmFsICgpIHtcbiAgICBsZXQgeGhyLCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIHhociA9IHRoaXMubG9hZGVyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICBsZXQgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgIHN0YXRzLnRmaXJzdCA9IDA7XG4gICAgc3RhdHMubG9hZGVkID0gMDtcbiAgICBjb25zdCB4aHJTZXR1cCA9IHRoaXMueGhyU2V0dXA7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHhoclNldHVwKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBmaXggeGhyU2V0dXA6ICh4aHIsIHVybCkgPT4ge3hoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1MYW5ndWFnZVwiLCBcInRlc3RcIik7fVxuICAgICAgICAgIC8vIG5vdCB3b3JraW5nLCBhcyB4aHIuc2V0UmVxdWVzdEhlYWRlciBleHBlY3RzIHhoci5yZWFkeVN0YXRlID09PSBPUEVOXG4gICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcbiAgICAgICAgICB4aHJTZXR1cCh4aHIsIGNvbnRleHQudXJsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFMTEgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiB4aHIub3BlbiBpZiBhdHRlbXB0aW5nIHRvIGFjY2VzcyBhbiBIVFRQIHJlc291cmNlIG92ZXIgSFRUUFNcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3IoeyBjb2RlOiB4aHIuc3RhdHVzLCB0ZXh0OiBlLm1lc3NhZ2UgfSwgY29udGV4dCwgeGhyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5yYW5nZUVuZCkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyAoY29udGV4dC5yYW5nZUVuZCAtIDEpKTtcbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5yZWFkeXN0YXRlY2hhbmdlLmJpbmQodGhpcyk7XG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSB0aGlzLmxvYWRwcm9ncmVzcy5iaW5kKHRoaXMpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSBjb250ZXh0LnJlc3BvbnNlVHlwZTtcblxuICAgIC8vIHNldHVwIHRpbWVvdXQgYmVmb3JlIHdlIHBlcmZvcm0gcmVxdWVzdFxuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIHRoaXMuY29uZmlnLnRpbWVvdXQpO1xuICAgIHhoci5zZW5kKCk7XG4gIH1cblxuICByZWFkeXN0YXRlY2hhbmdlIChldmVudCkge1xuICAgIGxldCB4aHIgPSBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlLFxuICAgICAgc3RhdHMgPSB0aGlzLnN0YXRzLFxuICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgLy8gZG9uJ3QgcHJvY2VlZCBpZiB4aHIgaGFzIGJlZW4gYWJvcnRlZFxuICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gPj0gSEVBREVSU19SRUNFSVZFRFxuICAgIGlmIChyZWFkeVN0YXRlID49IDIpIHtcbiAgICAgIC8vIGNsZWFyIHhociB0aW1lb3V0IGFuZCByZWFybSBpdCBpZiByZWFkeVN0YXRlIGxlc3MgdGhhbiA0XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgaWYgKHN0YXRzLnRmaXJzdCA9PT0gMCkge1xuICAgICAgICBzdGF0cy50Zmlyc3QgPSBNYXRoLm1heChwZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMudHJlcXVlc3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBsZXQgc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgICAgLy8gaHR0cCBzdGF0dXMgYmV0d2VlbiAyMDAgdG8gMjk5IGFyZSBhbGwgc3VjY2Vzc2Z1bFxuICAgICAgICBpZiAoc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICBzdGF0cy50bG9hZCA9IE1hdGgubWF4KHN0YXRzLnRmaXJzdCwgcGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICAgIGxldCBkYXRhLCBsZW47XG4gICAgICAgICAgaWYgKGNvbnRleHQucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgICAgICBkYXRhID0geGhyLnJlc3BvbnNlO1xuICAgICAgICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0cy5sb2FkZWQgPSBzdGF0cy50b3RhbCA9IGxlbjtcbiAgICAgICAgICBsZXQgcmVzcG9uc2UgPSB7IHVybDogeGhyLnJlc3BvbnNlVVJMLCBkYXRhOiBkYXRhIH07XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgeGhyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxuICAgICAgICAgIGlmIChzdGF0cy5yZXRyeSA+PSBjb25maWcubWF4UmV0cnkgfHwgKHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNDk5KSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGAke3N0YXR1c30gd2hpbGUgbG9hZGluZyAke2NvbnRleHQudXJsfWApO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcih7IGNvZGU6IHN0YXR1cywgdGV4dDogeGhyLnN0YXR1c1RleHQgfSwgY29udGV4dCwgeGhyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcmV0cnlcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGAke3N0YXR1c30gd2hpbGUgbG9hZGluZyAke2NvbnRleHQudXJsfSwgcmV0cnlpbmcgaW4gJHt0aGlzLnJldHJ5RGVsYXl9Li4uYCk7XG4gICAgICAgICAgICAvLyBhYm9ydHMgYW5kIHJlc2V0cyBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAvLyBzY2hlZHVsZSByZXRyeVxuICAgICAgICAgICAgdGhpcy5yZXRyeVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLCB0aGlzLnJldHJ5RGVsYXkpO1xuICAgICAgICAgICAgLy8gc2V0IGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgICAgIHRoaXMucmV0cnlEZWxheSA9IE1hdGgubWluKDIgKiB0aGlzLnJldHJ5RGVsYXksIGNvbmZpZy5tYXhSZXRyeURlbGF5KTtcbiAgICAgICAgICAgIHN0YXRzLnJldHJ5Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWFkeVN0YXRlID49IDIgQU5EIHJlYWR5U3RhdGUgIT09NCAocmVhZHlTdGF0ZSA9IEhFQURFUlNfUkVDRUlWRUQgfHwgTE9BRElORykgcmVhcm0gdGltZW91dCBhcyB4aHIgbm90IGZpbmlzaGVkIHlldFxuICAgICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBjb25maWcudGltZW91dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbG9hZHRpbWVvdXQgKCkge1xuICAgIGxvZ2dlci53YXJuKGB0aW1lb3V0IHdoaWxlIGxvYWRpbmcgJHt0aGlzLmNvbnRleHQudXJsfWApO1xuICAgIHRoaXMuY2FsbGJhY2tzLm9uVGltZW91dCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIG51bGwpO1xuICB9XG5cbiAgbG9hZHByb2dyZXNzIChldmVudCkge1xuICAgIGxldCB4aHIgPSBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgc3RhdHMgPSB0aGlzLnN0YXRzO1xuXG4gICAgc3RhdHMubG9hZGVkID0gZXZlbnQubG9hZGVkO1xuICAgIGlmIChldmVudC5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICBzdGF0cy50b3RhbCA9IGV2ZW50LnRvdGFsO1xuICAgIH1cblxuICAgIGxldCBvblByb2dyZXNzID0gdGhpcy5jYWxsYmFja3Mub25Qcm9ncmVzcztcbiAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgLy8gdGhpcmQgYXJnIGlzIHRvIHByb3ZpZGUgb24gcHJvZ3Jlc3MgZGF0YVxuICAgICAgb25Qcm9ncmVzcyhzdGF0cywgdGhpcy5jb250ZXh0LCBudWxsLCB4aHIpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBYaHJMb2FkZXI7XG4iLCJpbXBvcnQgUGxheWVyIGZyb20gJ3hncGxheWVyJ1xuaW1wb3J0IEhscyBmcm9tICcuL2hscy5qcy9obHMnXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi91dGlscydcblxuY2xhc3MgSGxzSnNQbGF5ZXIgZXh0ZW5kcyBQbGF5ZXIge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpXG4gICAgdGhpcy5obHNPcHRzID0gb3B0aW9ucy5obHNPcHRzIHx8IHt9XG4gICAgbGV0IHV0aWwgPSBQbGF5ZXIudXRpbFxuICAgIGxldCBwbGF5ZXIgPSB0aGlzXG4gICAgdGhpcy5icm93c2VyID0gdXRpbHMuZ2V0QnJvd3NlclZlcnNpb24oKVxuICAgIGlmKHBsYXllci5jb25maWcudXNlSGxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgoUGxheWVyLnNuaWZmZXIuZGV2aWNlID09PSAnbW9iaWxlJyAmJiBuYXZpZ2F0b3IucGxhdGZvcm0gIT09ICdNYWNJbnRlbCcgJiYgbmF2aWdhdG9yLnBsYXRmb3JtICE9PSAnV2luMzInKSB8fCB0aGlzLmJyb3dzZXIuaW5kZXhPZignU2FmYXJpJykgPiAtMSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoIXBsYXllci5jb25maWcudXNlSGxzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgTnVtYmVyLmlzRmluaXRlID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBsZXQgaGxzXG4gICAgaGxzID0gbmV3IEhscyh0aGlzLmhsc09wdHMpXG4gICAgdGhpcy5obHMgPSBobHNcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwbGF5ZXIsICdzcmMnLCB7XG4gICAgICBnZXQgKCkge1xuICAgICAgICByZXR1cm4gcGxheWVyLmN1cnJlbnRTcmNcbiAgICAgIH0sXG4gICAgICBzZXQgKHVybCkge1xuICAgICAgICB1dGlsLnJlbW92ZUNsYXNzKHBsYXllci5yb290LCAneGdwbGF5ZXItaXMtbGl2ZScpXG4gICAgICAgIGNvbnN0IGxpdmVEb20gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcueGdwbGF5ZXItbGl2ZScpXG4gICAgICAgIGlmIChsaXZlRG9tKSB7XG4gICAgICAgICAgbGl2ZURvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpdmVEb20pXG4gICAgICAgIH1cbiAgICAgICAgLy8gcGxheWVyLmNvbmZpZy51cmwgPSB1cmxcbiAgICAgICAgY29uc3QgcGF1c2VkID0gcGxheWVyLnBhdXNlZFxuICAgICAgICBwbGF5ZXIuaGxzLnN0b3BMb2FkKClcbiAgICAgICAgcGxheWVyLmhscy5kZXRhY2hNZWRpYSgpXG4gICAgICAgIHBsYXllci5obHMuZGVzdHJveSgpXG4gICAgICAgIHBsYXllci5obHMgPSBuZXcgSGxzKHBsYXllci5obHNPcHRzKVxuICAgICAgICBwbGF5ZXIucmVnaXN0ZXIodXJsKVxuICAgICAgICBpZiAoIXBhdXNlZCkge1xuICAgICAgICAgIHBsYXllci5wYXVzZSgpXG4gICAgICAgICAgcGxheWVyLm9uY2UoJ3BhdXNlJywgKCkgPT4ge1xuICAgICAgICAgICAgcGxheWVyLmhscy5sb2FkU291cmNlKHVybClcbiAgICAgICAgICB9KVxuICAgICAgICAgIHBsYXllci5vbmNlKCdjYW5wbGF5JywgKCkgPT4ge1xuICAgICAgICAgICAgcGxheWVyLnBsYXkoKS5jYXRjaChlcnIgPT4ge30pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwbGF5ZXIuaGxzLmxvYWRTb3VyY2UodXJsKVxuICAgICAgICB9XG4gICAgICAgIHBsYXllci5obHMuYXR0YWNoTWVkaWEocGxheWVyLnZpZGVvKVxuICAgICAgICBwbGF5ZXIub25jZSgnY2FucGxheScsICgpID0+IHtcbiAgICAgICAgICBwbGF5ZXIuY3VycmVudFRpbWUgPSAwXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgICB0aGlzLnJlZ2lzdGVyKHRoaXMuY29uZmlnLnVybClcbiAgICB0aGlzLm9uY2UoJ2NvbXBsZXRlJywgKCkgPT4ge1xuICAgICAgaGxzLmF0dGFjaE1lZGlhKHBsYXllci52aWRlbylcbiAgICAgIHBsYXllci5vbmNlKCdjYW5wbGF5JywgKCkgPT4ge1xuICAgICAgICBpZihwbGF5ZXIuY29uZmlnLmF1dG9wbGF5KSB7XG4gICAgICAgICAgcGxheWVyLnBsYXkoKS5jYXRjaChlcnIgPT4ge30pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpZihwbGF5ZXIuY29uZmlnLmlzTGl2ZSkge1xuICAgICAgICB1dGlsLmFkZENsYXNzKHBsYXllci5yb290LCAneGdwbGF5ZXItaXMtbGl2ZScpXG4gICAgICAgIGlmKCF1dGlsLmZpbmREb20ocGxheWVyLnJvb3QsICcueGdwbGF5ZXItbGl2ZScpKSB7XG4gICAgICAgICAgY29uc3QgbGl2ZSA9IHV0aWwuY3JlYXRlRG9tKCd4Zy1saXZlJywgJ+ato+WcqOebtOaSrScsIHt9LCAneGdwbGF5ZXItbGl2ZScpXG4gICAgICAgICAgcGxheWVyLmNvbnRyb2xzLmFwcGVuZENoaWxkKGxpdmUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMub25jZSgnZGVzdHJveScsICgpID0+IHtcbiAgICAgIGhscy5zdG9wTG9hZCgpXG4gICAgfSlcbiAgfVxuICByZWdpc3RlciAodXJsKSB7XG4gICAgbGV0IGhscyA9IHRoaXMuaGxzXG4gICAgbGV0IHV0aWwgPSBQbGF5ZXIudXRpbFxuICAgIGxldCBwbGF5ZXIgPSB0aGlzXG4gICAgaGxzLm9uKEhscy5FdmVudHMuTUVESUFfQVRUQUNIRUQsICgpID0+IHtcbiAgICAgIGhscy5sb2FkU291cmNlKHVybClcbiAgICB9KVxuXG4gICAgaGxzLm9uKEhscy5FdmVudHMuTEVWRUxfTE9BREVELCAobmFtZSwgZSkgPT4ge1xuICAgICAgaWYgKCFobHMuaW5pdGVkKSB7XG4gICAgICAgIGhscy5pbml0ZWQgPSB0cnVlXG4gICAgICAgIGlmIChlICYmIGUuZGV0YWlscyAmJiBlLmRldGFpbHMubGl2ZSkge1xuICAgICAgICAgIHV0aWwuYWRkQ2xhc3MocGxheWVyLnJvb3QsICd4Z3BsYXllci1pcy1saXZlJylcbiAgICAgICAgICBpZighdXRpbC5maW5kRG9tKHBsYXllci5yb290LCAnLnhncGxheWVyLWxpdmUnKSkge1xuICAgICAgICAgICAgY29uc3QgbGl2ZSA9IHV0aWwuY3JlYXRlRG9tKCd4Zy1saXZlJywgJ+ato+WcqOebtOaSrScsIHt9LCAneGdwbGF5ZXItbGl2ZScpXG4gICAgICAgICAgICBwbGF5ZXIuY29udHJvbHMuYXBwZW5kQ2hpbGQobGl2ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIGhscy5vbihIbHMuRXZlbnRzLkVSUk9SLCAoZXZlbnQsIGRhdGEpID0+IHtcbiAgICAgIHBsYXllci5lbWl0KCdITFNfRVJST1InLCB7XG4gICAgICAgIGVycm9yVHlwZTogZGF0YS50eXBlLFxuICAgICAgICBlcnJvckRldGFpbHM6IGRhdGEuZGV0YWlscyxcbiAgICAgICAgZXJyb3JGYXRhbDogZGF0YS5mYXRhbCxcbiAgICAgIH0pXG4gICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgSGxzLkVycm9yVHlwZXMuTkVUV09SS19FUlJPUjpcbiAgICAgICAgICAgIGhscy5zdGFydExvYWQoKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEhscy5FcnJvclR5cGVzLk1FRElBX0VSUk9SOlxuICAgICAgICAgICAgaGxzLnJlY292ZXJNZWRpYUVycm9yKClcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHBsYXllci5lbWl0KCdlcnJvcicsIGRhdGEpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuX3N0YXRpc3RpY3MoKTtcbiAgfVxuXG4gIF9zdGF0aXN0aWNzKCkge1xuICAgIGxldCBzdGF0c0luZm8gPSB7XG4gICAgICBzcGVlZDowLFxuICAgICAgcGxheWVyVHlwZTogXCJIbHNQbGF5ZXJcIlxuICAgIH07XG5cbiAgICBsZXQgbWVkaWFpbmZvID0ge1xuICAgICAgdmlkZW9EYXRhUmF0ZTowLFxuICAgICAgYXVkaW9EYXRhUmF0ZTowXG4gICAgfTtcbiAgICBsZXQgaGxzID0gdGhpcy5obHM7XG4gICAgbGV0IHBsYXllciA9IHRoaXM7XG5cbiAgICBobHMub24oSGxzLkV2ZW50cy5GUkFHX0xPQURfUFJPR1JFU1MsIChmbGFnLHBheWxvYWQpID0+e1xuICAgICAgc3RhdHNJbmZvLnNwZWVkID0gcGF5bG9hZC5zdGF0cy5sb2FkZWQgLyAxMDAwO1xuICAgIH0pO1xuICAgIGhscy5vbihIbHMuRXZlbnRzLkZSQUdfUEFSU0lOR19EQVRBLCAoZmxhZyxwYXlsb2FkKSA9PntcbiAgICAgIGlmIChwYXlsb2FkLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgbWVkaWFpbmZvLmZwcyA9IHBhcnNlSW50KHBheWxvYWQubmIvKHBheWxvYWQuZW5kUFRTIC1wYXlsb2FkLnN0YXJ0UFRTKSk7XG4gICAgICB9XG4gICAgfSlcblxuICAgIGhscy5vbihIbHMuRXZlbnRzLkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIChmbGFnLHBheWxvYWQpID0+e1xuICAgICAgbWVkaWFpbmZvLmhhc0F1ZGlvID0gKHBheWxvYWQudHJhY2tzICYmIHBheWxvYWQudHJhY2tzLmF1ZGlvKT8gdHJ1ZTogZmFsc2U7XG4gICAgICBtZWRpYWluZm8uaGFzVmlkZW8gPSAocGF5bG9hZC50cmFja3MgJiYgcGF5bG9hZC50cmFja3MuYXVkaW8pPyB0cnVlOiBmYWxzZTtcblxuICAgICAgaWYobWVkaWFpbmZvLmhhc0F1ZGlvKSB7XG4gICAgICAgIGxldCB0cmFjayA9IHBheWxvYWQudHJhY2tzLmF1ZGlvO1xuICAgICAgICBtZWRpYWluZm8uYXVkaW9DaGFubmVsQ291bnQgPSAodHJhY2subWV0YWRhdGEgJiYgdHJhY2subWV0YWRhdGEuY2hhbm5lbENvdW50KSA/IHRyYWNrLm1ldGFkYXRhLmNoYW5uZWxDb3VudDowO1xuICAgICAgICBtZWRpYWluZm8uYXVkaW9Db2RlYyA9IHRyYWNrLmNvZGVjO1xuICAgICAgfVxuXG4gICAgICBpZihtZWRpYWluZm8uaGFzVmlkZW8pIHtcbiAgICAgICAgbGV0IHRyYWNrID0gcGF5bG9hZC50cmFja3MudmlkZW87XG4gICAgICAgIG1lZGlhaW5mby52aWRlb0NvZGVjID0gdHJhY2suY29kZWM7XG4gICAgICAgIG1lZGlhaW5mby53aWR0aCA9ICh0cmFjay5tZXRhZGF0YSAmJiB0cmFjay5tZXRhZGF0YS53aWR0aCkgPyB0cmFjay5tZXRhZGF0YS53aWR0aDowO1xuICAgICAgICBtZWRpYWluZm8uaGVpZ2h0ID0gKHRyYWNrLm1ldGFkYXRhICYmIHRyYWNrLm1ldGFkYXRhLmhlaWdodCkgPyB0cmFjay5tZXRhZGF0YS5oZWlnaHQ6MDtcbiAgICAgIH1cbiAgICAgIG1lZGlhaW5mby5kdXJhdGlvbiA9IChwYXlsb2FkLmZyYWcgJiYgcGF5bG9hZC5mcmFnLmR1cmF0aW9uKSA/IHBheWxvYWQuZnJhZy5kdXJhdGlvbjowXG4gICAgICBtZWRpYWluZm8ubGV2ZWwgPShwYXlsb2FkLmZyYWcgJiYgcGF5bG9hZC5mcmFnLmxldmVsKSA/IHBheWxvYWQuZnJhZy5sZXZlbDowO1xuICAgICAgaWYobWVkaWFpbmZvLnZpZGVvQ29kZWMgfHwgbWVkaWFpbmZvLmF1ZGlvQ29kZWMpIHtcbiAgICAgICAgbWVkaWFpbmZvLm1pbWVUeXBlID0gYHZpZGVvL2hsczsgY29kZWNzPVwiJHttZWRpYWluZm8udmlkZW9Db2RlY307JHttZWRpYWluZm8uYXVkaW9Db2RlY31cImBcbiAgICAgIH1cblxuICAgICAgcGxheWVyLm1lZGlhaW5mbyA9IG1lZGlhaW5mbztcbiAgICAgIHBsYXllci5lbWl0KFwibWVkaWFfaW5mb1wiLCBtZWRpYWluZm8pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc3RhdGlzdGljc1RpbW1lciA9IHNldEludGVydmFsKCgpPT57XG4gICAgICBwbGF5ZXIuZW1pdChcInN0YXRpc3RpY3NfaW5mb1wiLCBzdGF0c0luZm8pO1xuICAgICAgc3RhdHNJbmZvLnNwZWVkID0gMDtcbiAgICB9LCAxMDAwKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9zdGF0aXN0aWNzVGltbWVyKTtcbiAgfVxufVxuXG5IbHNKc1BsYXllci5pc1N1cHBvcnRlZCA9IEhscy5pc1N1cHBvcnRlZFxuXG5leHBvcnQgZGVmYXVsdCBIbHNKc1BsYXllclxuIiwibGV0IHV0aWwgPSB7fVxuXG51dGlsLmdldEJyb3dzZXJWZXJzaW9uID0gZnVuY3Rpb24gKCkge1xuICBsZXQgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCAvL+WPluW+l+a1j+iniOWZqOeahHVzZXJBZ2VudOWtl+espuS4slxuICBpZih1c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwibW9iaWxlXCIpID4gLTEpIHtcbiAgICByZXR1cm4gXCJVbmtub3duXCJcbiAgfVxuICBpZiAodXNlckFnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpID4gLTEpIHtcbiAgICBsZXQgdmVyc2lvbiA9IHVzZXJBZ2VudC5tYXRjaCgvZmlyZWZveFxcL1tcXGQuXSsvZ2kpWzBdLm1hdGNoKC9bXFxkXSsvKVswXVxuICAgIHJldHVybiBcIkZpcmVmb3ggXCIrdmVyc2lvblxuICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKFwiRWRnZVwiKSA+IC0xKSB7XG4gICAgbGV0IHZlcnNpb24gPSB1c2VyQWdlbnQubWF0Y2goL2VkZ2VcXC9bXFxkLl0rL2dpKVswXS5tYXRjaCgvW1xcZF0rLylbMF1cbiAgICByZXR1cm4gXCJFZGdlIFwiK3ZlcnNpb25cbiAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcInJ2OjExXCIpID4gLTEpIHtcbiAgICByZXR1cm4gXCJJRSAxMVwiXG4gIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoXCJPcGVyYVwiKSA+IC0xIHx8IHVzZXJBZ2VudC5pbmRleE9mKFwiT1BSXCIpID4gLTEpIHtcbiAgICBpZiAodXNlckFnZW50LmluZGV4T2YoXCJPcGVyYVwiKSA+IC0xKSB7XG4gICAgICBsZXQgdmVyc2lvbiA9IHVzZXJBZ2VudC5tYXRjaCgvb3BlcmFcXC9bXFxkLl0rL2dpKVswXS5tYXRjaCgvW1xcZF0rLylbMF1cbiAgICAgIHJldHVybiBcIk9wZXJhIFwiK3ZlcnNpb25cbiAgICB9XG4gICAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKFwiT1BSXCIpID4gLTEpIHtcbiAgICAgIGxldCB2ZXJzaW9uID0gdXNlckFnZW50Lm1hdGNoKC9vcHJcXC9bXFxkLl0rL2dpKVswXS5tYXRjaCgvW1xcZF0rLylbMF1cbiAgICAgIHJldHVybiBcIk9wZXJhIFwiK3ZlcnNpb25cbiAgICB9XG4gIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoXCJDaHJvbWVcIikgPiAtMSkge1xuICAgIGxldCB2ZXJzaW9uID0gdXNlckFnZW50Lm1hdGNoKC9jaHJvbWVcXC9bXFxkLl0rL2dpKVswXS5tYXRjaCgvW1xcZF0rLylbMF1cbiAgICByZXR1cm4gXCJDaHJvbWUgXCIrdmVyc2lvblxuICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKFwiU2FmYXJpXCIpID4gLTEpIHtcbiAgICBsZXQgdmVyc2lvbiA9IHVzZXJBZ2VudC5tYXRjaCgvc2FmYXJpXFwvW1xcZC5dKy9naSlbMF0ubWF0Y2goL1tcXGRdKy8pWzBdXG4gICAgcmV0dXJuIFwiU2FmYXJpIFwiK3ZlcnNpb25cbiAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcIk1TSUVcIikgPiAtMSB8fCB1c2VyQWdlbnQuaW5kZXhPZihcIlRyaWRlbnRcIikgPiAtMSkge1xuICAgIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcIk1TSUVcIikgPiAtMSkge1xuICAgICAgbGV0IHZlcnNpb24gPSB1c2VyQWdlbnQubWF0Y2goL21zaWUgW1xcZC5dKy9naSlbMF0ubWF0Y2goL1tcXGRdKy8pWzBdXG4gICAgICByZXR1cm4gXCJJRSBcIit2ZXJzaW9uXG4gICAgfVxuICAgIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcIlRyaWRlbnRcIikgPiAtMSkge1xuICAgICAgbGV0IHZlcnNpb25UcmlkZW50ID0gdXNlckFnZW50Lm1hdGNoKC90cmlkZW50XFwvW1xcZC5dKy9naSlbMF0ubWF0Y2goL1tcXGRdKy8pWzBdXG4gICAgICBsZXQgdmVyc2lvbiA9IHBhcnNlSW50KHZlcnNpb25UcmlkZW50KSArIDRcbiAgICAgIHJldHVybiBcIklFIFwiK3ZlcnNpb25cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiVW5rbm93blwiXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgdXRpbFxuIiwiKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1tcIlBsYXllclwiXTsgfSgpKTsiXSwic291cmNlUm9vdCI6IiJ9